--------------------------------------------
-- Export file for user SCOTT             --
-- Created by lev on 15.01.2016, 15:34:07 --
--------------------------------------------

set define off
spool Pck.log

prompt
prompt Creating sequence CHANGES_ID
prompt ============================
prompt
create sequence SCOTT.CHANGES_ID
minvalue 1
maxvalue 999999999999999999999999999
start with 153190
increment by 1
cache 20
order;

prompt
prompt Creating sequence C_BILL_DET_ID
prompt ===============================
prompt
create sequence SCOTT.C_BILL_DET_ID
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence C_BILL_ID
prompt ===========================
prompt
create sequence SCOTT.C_BILL_ID
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence C_CHARGE_ID
prompt =============================
prompt
create sequence SCOTT.C_CHARGE_ID
minvalue 1
maxvalue 999999999999999999999999999
start with 30180186
increment by 1
cache 20
order;

prompt
prompt Creating sequence C_CHARGE_PREP_ID
prompt ==================================
prompt
create sequence SCOTT.C_CHARGE_PREP_ID
minvalue 1
maxvalue 999999999999999999999999999
start with 66913305
increment by 1
cache 20;

prompt
prompt Creating sequence C_COMP_ID
prompt ===========================
prompt
create sequence SCOTT.C_COMP_ID
minvalue 1
maxvalue 999999999999999999999999999
start with 21
increment by 1
cache 20;

prompt
prompt Creating sequence C_DEB_OPER_ID
prompt ===============================
prompt
create sequence SCOTT.C_DEB_OPER_ID
minvalue 1
maxvalue 999999999999999999999999999
start with 21
increment by 1
cache 20;

prompt
prompt Creating sequence C_DEB_USL_ID
prompt ==============================
prompt
create sequence SCOTT.C_DEB_USL_ID
minvalue 1
maxvalue 999999999999999999999999999
start with 112679321
increment by 1
cache 20;

prompt
prompt Creating sequence C_HOUSE_ID
prompt ============================
prompt
create sequence SCOTT.C_HOUSE_ID
minvalue 1
maxvalue 999999999999999999999999999
start with 37965
increment by 1
cache 20
order;

prompt
prompt Creating sequence C_KWTP_ID
prompt ===========================
prompt
create sequence SCOTT.C_KWTP_ID
minvalue 1
maxvalue 999999999999999999999999999
start with 433988
increment by 1
cache 20
order;

prompt
prompt Creating sequence C_KWTP_MG_ID
prompt ==============================
prompt
create sequence SCOTT.C_KWTP_MG_ID
minvalue 1
maxvalue 999999999999999999999999999
start with 101880
increment by 1
cache 20;

prompt
prompt Creating sequence C_LG_DOCS_ID
prompt ==============================
prompt
create sequence SCOTT.C_LG_DOCS_ID
minvalue 1
maxvalue 999999999999999999999999999
start with 1332689
increment by 1
cache 20;

prompt
prompt Creating sequence C_LSK_ID
prompt ==========================
prompt
create sequence SCOTT.C_LSK_ID
minvalue 1
maxvalue 999999999999999999999999999
start with 450054
increment by 1
cache 20
order;

prompt
prompt Creating sequence C_PEN_CORR_ID
prompt ===============================
prompt
create sequence SCOTT.C_PEN_CORR_ID
minvalue 1
maxvalue 999999999999999999999999999
start with 62
increment by 1
cache 20
order;

prompt
prompt Creating sequence C_REG_SCH_ID
prompt ==============================
prompt
create sequence SCOTT.C_REG_SCH_ID
minvalue 1
maxvalue 999999999999999999999999999
start with 181
increment by 1
cache 20
order;

prompt
prompt Creating sequence C_STATES_PR_ID
prompt ================================
prompt
create sequence SCOTT.C_STATES_PR_ID
minvalue 1
maxvalue 999999999999999999999999999
start with 94641
increment by 1
cache 20;

prompt
prompt Creating sequence C_STATES_SCH_ID
prompt =================================
prompt
create sequence SCOTT.C_STATES_SCH_ID
minvalue 1
maxvalue 999999999999999999999999999
start with 52201
increment by 1
cache 20;

prompt
prompt Creating sequence C_VVOD_ID
prompt ===========================
prompt
create sequence SCOTT.C_VVOD_ID
minvalue 1
maxvalue 999999999999999999999999999
start with 6407
increment by 1
cache 20
order;

prompt
prompt Creating sequence DU_OBJ_ID
prompt ===========================
prompt
create sequence SCOTT.DU_OBJ_ID
minvalue 1
maxvalue 999999999999999999999999999
start with 421
increment by 1
cache 20;

prompt
prompt Creating sequence KART_PR_ID
prompt ============================
prompt
create sequence SCOTT.KART_PR_ID
minvalue 1
maxvalue 999999999999999999999999999
start with 1059737
increment by 1
cache 20;

prompt
prompt Creating sequence KWTP_DAY_ID
prompt =============================
prompt
create sequence SCOTT.KWTP_DAY_ID
minvalue 1
maxvalue 999999999999999999999999999
start with 299741
increment by 1
cache 20;

prompt
prompt Creating sequence K_LSK_ID
prompt ==========================
prompt
create sequence SCOTT.K_LSK_ID
minvalue 1
maxvalue 999999999999999999999999999
start with 450453
increment by 1
cache 20
order;

prompt
prompt Creating sequence LIST_C_ID
prompt ===========================
prompt
create sequence SCOTT.LIST_C_ID
minvalue 1
maxvalue 999999999999999999999999999
start with 540571
increment by 1
cache 20;

prompt
prompt Creating sequence LOAD_PRIVS_ID
prompt ===============================
prompt
create sequence SCOTT.LOAD_PRIVS_ID
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence LOG_ACTIONS_ID
prompt ================================
prompt
create sequence SCOTT.LOG_ACTIONS_ID
minvalue 1
maxvalue 999999999999999999999999999
start with 5442530
increment by 1
cache 20
order;

prompt
prompt Creating sequence LOG_ID
prompt ========================
prompt
create sequence SCOTT.LOG_ID
minvalue 1
maxvalue 999999999999999999999999999
start with 424084
increment by 1
cache 20;

prompt
prompt Creating sequence MESSAGES_ID
prompt =============================
prompt
create sequence SCOTT.MESSAGES_ID
minvalue 0
maxvalue 999999999999999999999999999
start with 2461
increment by 1
cache 10;

prompt
prompt Creating sequence NABOR_ID
prompt ==========================
prompt
create sequence SCOTT.NABOR_ID
minvalue 1
maxvalue 999999999999999999999999999
start with 9
increment by 1
cache 20;

prompt
prompt Creating sequence NABOR_PROGS_ID
prompt ================================
prompt
create sequence SCOTT.NABOR_PROGS_ID
minvalue 1
maxvalue 999999999999999999999999999
start with 440
increment by 1
cache 20;

prompt
prompt Creating sequence PERIOD_REP_ID
prompt ===============================
prompt
create sequence SCOTT.PERIOD_REP_ID
minvalue 1
maxvalue 999999999999999999999
start with 1002
increment by 1
nocache;

prompt
prompt Creating sequence PLSQL_PROFILER_RUNNUMBER
prompt ==========================================
prompt
create sequence SCOTT.PLSQL_PROFILER_RUNNUMBER
minvalue 1
maxvalue 999999999999999999999999999
start with 273
increment by 1
nocache;

prompt
prompt Creating sequence PREP_FILE_ID
prompt ==============================
prompt
create sequence SCOTT.PREP_FILE_ID
minvalue 1
maxvalue 999999999999999999999999999
start with 141
increment by 1
cache 20
order;

prompt
prompt Creating sequence PREP_SAL_ID
prompt =============================
prompt
create sequence SCOTT.PREP_SAL_ID
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence REPORTS_ID
prompt ============================
prompt
create sequence SCOTT.REPORTS_ID
minvalue 1
maxvalue 999999999999999999999
start with 1146
increment by 1
nocache;

prompt
prompt Creating sequence REP_LEVELS_ID
prompt ===============================
prompt
create sequence SCOTT.REP_LEVELS_ID
minvalue 1
maxvalue 999999999999999999999
start with 1030
increment by 1
nocache;

prompt
prompt Creating sequence R_DOC_EVENTS_ID
prompt =================================
prompt
create sequence SCOTT.R_DOC_EVENTS_ID
minvalue 1
maxvalue 999999999999999999999999999
start with 274
increment by 1
cache 20
order;

prompt
prompt Creating sequence R_REQUESTS_ID
prompt ===============================
prompt
create sequence SCOTT.R_REQUESTS_ID
minvalue 1
maxvalue 999999999999999999999999999
start with 387
increment by 1
cache 20
order;

prompt
prompt Creating sequence SEQ_C_USERS_ID
prompt ================================
prompt
create sequence SCOTT.SEQ_C_USERS_ID
minvalue 1
maxvalue 999999999999999999999999999
start with 55
increment by 1
cache 20;

prompt
prompt Creating sequence SPR_KOEFF_ID
prompt ==============================
prompt
create sequence SCOTT.SPR_KOEFF_ID
minvalue 0
maxvalue 9999999999999999999999999
start with 56
increment by 1
nocache;

prompt
prompt Creating sequence SPR_PARAMS_ID
prompt ===============================
prompt
create sequence SCOTT.SPR_PARAMS_ID
minvalue 1
maxvalue 999999999999999999999999999
start with 1663
increment by 1
cache 20;

prompt
prompt Creating sequence SPR_PAR_SES_ID
prompt ================================
prompt
create sequence SCOTT.SPR_PAR_SES_ID
minvalue 1
maxvalue 999999999999999999999999999
start with 161
increment by 1
cache 20;

prompt
prompt Creating sequence SPR_REPXPAR_ID
prompt ================================
prompt
create sequence SCOTT.SPR_REPXPAR_ID
minvalue 1
maxvalue 999999999999999999999999999
start with 1041
increment by 1
cache 20;

prompt
prompt Creating sequence TEMP_PREP2_ID
prompt ===============================
prompt
create sequence SCOTT.TEMP_PREP2_ID
minvalue 1
maxvalue 999999999999999999999999999
start with 6201
increment by 1
cache 20;

prompt
prompt Creating sequence TEMP_PREP_ID
prompt ==============================
prompt
create sequence SCOTT.TEMP_PREP_ID
minvalue 1
maxvalue 999999999999999999999999999
start with 197401
increment by 1
cache 20;

prompt
prompt Creating sequence T_ACT_ID
prompt ==========================
prompt
create sequence SCOTT.T_ACT_ID
minvalue 0
maxvalue 9999999999999999999999999
start with 15
increment by 1
nocache;

prompt
prompt Creating sequence T_ADDR_TP_ID
prompt ==============================
prompt
create sequence SCOTT.T_ADDR_TP_ID
minvalue 0
maxvalue 9999999999999999999999999
start with 1
increment by 1
nocache;

prompt
prompt Creating sequence T_CORRECTS_PAYMENTS_ID
prompt ========================================
prompt
create sequence SCOTT.T_CORRECTS_PAYMENTS_ID
minvalue 0
maxvalue 9999999999999999999999999
start with 7762
increment by 1
nocache;

prompt
prompt Creating sequence T_DOCT_PATH_ID
prompt ================================
prompt
create sequence SCOTT.T_DOCT_PATH_ID
minvalue 0
maxvalue 9999999999999999999999999
start with 1
increment by 1
nocache;

prompt
prompt Creating sequence T_DOCXA_ID
prompt ============================
prompt
create sequence SCOTT.T_DOCXA_ID
minvalue 0
maxvalue 9999999999999999999999999
start with 26
increment by 1
nocache;

prompt
prompt Creating sequence T_DOC_DET_ID
prompt ==============================
prompt
create sequence SCOTT.T_DOC_DET_ID
minvalue 0
maxvalue 9999999999999999999999999
start with 30
increment by 1
nocache;

prompt
prompt Creating sequence T_DOC_ID
prompt ==========================
prompt
create sequence SCOTT.T_DOC_ID
minvalue 0
maxvalue 9999999999999999999999999
start with 30
increment by 1
nocache;

prompt
prompt Creating sequence T_DOC_TP_ID
prompt =============================
prompt
create sequence SCOTT.T_DOC_TP_ID
minvalue 0
maxvalue 9999999999999999999999999
start with 1
increment by 1
nocache;

prompt
prompt Creating sequence T_EXT_ID
prompt ==========================
prompt
create sequence SCOTT.T_EXT_ID
minvalue 0
maxvalue 9999999999999999999999999
start with 1
increment by 1
nocache;

prompt
prompt Creating sequence T_OBJ_DET_ID
prompt ==============================
prompt
create sequence SCOTT.T_OBJ_DET_ID
minvalue 0
maxvalue 9999999999999999999999999
start with 1
increment by 1
nocache;

prompt
prompt Creating sequence T_OBJ_ID
prompt ==========================
prompt
create sequence SCOTT.T_OBJ_ID
minvalue 0
maxvalue 9999999999999999999999999
start with 68
increment by 1
nocache;

prompt
prompt Creating sequence T_OBJ_S_ID
prompt ============================
prompt
create sequence SCOTT.T_OBJ_S_ID
minvalue 0
maxvalue 9999999999999999999999999
start with 5
increment by 1
nocache;

prompt
prompt Creating sequence T_OBJ_TP_ID
prompt =============================
prompt
create sequence SCOTT.T_OBJ_TP_ID
minvalue 0
maxvalue 9999999999999999999999999
start with 26
increment by 1
nocache;

prompt
prompt Creating sequence T_ORGT_ID
prompt ===========================
prompt
create sequence SCOTT.T_ORGT_ID
minvalue 0
maxvalue 9999999999999999999999999
start with 820
increment by 1
nocache;

prompt
prompt Creating sequence T_ORG_ID
prompt ==========================
prompt
create sequence SCOTT.T_ORG_ID
minvalue 0
maxvalue 9999999999999999999999999
start with 877
increment by 1
nocache;

prompt
prompt Creating sequence T_ORG_TP_ID
prompt =============================
prompt
create sequence SCOTT.T_ORG_TP_ID
minvalue 0
maxvalue 9999999999999999999999999
start with 828
increment by 1
nocache;

prompt
prompt Creating sequence T_RLXAC_ID
prompt ============================
prompt
create sequence SCOTT.T_RLXAC_ID
minvalue 0
maxvalue 9999999999999999999999999
start with 1
increment by 1
nocache;

prompt
prompt Creating sequence T_RLXRL_ID
prompt ============================
prompt
create sequence SCOTT.T_RLXRL_ID
minvalue 0
maxvalue 9999999999999999999999999
start with 1
increment by 1
nocache;

prompt
prompt Creating sequence T_RLXS_ID
prompt ===========================
prompt
create sequence SCOTT.T_RLXS_ID
minvalue 0
maxvalue 9999999999999999999999999
start with 1
increment by 1
nocache;

prompt
prompt Creating sequence T_ROLE_ID
prompt ===========================
prompt
create sequence SCOTT.T_ROLE_ID
minvalue 0
maxvalue 9999999999999999999999999
start with 12
increment by 1
nocache;

prompt
prompt Creating sequence T_SESS_ID
prompt ===========================
prompt
create sequence SCOTT.T_SESS_ID
minvalue 1
maxvalue 999999999999999999999999999
start with 3615
increment by 1
cache 20;

prompt
prompt Creating sequence T_USER_ID
prompt ===========================
prompt
create sequence SCOTT.T_USER_ID
minvalue 0
maxvalue 9999999999999999999999999
start with 1270
increment by 1
nocache;

prompt
prompt Creating sequence T_USXAC_ID
prompt ============================
prompt
create sequence SCOTT.T_USXAC_ID
minvalue 0
maxvalue 9999999999999999999999999
start with 1
increment by 1
nocache;

prompt
prompt Creating sequence T_USXRL_ID
prompt ============================
prompt
create sequence SCOTT.T_USXRL_ID
minvalue 0
maxvalue 9999999999999999999999999
start with 19586
increment by 1
nocache;

prompt
prompt Creating sequence T_USXS_ID
prompt ===========================
prompt
create sequence SCOTT.T_USXS_ID
minvalue 0
maxvalue 9999999999999999999999999
start with 1
increment by 1
nocache;

prompt
prompt Creating sequence U_LIST_ID
prompt ===========================
prompt
create sequence SCOTT.U_LIST_ID
minvalue 1
maxvalue 999999999999999999999
start with 135918
increment by 1
nocache;

prompt
prompt Creating function GETDT
prompt =======================
prompt
create or replace function scott.getdt(p_day in number, p_month in number, p_year in number) return date is
 l_dt date;
begin

if not (length(p_day) between 1 and 2 and 
    length(p_month) between 1 and 2 and 
    length(p_year) between 1 and 2) then
  Raise_application_error(-20000, '—правка по вызову: utils.gdt(dd,mm,yy)');
elsif nvl(p_day,0)=0 and nvl(p_month,0)=0 and nvl(p_year,0)=0 then
--по текущему периоду, текущему дню по sysdate 
  select trunc(sysdate) into l_dt 
  from dual;  
elsif nvl(p_day,0)<>0 and nvl(p_month,0)=0 and nvl(p_year,0)=0 then
--по текущему периоду, по дню 
  select to_date(p.period||lpad(p_day,2,'0'),'YYYYMMDD') into l_dt 
  from params p;  
elsif nvl(p_day,0)<>0 and p_month is not null and nvl(p_year,0)=0 then
--по периоду текущего года, по дню и є мес€ца
  select to_date(substr(p.period,1,4)||lpad(p_month,2,'0')||lpad(p_day,2,'0'),'YYYYMMDD') into l_dt 
  from params p;  
elsif nvl(p_day,0)<>0 and p_month is not null and p_year is not null then
--по периоду указанного года, по дню и є мес€ца
  select to_date('20'||lpad(p_year,2,'0')||lpad(p_month,2,'0')||lpad(p_day,2,'0'),'YYYYMMDD') into l_dt 
  from params p;  
else
  Raise_application_error(-20000, '—правка по вызову: utils.gdt(dd,mm,yy)');
end if;

return l_dt;

end getdt;
/

prompt
prompt Creating synonym GDT
prompt ====================
prompt
create or replace synonym SCOTT.GDT
  for SCOTT.GETDT;

prompt
prompt Creating view SPRORG
prompt ====================
prompt
create or replace force view scott.sprorg as
select null as type, id as kod, t.name, t.npp
 from t_org t;

prompt
prompt Creating view KILLME_V_CHARGES_FOR_SALDO
prompt ========================================
prompt
create or replace force view scott.killme_v_charges_for_saldo as
select /*+ ORDERED */
 p.lsk, sum(p.summa) as summa, p.usl, k.org
  from c_charge p, kart r, nabor k, sprorg t, params m
 where r.lsk = p.lsk
   and p.type = 1
   and r.lsk = k.lsk
   and k.usl = p.usl
   and t.kod = k.org
   and not exists
 (select e.usl_id from usl_excl e where e.usl_id = p.usl)
 group by p.lsk, p.usl, k.org;

prompt
prompt Creating view RMT_SPRORG
prompt ========================
prompt
create or replace force view scott.rmt_sprorg as
select "KODM","KOD","NAME" from scott.sprorg@hotora;

prompt
prompt Creating view RMT_S_REU_TREST
prompt =============================
prompt
create or replace force view scott.rmt_s_reu_trest as
select "REU","TREST","NAME_TR","TR_FORPLAN","FOR_DEBITS","FOR_SCHET","INK","FOR_PLAT" from scott.s_reu_trest@hotora;

prompt
prompt Creating view RMT_USL
prompt =====================
prompt
create or replace force view scott.rmt_usl as
select "USLM","USL","TYPE","RASZ","KARTW","KWTP","KWNI","PRNK","PRNKSU","SALD_USL","KOOP","PN","SUBSIDII","LPW","SPK","SPTAR","F_RAS","ED_IZM","NM","NM1","S_RAS","S_RAS_SCH","USL_P","SPTARN","USL_TYPE","USL_PLR","USL_NORM","USLM_DET","USL_SUM","KRT_R_SCH","TYP_USL","KART_P","ID_P_KF_R","ID_P_R","ID_K_KF_R","ID_K_R","FOR_SCH","USL_SV","F_RAS_V" from scott.usl@hotora;

prompt
prompt Creating view RMT_XXITO15
prompt =========================
prompt
create or replace force view scott.rmt_xxito15 as
select "REU","KUL","ND","OPER","DOPL","DAT","NKOM","NINK","FORREU","TREST","USL","ORG","PRIZNAK","OIGU1","OIGU2","TPL","SUMMA","MG" from scott.xxito15@hotora;

prompt
prompt Creating view S_REU_TREST
prompt =========================
prompt
create or replace force view scott.s_reu_trest as
select t.reu, t2.trest, t2.name as name_tr, t.name as name_reu, 0 as var
from t_org t, t_org t2 where (t.reu is not null or t.trest is not null)
and t.parent_id=t2.id;

prompt
prompt Creating view S_USL
prompt ===================
prompt
create or replace force view scott.s_usl as
select uslm, usl, nm
    from usl;

prompt
prompt Creating view S_USLM
prompt ====================
prompt
create or replace force view scott.s_uslm as
select distinct uslm as usl, nm1
    from usl
    order by nm1;

prompt
prompt Creating view VV_CHANGES_FOR_SALDO
prompt ==================================
prompt
create or replace force view scott.vv_changes_for_saldo as
select
          p.lsk, p.summa, p.usl, k.org, p.type, p.mgchange
           from kart r, a_nabor k, c_change p, params m
          where r.lsk = p.lsk
            and r.lsk = k.lsk
            and p.mgchange = k.mg
            and p.mgchange < m.period
            and k.usl = p.usl
            and nvl(p.org, 0) = 0-- где не указан код орг и старые периоды
            and to_char(p.dtek, 'YYYYMM') = m.period
            and exists             --и где найдена услуга в архивном справочнике
            (select * from a_nabor n where n.lsk=k.lsk and n.mg=p.mgchange and n.usl=k.usl)
         union all
         select
          p.lsk, p.summa, p.usl, k.org, p.type, p.mgchange
           from kart r, nabor k, c_change p, params m
          where r.lsk = p.lsk
            and r.lsk = k.lsk
            and p.mgchange < m.period
            and k.usl = p.usl
            and nvl(p.org, 0) = 0-- где не указан код орг и старые периоды
            and to_char(p.dtek, 'YYYYMM') = m.period
            and not exists             --и где Ќ≈ найдена услуга в архивном справочнике
            (select * from a_nabor n where n.lsk=k.lsk and n.mg=p.mgchange and n.usl=k.usl)
         union all
         select
          p.lsk, p.summa, p.usl, nvl(n.org, 0) as org, p.type, p.mgchange
           from c_change p, nabor n, params m
          where p.mgchange >= m.period and p.lsk=n.lsk and p.usl=n.usl
            and nvl(p.org, 0) = 0-- где не указан код орг и новые периоды
            and to_char(p.dtek, 'YYYYMM') = m.period
         union all
         select
          p.lsk, p.summa, p.usl, p.org as org, p.type, p.mgchange
           from kart r, c_change p, params m
          where p.mgchange >= m.period and r.lsk = p.lsk
            and nvl(p.org, 0) <> 0-- где указан код орг и новый период
            and to_char(p.dtek, 'YYYYMM') = m.period
;

prompt
prompt Creating view V_ARCH_CHARGE
prompt ===========================
prompt
create or replace force view scott.v_arch_charge as
select lsk, usl, mg, sum(summa) as summa
           from (select lsk, usl_id as usl, mg, summa_it as summa
                    from arch_charges t where t.usl_id<>'024'
                  union all
                  select lsk, usl_id, mg, -1 * summa
                    from arch_subsidii t where t.usl_id<>'024'
                  union all
                  select lsk, usl_id, mg, -1 * summa
                    from arch_privs t where t.usl_id<>'024'
                  union all
                  select lsk, usl_id, mg, summa from arch_changes t
                  where t.usl_id<>'024'
                  union all
                  select lsk, usl, mgchange, summa --учитываем текущие разовые изменени€
                    from c_change t, params p where t.usl<>'024' and t.mgchange<>p.period and
                    to_char(t.dtek,'YYYYMM')=p.period
                  ) a
          group by lsk, usl, mg
         having sum(summa) <> 0
;

prompt
prompt Creating view V_ARCH_CHARGE_ITG
prompt ===============================
prompt
create or replace force view scott.v_arch_charge_itg as
select lsk, mg, sum(summa) as summa from (
          select lsk, usl, mg, abs(sum(summa)) as summa
           from ( select lsk, usl_id as usl, mg, summa_it as summa
                    from arch_charges t where t.usl_id<>'024'
                  union all
                  select lsk, usl_id, mg, -1 * summa
                    from arch_subsidii t where t.usl_id<>'024'
                  union all
                  select lsk, usl_id, mg, -1 * summa
                    from arch_privs t where t.usl_id<>'024'
                  union all
                  select lsk, usl_id, mg, summa
                    from arch_changes t where t.usl_id<>'024'
                  union all
                  select lsk, usl, mgchange, summa --учитываем текущие разовые изменени€
                    from c_change t, params p where t.usl<>'024' and t.mgchange<>p.period and
                    to_char(t.dtek,'YYYYMM')=p.period
                    ) a
          group by lsk, usl, mg
         having sum(summa) <> 0) group by lsk, mg
;

prompt
prompt Creating view V_LSK_TP
prompt ======================
prompt
create or replace force view scott.v_lsk_tp as
select u.id, u.cd, u.name, u.npp from u_list u, u_listtp d
  where u.fk_listtp=d.id
    and d.cd='“ипы лиц.счета';

prompt
prompt Creating type REC_LSK
prompt =====================
prompt
create or replace type scott.rec_lsk as object (
  lsk            varchar(8)
   )
/

prompt
prompt Creating type TAB_LSK
prompt =====================
prompt
create or replace type scott.tab_lsk as table of rec_lsk
/

prompt
prompt Creating package P_HOUSES
prompt =========================
prompt
CREATE OR REPLACE PACKAGE SCOTT.P_HOUSES IS
  --глобальна€ переменна€, выбора типа лиц.счетов, с которыми работать
  --0- с ќсновными, 1 - с дополнительными, 2-со всеми
  g_sel_lsk_tp number;
  
   
  FUNCTION create_house(reu_ IN c_houses.reu%TYPE, kul_ IN c_houses.kul%TYPE, nd_ IN c_houses.nd%TYPE) RETURN NUMBER;

  PROCEDURE house_add_usl(
   p_lvl in number,
   lsk_ in kart.lsk%TYPE,
   house_id_ in c_houses.id%TYPE,
   p_reu in kart.reu%TYPE,
   p_trest in kart.reu%TYPE,
   usl_ in nabor.usl%TYPE,
   org_ in nabor.org%TYPE,
   koeff_ in number,
   norm_ in number,
   p_chrg in number);
 
 PROCEDURE house_chng_usl(
   p_lvl in number,
   house_id_ in c_houses.id%TYPE,
   p_reu in kart.reu%TYPE,
   p_trest in kart.reu%TYPE,
   usl_ in nabor.usl%TYPE,
   old_org_ in nabor.org%TYPE,
   new_org_ in nabor.org%TYPE,
   old_koeff_ in number,
   old_norm_ in number,
   new_koeff_ in number,
   new_norm_ in number,
   p_chrg in number);

 PROCEDURE house_del_usl(p_lvl     IN NUMBER,
                        lsk_      IN kart.lsk%TYPE,
                        house_id_ IN c_houses.id%TYPE,
                        p_reu      IN kart.reu%TYPE,
                        p_trest    IN kart.reu%TYPE,
                        usl_      IN nabor.usl%TYPE,
                        org_      IN nabor.org%TYPE,
                        koeff_    IN NUMBER,
                        norm_     IN NUMBER,
                        p_chrg in number);

  PROCEDURE change_house_status(house_id_   IN c_houses.id%TYPE,
                                status_     IN kart.status%TYPE,
                                old_status_ IN kart.status%TYPE);

  PROCEDURE change_house_vvod(house_id_    IN c_houses.id%TYPE,
                              usl_         IN nabor.usl%TYPE,
                              fk_vvod_new_ IN nabor.fk_vvod%TYPE,
                              fk_vvod_old_ IN nabor.fk_vvod%TYPE);

  FUNCTION change_tarif(tsource_ IN NUMBER, tdest_ IN NUMBER) RETURN NUMBER;
  FUNCTION change_prog_tarif(id_            IN spr_tarif.id%TYPE,
                             parent_id_     IN spr_tarifxprogs.fk_tarif%TYPE,
                             old_parent_id_ IN spr_tarifxprogs.fk_tarif%TYPE) RETURN NUMBER;
  FUNCTION copy_prog_tarif(id_ IN spr_tarif.id%TYPE, parent_id_ IN spr_tarifxprogs.fk_tarif%TYPE) RETURN NUMBER;
  FUNCTION del_prog_tarif(id_ IN spr_tarif.id%TYPE, parent_id_ IN spr_tarifxprogs.fk_tarif%TYPE) RETURN NUMBER;
  PROCEDURE add_house_list(p_err      OUT VARCHAR2, p_fk_house IN t_housexlist.fk_house%TYPE,
                           p_fk_list  IN t_housexlist.fk_list%TYPE);
  PROCEDURE del_house_list(p_id IN t_housexlist.id%TYPE);
  FUNCTION add_prog(lsk_      IN nabor_progs.lsk%TYPE,
                    fk_tarif_ IN nabor_progs.fk_tarif%TYPE,
                    usl_      IN nabor_progs.usl%TYPE,
                    id_dvb_   IN NUMBER) RETURN NUMBER;
  FUNCTION del_prog(lsk_ IN nabor_progs.lsk%TYPE, id_ IN nabor_progs.fk_tarif%TYPE) RETURN NUMBER;
  FUNCTION del_prog(lsk_ IN nabor_progs.lsk%TYPE) RETURN NUMBER;

  FUNCTION find_unq_lsk(p_reu IN kart.reu%type, 
                        p_lsk in kart.lsk%type --рекоммендованый лиц.сч.
                        )
  RETURN VARCHAR2;
  procedure kart_lsk_ext_add_house(p_house in kart.house_id%type);
  function kart_lsk_ext_add(p_lsk in kart.lsk%type, p_lsk_new in kart.lsk%type) return number;

  procedure set_g_lsk_tp(p_tp in number);
  function get_g_lsk_tp return number;
  function get_other_lsk(p_lsk in kart.lsk%type) return tab_lsk;
END P_HOUSES;
/

prompt
prompt Creating view V_ARCH_KART
prompt =========================
prompt
create or replace force view scott.v_arch_kart as
select k."LSK",k."KUL",k."ND",k."KW",k."FIO",k."KPR",k."KPR_WR",k."KPR_OT",k."KPR_CEM",k."KPR_S",k."OPL",k."PPL",k."PLDOP",k."KI",k."PSCH",k."PSCH_DT",k."GT",k."STATUS",k."KWT",k."LODPL",k."BEKPL",k."BALPL",k."KOMN",k."ET",k."KFG",k."KFOT",k."PHW",k."MHW",k."PGW",k."MGW",k."PEL",k."MEL",k."SUB_NACH",k."SUBSIDII",k."SUB_DATA",k."POLIS",k."SCH_EL",k."REU",k."VVOD",k."VVOD_EL",k."TEXT",k."SCHEL_DT",k."EKSUB1",k."EKSUB2",k."KRAN",k."KRAN1",k."EL",k."EL1",k."SGKU",k."DOPPL",k."SUBS_COR",k."SUBS_CUR",k."HOUSE_ID",k."OVRPAYMNT",k."DOLG",k."PENYA",k."MG",k."C_LSK_ID",k."OLD_DOLG",k."MG1",k."MG2",k."KAN_SCH",k."SUBS_INF",k."OLD_PEN",k."K_LSK_ID",k."DOG_NUM",k."SCHEL_END",k."FK_DEB_ORG",k."C_VVOD_EL_ID",k."K_FAM",k."K_IM",k."K_OT",k."MEMO",k."FK_DISTR",k."LAW_DOC",k."FK_PASP_ORG",k."FK_ERR",k."LAW_DOC_DT",k."PRVT_DOC",k."PRVT_DOC_DT",k."CPN",k."KPR_WRP",k."PN_DT",k."LSK_EXT",k."FK_TP"
    from arch_kart k, v_lsk_tp tp
    where k.fk_tp=tp.id(+)
    and case when p_houses.get_g_lsk_tp=0 and tp.cd='LSK_TP_MAIN' then 1 --только основные лс
             when p_houses.get_g_lsk_tp=0 and tp.cd is null then 1 --считать основными лс где не заполнено k.fk_tp (старые периоды)
             when p_houses.get_g_lsk_tp=1 and tp.cd='LSK_TP_ADDIT' then 1  --только дополнительные лс
             when p_houses.get_g_lsk_tp=2 then 1 --все лс
             else 0 end=1
;

prompt
prompt Creating view V_CHARGEPAY
prompt =========================
prompt
create or replace force view scott.v_chargepay as
select t.lsk, t.mg, t.period, sum(decode(t.type,0,summa,-1*summa)) as summa
 from C_CHARGEPAY t
 group by t.lsk, t.mg, t.period;

prompt
prompt Creating view V_CHECK_INKAS
prompt ===========================
prompt
create or replace force view scott.v_check_inkas as
select r.dat_ink, r.nkom, r.nink, sum(v.summa) summa_g, sum(d.summa) summa from
(select distinct dat_ink, nkom, nink from kwtp_day k) r,
(select nkom,dat_ink,nink,sum(summa) as summa from kwtp_day k,oper
 where k.oper=oper.oper
 and k.lsk not like '00009999' and substr(oper.oigu,1,1)='1'
 group by nkom,dat_ink,nink) v,
(select nkom,dat_ink,nink,sum(summa) as summa from kwtp_day k,oper
 where k.oper=oper.oper
 and k.lsk not like '00009999' and substr(oper.oigu,2,1)='1'
 group by nkom,dat_ink,nink) d
where r.dat_ink=v.dat_ink(+) and r.dat_ink=d.dat_ink(+)
and r.nkom=v.nkom(+) and r.nkom=d.nkom(+) and r.nink=v.nink(+) and r.nink=d.nink(+)
group by r.dat_ink, r.nkom, r.nink
order by r.dat_ink;

prompt
prompt Creating view V_CHECK_INKAS1
prompt ============================
prompt
CREATE OR REPLACE FORCE VIEW SCOTT.V_CHECK_INKAS1
(dat_ink, nkom, nink, summa_g, summa)
AS
SELECT r.dat, r.nkom, r.nink, SUM(v.summa) summa_g, SUM(d.summa) summa FROM
(SELECT DISTINCT dat, nkom, nink FROM scott.XITO5 k) r,
(SELECT nkom,dat,nink,SUM(ska) AS summa FROM scott.XITO5 k,OPER
 WHERE k.OPER=OPER.OPER
  AND SUBSTR(OPER.oigu,1,1)='1'
 GROUP BY nkom,dat,nink) v,
(SELECT nkom,dat,nink,SUM(ska) AS summa FROM scott.XITO5 k,scott.OPER
 WHERE k.OPER=OPER.OPER
  AND SUBSTR(OPER.oigu,2,1)='1'
 GROUP BY nkom,dat,nink) d
WHERE r.dat=v.dat(+) AND r.dat=d.dat(+)
AND r.nkom=v.nkom(+) AND r.nkom=d.nkom(+) AND r.nink=v.nink(+) AND r.nink=d.nink(+)
GROUP BY r.dat, r.nkom, r.nink
ORDER BY r.dat;

prompt
prompt Creating view V_CUR_CHARGE
prompt ==========================
prompt
create or replace force view scott.v_cur_charge as
select lsk, usl, mg, sum(summa) as summa
           from (select lsk, usl, summa, p.period as mg
                    from c_charge t, params p
                   where t.type = 1 and t.usl<>'024'
                  union all
                  select lsk, usl, -1 * summa, p.period as mg
                    from c_charge t, params p
                   where t.type = 2 and t.usl<>'024'
                  union all
                  select lsk, usl, -1 * summa, p.period as mg
                    from c_charge t, params p
                   where t.type = 4 and t.usl<>'024'
                  union all
                  select lsk, usl, summa, p.period as mg --учитываем текущие разовые изменени€
                    from c_change t, params p where t.usl<>'024' and t.mgchange=p.period and
                    to_char(t.dtek,'YYYYMM')=p.period
                   ) a
          group by lsk, usl, mg
         having sum(summa) <> 0
;

prompt
prompt Creating view V_CUR_CHARGE_ITG
prompt ==============================
prompt
create or replace force view scott.v_cur_charge_itg as
select lsk, sum(summa) as summa
           from (select lsk, summa
                    from c_charge t
                   where t.type = 1 and t.usl<>'024'
                  union all
                  select lsk, -1 * summa
                    from c_charge t
                   where t.type = 2 and t.usl<>'024'
                  union all
                  select lsk, -1 * summa
                    from c_charge t
                   where t.type = 4 and t.usl<>'024'
                  union all
                  select lsk, summa --учитываем текущие разовые изменени€
                    from c_change t, params p where t.usl<>'024' and t.mgchange=p.period and
                    to_char(t.dtek,'YYYYMM')=p.period
                   ) a
          group by lsk
         having sum(summa) <> 0
;

prompt
prompt Creating view V_CUR_DAYS
prompt ========================
prompt
create or replace force view scott.v_cur_days as
select to_date(p.period||case when length(to_char(rownum))=1
       then '0'||to_char(rownum)
       else to_char(rownum) end ,'YYYYMMDD') as dat
     from (select level from dual connect by level < 32), params p
where rownum<=to_char(last_day(to_date(p.period||'01','YYYYMMDD')),'DD');

prompt
prompt Creating view V_CUR_DAYS_PR
prompt ===========================
prompt
create or replace force view scott.v_cur_days_pr as
select c.lsk, c.id, a."DAT" from
(select to_date(p.period||case when length(to_char(rownum))=1
       then '0'||to_char(rownum)
       else to_char(rownum) end ,'YYYYMMDD') as dat
     from (select level from dual connect by level < 32), params p
where rownum<=to_char(last_day(to_date(p.period||'01','YYYYMMDD')),'DD')) a, c_kart_pr c;

prompt
prompt Creating view V_CUR_DAYS_PR_USL
prompt ===============================
prompt
create or replace force view scott.v_cur_days_pr_usl as
select c.lsk, c.id, a.dat, u.usl, u.fk_calc_tp from
(select to_date(p.period||case when length(to_char(rownum))=1
       then '0'||to_char(rownum)
       else to_char(rownum) end ,'YYYYMMDD') as dat
     from (select level from dual connect by level < 32), params p
where rownum<=to_char(last_day(to_date(p.period||'01','YYYYMMDD')),'DD')) a, c_kart_pr c, usl u;

prompt
prompt Creating view V_CUR_USXRL
prompt =========================
prompt
create or replace force view scott.v_cur_usxrl as
select r."ID",r."CD",r."FK_ORG",r."FK_USER",r."FK_ROLE",r."V",r."GRANTABLE",r."FK_ORGT",r."TYPE",r."MENU_ID", o.name as role_name from t_user u, t_usxrl r, t_role o where u.cd=user
and u.id=r.fk_user and r.fk_role=o.id;

prompt
prompt Creating view V_CUR_RLXFUNCT
prompt ============================
prompt
create or replace force view scott.v_cur_rlxfunct as
select t."ID",t."CD",t."FK_ROLE",t."FK_ROLE2",t."FK_FUNCT",t."V",t."GRANTABLE",t."FK_TYPE",t."FK_TYPE2", v.fk_org from t_rlxfunct t, v_cur_usxrl v
where t.fk_role2=v.fk_role;

prompt
prompt Creating view V_CUR_RLXORG
prompt ==========================
prompt
create or replace force view scott.v_cur_rlxorg as
select a.id from t_org a
connect by prior a.id=a.parent_id
start with a.id=(select v.fk_org from v_cur_usxrl v);

prompt
prompt Creating view V_CU_USXRL
prompt ========================
prompt
create or replace force view scott.v_cu_usxrl as
select r."ID",
       r."CD",
       r."FK_ORG",
       r."FK_USER",
       r."FK_ROLE",
       r."V",
       r."GRANTABLE",
       r."FK_ORGT",
       r."TYPE",
       r."MENU_ID",
       o.name as role_name
  from t_user u, t_usxrl r, t_role o
 where u.cd = user
   and u.id = r.fk_user
   and r.fk_role = o.id;

prompt
prompt Creating view V_CU_RLXAC
prompt ========================
prompt
create or replace force view scott.v_cu_rlxac as
select x."ID",x."CD",x."FK_ROLE",x."FK_OBJ",x."FK_ACT",x."V",x."GRANTABLE",x."FK_OBJT",x."FK_DOCTP" from v_cu_usxrl t, t_rlxac x
where t.fk_role=x.fk_role;

prompt
prompt Creating view V_DEBITS_LSK_MONTH
prompt ================================
prompt
create or replace force view scott.v_debits_lsk_month as
select lsk, reu, kul, name, nd, kw, fio, status, opl, cnt_month, dolg, nachisl, penya, v.mg,
 v.payment
from debits_lsk_month v
 where exists
(select * from scott.list_choices_reu l where l.reu=v.reu and l.sel=0);

prompt
prompt Creating view V_EXPORTER
prompt ========================
prompt
create or replace force view scott.v_exporter as
select lsk,usl,sum(summa) summa
    from c_charge where type=1
    group by lsk,usl
union all
select lsk,usl,sum(summa)*-1 summa
    from c_charge where type=2
    group by lsk,usl
union all
select lsk,usl,sum(summa)*-1 summa
    from c_charge where type=4
    group by lsk,usl
union all
select lsk,usl,sum(summa) summa
    from c_change
    group by lsk,usl;

prompt
prompt Creating view V_EXPORTER2
prompt =========================
prompt
create or replace force view scott.v_exporter2 as
select k.reu, k.lsk, s.name as street, ltrim(k.nd, '0') as nd, ltrim(k.kw, '0') as kw, k.fio,
k.opl, k.status
from kart k, spul s where k.kul=s.id;

prompt
prompt Creating view V_EXPORTER3
prompt =========================
prompt
create or replace force view scott.v_exporter3 as
select t.lsk,
       s.name || ',' || LTRIM(k.nd, '0') || '-' || LTRIM(k.kw, '0') as adr,
       t.reu,
       t.kul,
       t.nd,
       t.kw,
       initcap(rtrim(a.fio)) || ', ' || to_char(a.dat_rog, 'DD/MM/YYYY') || ', ' ||
       trim(d.doc) as fio,
       k.status,
       k.opl,
       lg_id,
       t.usl,
       t.org,
       t.cnt_main,
       t.summa,
       t.mg
  from xito_lg4 t,
       arch_kart k,
       a_kart_pr a,
       (select /* „®ѕќѕјЋќ Ќјѕ»—јЋ, –≈јЋ№Ќќ */
         c_kart_pr_id, mg, max(doc) as doc
          from a_lg_docs
         group by c_kart_pr_id, mg) d,
       spul s
 where t.lsk = a.lsk
   and a.id = d.c_kart_pr_id
   and a.mg = d.mg
   and t.kul = s.id
   and t.nomer = a.id
   and t.mg = a.mg
   and t.lsk = k.lsk
   and t.mg = k.mg
   and exists (select *
          from scott.list_choices_reu l
         where l.reu = t.reu
           and l.sel = 0);

prompt
prompt Creating view V_EXP_KART
prompt ========================
prompt
create or replace force view scott.v_exp_kart as
select k.reu, k.lsk, k.kul, s.name, ltrim(k.nd,'0') as nd, ltrim(k.kw,'0') as kw, k.fio from kart k, spul s
where k.kul=s.id and k.psch <> 8
order by k.kul, s.name, k.nd, k.kw;

prompt
prompt Creating view V_EXP_LSKNEW2
prompt ===========================
prompt
create or replace force view scott.v_exp_lsknew2 as
select k.lsk,
k.reu, k.kul, s.name, ltrim(k.nd,'0') as nd, ltrim(k.kw,'0') as kw, k.fio
 from kart k, spul s
where k.kul=s.id and k.psch not in (8,9);

prompt
prompt Creating view V_EXP_LSK_LSKNEW
prompt ==============================
prompt
create or replace force view scott.v_exp_lsk_lsknew as
select k.lsk, k1.lsk as lsknew,
k.reu, k.kul, s.name, ltrim(k.nd,'0') as nd, ltrim(k.kw,'0') as kw, k.fio
 from kart k, kart k1, spul s
where k.k_lsk_id=k1.k_lsk_id and k.psch=8
and k.lsk <> k1.lsk and k.kul=s.id;

prompt
prompt Creating view V_GEN_LG2
prompt =======================
prompt
CREATE OR REPLACE FORCE VIEW SCOTT.V_GEN_LG2 AS
SELECT a.reu,
             a.trest,
             a.kul,
             a.nd,
             a.USLM,
             a.lg_id,
             a.ORG,
             SUM(summa) summa,
             SUM(cnt_main) cnt_main,
             SUM(cnt) cnt,
             period
        FROM (SELECT lsk,
                     reu,
                     trest,
                     kul,
                     nd,
                     USLM,
                     lg_id,
                     ORG,
                     nomer,
                     cnt_main,
                     cnt,
                     period,
                     SUM(summa) AS summa
                FROM (SELECT /*+ ORDERED */
                       t.lsk,
                       e.reu,
                       s.trest,
                       e.kul,
                       e.nd,
                       u.USLM,
                       t.lg_id,
                       d.kod as org,
                       t.nomer,
                       DECODE(t.main,2,0,t.main) AS cnt_main,
                       t.summa,
                       1 AS cnt,
                       p.period
                        FROM PRIVS       t,
                             KART        e,
                             NABOR       k,
                             USL         u,
                             S_REU_TREST s,
                             PARAMS      p,
                             SPRORG      d
                       WHERE u.USL = t.usl_id
                         AND t.lsk = e.lsk
                         AND e.reu = s.reu
                         AND e.lsk = k.lsk
                         AND t.usl_id = k.USL
                         AND k.ORG = d.kod AND t.main NOT IN (2)
                      UNION ALL
                      SELECT t.lsk,
                             s.reu,
                             s.trest,
                             e.kul,
                             e.nd,
                             u.USLM,
                             t.lg_id,
                             t.ORG,
                             0 AS nomer,
                             t.main,
                             t.summa,
                             1 AS cnt,
                             p.period
                        FROM T_CORRECTS_LG t,
                             KART          e,
                             USL           u,
                             S_REU_TREST   s,
                             PARAMS        p
                       WHERE e.lsk = t.lsk
                         AND t.USL = u.USL
                         AND e.reu = s.reu
                         AND t.mg = p.period AND t.main NOT IN (2))
               GROUP BY lsk,
                        reu,
                        trest,
                        kul,
                        nd,
                        USLM,
                        lg_id,
                        ORG,
                        nomer,
                        cnt_main,
                        cnt,
                        period) a
       GROUP BY a.reu, a.trest, a.kul, a.nd, a.USLM, a.lg_id, a.ORG, a.period;

prompt
prompt Creating view V_GEN_LG2_C
prompt =========================
prompt
CREATE OR REPLACE FORCE VIEW SCOTT.V_GEN_LG2_C AS
SELECT a.reu,
             a.trest,
             a.kul,
             a.nd,
             a.USLM,
             a.lg_id,
             a.ORG,
             SUM(summa) summa,
             0 cnt_main,
             0 cnt,
             period
        FROM (SELECT lsk,
                     reu,
                     trest,
                     kul,
                     nd,
                     USLM,
                     lg_id,
                     ORG,
                     nomer,
                     cnt_main,
                     cnt,
                     period,
                     SUM(summa) AS summa
                FROM (SELECT /*+ ORDERED */
                       t.lsk,
                       e.reu,
                       s.trest,
                       e.kul,
                       e.nd,
                       u.USLM,
                       t.lg_id,
                       d.kod as org,
                       t.nomer,
                       DECODE(t.main,2,0,t.main) AS cnt_main,
                       t.summa,
                       1 AS cnt,
                       p.period
                        FROM PRIVS       t,
                             KART        e,
                             NABOR       k,
                             USL         u,
                             S_REU_TREST s,
                             PARAMS      p,
                             SPRORG      d
                       WHERE u.USL = t.usl_id
                         AND t.lsk = e.lsk
                         AND e.reu = s.reu
                         AND e.lsk = k.lsk
                         AND t.usl_id = k.USL
                         AND k.ORG = d.kod AND t.main IN (2)
                      UNION ALL
                      SELECT t.lsk,
                             s.reu,
                             s.trest,
                             e.kul,
                             e.nd,
                             u.USLM,
                             t.lg_id,
                             t.ORG,
                             0 AS nomer,
                             t.main,
                             t.summa,
                             1 AS cnt,
                             p.period
                        FROM T_CORRECTS_LG t,
                             KART          e,
                             USL           u,
                             S_REU_TREST   s,
                             PARAMS        p
                       WHERE e.lsk = t.lsk
                         AND t.USL = u.USL
                         AND e.reu = s.reu
                         AND t.mg = p.period AND t.main IN (2))
               GROUP BY lsk,
                        reu,
                        trest,
                        kul,
                        nd,
                        USLM,
                        lg_id,
                        ORG,
                        nomer,
                        cnt_main,
                        cnt,
                        period) a
       GROUP BY a.reu, a.trest, a.kul, a.nd, a.USLM, a.lg_id, a.ORG, a.period;

prompt
prompt Creating view V_GEN_LG3
prompt =======================
prompt
CREATE OR REPLACE FORCE VIEW SCOTT.V_GEN_LG3 AS
SELECT a.reu,
             a.trest,
             a.kul,
             a.nd,
             a.USL,
             a.lg_id,
             a.ORG,
             SUM(summa) summa,
             SUM(cnt_main) cnt_main,
             SUM(cnt) cnt,
             period
        FROM (SELECT lsk,
                     reu,
                     trest,
                     kul,
                     nd,
                     USL,
                     lg_id,
                     ORG,
                     nomer,
                     cnt_main,
                     cnt,
                     period,
                     SUM(summa) AS summa
                FROM (SELECT /*+ ORDERED */
                       t.lsk,
                       e.reu,
                       s.trest,
                       e.kul,
                       e.nd,
                       t.usl_id AS USL,
                       t.lg_id,
                       d.kod as org,
                       t.nomer,
                       t.main AS cnt_main,
                       t.summa,
                       1 AS cnt,
                       p.period
                        FROM PRIVS       t,
                             KART        e,
                             NABOR       k,
                             S_REU_TREST s,
                             PARAMS      p,
                             SPRORG      d
                       WHERE t.lsk = e.lsk
                         AND e.reu = s.reu
                         AND e.lsk = k.lsk
                         AND t.usl_id = k.USL
                         AND k.ORG = d.kod AND t.main NOT IN (2)
                      UNION ALL
                      SELECT t.lsk,
                             s.reu,
                             s.trest,
                             e.kul,
                             e.nd,
                             t.USL,
                             t.lg_id,
                             t.ORG,
                             0 AS nomer,
                             t.main,
                             t.summa,
                             1 AS cnt,
                             p.period
                        FROM T_CORRECTS_LG t,
                             KART          e,
                             S_REU_TREST   s,
                             PARAMS        p
                       WHERE e.lsk = t.lsk
                         AND e.reu = s.reu
                         AND t.mg = p.period AND t.main NOT IN (2))
               GROUP BY lsk,
                        reu,
                        trest,
                        kul,
                        nd,
                        USL,
                        lg_id,
                        ORG,
                        nomer,
                        cnt_main,
                        cnt,period) a
       GROUP BY a.reu, a.trest, a.kul, a.nd, a.USL, a.lg_id, a.ORG, a.period;

prompt
prompt Creating view V_GEN_LG3_C
prompt =========================
prompt
CREATE OR REPLACE FORCE VIEW SCOTT.V_GEN_LG3_C AS
SELECT a.reu,
             a.trest,
             a.kul,
             a.nd,
             a.USL,
             a.lg_id,
             a.ORG,
             SUM(summa) summa,
             0 cnt_main,
             0 cnt,
             period
        FROM (SELECT lsk,
                     reu,
                     trest,
                     kul,
                     nd,
                     USL,
                     lg_id,
                     ORG,
                     nomer,
                     cnt_main,
                     cnt,
                     period,
                     SUM(summa) AS summa
                FROM (SELECT /*+ ORDERED */
                       t.lsk,
                       e.reu,
                       s.trest,
                       e.kul,
                       e.nd,
                       t.usl_id AS USL,
                       t.lg_id,
                       d.kod as org,
                       t.nomer,
                       t.main AS cnt_main,
                       t.summa,
                       1 AS cnt,
                       p.period
                        FROM PRIVS       t,
                             KART        e,
                             NABOR       k,
                             S_REU_TREST s,
                             PARAMS      p,
                             SPRORG      d
                       WHERE t.lsk = e.lsk
                         AND e.reu = s.reu
                         AND e.lsk = k.lsk
                         AND t.usl_id = k.USL
                         AND k.ORG = d.kod AND t.main IN (2)
                      UNION ALL
                      SELECT t.lsk,
                             s.reu,
                             s.trest,
                             e.kul,
                             e.nd,
                             t.USL,
                             t.lg_id,
                             t.ORG,
                             0 AS nomer,
                             t.main,
                             t.summa,
                             1 AS cnt,
                             p.period
                        FROM T_CORRECTS_LG t,
                             KART          e,
                             S_REU_TREST   s,
                             PARAMS        p
                       WHERE e.lsk = t.lsk
                         AND e.reu = s.reu
                         AND t.mg = p.period AND t.main IN (2))
               GROUP BY lsk,
                        reu,
                        trest,
                        kul,
                        nd,
                        USL,
                        lg_id,
                        ORG,
                        nomer,
                        cnt_main,
                        cnt,period) a
       GROUP BY a.reu, a.trest, a.kul, a.nd, a.USL, a.lg_id, a.ORG, a.period;

prompt
prompt Creating view V_GEN_LG4
prompt =======================
prompt
CREATE OR REPLACE FORCE VIEW SCOTT.V_GEN_LG4 AS
SELECT               lsk,
                     reu,
                     kul,
                     nd,
                     kw,
                     trest,
                     USL,
                     lg_id,
                     ORG,
                     nomer,
                     cnt_main,
                     cnt,
                     period,
                     SUM(summa) AS summa
                FROM (SELECT /*+ ORDERED */
                       e.lsk,
                       e.reu,
                       e.kul,
                       e.nd,
                       e.kw,
                       s.trest,
                       t.usl_id AS USL,
                       t.lg_id,
                       d.kod as org,
                       t.nomer,
                       t.main AS cnt_main,
                       t.summa,
                       1 AS cnt,
                       p.period
                        FROM PRIVS       t,
                             KART        e,
                             NABOR       k,
                             S_REU_TREST s,
                             PARAMS      p,
                             SPRORG      d
                       WHERE t.lsk = e.lsk
                         AND e.reu = s.reu
                         AND e.lsk = k.lsk
                         AND t.usl_id = k.USL
                         AND k.ORG = d.kod AND t.main NOT IN (2)
                      UNION ALL
                      SELECT t.lsk,
                             s.reu,
                             e.kul,
                             e.nd,
                             e.kw,
                             s.trest,
                             t.USL,
                             t.lg_id,
                             t.ORG,
                             0 AS nomer,
                             t.main,
                             t.summa,
                             1 AS cnt,
                             p.period
                        FROM T_CORRECTS_LG t,
                             KART          e,
                             S_REU_TREST   s,
                             PARAMS        p
                       WHERE e.lsk = t.lsk
                         AND e.reu = s.reu
                         AND t.mg = p.period AND t.main NOT IN (2))
               GROUP BY lsk,
                        reu,
                        kul,
                        nd,
                        kw,
                        trest,
                        USL,
                        lg_id,
                        ORG,
                        nomer,
                        cnt_main,
                        cnt,
                        period;

prompt
prompt Creating view V_HOUSE_PARS
prompt ==========================
prompt
create or replace force view scott.v_house_pars as
select u."ID",u."CD",u."NAME",u."NM",u."FK_LISTTP",u."NPP",u."VAL_TP",u."FK_UNIT" from u_list u, u_listtp tp
where tp.cd='house_params'
and u.fk_listtp=tp.id;

prompt
prompt Creating view V_KART
prompt ====================
prompt
create or replace force view scott.v_kart as
select k."LSK",k."KUL",k."ND",k."KW",k."FIO",k."KPR",k."KPR_WR",k."KPR_OT",k."KPR_CEM",k."KPR_S",k."OPL",k."PPL",k."PLDOP",k."KI",k."PSCH",k."PSCH_DT",k."STATUS",k."KWT",k."LODPL",k."BEKPL",k."BALPL",k."KOMN",k."ET",k."KFG",k."KFOT",k."PHW",k."MHW",k."PGW",k."MGW",k."PEL",k."MEL",k."SUB_NACH",k."SUBSIDII",k."SUB_DATA",k."POLIS",k."SCH_EL",k."REU",k."TEXT",k."SCHEL_DT",k."EKSUB1",k."EKSUB2",k."KRAN",k."KRAN1",k."EL",k."EL1",k."SGKU",k."DOPPL",k."SUBS_COR",k."HOUSE_ID",k."C_LSK_ID",k."MG1",k."MG2",k."KAN_SCH",k."SUBS_INF",k."K_LSK_ID",k."DOG_NUM",k."SCHEL_END",k."FK_DEB_ORG",k."SUBS_CUR",k."K_FAM",k."K_IM",k."K_OT",k."MEMO",k."FK_DISTR",k."LAW_DOC",k."FK_PASP_ORG",k."FLAG",k."FLAG1",k."FK_ERR",k."LAW_DOC_DT",k."PRVT_DOC",k."PRVT_DOC_DT",k."CPN",k."KPR_WRP",k."PN_DT",k."LSK_EXT",k."FK_TP"
    from kart k, v_lsk_tp tp
    where k.fk_tp=tp.id(+)
    and case when p_houses.get_g_lsk_tp=0 and tp.cd='LSK_TP_MAIN' then 1 --только основные лс
             when p_houses.get_g_lsk_tp=0 and tp.cd is null then 1 --считать основными лс где не заполнено k.fk_tp (старые периоды)
             when p_houses.get_g_lsk_tp=1 and tp.cd='LSK_TP_ADDIT' then 1  --только дополнительные лс
             when p_houses.get_g_lsk_tp=2 then 1 --все лс
             else 0 end=1
;

prompt
prompt Creating view V_KART_SUBS
prompt =========================
prompt
create or replace force view scott.v_kart_subs as
select null as mg, null as lsk from dual;

prompt
prompt Creating view V_KART_SUBS2
prompt ==========================
prompt
create or replace force view scott.v_kart_subs2 as
select t.reu, t.lsk, p.name, ltrim(t.nd,'0') as nd, ltrim(t.kw,'0') as kw, s.summa as subs, e.summa as subs_el, t.mg
 from arch_kart t, a_houses h, spul p, list_choices_reu l,
 (select lsk, mg, sum(summa) as summa from arch_subsidii
  where usl_id<>'024' group by lsk, mg) s,
 (select lsk, mg, sum(summa) as summa from arch_subsidii
  where usl_id='024' group by lsk, mg) e,
 (select lsk, mg, sum(summa) as summa from arch_charges
  where usl_id = '023' group by lsk, mg
  having sum(summa) <>0
  ) c
 where t.lsk=s.lsk(+) and t.mg=s.mg(+)
  and h.mg=t.mg and t.house_id=h.id and nvl(h.house_type ,0) = 1 /* общаги */
  and t.lsk=e.lsk(+) and t.mg=e.mg(+)
  and t.lsk=c.lsk(+) and t.mg=c.mg(+)
  and t.kul=p.id and e.summa <> 0
  and t.reu=l.reu and l.sel=0;

prompt
prompt Creating view V_LOAD_PRIVS
prompt ==========================
prompt
create or replace force view scott.v_load_privs as
select t.id, k.lsk, k.fk_tp, t."ORG1",t."DATN",t."POSEL",
t."NASP",t."NYLIC",t."NDOM",t."NKORP",t."NKW",t."NKOMN",
t."LCHET",t."FAMIL",t."IMJA",t."OTCH",t."DROG",t."ID_PKU",
t."PKU",t."GKU1",t."LCHET1",t."ED_IZM1",t."FAKT1",t."SUM_F1",t."PRZ1",t."GKU2",t."LCHET2",t."ED_IZM2",t."FAKT2",t."SUM_F2",t."NORM2",t."FAKT21",t."SUM_F21",t."O_PL2",t."PRZ2",t."GKU3",t."LCHET3",t."ED_IZM3",t."FAKT3",t."SUM_F3",t."NORM3",t."PR3_1",t."PR3_2",t."PR3_3",t."O_PL3",t."PRZ3",t."GKU4",t."LCHET4",t."ED_IZM4",t."FAKT4",t."SUM_F4",t."NORM4",t."PRZ4",t."GKU5",t."LCHET5",t."ED_IZM5",t."FAKT5",t."SUM_F5",t."NORM5",t."FAKT51",t."SUM_F51",t."O_PL5",t."PRZ5",t."GKU6",t."LCHET6",t."ED_IZM6",t."FAKT6",t."SUM_F6",t."NORM6",t."PRZ6",t."GKU7",t."LCHET7",t."ED_IZM7",t."FAKT7",t."SUM_F7",t."NORM7",t."FAKT71",t."SUM_F71",t."O_PL7",t."PRZ7",t."GKU8",t."LCHET8",t."ED_IZM8",t."FAKT8",t."SUM_F8",t."NORM8",t."PRZ8",t."GKU9",t."LCHET9",t."ED_IZM9",t."FAKT9",t."SUM_F9",t."NORM9",t."FAKT91",t."TF_N",t."TF_SV",t."O_PL9",t."PRZ9",t."GKU10",t."LCHET10",t."ED_IZM10",t."FAKT10",t."SUM_F10",t."PRZ10",t."FK_LSK",t."FK_FILE",t."TP"
  from load_privs t
  left join prep_house t2
    on t.nylic=t2.ext_nylic and nvl(t.ndom,'XXX')=nvl(t2.ext_ndom,'XXX') and nvl(t.nkorp,'XXX')=nvl(t2.ext_nkorp,'XXX')
  left join prep_street t3
    on t3.ext_nylic = t2.ext_nylic
  left join v_lsk_tp tp2 on tp2.cd='LSK_TP_MAIN'
  left join kart k
    on k.nd=t2.nd and k.kul=t3.kul and k.kw=lpad(t.nkw,7,'0')
    and k.psch not in (8,9)and k.fk_tp=tp2.id and k.sel1=1
  where  nvl(t.tp,0)=0;

prompt
prompt Creating view V_MESSAGES
prompt ========================
prompt
create or replace force view scott.v_messages as
select m.id, m.user_id, m.from_id, m.text, is_read, is_read_lamp,
     decode(uid,m.from_id,0,1) as can_set_is_read,  m.dat
    from messages m
   where m.user_id=uid or m.from_id=uid;

prompt
prompt Creating view V_MESSAGES_LAST
prompt =============================
prompt
create or replace force view scott.v_messages_last as
select text, dat, username, id, user_id from
(select m.text, m.dat, a.username, m.id, a.user_id
    from messages m, all_users a
   where m.user_id=uid and a.user_id=m.from_id and m.is_read_lamp=0
order by m.dat desc)
where rownum=1;

prompt
prompt Creating view V_MONTH
prompt =====================
prompt
create or replace force view scott.v_month as
select 1 as id, 'январь' as month from dual
union all
select 2 as id, '‘евраль' as month from dual
union all
select 3 as id, 'ћарт' as month from dual
union all
select 4 as id, 'јпрель' as month from dual
union all
select 5 as id, 'ћай' as month from dual
union all
select 6 as id, '»юнь' as month from dual
union all
select 7 as id, '»юль' as month from dual
union all
select 8 as id, 'јвгуст' as month from dual
union all
select 9 as id, '—ент€брь' as month from dual
union all
select 10 as id, 'ќкт€брь' as month from dual
union all
select 11 as id, 'Ќо€брь' as month from dual
union all
select 12 as id, 'ƒекабрь' as month from dual;

prompt
prompt Creating view V_PARAMS
prompt ======================
prompt
create or replace force view scott.v_params as
select p.id, p.param, p.message, p.ver, p.mess_hint,
p.period, (select count(*) as cnt from scott.v_messages v
where v.is_read_lamp= 0 and v.can_set_is_read = 1
and v.user_id=uid) as cntmess,
TO_CHAR(ADD_MONTHS( to_date( p.period,'YYYYMM'),1),'YYYYMM') as period1,
TO_CHAR(to_date( p.period,'YYYYMM'),'MM/YYYY') as period2,
TO_CHAR(ADD_MONTHS( to_date( p.period,'YYYYMM'),-1),'YYYYMM') as period3,
CASE WHEN ROUND(sysdate-p.agent_uptime,2) > 0.02 THEN 1 ELSE 0 END
    as agent_uptime, p.agent_uptime as agent_time
from scott.params p;

prompt
prompt Creating package INIT
prompt =====================
prompt
create or replace package scott.init is
ncomp_ c_kwtp.nkom%type;
dtek_ c_kwtp.dtek%type;
spr_tarif_upd_ number;
g_admin_acc number;
g_user number;

--начальна€ дата мес€ца
g_dt_start date;
--конечна€ дата мес€ца
g_dt_end date;
--текущий период
g_period params.period%type;

--начальна€ дата мес€ца, дл€ текущих операций
g_dt_cur_start date;
--конечна€ дата мес€ца, дл€ текущих операций
g_dt_cur_end date;

PROCEDURE set_nkom(nkom_ in c_comps.nkom%type);
FUNCTION get_nkom return c_comps.nkom%type;
FUNCTION get_org_nkom
  return c_comps.fk_org%type;
FUNCTION compare_org(p_fk_org1 IN t_org.id%TYPE, p_fk_org2 IN t_org.id%TYPE)
  return number;
FUNCTION get_role return t_role.name%type;

FUNCTION get_login_acc
 return number;

FUNCTION get_fio
  return t_user.name%type;

FUNCTION get_def_reu
  return permissions.reu%type;

FUNCTION get_cur_period
  return params.period%type;

FUNCTION get_kart_ed1
  return params.kart_ed1%type;

FUNCTION get_is_cnt_sch
  return params.cnt_sch%type;

FUNCTION get_gen_exp_lst
  return params.gen_exp_lst%type;

FUNCTION get_org_var
  return params.org_var%type;

FUNCTION get_show_exp_pay
  return params.show_exp_pay%type;

FUNCTION get_have_splash
  return params.splash%type;

FUNCTION recharge_bill
  return params.recharge_bill%type;

FUNCTION get_errors
  return varchar2;
FUNCTION get_dbid
  return varchar2;
Function set_date(dat_ in c_kwtp.dtek%type)
  return number;
function is_allow (name_ in varchar2) return number;
function is_allow_acc(l_obj_name in varchar2) return number;

procedure set_user;

Function check_date(dat_ in c_kwtp.dtek%type)
  return number;
FUNCTION get_date return c_kwtp.dtek%type;

function get_dt_start
  return c_kwtp.dtek%type;
function get_dt_end
  return c_kwtp.dtek%type;
function get_cur_dt_start
  return c_kwtp.dtek%type;
function get_cur_dt_end
  return c_kwtp.dtek%type;

FUNCTION get_period_date(p_nkom in c_comps.nkom%type) return c_kwtp.dtek%type;
FUNCTION get_period
  return params.period%type;
procedure set_state(state_ in params.state_base_%type);
Function get_state
  return number;
Function get_user
  return number;
Function get_load_dir
  return varchar2;
function get_unq_comp return number;

end init;
/

prompt
prompt Creating view V_PENYA_FOR_SALDO
prompt ===============================
prompt
create or replace force view scott.v_penya_for_saldo as
select p.lsk, sum(p.summa) as summa, p.usl, p.org
  from kwtp_day p
 where p.priznak=0
   and not exists
 (select e.usl_id from usl_excl e where e.usl_id = p.usl)
   and p.dtek between init.get_dt_start and init.get_dt_end
 group by p.lsk, p.usl, p.org;

prompt
prompt Creating view V_PERIOD_REPORTS
prompt ==============================
prompt
CREATE OR REPLACE FORCE VIEW SCOTT.V_PERIOD_REPORTS AS
SELECT r.id, r.cd, mg, dat, dat AS cdat, p.signed
    FROM PERIOD_REPORTS p, reports r WHERE p.signed = 1
    and r.id=p.id
    ORDER BY dat DESC;

prompt
prompt Creating view V_PERMISSIONS_MAIN
prompt ================================
prompt
create or replace force view scott.v_permissions_main as
select p."USERNAME", p."REU", p."TREST", p."TYPE", p."MENU_ID", p."USER_ID",
       p."ROLE_ID", p."R_DOC_FUNCT_ID"
  from permissions p, t_user u
 where p.user_id=u.id and u.cd='BUGH1'
   and p.type = 4;

prompt
prompt Creating view V_PERMISSIONS_MENU
prompt ================================
prompt
create or replace force view scott.v_permissions_menu as
select t."USERNAME", t."REU", t."TREST", t."TYPE", t."MENU_ID", t."USER_ID",
       t."ROLE_ID", t."R_DOC_FUNCT_ID", m.name, m.name1
  from permissions t, t_user u, menu m
 where t.type in (2)
   and t.user_id=u.id and u.cd='BUGH1'
   and t.menu_id = m.id
   order by m.id;

prompt
prompt Creating view V_PERMISSIONS_MENU2
prompt =================================
prompt
create or replace force view scott.v_permissions_menu2 as
select t."USERNAME", t."REU", t."TREST", t."TYPE", t."MENU_ID", t."USER_ID",
       t."ROLE_ID", t."R_DOC_FUNCT_ID", m.name, m.name1
  from permissions t, t_user u, menu m
 where t.type in (2, 3)
   and t.user_id=u.id and u.cd='BUGH1'
   and t.menu_id = m.id
   order by m.id;

prompt
prompt Creating view V_PERMISSIONS_MENU3
prompt =================================
prompt
create or replace force view scott.v_permissions_menu3 as
select t."USERNAME", t."REU", t."TREST", t."TYPE", t."MENU_ID", t."USER_ID",
       t."ROLE_ID", t."R_DOC_FUNCT_ID", m.name, m.name1
  from permissions t, t_user u, menu m
 where t.type in (2, 3, 5)
   and t.user_id=u.id and u.cd='BUGH1'
   and t.menu_id = m.id
 order by m.id;

prompt
prompt Creating view V_PERMISSIONS_REU
prompt ===============================
prompt
create or replace force view scott.v_permissions_reu as
select p.fk_reu as reu, s.name_reu
 from t_user u, c_users_perm p, u_list i, s_reu_trest s
      where u.id=p.user_id and u.cd=user and p.fk_reu=s.reu
      and i.id=p.fk_perm_tp and i.cd='доступ к отчЄтам'

/*select p."USERNAME", p."REU", p."TREST", p."TYPE", p."MENU_ID", p."USER_ID",
       p."ROLE_ID", p."R_DOC_FUNCT_ID", s.name_reu
  from permissions p, s_reu_trest s, t_user c
 where c.cd = 'BUGH1'
   and c.id = p.user_id
   and p.type = 0
   and p.reu = s.reu
 order by p.reu;*/;

prompt
prompt Creating view V_PERMISSIONS_ND
prompt ==============================
prompt
create or replace force view scott.v_permissions_nd as
select distinct t.kul, t.nd, t.reu from kart t, v_permissions_reu v where
     t.reu=v.reu order by t.kul,t.nd;

prompt
prompt Creating view V_PERMISSIONS_TREST
prompt =================================
prompt
create or replace force view scott.v_permissions_trest as
select distinct p."USERNAME", p."REU", p."TREST", p."TYPE", p."MENU_ID",
                p."USER_ID", p."ROLE_ID", p."R_DOC_FUNCT_ID",
                s.name as name_tr
  from permissions p, t_org s, t_user c
 where c.cd = 'BUGH1'
   and c.id = p.user_id
   and p.trest = s.trest
   and p.type = 1
 order by p.trest;

prompt
prompt Creating view V_PRIVS_FOR_SALDO
prompt ===============================
prompt
create or replace force view scott.v_privs_for_saldo as
select
 p.lsk, sum(p.summa) as summa, p.usl_id as usl, t.fk_org2 as org, 0 as id_region
  from privs p, params m, kart r, nabor k, t_org t
 where r.lsk = p.lsk
   and r.lsk = k.lsk
   and k.usl = p.usl_id
   and k.org=t.id
   and not exists
 (select e.usl_id from usl_excl e where e.usl_id = p.usl_id)
 group by p.lsk, p.usl_id, t.fk_org2;

prompt
prompt Creating view V_STATES_SCH
prompt ==========================
prompt
create or replace force view scott.v_states_sch as
select a."ID",a."LSK",a."FK_STATUS",a."DT1",a."DT2"
  from c_states_sch a, params p
 where (to_date(p.period || '01', 'YYYYMMDD') between
       nvl(a.dt1, to_date('01011900', 'DDMMYYYY')) and
       nvl(a.dt2, to_date('01012900', 'DDMMYYYY'))
    or last_day(to_date(p.period || '01', 'YYYYMMDD')) between
       nvl(a.dt1, to_date('01011900', 'DDMMYYYY')) and
       nvl(a.dt2, to_date('01012900', 'DDMMYYYY')));

prompt
prompt Creating view V_SUBSIDII_FOR_SALDO
prompt ==================================
prompt
create or replace force view scott.v_subsidii_for_saldo as
select p.lsk, sum(p.summa) as summa, p.usl, k.org
  from nabor k, kart r, subsidii p, params m
 where r.lsk = k.lsk
   and r.lsk = p.lsk
   and k.usl = p.usl
 group by p.lsk, p.usl, k.org;

prompt
prompt Creating view V_USXRL
prompt =====================
prompt
create or replace force view scott.v_usxrl as
select u.id as user_id, u.cd, u.name, o.cd as role_cd, o.name as role_name
from t_user u, t_usxrl r, t_role o
where u.id=r.fk_user and r.fk_role=o.id;

prompt
prompt Creating view V_XITO5
prompt =====================
prompt
CREATE OR REPLACE FORCE VIEW SCOTT.V_XITO5 AS
SELECT SUM(summa) summa,  s.trest, s.reu, SUBSTR(o.oigu,1,1) other ,
          DECODE(o.tpl,'5',1,0) nal, SUBSTR(o.oigu,2,1) ink, t.oper
     FROM kwtp_day t, oper o, kart k,s_reu_trest s
     WHERE t.oper=o.oper AND t.priznak=1
     AND t.lsk =k.lsk and k.reu=s.reu
     and t.dat_ink between init.get_dt_start and init.get_dt_end
     GROUP BY s.trest, s.reu, SUBSTR(o.oigu,1,1), DECODE(o.tpl,'5',1,0),
          SUBSTR(o.oigu,2,1), t.oper;

prompt
prompt Creating view V_XITO5_ALL
prompt =========================
prompt
CREATE OR REPLACE FORCE VIEW SCOTT.V_XITO5_ALL AS
SELECT summa ska, 0 pn, s.trest, SUBSTR(t.nkom,1,2) reu, SUBSTR(o.oigu,1,1) other ,
          DECODE(o.tpl,'5',1,0) nal, SUBSTR(o.oigu,2,1) ink, t.oper
     FROM kwtp_day t, t_org s, oper o, c_comps c
     WHERE t.oper=o.oper AND t.priznak=1
     and t.nkom=c.nkom and c.fk_org=s.id
     and t.dat_ink between init.get_dt_start and init.get_dt_end
UNION ALL
SELECT 0 ska, summa pn, s.trest, SUBSTR(t.nkom,1,2) reu, SUBSTR(o.oigu,1,1) other ,
          DECODE(o.tpl,'5',1,0) nal, SUBSTR(o.oigu,2,1) ink, t.oper
     FROM kwtp_day t, t_org s, oper o, c_comps c
     WHERE t.oper=o.oper AND t.priznak=0
     and t.nkom=c.nkom and c.fk_org=s.id
     and t.dat_ink between init.get_dt_start and init.get_dt_end;

prompt
prompt Creating view V_XITO5_ALLDAY
prompt ============================
prompt
CREATE OR REPLACE FORCE VIEW SCOTT.V_XITO5_ALLDAY AS
(



SELECT g.ska,g.pn,g.trest,g.reu,g.other,g.nal,g.ink,g.oper,g.md,g.nkom,g.nink FROM
(
SELECT t.lsk,  summa ska, 0 pn,  s.trest, SUBSTR(t.nkom,1,2) reu, SUBSTR(o.oigu,1,1) other ,
          DECODE(o.tpl,'5',1,0) nal, SUBSTR(o.oigu,2,1) ink, t.oper, t.dat_ink as md, t.nkom, t.nink
     FROM kwtp_day t, t_org s, oper o, c_comps c
     WHERE t.oper=o.oper AND t.priznak=1
     and t.nkom=c.nkom and c.fk_org=s.id
     and t.dat_ink between init.get_dt_start and init.get_dt_end
) g
UNION ALL
SELECT g.ska,g.pn,g.trest,g.reu,g.other,g.nal,g.ink,g.oper,g.md,g.nkom,g.nink FROM
(
SELECT t.lsk,  0 ska, summa pn,  s.trest, SUBSTR(t.nkom,1,2) reu, SUBSTR(o.oigu,1,1) other ,
          DECODE(o.tpl,'5',1,0) nal, SUBSTR(o.oigu,2,1) ink, t.oper, t.dat_ink as md, t.nkom, t.nink
     FROM kwtp_day t, t_org s, oper o, c_comps c
     WHERE t.oper=o.oper AND t.priznak=0
     and t.nkom=c.nkom and c.fk_org=s.id
     and t.dat_ink between init.get_dt_start and init.get_dt_end
) g


);

prompt
prompt Creating view V_XITO5_ALLDAY_
prompt =============================
prompt
CREATE OR REPLACE FORCE VIEW SCOTT.V_XITO5_ALLDAY_ AS
(SELECT g.ska, g.pn, g.trest, g.reu, g.from_reu, g.other, g.nal, g.ink, g.oper, g.md FROM
(
SELECT t.lsk,  summa ska, 0 pn,  s.trest, s.reu, SUBSTR(nkom,1,2) from_reu, SUBSTR(o.oigu,1,1) other ,
          DECODE(o.tpl,'5',1,0) nal, SUBSTR(o.oigu,2,1) ink, t.oper, t.dat_ink as md
     FROM kwtp_day t, kart k, s_reu_trest s, oper o
     WHERE t.oper=o.oper AND t.priznak=1
     AND t.lsk =k.lsk and k.reu=s.reu
     and t.dat_ink between init.get_dt_start and init.get_dt_end
UNION ALL
SELECT t.lsk,  summa ska, 0 pn,  s.trest, SUBSTR(nkom,1,2) reu, SUBSTR(nkom,1,2) from_reu, SUBSTR(o.oigu,1,1) other ,
          DECODE(o.tpl,'5',1,0) nal, SUBSTR(o.oigu,2,1) ink, t.oper, t.dat_ink as md
     FROM kwtp_day t, s_reu_trest s, oper o
     WHERE t.oper=o.oper AND t.priznak=1
     AND t.lsk LIKE '„%' AND s.reu=SUBSTR(nkom,1,2)
     and t.dat_ink between init.get_dt_start and init.get_dt_end
) g
UNION ALL
SELECT g.ska, g.pn, g.trest, g.reu, g.from_reu, g.other, g.nal, g.ink, g.oper, g.md FROM
(
SELECT t.lsk,  0 ska, summa pn,  s.trest, s.reu, SUBSTR(nkom,1,2) from_reu, SUBSTR(o.oigu,1,1) other ,
          DECODE(o.tpl,'5',1,0) nal, SUBSTR(o.oigu,2,1) ink, t.oper, t.dat_ink as md
     FROM kwtp_day t, kart k, s_reu_trest s, oper o
     WHERE t.oper=o.oper AND t.priznak=0
     AND t.lsk =k.lsk and k.reu=s.reu
     and t.dat_ink between init.get_dt_start and init.get_dt_end
UNION ALL
SELECT t.lsk,  summa ska, 0 pn,  s.trest, SUBSTR(nkom,1,2) reu, SUBSTR(nkom,1,2) from_reu, SUBSTR(o.oigu,1,1) other ,
          DECODE(o.tpl,'5',1,0) nal, SUBSTR(o.oigu,2,1) ink, t.oper, t.dat_ink as md
     FROM kwtp_day t, s_reu_trest s, oper o
     WHERE t.oper=o.oper AND t.priznak=0
     AND t.lsk LIKE '„%' AND s.reu=SUBSTR(nkom,1,2)
     and t.dat_ink between init.get_dt_start and init.get_dt_end
) g
);

prompt
prompt Creating view V_XITO5_ALL_
prompt ==========================
prompt
CREATE OR REPLACE FORCE VIEW SCOTT.V_XITO5_ALL_ AS
(SELECT g.ska,g.pn,g.trest,g.reu,g.from_reu,g.other,g.nal,g.ink,g.oper FROM
(

SELECT t.lsk,  summa ska, 0 pn,  s.trest, s.reu, SUBSTR(nkom,1,2) from_reu, SUBSTR(o.oigu,1,1) other ,
          DECODE(o.tpl,'5',1,0) nal, SUBSTR(o.oigu,2,1) ink, t.oper
     FROM kwtp_day t, kart k, s_reu_trest s, oper o
     WHERE t.oper=o.oper AND t.priznak=1
     AND t.lsk =k.lsk and k.reu=s.reu
     and t.dat_ink between init.get_dt_start and init.get_dt_end
UNION ALL
SELECT t.lsk,  summa ska, 0 pn,  s.trest, SUBSTR(nkom,1,2) reu, SUBSTR(nkom,1,2) from_reu, SUBSTR(o.oigu,1,1) other ,
          DECODE(o.tpl,'5',1,0) nal, SUBSTR(o.oigu,2,1) ink, t.oper
     FROM kwtp_day t, s_reu_trest s, oper o
     WHERE t.oper=o.oper AND t.priznak=1
     AND t.lsk LIKE '„%' AND s.reu=SUBSTR(nkom,1,2)
     and t.dat_ink between init.get_dt_start and init.get_dt_end
) g
UNION ALL
SELECT g.ska,g.pn,g.trest,g.reu,g.from_reu,g.other,g.nal,g.ink,g.oper FROM
(

SELECT t.lsk,  0 ska, summa pn,  s.trest, s.reu, SUBSTR(nkom,1,2) from_reu, SUBSTR(o.oigu,1,1) other ,
          DECODE(o.tpl,'5',1,0) nal, SUBSTR(o.oigu,2,1) ink, t.oper
     FROM kwtp_day t, kart k, s_reu_trest s, oper o
     WHERE t.oper=o.oper AND t.priznak=0
     AND t.lsk =k.lsk and k.reu=s.reu
     and t.dat_ink between init.get_dt_start and init.get_dt_end
UNION ALL
SELECT t.lsk,  0 ska, summa pn,  s.trest, SUBSTR(nkom,1,2) reu, SUBSTR(nkom,1,2) from_reu, SUBSTR(o.oigu,1,1) other ,
          DECODE(o.tpl,'5',1,0) nal, SUBSTR(o.oigu,2,1) ink, t.oper
     FROM kwtp_day t, s_reu_trest s, oper o
     WHERE t.oper=o.oper AND t.priznak=0
     AND t.lsk LIKE '„%' AND s.reu=SUBSTR(nkom,1,2)
     and t.dat_ink between init.get_dt_start and init.get_dt_end
) g
);

prompt
prompt Creating view V_XITO5_PEN
prompt =========================
prompt
CREATE OR REPLACE FORCE VIEW SCOTT.V_XITO5_PEN AS
SELECT SUM(summa) summa,  s.trest, s.reu, SUBSTR(o.oigu,1,1) other ,
          DECODE(o.tpl,'5',1,0) nal, SUBSTR(o.oigu,2,1) ink, t.oper
     FROM kwtp_day t, oper o, kart k, s_reu_trest s
     WHERE t.oper=o.oper AND t.priznak=0
       AND t.lsk =k.lsk and k.reu=s.reu
       and t.dat_ink between init.get_dt_start and init.get_dt_end
     GROUP BY s.trest, s.reu, SUBSTR(o.oigu,1,1), DECODE(o.tpl,'5',1,0),
          SUBSTR(o.oigu,2,1), t.oper;

prompt
prompt Creating package ADMIN
prompt ======================
prompt
CREATE OR REPLACE PACKAGE SCOTT.ADMIN IS
  time_ date;
  procedure fix_base(fix_ in number);
  PROCEDURE sign_reports;
  PROCEDURE disable_logons(param_ IN PARAMS.param%TYPE,
                           mess_  IN PARAMS.message%TYPE);
  PROCEDURE send_message(msg_ IN MESSAGES.text%TYPE);
  procedure analyze_all_tables;
  PROCEDURE ANALYZE(table_ IN sys.all_tables.table_name%TYPE);
  PROCEDURE analyze_db;
  PROCEDURE make_readed_message(id_ IN MESSAGES.id%TYPE);
  PROCEDURE trg_del_var;
  PROCEDURE trg_set_var(id_ IN NUMBER);
  PROCEDURE trg_del_rec;
  procedure test_tables;
  procedure user_add_perm(fk_pasp_org_ in c_users_perm.fk_pasp_org%type,
    fk_reu_ in c_users_perm.fk_reu%type,
    user_id_ in t_user.id%type, fk_perm_tp_ in c_users_perm.fk_perm_tp%type,
    fk_comp_ in c_users_perm.fk_comp%type);
  procedure user_del_perm(fk_pasp_org_ in c_users_perm.fk_pasp_org%type,
    fk_reu_ in c_users_perm.fk_reu%type,
    user_id_ in t_user.id%type, fk_perm_tp_ in c_users_perm.fk_perm_tp%type,
    fk_comp_ in c_users_perm.fk_comp%type);
  procedure set_state_base(var_ in number);
  function get_state_base
   return number;
  procedure set_ver(ver_ in number, type_ in number);
  procedure dsb_constr;
  procedure enb_constr;
  procedure compress_nabor;

END ADMIN;
/

prompt
prompt Creating package AGENT
prompt ======================
prompt
CREATE OR REPLACE PACKAGE SCOTT.agent IS
 TYPE rep_refcursor IS REF CURSOR;
 PROCEDURE uptime;
 PROCEDURE load_proc_plan;
 procedure load_subs_el;
 procedure load_subs_cor;
 procedure load_subs_inf;
 procedure recv_payment_for_en (dat1_ in date,
                                   dat2_ in date);
 procedure unload_en;
 procedure list_lsk(kul_           in kart.kul%type,
                      nd_            in kart.nd%type,
                      kw_            in kart.kw%type,
                      prep_refcursor in out rep_refcursor);

END agent;
/

prompt
prompt Creating package C_CHANGES
prompt ==========================
prompt
create or replace package scott.C_CHANGES is
  PROCEDURE clear_changes_proc;
  PROCEDURE gen_changes_proclsk(lsk_   in c_change.lsk%type,
                                summa_ in c_change.summa%type,
                                usl_   in c_change.usl%type,
                                mg_    in c_change.mgchange%type,
                                text_ in varchar2);
  FUNCTION test_abs_or_proc return number;
  PROCEDURE gen_changes_proc(lsk_start_ in c_change.lsk%type,
                            lsk_end_   in c_change.lsk%type,
                            mg_        in c_change.mgchange%type,
                            p_mg2        in c_change.mg2%type,
                            usl_add_ in number,
                            is_sch_ in number,
                            l_psch in number,
                            tst_ in number,
                            text_ in varchar2,
                            result_ out number,
                            doc_id_ out number,
                            p_kran1 in number,
                            p_status in number,
                            p_chrg in number,
                            p_kan in number,
                            p_wo_kpr in number, --отсутствие проживающих(1-да, 0, null - нет) (нулевые квартиры) по жел.  ис, 02.12.14!
                            p_lsk_tp_var in number --вариант перерасчета (0-только по основным лс., 1 - только по дополнит лс., 2 - по тем и другим)
                            );
  procedure gen_pay_corrects(src_usl_ in usl.usl%type,
      src_org_ in t_org.id%type,
      dst_usl_ in usl.usl%type,
      dst_org_ in t_org.id%type,
      reu_ in t_org.reu%type,
      p_tp in number);
  procedure gen_corrects(src_usl_ in usl.usl%type,
    src_org_ in t_org.id%type,
    dst_usl_ in usl.usl%type,
    dst_org_ in t_org.id%type,
    reu_ in t_org.reu%type,
    text_ in c_change_docs.text%type);
  procedure del_chng_doc(id_ in c_change_docs.id%type);
  procedure del_chng(id_ in c_change.id%type);
  procedure del_corr(fk_doc_ in c_change_docs.id%type);
end C_CHANGES;
/

prompt
prompt Creating package C_CHARGES
prompt ==========================
prompt
create or replace package scott.C_CHARGES is
 --глобальные переменные дл€ триггера
 nabor_lsk_ nabor.lsk%type;
 nabor_lsk2_ nabor.lsk%type;

 chng_relat_id number;
 trg_c_lg_docs_bd number;
 trg_c_lg_docs_bd_fio c_kart_pr.fio%type;
 trg_c_lg_docs_bd_lsk c_kart_pr.lsk%type;

 type t_lsk is table of kart.lsk%type;
 tab_lsk t_lsk := t_lsk(null);

 type t_vvod_id is table of c_vvod.id%type;
 tab_vvod_id t_vvod_id := t_vvod_id(null);

 type t_c_kart_pr_id is table of c_kart_pr.id%type;
 tab_c_kart_pr_id t_c_kart_pr_id := t_c_kart_pr_id(null);

 trg_kart_flag number;
 trg_t_org_flag number;
 --флаг дл€ использовани€ в скриптах
 scr_flag_ number;
 --флаг сн€ти€ логгинга при удалении строк в переходе мес€ца
 trg_proc_next_month number;
 --флаг-признак работы в скрипте (первонач. загрузка данных)
 debug_flag_ number;

 --“аблица лиц. по которым обновились определенные пол€ в триггере
 type t_klsk is table of number;
 trg_tab_klsk t_klsk := t_klsk(null);
 --флаг, дл€ триггера
 trg_klsk_flag number;
  
 --структуры дл€ использовани€ в триггерах по c_states_sch
 type trg_states is record
 (
  id c_states_sch.id%type,
  lsk c_states_sch.lsk%type,
  dt1 c_states_sch.dt1%type,
  dt2 c_states_sch.dt2%type
 );
 trg_rec_states trg_states;
 type tab_rec_states is table of trg_rec_states%type;
 tb_rec_states tab_rec_states := tab_rec_states(null);

 --структуры дл€ использовани€ в триггерах по c_states_pr
 type trg_pr_states is record
 (
  id c_states_pr.id%type,
  fk_kart_pr c_states_pr.id%type,
  fk_tp c_states_pr.id%type,
  dt1 c_states_pr.dt1%type,
  dt2 c_states_pr.dt2%type
 );
 trg_rec_pr_states trg_pr_states;
 type tab_rec_pr_states is table of trg_rec_pr_states%type;
 tb_rec_pr_states tab_rec_pr_states := tab_rec_pr_states(null);

 trg_c_kart_pr_flag number;
 trg_c_kart_pr_bd number;
 trg_c_kart_pr_bd_fio c_kart_pr.fio%type;
 trg_c_kart_pr_bd_lsk c_kart_pr.lsk%type;
 trg_c_vvod number; --флаг, чтобы правильно писать в лог описание процесса

 function get_upd_tab return tab_rec_states
  parallel_enable pipelined;
 FUNCTION gen_charges_sch(lsk_ VARCHAR2, usl_ in usl.usl%type, var_ in number, cnt_ in number)
   return number;
 PROCEDURE gen_chrg_all(p_lvl     IN NUMBER,
                         house_id_ IN c_houses.id%TYPE,
                         p_reu     IN kart.reu%TYPE,
                         p_trest   IN kart.reu%TYPE);
 FUNCTION gen_charges(lsk_ VARCHAR2, lsk_end_ VARCHAR2, house_id_ c_houses.id%TYPE,
    p_vvod c_vvod.id%type, iscommit_ number, sendmsg_ number)
    return number;

end C_CHARGES;
/

prompt
prompt Creating package C_CPENYA
prompt =========================
prompt
create or replace package scott.C_CPENYA is
  time_ DATE;
 procedure gen_charge_pay_pen;
 procedure gen_charge_pay_pen(dat_ in date);
 PROCEDURE gen_charge_pay_full;
--обертка под старый вызов
 PROCEDURE gen_charge_pay(lsk_ in kart.lsk%type, iscommit_ in number);
 PROCEDURE gen_charge_pay(lsk_ in kart.lsk%type, --лиц счет
                         iscommit_ in number,   --ставить ли коммит
                         p_dt in date           --дата по которую принимать транзакции
                        );

 PROCEDURE gen_penya(lsk_ in kart.lsk%type, islastmonth_ in number, p_commit in number);
 PROCEDURE gen_penya(lsk_ in kart.lsk%type,  dat_ in date, islastmonth_ in number, p_commit in number);
end C_CPENYA;
/

prompt
prompt Creating type REC_REDIR
prompt =======================
prompt
create or replace type scott.rec_redir as object (
  reu        VARCHAR2(2),
  fk_usl_src CHAR(3),
  fk_usl_dst CHAR(3),
  fk_org_src NUMBER,
  fk_org_dst NUMBER,
  tp         number
    )
/

prompt
prompt Creating type TAB_REDIR
prompt =======================
prompt
create or replace type scott.tab_redir as table of rec_redir
/

prompt
prompt Creating package C_DIST_PAY
prompt ===========================
prompt
create or replace package scott.C_DIST_PAY is

 procedure gen_deb_usl_all;
 procedure gen_deb_usl(l_lsk in kart.lsk%type, l_commit in number);
 procedure dist_pay_all;
 procedure dist_pay_deb_mg_lsk(p_reu in kart.reu%type, p_rec in c_kwtp_mg%rowtype);
 procedure dist_pay_lsk_force;

 --обЄртка дл€ функции по редиректу 
 --¬Ќ»ћјЌ»≈!!!!(только дл€ начислени€!!!! не использовать дл€ редиректа оплаты, так как не выполн€ет редирект услуги)
 function redirect_org (p_tp in number, --1-оплата, 0 - пен€
                        p_reu in varchar2, --код –Ё”
                        p_usl_src in varchar2, --исходна€ услуга
                        p_org_src in number,  --исходна€ орг.
                        t_redir in tab_redir --таблица редиректов
                        ) return number;
 --редирект оплаты/пени 
 procedure redirect (p_tp in number, --1-оплата, 0 - пен€
                        p_reu in varchar2, --код –Ё”
                        p_usl_src in varchar2, --исходна€ услуга
                        p_usl_dst out varchar2,--перенаправленна€ услуга
                        p_org_src in number,  --исходна€ орг.
                        p_org_dst out number, --перенаправленна€ орг.
                        t_redir in tab_redir --таблица редиректов
                        );
  procedure dist_pay_lsk_avnc_force;
end C_DIST_PAY;
/

prompt
prompt Creating package C_EXP_LIST
prompt ===========================
prompt
CREATE OR REPLACE PACKAGE SCOTT.C_EXP_LIST IS
  time_ DATE;
  PROCEDURE privs_export;
  PROCEDURE changes_export;
  PROCEDURE charges_export;
END C_EXP_LIST;
/

prompt
prompt Creating package C_GEN_PAY
prompt ==========================
prompt
create or replace package scott.C_GEN_PAY is
 time_ date;
 PROCEDURE distrib_payment_mg;
 PROCEDURE distrib_days(dat1_ in date, dat2_ in date);
 procedure dist_pay_lsk(rec2_ in c_kwtp_mg%rowtype, itr_ in number);
 procedure dist_pay_var(p_reu in varchar2, excl_usl_ in oper.fk_usl%type, rec_ in c_kwtp_mg%rowtype, var_ in number, fk_distr_ in number);
 procedure dist_pay_prep(rec_ in c_kwtp_mg%rowtype, l_summa in number,
  fk_distr_ in number, l_itg out number, l_priznak in kwtp_day.priznak%type,
  l_forсesign in number);
 procedure dist_pay_lsk_force;
 procedure dist_pay_del_corr;
 procedure dist_pay_add_corr(var_ in number);
 --редирект оплаты/пени 
 procedure redirect (p_tp in number, --1-оплата, 0 - пен€
                        p_reu in varchar2, --код –Ё”
                        p_usl_src in varchar2, --исходна€ услуга
                        p_usl_dst out varchar2, --исходна€ орг.
                        p_org_src in number, --перенаправленна€ услуга
                        p_org_dst out number --перенаправленна€ орг.
                        );
 procedure dist_sal_corr;
end C_GEN_PAY;
/

prompt
prompt Creating package C_GET_PAY
prompt ==========================
prompt
create or replace package scott.C_GET_PAY is
 --глобальна€ переменна€ определ€юща€ текущий номер компьютера пользовател€
TYPE rep_refcursor IS REF CURSOR;

--флаг распределени€ оплаты
g_flag_upd number;
function get_payment_bank_date
  return date;
function check_payment_bank_date
  return number;
function check_payment_bank_nink(nink_ in c_kwtp.nink%type)
  return number;
function get_payment_bank_summa
  return number;
function get_payment_bank_summp
  return number;
procedure cur_payment_bank (id_ in number, prep_refcursor in out rep_refcursor);
function recv_payment_bank(nink_ in c_kwtp.nink%type)
  return number;

procedure get_payment(dtek_ in c_kwtp.dtek%type, lsk_ in c_kwtp.lsk%type, summa_ in c_kwtp.summa%type,
  penya_ in c_kwtp.penya%type, oper_ in c_kwtp.oper%type, dopl_ in c_kwtp.dopl%type,
  iscorrect_ number, nkvit1_ in c_kwtp.nkvit%type, iscommit_ in number,
   num_doc_ in c_kwtp.num_doc%type, dat_doc_ in c_kwtp.dat_doc%type);

procedure get_payment_mg(id_ in c_kwtp.id%type, nkvit_ in c_kwtp.nkvit%type,
  lsk_ in c_kwtp.lsk%type, summa_ in c_kwtp.summa%type,
  penya_ in c_kwtp.penya%type, oper_ in c_kwtp.oper%type,
  dopl_ in c_kwtp.dopl%type, iscorrect_ in number, nkom_ in c_kwtp.nkom%type,
  dtek_ in c_kwtp.dtek%type, nink_ in c_kwtp.nink%type);

function get_tails return number;
function dst_money_cur_month(summa_ number)
   return number;
function get_money_nal(lsk_ in kart.lsk%type)
  return c_kwtp.id%type;
procedure make_inkass;
procedure init_c_kwtp_temp_dolg (lsk_ in kart.lsk%type);
procedure remove_pay(id_ in c_kwtp.id%type);
procedure remove_inkass(nkom_ in c_kwtp.nkom%type, nink_ in c_kwtp.nink%type);
function reverse_pay(p_kwtp_id in c_kwtp.id%type) return number;

end C_GET_PAY;
/

prompt
prompt Creating package C_KART
prompt =======================
prompt
create or replace package scott.C_KART is
--  procedure set_part_kpr_old(l_lsk in kart.lsk%type);
 /* procedure set_part_kpr_all(p_kart_pr in c_kart_pr.id%type);
  procedure set_part_kpr_all_lsk;
  procedure set_part_kpr_house(p_house_id in c_houses.id%type);
*/
  procedure set_part_kpr_vvod(p_vvod in c_vvod.id%type); 
/*  procedure set_part_kpr(p_lsk in kart.lsk%type, --лицевой
                         p_tp in u_list.cd%type --тип лицевого, дл€ расчета капремонта в доп.счетах (дл€ подстановки проживающих из основного
                         );*/
  procedure set_part_kpr(p_lsk in kart.lsk%type, p_usl in usl.usl%type,
                       p_set_utl_kpr in number,
                       p_tp in u_list.cd%type --тип лицевого, дл€ расчета капремонта в доп.счетах (дл€ подстановки проживающих из основного
                       );
  procedure get_days(
     p_usl_type2 in usl.usl_type2%type,
     p_days in out number,
     p_days_wrz in out number, p_days_wro in out number,
     p_days_kpr2 in out number,
     p_prop in c_states_pr.fk_status%type,
     p_prop_reg in c_states_pr.fk_status%type,
   p_var_cnt_kpr in number);
  function get_is_sch (
    p_fk_calc in usl.fk_calc_tp%type,
    p_psch in kart.psch%type, p_sch_el in kart.sch_el%type) return number;
  function get_is_chrg(p_sptarn in usl.sptarn%type,
      p_koeff in nabor.koeff%type, p_norm in nabor.norm%type) return number;

end C_KART;
/

prompt
prompt Creating package C_LOAD_PRIVS
prompt =============================
prompt
create or replace package scott.c_load_privs is
  type rep_refcursor is ref cursor;
  --очистить подготовительные справочники
  procedure clear_spr;
  --очистить подготовительные таблицы
  procedure clear_tabs;
  --добавить строку с наименованием файла, обновить залитые строки
  procedure add_file(p_name in prep_file.name%type);
  --подоговить таблицу соответствий улиц
  procedure prep_street;
  --подоговить таблицу соответствий домов 
  procedure prep_house;

  --подготовка таблицы к выгрузке
  procedure prep_output(p_mg in params.period%type, p_file in number, p_cnt out number);
  --рефкурсор дл€ выгрузки
  procedure rep(p_file in number, prep_refcursor in out rep_refcursor);
  
end c_load_privs;
/

prompt
prompt Creating package C_OBJ_PAR
prompt ==========================
prompt
create or replace package scott.c_obj_par is
 function get_num_param(p_k_lsk_id in k_lsk.id%type, p_lsk in kart.lsk%type,
   p_cd in u_list.cd%type) return t_objxpar.n1%type;
 function get_num_param(p_k_lsk_id in k_lsk.id%type, p_lsk in kart.lsk%type,
   p_cd in u_list.cd%type,
   p_cdtp in u_listtp.cd%type) return t_objxpar.n1%type;
 function get_str_param(p_k_lsk_id in k_lsk.id%type, p_lsk in kart.lsk%type,
   p_cd in u_list.cd%type) return t_objxpar.s1%type;
 function get_str_param(p_k_lsk_id in k_lsk.id%type, p_lsk in kart.lsk%type,
   p_cd in u_list.cd%type,
   p_cdtp in u_listtp.cd%type) return t_objxpar.s1%type;
 function set_num_param(p_k_lsk_id in k_lsk.id%type, p_lsk in kart.lsk%type,
   p_cd in varchar2, p_val in t_objxpar.n1%type) return t_objxpar.id%type;
 function set_num_param(p_k_lsk_id in k_lsk.id%type, p_lsk in kart.lsk%type,
   p_cd in varchar2, p_val in t_objxpar.n1%type, p_cdtp in u_listtp.cd%type)
   return t_objxpar.id%type;
 function set_str_param(p_k_lsk_id in k_lsk.id%type, p_lsk in kart.lsk%type,
   p_cd in varchar2, p_val in t_objxpar.s1%type) return t_objxpar.id%type;
 function set_str_param(p_k_lsk_id in k_lsk.id%type, p_lsk in kart.lsk%type,
   p_cd in varchar2, p_val in t_objxpar.s1%type, p_cdtp in u_listtp.cd%type)
   return t_objxpar.id%type;
function set_date_param(p_k_lsk_id in k_lsk.id%type, p_lsk in kart.lsk%type,
   p_cd in varchar2, p_val in t_objxpar.d1%type, p_dflt in number)
   return t_objxpar.id%type;
 function set_date_param(p_k_lsk_id in k_lsk.id%type, p_lsk in kart.lsk%type,
   p_cd in varchar2, p_val in t_objxpar.d1%type, p_dflt in number,
   p_cdtp in u_listtp.cd%type) return t_objxpar.id%type;
 function set_md5_param(p_k_lsk_id in k_lsk.id%type, p_lsk in kart.lsk%type,
   p_cd in varchar2, p_val in varchar2) return t_objxpar.id%type;
 function ins_num_param(p_k_lsk_id in k_lsk.id%type, p_lsk in kart.lsk%type,
   p_cd in varchar2, p_val in t_objxpar.n1%type,
   p_usl in usl.usl%type,
   p_tp in t_objxpar.tp%type) return t_objxpar.id%type;
end c_obj_par;
/

prompt
prompt Creating type REC_SUMM
prompt ======================
prompt
create or replace type scott.rec_summ as object (
    fk_cd varchar2(3),
    fk_id number,
    summa number,
    tp number
    )
/

prompt
prompt Creating type TAB_SUMM
prompt ======================
prompt
create or replace type scott.tab_summ as table of rec_summ
/

prompt
prompt Creating package C_PREP
prompt =======================
prompt
create or replace package scott.C_PREP is

 procedure dist_summa;
 procedure dist_summa2;
 --распределить сумму полностью (любой знак), пропорционально, по другим значени€м
 function dist_summa_full(p_sum in number, t_summ in out tab_summ) return number;

end C_PREP;
/

prompt
prompt Creating package C_VALID
prompt ========================
prompt
create or replace package scott.C_VALID is
g_upd_usl number;
procedure set_valid_lsk(p_lsk in kart.lsk%type, p_valid in number, p_tp in varchar2);
--procedure set_valid_ext_lsk(p_lsk in kart.lsk%type, p_valid in number, p_tp in varchar2,
--  p_vvod in c_vvod.id%type);
--procedure set_valid_as_vvod(p_vvod in c_vvod.id%type, p_valid in number, p_tp in varchar2);
--procedure set_valid_as_house(p_lsk in kart.lsk%type, p_valid in number, p_tp in varchar2);
function get_valid_lsk(p_lsk in kart.lsk%type, p_tp in varchar2) return number;
--procedure set_valid_klsk(p_klsk in k_lsk.id%type, p_valid in number, p_tp in varchar2, p_cdtp in varchar2);
--function get_valid_klsk(p_klsk in k_lsk.id%type, p_tp in varchar2, p_cdtp in varchar2) return number;

--procedure set_valid_states_pr(p_kart_pr in c_states_pr.id%type, p_valid in number, p_tp in varchar2);
--procedure set_valid_for_vvod(p_vvod in c_vvod.id%type, p_lsk in kart.lsk%type, p_valid in number, p_tp in varchar2);
--procedure set_valid_vvod(p_vvod in c_vvod.id%type, p_valid in number, p_tp in varchar2);
--procedure set_valid_house(p_house in c_houses.id%type, p_valid in number, p_tp in varchar2);
--procedure set_valid_all_nc(p_valid in number, p_tp in varchar2);
procedure set_valid_all(p_valid in number, p_tp in varchar2);


end C_VALID;
/

prompt
prompt Creating package DBASE_PKG
prompt ==========================
prompt
create or replace package scott.dbase_pkg
as

    -- procedure to a load a table with records
    -- from a DBASE file.
    --
    -- Uses a BFILE to read binary data and dbms_sql
    -- to dynamically insert into any table you
    -- have insert on.
    --
    -- p_dir is the name of an ORACLE Directory Object
    --       that was created via the CREATE DIRECTORY
    --       command
    --
    -- p_file is the name of a file in that directory
    --        will be the name of the DBASE file
    --
    -- p_tname is the name of the table to load from
    --
    -- p_cnames is an optional list of comma separated
    --          column names.  If not supplied, this pkg
    --          assumes the column names in the DBASE file
    --          are the same as the column names in the
    --          table
    --
    -- p_show boolean that if TRUE will cause us to just
    --        PRINT (and not insert) what we find in the
    --        DBASE files (not the data, just the info
    --        from the dbase headers....)
  function parse_row_txt(txt_ in varchar2, at_ in number)
   return varchar2;
  procedure load_e(p_org in t_org.id%type);
  function get_cnt_to_load(p_org in t_org.id%type) return number;
  procedure ins_to_kart(p_org in t_org.id%type);
  procedure load_other_file_dbf(p_dir in varchar2,
                      p_file in varchar2);
  procedure load_file_txt_bulk(p_dir in varchar2,
                      p_file in varchar2);
  procedure load_file_txt(p_dir in varchar2,
                      p_file in varchar2);
  procedure load_file_dbf(p_dir in varchar2,
                      p_file in varchar2);
  procedure load_file_dbf2(p_dir in varchar2,
                      p_file in varchar2);
  procedure load_db(p_dir in varchar2,
                      isdel_ in number,
                      fname_ in varchar2,
                      tname_ in varchar2);
  --загрузка dbf                      
  procedure load_db(p_dir in varchar2,
                        isdel_ in number,
                        fname_ in varchar2,
                        tname_ in varchar2,
                        p_is_comm in number --0-без коммита, 1-коммит
                        );
  procedure load_Table( p_dir    in varchar2,
                          p_file   in varchar2,
                          p_tname  in varchar2,
                          p_cnames in varchar2 default NULL,
                          p_show   in BOOLEAN default FALSE);
end;
/

prompt
prompt Creating package EXT_PKG
prompt ========================
prompt
CREATE OR REPLACE PACKAGE SCOTT.ext_pkg
AUTHID CURRENT_USER IS
procedure exp_base(var_ in number, p_mg1 in params.period%type, p_mg2 in params.period%type);
--procedure exp_base_arch(p_mg1 in params.period%type, p_mg2 in params.period%type);
procedure imp_vol_all;
procedure exp_vol_all;
procedure imp_vol_usl(cd_usl_ in usl.cd%type);
function is_lst(p_cd_org in varchar2) return number;
procedure fill_table;

END ext_pkg;
/

prompt
prompt Creating package EXT_PKG_NEW
prompt ============================
prompt
CREATE OR REPLACE PACKAGE SCOTT.ext_pkg_new
AUTHID CURRENT_USER IS
procedure exp_base(var_ in number, p_mg1 in params.period%type, p_mg2 in params.period%type);
--procedure exp_base_arch(p_mg1 in params.period%type, p_mg2 in params.period%type);
procedure imp_vol_all;
procedure exp_vol_all;
procedure imp_vol_usl(cd_usl_ in usl.cd%type);
function is_lst(p_cd_org in varchar2) return number;
procedure fill_table;

END ext_pkg_new;
/

prompt
prompt Creating package GEN
prompt ====================
prompt
create or replace package scott.gen is
  TYPE rep_refcursor IS REF CURSOR;
  procedure gen_check (err_ out number, err_str_ out varchar2,
    var_ in number);
  procedure gen_check_lst (var_ in number,
                           prep_refcursor IN OUT rep_refcursor);
  procedure smpl_chk (p_var in number,
                           prep_refcursor IN OUT rep_refcursor);
  procedure prep_kart_pr;
  procedure gen_opl_xito3;--
  procedure gen_opl_xito5_;--
  procedure gen_opl_xito5;--
  procedure gen_opl_xito5day(dat1_ in xito5.dat%type,
                             dat2_ in xito5.dat%type);
  procedure gen_opl_xito5day_(dat1_ in xito5_.dat%type,
                              dat2_ in xito5_.dat%type);
  procedure gen_opl_xito10day(dat1_ in xxito10.dat%type,
                              dat2_ in xxito10.dat%type);
  procedure gen_opl_xito10;--
  procedure gen_c_charges(lsk_ in kart.lsk%type);
  procedure gen_lg;--
  procedure gen_saldo(lsk_ in kart.lsk%type);
  procedure gen_saldo_houses;--
  procedure gen_debits_lsk_month(dat_ in date);
  procedure gen_xito13;
  procedure load_saldo(mg_ in varchar2); --???чЄ эт такое?
--  procedure distrib_vols;
  procedure prepare_arch_lsk(lsk_     in kart.lsk%type,
                             var_     in number);
  procedure prepare_arch_k_lsk(k_lsk_id_     in kart.k_lsk_id%type,
                             pen_last_month_ in number,
                             var_     in number);
  procedure prepare_arch_adr(kul_ in kart.kul%type,
                             nd_  in kart.nd%type,
                             kw_  in kart.kw%type,
                             var_ in number);
  procedure prepare_arch_all;
  procedure prepare_arch(lsk_ in kart.lsk%type);
  procedure upd_acrh_kart(p_lsk in kart.lsk%type,
     p_mg in params.period%type,
     p_mg1 in params.period%type,
     p_old_mg in params.period%type
     );
  procedure upd_arch_kart2(p_klsk in number, p_mg in params.period%type);
  procedure gen_stat_debits;
  procedure go_next_month_year;
  procedure go_nye_phase1;
  procedure go_nye_phase2;
  procedure go_nye_phase3;
  procedure gen_clear_tables;
  procedure gen_del_add_partitions;
  procedure make_part(tablename_ in varchar2,
                      tabspc_    in varchar2,
                      partname_  in varchar2,
                      mg_        in varchar2);
  procedure drop_part(tablename_ in varchar2, mg_ in varchar2);
  procedure trunc_part(tablename_ in varchar2, mg_ in varchar2);
  procedure auto_charge;
end gen;
/

prompt
prompt Creating package GENERATOR
prompt ==========================
prompt
CREATE OR REPLACE PACKAGE SCOTT.generator IS
  time_ DATE;
  -- Author  : LEV
  -- Created : 24/02/04 15:08:53
  -- Purpose :
  -- Public type declarations
  TYPE rep_refcursor IS REF CURSOR;
  TYPE sal_refcursor IS REF CURSOR;
  PROCEDURE disable_keys(var_ IN NUMBER);
  PROCEDURE enable_keys(var_ IN NUMBER);
  PROCEDURE test_constr_errs(cnt_ OUT NUMBER, var_ IN NUMBER);
  PROCEDURE del_table_rows(tname_      IN VARCHAR2,
                           field_name_ IN VARCHAR2,
                           dat1_       IN DATE,
                           dat2_       IN DATE);
  PROCEDURE del_table_rows_allxito(dat_ IN VARCHAR2);
  PROCEDURE insert_charges(lsk_   IN VARCHAR2,
                           usl_   IN VARCHAR2,
                           mg_    IN VARCHAR2,
                           summa_ IN NUMBER);
  PROCEDURE delete_charges(lsk1_ IN VARCHAR2, lsk2_ IN VARCHAR2);
  PROCEDURE delete_subsidii(lsk1_ IN VARCHAR2, lsk2_ IN VARCHAR2);
  PROCEDURE insert_subsidii(lsk_   IN VARCHAR2,
                            usl_   IN VARCHAR2,
                            mg_    IN VARCHAR2,
                            summa_ IN NUMBER);
  PROCEDURE report_saldo(reu_           IN VARCHAR2,
                         trest_         IN VARCHAR2,
                         mg_            IN VARCHAR2,
                         mg1_           IN VARCHAR2,
                         prep_refcursor IN OUT rep_refcursor);
  PROCEDURE report_debit(type_          IN NUMBER,
                         trest_         IN S_REU_TREST.trest%TYPE,
                         prep_refcursor IN OUT rep_refcursor);
  PROCEDURE report_proc_org(prep_refcursor IN OUT rep_refcursor);
  PROCEDURE report_proc_plan(reu_           IN S_REU_TREST.reu%TYPE,
                             trest_         IN S_REU_TREST.trest%TYPE,
                             dat1_          IN PROC_PLAN_LOADED.dat%TYPE,
                             dat2_          IN PROC_PLAN_LOADED.dat%TYPE,
                             prep_refcursor IN OUT rep_refcursor);
  PROCEDURE report_opl_tr_own(prep_refcursor IN OUT rep_refcursor);

  PROCEDURE report_pen(var_            IN NUMBER,
                       reu_            IN VARCHAR2,
                       trest_          IN VARCHAR2,
                       dat_            IN DATE,
                       dat1_           IN DATE,
                       mg_             IN VARCHAR2,
                       mg1_            IN VARCHAR2,
                       v_rep_refcursor IN OUT rep_refcursor);
  PROCEDURE report_check_rep(var_            IN NUMBER,
                             mg_             IN XITOG3.mg%TYPE,
                             mg1_            IN XITOG3.mg%TYPE,
                             v_rep_refcursor IN OUT rep_refcursor);
/*  procedure report_lg_usl_org(var_           in number,
                              var1_          in number,
                              reu_           in xito_lg2.reu%type,
                              trest_         in xito_lg2.trest%type,
                              houses_        in number,
                              org_           in xito_lg2.org_id%type,
                              mg_            in xito_lg2.mg%type,
                              mg1_           in xito_lg2.mg%type,
                              prep_refcursor in out rep_refcursor);
  procedure report_lg_stat(mg_            in xito_lg2.mg%type,
                           prep_refcursor in out rep_refcursor);*/

  PROCEDURE report_bank(var_           IN NUMBER,
                        dat_           IN XITO5.dat%TYPE,
                        dat1_          IN XITO5.dat%TYPE,
                        mg_            IN XITO5.mg%TYPE,
                        mg1_           IN XITO5.mg%TYPE,
                        prep_refcursor OUT rep_refcursor);
  PROCEDURE list_choice(clr_           IN NUMBER,
                        prep_refcursor IN OUT rep_refcursor);
  PROCEDURE list_choice_set(set_ IN NUMBER);
  PROCEDURE list_choice_uch(clr_           IN NUMBER,
                            prep_refcursor IN OUT rep_refcursor);
  PROCEDURE list_choice_set_uch(set_ IN NUMBER);
  PROCEDURE list_choice_usl(clr_           IN NUMBER,
                            prep_refcursor IN OUT rep_refcursor);
  PROCEDURE list_choice_usl_set(set_ IN NUMBER);
  PROCEDURE list_choice_reu(clr_           IN NUMBER,
                            prep_refcursor IN OUT rep_refcursor);
  procedure list_choice_hs_set(set_ in number);
  procedure list_choice_hs(clr_ in number,
                        prep_refcursor in out rep_refcursor);
  PROCEDURE del_day_payments(mg_ IN VARCHAR2);
  PROCEDURE check_day_hints(cnt_ OUT NUMBER);
END generator;
/

prompt
prompt Creating package GEN_PREP
prompt =========================
prompt
create or replace package scott.GEN_PREP is

procedure dist_npg_on_saldo3(p_lsk in scott.kart.lsk%type, p_round in number,
   p_mg in varchar2, p_mg_back in varchar2, p_i out number, p_i1 out number, p_err out number);
end GEN_PREP;
/

prompt
prompt Creating package GEN_STAT
prompt =========================
prompt
create or replace package scott.gen_stat is

procedure gen_stat_usl(dat_ in date);

end gen_stat;
/

prompt
prompt Creating package LOGGER
prompt =======================
prompt
CREATE OR REPLACE PACKAGE SCOTT.logger IS
  procedure log_act(lsk_ in log_actions.lsk%type,
    text_ in log_actions.text%type,
    fk_type_act_ in log_actions.fk_type_act%type);
  function log_text(fld_ in varchar2, old_ in varchar2, new_  in varchar2) return varchar2;
  PROCEDURE log_(time_ IN DATE, comments_ IN VARCHAR2);
  PROCEDURE log_ext_(time_ IN DATE, comments_ IN scott.log.comments_ext%type);
  procedure log_sec_;
  procedure ins_period_rep(cd_ in reports.cd%type,
   mg_ in period_reports.mg%type, dat_ in period_reports.dat%type,
    signed_in_ in period_reports.signed%type);
  function prep_err return varchar2;
  procedure raiseError(
    error_source varchar2,
    error_message varchar2 default prep_err || sqlerrm,
    error_code number default -20001
  );

END logger;
/

prompt
prompt Creating package OLD_PREP
prompt =========================
prompt
create or replace package scott.OLD_PREP is

 procedure dist_summa;

end OLD_PREP;
/

prompt
prompt Creating package P_VVOD
prompt =======================
prompt
create or replace package scott.p_vvod is
  g_tp number;
  procedure gen_dist(p_klsk           in c_vvod.fk_k_lsk%type,
                     p_dist_tp        in c_vvod.dist_tp%type,
                     p_usl            in c_vvod.usl%type,
                     p_use_sch        in out c_vvod.use_sch%type,
                     p_old_use_sch    in c_vvod.use_sch%type,
                     p_kub_nrm_fact   in out c_vvod.kub_nrm_fact%type,
                     p_kub_sch_fact   in out c_vvod.kub_sch_fact%type,
                     p_kub_ar_fact    in out c_vvod.kub_ar_fact%type,
                     p_kub_ar         in out c_vvod.kub_ar%type,
                     p_opl_ar         in out c_vvod.opl_ar%type,
                     p_kub_sch        in out c_vvod.kub_sch%type,
                     p_sch_cnt        in out c_vvod.sch_cnt%type,
                     p_sch_kpr        in out c_vvod.sch_kpr%type,
                     p_kpr            in out c_vvod.kpr%type,
                     p_cnt_lsk        in out c_vvod.cnt_lsk%type,
                     p_kub_norm       in out c_vvod.kub_norm%type,
                     p_kub_fact       in out c_vvod.kub_fact%type,
                     p_kub_man        in out c_vvod.kub_man%type,
                     p_kub            in c_vvod.kub%type,
                     p_edt_norm       in c_vvod.edt_norm%type,
                     p_kub_dist       out c_vvod.kub%type,
                     p_id             in c_vvod.id%type,
                     p_opl_add        in out c_vvod.opl_add%type,
                     p_house_id       in c_vvod.house_id%type,
                     p_old_kub        in c_vvod.kub%type,
                     p_limit_proc     in c_vvod.limit_proc%type,
                     p_old_limit_proc in c_vvod.limit_proc%type,
                     p_gen_part_kpr   in number,
                     p_wo_limit       in c_vvod.wo_limit%type);
  procedure gen_clear_odn(p_usl      in c_vvod.usl%type,
                          p_usl_chld in c_vvod.usl%type,
                          p_house    in c_houses.id%type,
                          p_vvod     in c_vvod.id%type);
  procedure gen_dist_wo_vvod_usl(p_vvod in c_vvod.id%type);
  procedure gen_dist_all_houses;
  procedure gen_test_one_vvod(p_cur_dt  in date,
                              p_vvod_id in c_vvod.id%type);
  procedure del_broken_sch_all;
  procedure del_broken_sch(p_usl in usl.usl%type);
  function gen_auto_chrg_all(p_set in number, p_usl in usl.usl%type)
    return number;
  function opl_liter(p_opl_man in number) return number;
  procedure kmp_dist_all_houses;
end p_vvod;
/

prompt
prompt Creating package REP_BILLS
prompt ==========================
prompt
create or replace package scott.rep_bills is
  type ccur is ref cursor;
  type rec_bills is record(
    mg1         char(6),
    mg          char(6),
    k_lsk_id    number,
    lsk         char(8),
    streetname  varchar2(42), --
    fio         varchar2(50),
    monthyear   varchar2(30), --
    status      number(1),
    psch        number(1),
    phw         number,
    pgw         number,
    pel         number,
    kul         char(4),
    opl         number(7, 2),
    pldop       number(7, 2),
    kpr         number(3),
    kpr_ot      number(3),
    kpr_wr      number(3),
    kpr_wrp     number(3),
    name_org    t_org.name%type, --
    phone       t_org.phone%type, --
    phone2      t_org.phone2%type, --
    ki          number(2),
    subs_inf    number,
    npp         number,
    usl         char(3),
    nm          varchar2(38),
    lg_mains    number,
    lg_ids      varchar2(300), --
    itg_pen     number,
    itg_pay     number,
    itg_pen_pay number,
    tarif       number,
    pl_svnorm   number,
    vol         number, --
    charges     number, --
    privs       number, --
    changes0    number, --
    ch_proc0    number, --
    changes1    number, --
    changes2    number, --
    sl          number, --сальдо исх.ред.01.10.12
    subs        number, --
    sub_el      number, --
    itog        number, --
    itog_uszn   number, --
    lgname      char(25), --
    lg_id       number,
    cnt         number,
    lg_koef     number,
    fname_sch   varchar2(25), --вынести в параметры
    prev_chrg   number,
    prev_pay    number,
    payment     number,
    penya       number,
    monthpenya  number,
    monthpenya2 number,
    dolg        number,
    old_dolg    number,
    itog_dolg   number,
    ovrpaymnt   number,
    sal_in      number,
    dolg2       number,
    org         number,
    bill_brake  number
    );
  type tbl_bills is table of rec_bills;


  procedure get_breaks(p_reu in kart.reu%type,
                       p_cnt number,
                       p_mg in params.period%type,
                       p_recset OUT SYS_REFCURSOR);

  function pipe_bills(lsk_  in kart.lsk%type,
                      lsk1_ in kart.lsk%type,
                      var_  in number,
                      var2_ in number,
                      kul_  in kart.kul%type,
                      nd_   in kart.nd%type,
                      kw_   in kart.kw%type,
                      mg1_  in params.period%type,
                      mg2_  in params.period%type) return tbl_bills
    pipelined;

procedure main(p_sel_obj in number,
               p_reu in kart.reu%type,
               p_kul in kart.kul%type,
               p_nd in kart.nd%type,
               p_kw in kart.kw%type,
               p_lsk in kart.lsk%type,
               p_lsk1 in kart.lsk%type,
               p_firstrec in number,
               p_lastrec in number,
               p_var2 in number,
               p_var3 in number,
               p_cntrec in number,
               p_mg in params.period%type,
               p_rfcur out ccur
  );
procedure deb(p_k_lsk_id in number,
              p_lsk in kart.lsk%type,
              p_rfcur out ccur
  );  
end rep_bills;
/

prompt
prompt Creating package REP_CHARGES
prompt ============================
prompt
CREATE OR REPLACE PACKAGE SCOTT.rep_charges IS
  TYPE rep_refcursor IS REF CURSOR;
  PROCEDURE report_xito13(reu_           IN XITO13.reu%TYPE,
                          kul_           IN XITO13.kul%TYPE,
                          nd_            IN XITO13.nd%TYPE,
                          trest_         IN XITO13.trest%TYPE,
                          mg_            IN XITO13.mg%TYPE,
                          mg1_           IN XITO13.mg%TYPE,
                          prep_refcursor IN OUT rep_refcursor);
END rep_charges;
/

prompt
prompt Creating package REP_LISTS
prompt ==========================
prompt
create or replace package scott.rep_lists is
  type rep_refcursor is ref cursor;
  procedure report(rep_id_ in number,
                          mg_            in a_charge.mg%type,
                          org_ in number,
                          var_ in number,
                          cnt_ in number,
                          proc_ in number,
                          fname_ in varchar2,
                          prep_refcursor in out rep_refcursor);
end rep_lists;
/

prompt
prompt Creating package REP_OPL
prompt ========================
prompt
CREATE OR REPLACE PACKAGE SCOTT.rep_opl IS
  TYPE rep_refcursor IS REF CURSOR;
  PROCEDURE report_xito10(var_           IN XXITO12.var%TYPE,
                          reptype_       IN NUMBER,
                          det_           IN NUMBER, --ƒополнительна€ расшифровка по предпри€ти€м
                          reu_           IN XXITO12.reu%TYPE,
                          kul_           IN XXITO12.kul%TYPE,
                          nd_            IN XXITO12.nd%TYPE,
                          trest_         IN XXITO12.trest%TYPE,
                          org_           IN NUMBER,
                          dat_           IN XXITO12.dat%TYPE,
                          dat1_          IN XXITO12.dat%TYPE,
                          status_        IN XXITO12.STATUS%TYPE,
                          mg_            IN XXITO12.mg%TYPE,
                          mg1_           IN XXITO12.mg%TYPE,
                          period_        IN XXITO12.dopl%TYPE,
                          period1_       IN XXITO12.dopl%TYPE,
                          prep_refcursor IN OUT rep_refcursor);

  PROCEDURE report_xito3(reu_           IN VARCHAR2,
                         trest_         IN VARCHAR2,
                         mg_            IN VARCHAR2,
                         mg1_           IN VARCHAR2,
                         prep_refcursor IN OUT rep_refcursor);

  PROCEDURE report_xito11(oper_          IN VARCHAR2,
                          reu_           IN VARCHAR2,
                          trest_         IN VARCHAR2,
                          org_           IN NUMBER,
                          dat_           IN XITO5.dat%TYPE,
                          dat1_          IN XITO5.dat%TYPE,
                          mg_            IN VARCHAR2,
                          mg1_           IN VARCHAR2,
                          prep_refcursor IN OUT rep_refcursor);
  PROCEDURE report_xito5(var_           IN NUMBER,
                         type_          IN NUMBER,
                         reu_           IN VARCHAR2,
                         trest_         IN VARCHAR2,
                         dat_           IN XITO5.dat%TYPE,
                         dat1_          IN XITO5.dat%TYPE,
                         mg_            IN VARCHAR2,
                         mg1_           IN VARCHAR2,
                         prep_refcursor IN OUT rep_refcursor);
  PROCEDURE report_xito5_itog(var_           IN NUMBER,
                              type_          IN NUMBER,
                              dat_           IN XITO5.dat%TYPE,
                              dat1_          IN XITO5.dat%TYPE,
                              mg_            IN VARCHAR2,
                              mg1_           IN VARCHAR2,
                              prep_refcursor IN OUT rep_refcursor);
END rep_opl;
/

prompt
prompt Creating package REP_SALDO
prompt ==========================
prompt
create or replace package scott.rep_saldo is
TYPE rep_refcursor IS REF CURSOR;
  PROCEDURE report_saldo(reu_           IN VARCHAR2,
                         trest_         IN VARCHAR2,
                         uslm_         IN VARCHAR2,
                         mg_            IN VARCHAR2,
                         mg1_           IN VARCHAR2,
                         var_         IN NUMBER,
                         prep_refcursor IN OUT rep_refcursor);
  PROCEDURE report_saldo_org_uslm(reu_           IN VARCHAR2,
                                  trest_         IN VARCHAR2,
                                  mg_            IN VARCHAR2,
                                  mg1_           IN VARCHAR2,
                                  kul_           IN VARCHAR2,
                                  nd_            IN VARCHAR2,
                                  var_           IN NUMBER,
                                  prep_refcursor IN OUT rep_refcursor);
  PROCEDURE report_saldo_uslm2(reu_           IN VARCHAR2,
                               trest_         IN VARCHAR2,
                               mg_            IN VARCHAR2,
                               mg1_           IN VARCHAR2,
                               kul_           IN VARCHAR2,
                               nd_            IN VARCHAR2,
                               uch_           IN NUMBER,
                               var_           IN NUMBER,
                               prep_refcursor IN OUT rep_refcursor);
  PROCEDURE report_saldo_org_uslm_itog(type_          IN NUMBER,
                                       reu_           IN VARCHAR2,
                                       trest_         IN VARCHAR2,
                                       uslk_          IN uslk.uslk%TYPE,
                                       mg_            IN VARCHAR2,
                                       mg1_           IN VARCHAR2,
                                       kul_           IN VARCHAR2,
                                       nd_            IN VARCHAR2,
                                       prep_refcursor IN OUT rep_refcursor);
  PROCEDURE report_saldo_org_uslm_itog2(type_          IN NUMBER,
                                        reu_           IN VARCHAR2,
                                        trest_         IN VARCHAR2,
                                        uslk_          IN uslk.uslk%TYPE,
                                        mg_            IN VARCHAR2,
                                        mg1_           IN VARCHAR2,
                                        kul_           IN VARCHAR2,
                                        nd_            IN VARCHAR2,
                                        uch_           IN NUMBER,
                                        prep_refcursor IN OUT rep_refcursor);
  PROCEDURE report_charges_usl(reu_           IN VARCHAR2,
                               trest_         IN VARCHAR2,
                               mg_            IN VARCHAR2,
                               mg1_           IN VARCHAR2,
                               var_           IN NUMBER,
                               type_           IN NUMBER,
                               det_           IN NUMBER,
                               prep_refcursor IN OUT rep_refcursor);
end rep_saldo;
/

prompt
prompt Creating package SCRIPTS
prompt ========================
prompt
create or replace package scott.scripts is
  procedure swap_payment;
  procedure swap_payment9;
  procedure swap_payment7;
  procedure swap_payment2;
  procedure swap_payment3;
  procedure gen_del_add_partitions;
  procedure new_usl(usl_ in varchar2);
  procedure script_renumber(oldreu_ in kart.reu%type,
                            reu_    in kart.reu%type);
  procedure create_uk(newreu_ in kart.reu%type,
                      nreu_   in varchar2,
                      mg1_    in params.period%type,
                      mg2_    in params.period%type);
  procedure saldo_c_lsk(newreu_ in kart.reu%type);

  procedure close_uk(newreu_ in kart.reu%type, mg2_ in params.period%type);
  procedure replace_uk_new(newreu_ in kart.reu%type);
  procedure create_uk_new(newreu_ in kart.reu%type,
                          lsk_ in kart.lsk%type,
                          type_ in number,
                          p_tp_sal in number,
                          org_ in nabor.org%type);
  procedure clear_tables;
  procedure clear_tables2;
  procedure clear_tables3;
  procedure saldo_uk_div;
  procedure swap_payment4(reu_ in varchar2, newreu_ in varchar2);
  procedure swap_payment5;
  procedure swap_changes;
  procedure upd_nabor(oldorg_ in number, org_ in number, newreu_ in kart.reu%type);
  procedure go_back_month;
  procedure create_killme;
  procedure swap_oborot;
  procedure ins_vvod;
  procedure create_kart;
  procedure find_table;
  procedure swap_payment8;
  procedure set_sal_mg;
  procedure swap_oborot2;
  procedure swap_oborot3;
  procedure close_sal;
  procedure close_sal2;
  procedure close_sal3;
  procedure swap_sal1;
  procedure swap_payment10;
  procedure swap_sal2;
  procedure swap_sal3;
  procedure swap_sal4;
  procedure swap_sal_chpay;
  procedure swap_sal_chpay2;
  procedure swap_sal_chpay3;
end scripts;
/

prompt
prompt Creating package STAT
prompt =====================
prompt
CREATE OR REPLACE PACKAGE SCOTT.stat IS
  TYPE rep_refcursor IS REF CURSOR;
  PROCEDURE rep_stat(reu_           IN VARCHAR2,
                     kul_           IN VARCHAR2,
                     nd_            IN VARCHAR2,
                     trest_         IN VARCHAR2,
                     mg_            IN VARCHAR2,
                     mg1_           IN VARCHAR2,
                     dat_           IN DATE,
                     dat1_          IN DATE,
                     var_           IN NUMBER,
                     det_           IN NUMBER,
                     org_           IN NUMBER,
                     oper_           IN VARCHAR2,
                     сd_            IN VARCHAR2,
                     spk_id_        IN NUMBER,
                     p_house        IN NUMBER,
                     p_out_tp       IN NUMBER,   --тип выгрузки (null- в рефкурсор, 1-в текстовый файл в дир по умолчанию)
                     prep_refcursor IN OUT rep_refcursor);
procedure rep_detail(p_cd in varchar2, p_mg in params.period%type, p_lsk in kart.lsk%type,
                       prep_refcursor in out rep_refcursor);


PROCEDURE SQLTofile(p_sql IN VARCHAR2,
                    p_dir IN VARCHAR2,
                    p_header_file IN VARCHAR2,
                    p_data_file IN VARCHAR2 := NULL,
                    p_dlmt IN Varchar2 :=';' --разделитель, по умолчанию - ';'
                    );

END stat;
/

prompt
prompt Creating package UPDATER
prompt ========================
prompt
create or replace package scott.UPDATER is

procedure send_message(msg_ in messages.text%type);
procedure set_ver(ver_ in number, type_ in number);
procedure del_types;

end UPDATER;
/

prompt
prompt Creating package UTILS
prompt ======================
prompt
create or replace package scott.utils is
 --глобальна€ переменна€ дл€ триггера, дл€ добавлени€ нового spk_id
 spk_id_ spk.id%type;
 --sprorg_kod_ sprorg.kod%type;
 spr_tarif_id_ spr_tarif.id%type;
 spr_tarif_root_id_ spr_tarif.id%type;
 oper_ oper.oper%type;

 function MONTH_NAME1(month_ NUMBER) RETURN varchar2;
 function MONTH_NAME(month_ NUMBER) RETURN VARCHAR2;
 function add_months_pr(mg_ in varchar2, cnt_ in number) return varchar2;
 FUNCTION get_org_lsk(p_lsk IN kart.lsk%TYPE)
           RETURN NUMBER;
 FUNCTION get_nkom_pay_lsk(p_lsk IN kart.lsk%TYPE)
    RETURN c_comps.nkom%type;
 function GET_LSK_BY_ADR(kul_ kart.kul%TYPE, nd_ kart.nd%TYPE, kw_ kart.kw%TYPE)
           RETURN VARCHAR2;
 function GET_C_LSK_ID_BY_ADR(kul_ kart.kul%TYPE, nd_ kart.nd%TYPE, kw_ kart.kw%TYPE)
           RETURN VARCHAR2;
function GET_LSK_BY_ADR2(house_id_ kart.house_id%TYPE, kw_ kart.kw%TYPE)
           RETURN VARCHAR2;
 function GET_LSK_BY_ADR3(house_id_ kart.house_id%TYPE, kw_ kart.kw%TYPE)
           RETURN kart.k_lsk_id%type;
 function GET_LSK_BY_ADR4(house_id_ kart.house_id%TYPE, kw_ kart.kw%TYPE)
           RETURN kart.c_lsk_id%type;
 function GET_K_LSK_ID_BY_LSK(lsk_ kart.lsk%TYPE)
           RETURN kart.k_lsk_id%type;
 function GET_C_LSK_ID_BY_LSK(lsk_ kart.lsk%TYPE)
           RETURN kart.c_lsk_id%type;
 function GET_ADR_BY_LSK(lsk_ kart.lsk%TYPE)
           RETURN varchar2;
 function ALLOW_FUNCT(fk_type_ in number)
           RETURN NUMBER;
  function ALLOW_EDIT_LSK(lsk_ kart.lsk%TYPE, cd_ in varchar2)
           RETURN NUMBER;
 function ALLOW_CR_NEW_LSK(lsk_ kart.lsk%TYPE)
           RETURN NUMBER;
 function ALLOW_CHANGES_LSK(lsk_ kart.lsk%TYPE)
           RETURN NUMBER;
 function GET_NEW_LSK (lsk_ in kart.lsk%TYPE, p_lsk in kart.lsk%TYPE)
           RETURN kart.lsk%type;
 FUNCTION GET_NEW_LSK_BY_REU(p_reu kart.reu%TYPE) RETURN kart.lsk%TYPE;
 function create_vvod (house_id_ c_houses.id%TYPE, usl_ c_vvod.usl%TYPE,
           num_ c_vvod.vvod_num%TYPE)
           RETURN number;
 function delete_vvod (id_ c_vvod.id%TYPE)
           RETURN number;
 function CREATE_LSK (lsk_ kart.lsk%TYPE, lsk_new_ kart.lsk%TYPE, 
      p_lsk_ext kart.lsk_ext%type, p_fio kart.fio%type)
           RETURN number;
 procedure ins_lg_doc (kart_pr_id_ in c_kart_pr.id%type);
 procedure del_lg_doc (c_lg_docs_id_ in c_lg_docs.id%type);
 procedure count_krt_kpr (lsk_ in kart.lsk%type);
 function count_krt_kpr (user_id_ in number) return number;
 function get_report_name (id_ in number)
   return varchar2;
 function get_sum_str_2(source in number) return varchar2;
 function f_order(str_ varchar2, len_ number) return varchar2;
 function f_order2(str_ varchar2) return varchar2;
 function f_ord2(str_ varchar2) return varchar2;
 function f_ord3(p_str varchar2) return varchar2;
 function f_ord_digit(p_str varchar2) return number;
 function add_months2(mg_ in varchar2, months_ in number) return varchar2;
 procedure prep_users_tree;
 procedure prep_users_par;
 function concatenate(v_rownum    number,
                     v_string    varchar2,
                     v_delimiter varchar2 default null,
                     v_call_id number default 1) return varchar2;
 function tst_krt(lsk_ in kart.lsk%type, var_ in number) return varchar2;
 procedure set_kpr(lsk_ in kart.lsk%type);
 procedure set_krt_adm (lsk_ in c_kart_pr.lsk%type);
 procedure set_krt_adm2 (fk_kart_pr_ in c_kart_pr.id%type);
 procedure upd_c_kart_pr_state(fk_kart_pr_ in c_kart_pr.id%type);
 procedure killme_upd_nabor_kf_kpr(lsk_ in kart.lsk%type);
 procedure killme_upd_nabor_kf_kpr2(id_ in c_kart_pr.id%type);
 function add_list(cdtp_ in u_listtp.cd%type, cd_ in u_list.cd%type,
   name_ in u_list.name%type) return number;
 procedure add_usl(uslm_ in usl.uslm%type, prefix_ in varchar2,
   name_ in varchar2, name2_ in usl.nm2%type, cd_ in usl.cd%type,
   price_ in prices.summa%type, org_ in nabor.org%type,
   koeff_ in nabor.koeff%type, norm_ in nabor.norm%type,
   usl_koeff_ in usl.usl%type, usl_norm_ in usl.usl%type,
   usl_org_ in usl.usl%type);
 procedure usl_add_flds;
 function del_lsk(lsk_ in kart.lsk%type) return varchar2;
 procedure del_usl(usl_ in usl.usl%type);
 procedure del_uslm(uslm_ in usl.uslm%type);
 procedure cp_price(err_ out number, err_str_ out varchar2,
   usl_ in prices.usl%type, fk_org_src_ in prices.fk_org%type,
   fk_org_dst_ in prices.fk_org%type);
 procedure del_price(usl_ in prices.usl%type, fk_org_ in prices.fk_org%type);
 function set_int_param(l_cd spr_params.cd%type,
     l_val spr_params.parn1%type) return spr_params.id%type;
 function get_int_param(cd_ varchar2) return spr_params.parn1%type;
 function getS_int_param(cd_ varchar2) return spr_params.parn1%type;
 function get_bool_param(cd_ varchar2) return spr_params.parn1%type;
 function getS_bool_param(cd_ varchar2) return spr_params.parn1%type;
 function get_str_param(cd_ varchar2) return spr_params.parvc1%type;
 function getS_str_param(cd_ varchar2) return spr_params.parvc1%type;
 function get_date_param(cd_ varchar2) return spr_params.pardt1%type;
 function getS_date_param(cd_ varchar2) return spr_params.pardt1%type;
 function getS_list_param(cd_ varchar2) return list_c.sel_id%type;
 function getScd_list_param(cd_ varchar2) return list_c.sel_cd%type;
 procedure fill_list_c (fk_par_ in spr_params.id%type);
 procedure set_list_c (fk_par_ in spr_params.id%type, id_ in list_c.id%type);
 procedure rep_add_param (fk_rep_ in reports.id%type, fk_par_ in spr_params.id%type);
 procedure rep_del_param (fk_rep_ in reports.id%type, fk_par_ in spr_params.id%type);
 function have_sch(p_lsk in kart.lsk%type, p_counter in usl.counter%type) return number;
 procedure upd_krt_sch_state(lsk_ in kart.lsk%type);
 function set_krt_psch (dat_ in c_states_sch.dt1%type,
   fk_status_ in c_states_sch.fk_status%type, lsk_ in kart.lsk%type) return integer;
 function set_base_state_gen(l_set in number) return number;

 --проверка справочника redir_pay
 function check_redir_pay return number;
end utils;
/

prompt
prompt Creating type REC_BILLS
prompt =======================
prompt
create or replace type scott.rec_bills as object(
    mg1         char(6),
    mg          char(6),
    k_lsk_id    number,
    lsk         char(8),
    streetname  varchar2(42), --
    fio         varchar2(50),
    monthyear   varchar2(30), --
    status      number(1),
    psch        number(1),
    phw         number,
    pgw         number,
    pel         number,
    kul         char(4),
    opl         number(7, 2),
    pldop       number(7, 2),
    kpr         number(3),
    kpr_ot      number(3),
    kpr_wr      number(3),
    kpr_wrp     number(3),
    name_org    varchar2(100), --
    phone       varchar2(50), --
    phone2      varchar2(50), --
    ki          number(2),
    subs_inf    number,
    npp         number,
    usl         char(3),
    nm          varchar2(38),
    lg_mains    number,
    lg_ids      varchar2(300), --
    itg_pen     number,
    itg_pay     number,
    itg_pen_pay number,
    tarif       number,
    pl_svnorm   number,
    vol         number, --
    charges     number, --
    privs       number, --
    changes0    number, --
    ch_proc0    number, --
    changes1    number, --
    changes2    number, --
    sl          number, --сальдо исх.ред.01.10.12
    subs        number, --
    sub_el      number, --
    itog        number, --
    itog_uszn   number, --
    lgname      char(25), --
    lg_id       number,
    cnt         number,
    lg_koef     number,
    fname_sch   varchar2(25), --вынести в параметры
    prev_chrg   number,
    prev_pay    number,
    payment     number,
    penya       number,
    monthpenya  number,
    monthpenya2 number,
    dolg        number,
    old_dolg    number,
    itog_dolg   number,
    ovrpaymnt   number,
    sal_in      number,
    dolg2       number,
    org         number)
/

prompt
prompt Creating type REC_NABOR
prompt =======================
prompt
create or replace type scott.rec_nabor as object (
  lsk            CHAR(8),
  usl            CHAR(3),
  org            NUMBER(3),
  koeff          NUMBER,
  norm           NUMBER,
  fk_tarif       NUMBER,
  fk_vvod        NUMBER,
  vol            NUMBER,
  vol_add        NUMBER,
  kf_kpr         NUMBER,
  sch_auto       NUMBER,
  nrm_kpr        NUMBER,
  kf_kpr_sch     NUMBER,
  kf_kpr_wrz     NUMBER,
  kf_kpr_wro     NUMBER,
  kf_kpr_wrz_sch NUMBER,
  kf_kpr_wro_sch NUMBER,
  limit          NUMBER,
  nrm_kpr2       number
   )
/

prompt
prompt Creating type REC_SALDO
prompt =======================
prompt
create or replace type scott.rec_saldo as object (
    mg varchar2(6),
    usl varchar2(3),
    org number,
    summa number,
    summa1 number,
    summa2 number
    )
/

prompt
prompt Creating type REC_STATE
prompt =======================
prompt
create or replace type scott.rec_state as object (
  fk_kart_pr     number,
  fk_status      number,
  tp             number,
  dt1            date,
  dt2            date,
  dat_rog        date,
  rel_cd         varchar2(128)
   )
/

prompt
prompt Creating type SYS_PLSQL_52946_165_2
prompt ===================================
prompt
create or replace type scott.SYS_PLSQL_52946_165_2 as object (ID NUMBER,
LSK CHAR(8),
DT1 DATE,
DT2 DATE);
/

prompt
prompt Creating type SYS_PLSQL_52946_209_2
prompt ===================================
prompt
create or replace type scott.SYS_PLSQL_52946_209_2 as table of SCOTT."SYS_PLSQL_52946_165_2";
/

prompt
prompt Creating type SYS_PLSQL_52946_DUMMY_2
prompt =====================================
prompt
create or replace type scott.SYS_PLSQL_52946_DUMMY_2 as table of number;
/

prompt
prompt Creating type SYS_PLSQL_53039_12_2
prompt ==================================
prompt
create or replace type scott.SYS_PLSQL_53039_12_2 as object (MG1 CHAR(6),
MG CHAR(6),
K_LSK_ID NUMBER,
LSK CHAR(8),
STREETNAME VARCHAR2(42),
FIO VARCHAR2(50),
MONTHYEAR VARCHAR2(30),
STATUS NUMBER(1),
PSCH NUMBER(1),
PHW NUMBER,
PGW NUMBER,
PEL NUMBER,
KUL CHAR(4),
OPL NUMBER(7,2),
PLDOP NUMBER(7,2),
KPR NUMBER(3),
KPR_OT NUMBER(3),
KPR_WR NUMBER(3),
KPR_WRP NUMBER(3),
NAME_ORG VARCHAR2(64),
PHONE VARCHAR2(15),
PHONE2 VARCHAR2(15),
KI NUMBER(2),
SUBS_INF NUMBER,
NPP NUMBER,
USL CHAR(3),
NM VARCHAR2(38),
LG_MAINS NUMBER,
LG_IDS VARCHAR2(300),
ITG_PEN NUMBER,
ITG_PAY NUMBER,
ITG_PEN_PAY NUMBER,
TARIF NUMBER,
PL_SVNORM NUMBER,
VOL NUMBER,
CHARGES NUMBER,
PRIVS NUMBER,
CHANGES0 NUMBER,
CH_PROC0 NUMBER,
CHANGES1 NUMBER,
CHANGES2 NUMBER,
SL NUMBER,
SUBS NUMBER,
SUB_EL NUMBER,
ITOG NUMBER,
ITOG_USZN NUMBER,
LGNAME CHAR(25),
LG_ID NUMBER,
CNT NUMBER,
LG_KOEF NUMBER,
FNAME_SCH VARCHAR2(25),
PREV_CHRG NUMBER,
PREV_PAY NUMBER,
PAYMENT NUMBER,
PENYA NUMBER,
MONTHPENYA NUMBER,
MONTHPENYA2 NUMBER,
DOLG NUMBER,
OLD_DOLG NUMBER,
ITOG_DOLG NUMBER,
OVRPAYMNT NUMBER,
SAL_IN NUMBER,
DOLG2 NUMBER,
ORG NUMBER,
BILL_BRAKE NUMBER);
/

prompt
prompt Creating type SYS_PLSQL_53039_403_2
prompt ===================================
prompt
create or replace type scott.SYS_PLSQL_53039_403_2 as table of SCOTT."SYS_PLSQL_53039_12_2";
/

prompt
prompt Creating type SYS_PLSQL_53039_DUMMY_2
prompt =====================================
prompt
create or replace type scott.SYS_PLSQL_53039_DUMMY_2 as table of number;
/

prompt
prompt Creating type TAB_NABOR
prompt =======================
prompt
create or replace type scott.tab_nabor as table of rec_nabor
/

prompt
prompt Creating type TAB_SALDO
prompt =======================
prompt
create or replace type scott.tab_saldo as table of rec_saldo
/

prompt
prompt Creating type TAB_STATE
prompt =======================
prompt
create or replace type scott.tab_state as table of rec_state
/

prompt
prompt Creating type TBL_BILLS
prompt =======================
prompt
create or replace type scott.tbl_bills is table of rec_bills
/

prompt
prompt Creating procedure DBF_FILE_OPEN
prompt ================================
prompt
create or replace procedure scott.dbf_file_open
as
file_name bfile;
begin
   file_name:=bfilename('LOAD_FILES','test.dbf');
   dbms_lob.open(file_name);
   dbms_output.put_line('Successful');
end;
/

prompt
prompt Creating procedure DRB18_ѕќ—“”ѕЋ≈Ќ»я_ѕќ_Ћ—
prompt ==========================================
prompt
create or replace procedure scott.DRB18_ѕоступлени€_по_лс is
begin
  Null;
end DRB18_ѕоступлени€_по_лс;
/

prompt
prompt Creating procedure DRB1_—ќ’–јЌ»“№_ЎјЅЋќЌ
prompt ========================================
prompt
create or replace procedure scott.DRb1_—охранить_шаблон is
begin
  Null;
end DRb1_—охранить_шаблон;

grant execute on DRb1_—охранить_шаблон to PROGRAMMER;
/

prompt
prompt Creating procedure DRB5_ј–’»¬
prompt =============================
prompt
create or replace procedure scott.DRB5_јрхив is
begin
  Null;
end DRB5_јрхив;
/

prompt
prompt Creating procedure DRN103_—ѕ–ј¬ќ„Ќ» _”—Ћ”√
prompt ==========================================
prompt
create or replace procedure scott.drn103_—правочник_услуг is
begin
  Null;
end drn103_—правочник_услуг;
/

prompt
prompt Creating procedure DRN105_¬¬ќƒ_ќЅЏ≈ћќ¬_ѕќ_Ћ—
prompt ============================================
prompt
create or replace procedure scott.drn105_¬вод_объемов_по_лс is
begin
  Null;
end drn105_¬вод_объемов_по_лс;
/

prompt
prompt Creating procedure DRN10_ќѕЋј“ј_¬Ќ≈ЎЌяя
prompt =======================================
prompt
create or replace procedure scott.drn10_ќплата_внешн€€ is
begin
  Null;
end drn10_ќплата_внешн€€;
/

prompt
prompt Creating procedure DRN10_ќѕЋј“ј_ѕќ_јЌ“≈ЌЌјћ
prompt ===========================================
prompt
CREATE OR REPLACE PROCEDURE SCOTT."DRN10_ќѕЋј“ј_ѕќ_јЌ“≈ЌЌјћ" is
begin
  Null;
end drn10_ќплата_по_антеннам;
/

prompt
prompt Creating procedure DRN10_—¬≈– »
prompt ===============================
prompt
create or replace procedure scott.drN10_—верки is
begin
  Null;
end drN10_—верки;
/

prompt
prompt Creating procedure DRN117_ ќ––_—јЋ№ƒќ
prompt =====================================
prompt
create or replace procedure scott.drN117_ орр_сальдо is
begin
  Null;
end drN117_ орр_сальдо;
/

prompt
prompt Creating procedure DRN11_ѕј—ѕќ–“Ќџ…_—“ќЋ
prompt ========================================
prompt
create or replace procedure scott.drn11_ѕаспортный_стол is
begin
  Null;
end drn11_ѕаспортный_стол;
/

prompt
prompt Creating procedure DRN11_—¬≈– ј_ѕќ_ƒЌяћ
prompt =======================================
prompt
create or replace procedure scott.drN11_—верка_по_дн€м is
begin
  Null;
end drN11_—верка_по_дн€м;
/

prompt
prompt Creating procedure DRN123_LK
prompt ============================
prompt
create or replace procedure scott.drN123_LK is
begin
  Null;
end drN123_LK;
/

prompt
prompt Creating procedure DRN125_—ѕ»— »_»Ќ“≈–Ќ≈“1
prompt ==========================================
prompt
create or replace procedure scott.drN125_—писки_интернет1 is
begin
  Null;
end drN125_—писки_интернет1;
/

prompt
prompt Creating procedure DRN126_—ѕ»— »_«јƒќЋ∆_ќ–√
prompt ===========================================
prompt
create or replace procedure scott.drn126_—писки_задолж_орг is
begin
  Null;
end drn126_—писки_задолж_орг;
/

prompt
prompt Creating procedure DRN127_ќ“„≈“_ѕќ_Ќќ–ћј“_ѕќ“–
prompt ==============================================
prompt
create or replace procedure scott.drn127_ќтчет_по_нормат_потр is
begin
  Null;
end drn127_ќтчет_по_нормат_потр;
/

prompt
prompt Creating procedure DRN128_—ѕ–ј¬ ј_ѕ–»Ћ5
prompt =======================================
prompt
create or replace procedure scott.drn128_—правка_прил5 is
begin
  Null;
end drn128_—правка_прил5;
/

prompt
prompt Creating procedure DRN129_ ј——ј
prompt ===============================
prompt
create or replace procedure scott.drN129_ асса is
begin
  Null;
end drN129_ асса;
/

prompt
prompt Creating procedure DRN12_—¬≈– ј_ѕќ_»Ќ ј—
prompt ========================================
prompt
create or replace procedure scott.drN12_—верка_по_инкас is
begin
  Null;
end drN12_—верка_по_инкас;
/

prompt
prompt Creating procedure DRN132_ќ“„≈“_ѕќ_ јѕ2
prompt =======================================
prompt
create or replace procedure scott.drn132_ќтчет_по_кап2 is
begin
  Null;
end drn132_ќтчет_по_кап2;
/

prompt
prompt Creating procedure DRN134_«ј√–”« ј_Ћ№√ќ“Ќ» ќ¬
prompt =============================================
prompt
create or replace procedure scott.drn134_«агрузка_льготников is
begin
  Null;
end drn134_«агрузка_льготников;
/

prompt
prompt Creating procedure DRN13_јƒћ»Ќ
prompt ==============================
prompt
create or replace procedure scott.drN13_јдмин is
begin
  Null;
end drN13_јдмин;
/

prompt
prompt Creating procedure DRN14_ќѕЋј“ј_ѕќ_”—Ћ”√≈
prompt =========================================
prompt
create or replace procedure scott.drN14_ќплата_по_услуге is
begin
  Null;
end drn14_ќплата_по_услуге;
/

prompt
prompt Creating procedure DRN15_ќѕЋј“ј_ѕќ_—“–ј’ќ¬џћ
prompt ============================================
prompt
create or replace procedure scott.drN15_ќплата_по_страховым is
begin
  Null;
end drN15_ќплата_по_страховым;
/

prompt
prompt Creating procedure DRN16_”ѕ–ј¬Ћ≈Ќ»≈
prompt ===================================
prompt
create or replace procedure scott.drN16_”правление is
begin
  Null;
end drN16_”правление;
/

prompt
prompt Creating procedure DRN17_ќЅќ–ќ“Ќјя_OLAP
prompt =======================================
prompt
CREATE OR REPLACE PROCEDURE SCOTT.drN17_ќборотна€_OLAP IS
BEGIN
  NULL;
END drN17_ќборотна€_OLAP;
/

prompt
prompt Creating procedure DRN18_—јЋ№ƒќ
prompt ===============================
prompt
create or replace procedure scott.drN18_—альдо is
begin
  Null;
end drN18_—альдо;
/

prompt
prompt Creating procedure DRN1_‘ј…Ћ
prompt ============================
prompt
create or replace procedure scott.drN1_‘айл is
begin
   DBMS_SESSION.SET_NLS('NLS_NUMERIC_CHARACTERS','''.,''');
end drN1_‘айл;
/

prompt
prompt Creating procedure DRN210_ќѕЋј“ј_ѕќ_ќѕ≈–ј÷2
prompt ===========================================
prompt
create or replace procedure scott.drN210_ќплата_по_операц2 is
begin
  Null;
end drN210_ќплата_по_операц2;
/

prompt
prompt Creating procedure DRN212_ќѕЋј“ј_ѕќ_“–≈—“јћ
prompt ===========================================
prompt
create or replace procedure scott.drN212_ќплата_по_трестам is
begin
  Null;
end drN212_ќплата_по_трестам;
/

prompt
prompt Creating procedure DRN213_ќЅќ–ќ“Ќјя_ќ“ќѕ2
prompt =========================================
prompt
create or replace procedure scott.drn213_ќборотна€_отоп2 is
begin
  Null;
end drn213_ќборотна€_отоп2;
/

prompt
prompt Creating procedure DRN24_¬џѕќЋЌ≈Ќ»≈_ѕЋјЌј
prompt =========================================
prompt
CREATE OR REPLACE PROCEDURE SCOTT.drn24_¬ыполнение_плана IS
BEGIN
  NULL;
END drn24_¬ыполнение_плана;
/

prompt
prompt Creating procedure DRN26_¬¬ќƒ_ѕќ ј«ј“
prompt =====================================
prompt
create or replace procedure scott.drN26_¬вод_показат is
begin
  Null;
end drN26_¬вод_показат;
/

prompt
prompt Creating procedure DRN27_ѕ≈Ќя
prompt =============================
prompt
create or replace procedure scott.drn27_ѕен€ is
begin
  Null;
end drn27_ѕен€;
/

prompt
prompt Creating procedure DRN28_«јƒќЋ∆Ќ_ѕ–≈ƒѕ–
prompt =======================================
prompt
create or replace procedure scott.drn28_«адолжн_предпр is
begin
  Null;
end drn28_«адолжн_предпр;
/

prompt
prompt Creating procedure DRN29_ќѕЋј“ј
prompt ===============================
prompt
create or replace procedure scott.drN29_ќплата is
begin
  Null;
end drN29_ќплата;
/

prompt
prompt Creating procedure DRN2_¬џ’ќƒ
prompt =============================
prompt
create or replace procedure scott.drN2_¬ыход is
begin
  Null;
end drN2_¬ыход;
/

prompt
prompt Creating procedure DRN30_ ќЌ“–ќЋ№_—јЋ№ƒќ
prompt ========================================
prompt
create or replace procedure scott.drN30_ онтроль_—альдо is
begin
  Null;
end drN30_ онтроль_—альдо;
/

prompt
prompt Creating procedure DRN31_ќѕЋј“ј_ѕќ_ѕ–≈ƒѕ–3
prompt ==========================================
prompt
create or replace procedure scott.drN31_ќплата_по_предпр3 is
begin
  Null;
end drN31_ќплата_по_предпр3;
/

prompt
prompt Creating procedure DRN33_“≈ ”ў»≈_–јЅќ“џ
prompt =======================================
prompt
create or replace procedure scott.drN33_“екущие_работы is
begin
  Null;
end drN33_“екущие_работы;
/

prompt
prompt Creating procedure DRN34_ ќ––≈ “»–ќ¬ ј_—јЋ№ƒќ
prompt =============================================
prompt
create or replace procedure scott.drN34_ орректировка_сальдо is
begin
  Null;
end drN34_ орректировка_сальдо;
/

prompt
prompt Creating procedure DRN36_—¬≈– ј_¬≈ƒќћќ—“≈…
prompt ==========================================
prompt
create or replace procedure scott.drn36_—верка_ведомостей is
begin
  Null;
end drn36_—верка_ведомостей;
/

prompt
prompt Creating procedure DRN37_ќѕЋј“ј_ЅјЌ ј
prompt =====================================
prompt
create or replace procedure scott.drN37_ќплата_банка is
begin
  Null;
end drN37_ќплата_банка;
/

prompt
prompt Creating procedure DRN38_ѕќƒѕ»—№_ќ“„≈“ќ¬
prompt ========================================
prompt
create or replace procedure scott.drn38_ѕодпись_отчетов is
begin
  Null;
end drn38_ѕодпись_отчетов;
/

prompt
prompt Creating procedure DRN39_—“ј“»—“» ј
prompt ===================================
prompt
create or replace procedure scott.drN39_—татистика is
begin
  Null;
end drN39_—татистика;
/

prompt
prompt Creating procedure DRN3_–јЅќ„≈≈_ћ≈—“ќ
prompt =====================================
prompt
create or replace procedure scott.drN3_–абочее_место is
begin
  Null;
end drN3_–абочее_место;
/

prompt
prompt Creating procedure DRN40_—¬≈ƒ≈Ќ»я_ѕќ_Ћ№√ќ“јћ
prompt ============================================
prompt
create or replace procedure scott.drN40_—ведени€_по_льготам is
begin
  Null;
end drN40_—ведени€_по_льготам;
/

prompt
prompt Creating procedure DRN41_—“ј“»—“» ј_ѕќ_ѕ–»¬ј“
prompt =============================================
prompt
create or replace procedure scott.drN41_—татистика_по_приват is
begin
  Null;
end drN41_—татистика_по_приват;
/

prompt
prompt Creating procedure DRN42_ѕј–јћ≈“–џ
prompt ==================================
prompt
create or replace procedure scott.drN42_ѕараметры is
begin
  Null;
end drN42_ѕараметры;
/

prompt
prompt Creating procedure DRN43_ѕ≈–»ќƒ»„≈— јя
prompt ======================================
prompt
create or replace procedure scott.drn43_ѕериодическа€ is
begin
     NULL;
end drn43_ѕериодическа€;
/

prompt
prompt Creating procedure DRN43_ѕ≈„ј“№_—„≈“ќ¬
prompt ======================================
prompt
create or replace procedure scott.drn43_ѕечать_счетов is
begin
     NULL;
end drn43_ѕечать_счетов;
/

prompt
prompt Creating procedure DRN44_—„≈“ј
prompt ==============================
prompt
create or replace procedure scott.drN44_—чета is
begin
  Null;
end drN44_—чета;
/

prompt
prompt Creating procedure DRN46_ ќ––≈ “»–ќ¬ ј_—јЋ№ƒќ_ќѕЋ
prompt =================================================
prompt
create or replace procedure scott.drN46_ орректировка_сальдо_опл is
begin
  Null;
end drN46_ орректировка_сальдо_опл;
/

prompt
prompt Creating procedure DRN48_Ќј„»—Ћ≈Ќ»≈_ѕќ_ƒќћјћ
prompt ============================================
prompt
create or replace procedure scott.drN48_Ќачисление_по_домам is
begin
  Null;
end drN48_Ќачисление_по_домам;
/

prompt
prompt Creating procedure DRN4_ ј–“ќ„ »
prompt ================================
prompt
create or replace procedure scott.drN4_ арточки is
begin
  Null;
end drN4_ арточки;
/

prompt
prompt Creating procedure DRN4_‘ќ–ћ»–ќ¬јЌ»≈
prompt ====================================
prompt
create or replace procedure scott.drN4_‘ормирование is
begin
  Null;
end drN4_‘ормирование;
/

prompt
prompt Creating procedure DRN50_ќЅќ–ќ“џ_ѕќ_ƒќћјћ
prompt =========================================
prompt
create or replace procedure scott.drn50_ќбороты_по_домам is
begin
  Null;
end drn50_ќбороты_по_домам;
/

prompt
prompt Creating procedure DRN510_—ѕ–ј¬ ј_ѕ–»Ћ6
prompt =======================================
prompt
create or replace procedure scott.drn510_—правка_прил6 is
begin
  Null;
end drn510_—правка_прил6;
/

prompt
prompt Creating procedure DRN511_—ѕ–ј¬ ј_ѕ–»Ћ7
prompt =======================================
prompt
create or replace procedure scott.drn511_—правка_прил7 is
begin
  Null;
end drn511_—правка_прил7;
/

prompt
prompt Creating procedure DRN54_¬¬ќƒ_ќѕЋј“џ
prompt ====================================
prompt
create or replace procedure scott.drN54_¬вод_оплаты is
begin
  Null;
end drN54_¬вод_оплаты;
/

prompt
prompt Creating procedure DRN55_»Ќ ј——ј÷»я
prompt ===================================
prompt
create or replace procedure scott.drN55_»нкассаци€ is
begin
  Null;
end drN55_»нкассаци€;
/

prompt
prompt Creating procedure DRN56_ѕ≈–≈–ј—„_ѕќ_ƒќћјћ
prompt ==========================================
prompt
create or replace procedure scott.drN56_ѕерерасч_по_домам is
begin
  Null;
end drN56_ѕерерасч_по_домам;
/

prompt
prompt Creating procedure DRN57_¬¬ќƒ_ќЅЏ≈ћќ¬_ѕќ_ƒќћјћ
prompt ==============================================
prompt
create or replace procedure scott.drN57_¬вод_объемов_по_домам is
begin
  Null;
end drN57_¬вод_объемов_по_домам;
/

prompt
prompt Creating procedure DRN59_ѕ–ќ—ћќ“–_ѕ≈–≈–ј—„≈“ќ¬
prompt ==============================================
prompt
create or replace procedure scott.drN59_ѕросмотр_перерасчетов is
begin
  Null;
end drN59_ѕросмотр_перерасчетов;
/

prompt
prompt Creating procedure DRN61_—ѕ–ј¬ќ„Ќ» »
prompt ====================================
prompt
create or replace procedure scott.drN61_—правочники is
begin
  Null;
end drN61_—правочники;
/

prompt
prompt Creating procedure DRN62_”—Ћ”√»_ѕќ_ƒќћјћ
prompt ========================================
prompt
create or replace procedure scott.drN62_”слуги_по_домам is
begin
  Null;
end drN62_”слуги_по_домам;
/

prompt
prompt Creating procedure DRN63_—ѕ–ј¬ќ„Ќ» _ ј“≈√ќ–»…
prompt =============================================
prompt
create or replace procedure scott.drN63_—правочник_категорий is
begin
  Null;
end drN63_—правочник_категорий;
/

prompt
prompt Creating procedure DRN64_¬¬ќƒ
prompt =============================
prompt
create or replace procedure scott.drn64_¬вод is
begin
  Null;
end drn64_¬вод;
/

prompt
prompt Creating procedure DRN65_ќѕЋј“ј
prompt ===============================
prompt
create or replace procedure scott.drN65_ќплата is
begin
  Null;
end drN65_ќплата;
/

prompt
prompt Creating procedure DRN6_ѕ≈„ј“№
prompt ==============================
prompt
create or replace procedure scott.drN6_ѕечать is
begin
  Null;
end drN6_ѕечать;
/

prompt
prompt Creating procedure DRN71_—¬≈– ј_»Ќ ј——ј÷»…
prompt ==========================================
prompt
create or replace procedure scott.drN71_—верка_инкассаций is
begin
  Null;
end drN71_—верка_инкассаций;
/

prompt
prompt Creating procedure DRN71_—¬≈– ј_ѕ≈–≈–ј—„≈“ќ¬
prompt ============================================
prompt
CREATE OR REPLACE PROCEDURE SCOTT."DRN71_—¬≈– ј_ѕ≈–≈–ј—„≈“ќ¬" is
begin
  Null;
end drN71_—верка_перерасчетов;
/

prompt
prompt Creating procedure DRN72_∆”–ЌјЋ_ƒ≈…—“¬»…2
prompt =========================================
prompt
create or replace procedure scott.DRN72_∆урнал_действий2 is
begin
  Null;
end DRN72_∆урнал_действий2;
/

prompt
prompt Creating procedure DRN73_«јя¬ »
prompt ===============================
prompt
CREATE OR REPLACE PROCEDURE SCOTT."DRN73_«јя¬ »" is
begin
  Null;
end drN73_«а€вки;
/

prompt
prompt Creating procedure DRN73_—»—“≈ћј
prompt ================================
prompt
create or replace procedure scott.drn73_—истема is
begin
  Null;
end drn73_—истема;
/

prompt
prompt Creating procedure DRN74_ќЅћ≈Ќ_ƒјЌЌџћ»
prompt ======================================
prompt
create or replace procedure scott.drn74_ќбмен_данными is
begin
  Null;
end drn74_ќбмен_данными;
/

prompt
prompt Creating procedure DRN75_—“ј“»—“» ј_ѕ–ќ√–јћћ
prompt ============================================
prompt
create or replace procedure scott.drn75_—татистика_программ is
begin
  Null;
end drn75_—татистика_программ;
/

prompt
prompt Creating procedure DRN76_¬—≈ћ_¬џ…“»
prompt ===================================
prompt
create or replace procedure scott.drn76_¬сем_выйти is
begin
  Null;
end drn76_¬сем_выйти;
/

prompt
prompt Creating procedure DRN77_ЅјЌ 
prompt =============================
prompt
create or replace procedure scott.drN77_Ѕанк is
begin
  Null;
end drN77_Ѕанк;
/

prompt
prompt Creating procedure DRN78_ќѕЋј“ј_ЌјЋ
prompt ===================================
prompt
create or replace procedure scott.drn78_ќплата_нал is
begin
  Null;
end drn78_ќплата_нал;
/

prompt
prompt Creating procedure DRN79_—¬≈– ј_ѕ≈–≈–ј—„≈“ќ¬
prompt ============================================
prompt
create or replace procedure scott.drN79_—верка_перерасчетов is
begin
  Null;
end drN79_—верка_перерасчетов;
/

prompt
prompt Creating procedure DRN7_ќѕЋј“ј_ѕќ_ѕ”Ќ “јћ
prompt =========================================
prompt
create or replace procedure scott.drN7_ќплата_по_пунктам is
begin
  Null;
end drN7_ќплата_по_пунктам;
/

prompt
prompt Creating procedure DRN81_«ј√–”« ј_ѕ–ќ„»’_‘ј…Ћќ¬
prompt ===============================================
prompt
create or replace procedure scott.drN81_«агрузка_прочих_файлов is
begin
  Null;
end drN81_«агрузка_прочих_файлов;
/

prompt
prompt Creating procedure DRN82_¬¬ќƒ_ќѕЋј“џ_ѕќ_јƒ–
prompt ===========================================
prompt
create or replace procedure scott.drN82_¬вод_оплаты_по_адр is
begin
  Null;
end drN82_¬вод_оплаты_по_адр;
/

prompt
prompt Creating procedure DRN83_—ѕ»— »_«јƒќЋ∆Ќ» ќ¬
prompt ===========================================
prompt
create or replace procedure scott.drn83_—писки_задолжников is
begin
  Null;
end drn83_—писки_задолжников;
/

prompt
prompt Creating procedure DRN84_—ѕ–ј¬ќ„Ќ» _ќ–√_«јƒќЋ∆Ќ
prompt ===============================================
prompt
create or replace procedure scott.drN84_—правочник_орг_задолжн is
begin
  Null;
end drN84_—правочник_орг_задолжн;
/

prompt
prompt Creating procedure DRN85_—ѕ»— »_Ћ№√ќ“Ќ» ќ¬
prompt ==========================================
prompt
create or replace procedure scott.drn85_—писки_льготников is
begin
  Null;
end drn85_—писки_льготников;
/

prompt
prompt Creating procedure DRN86_ј¬“ќЌј„»—Ћ≈Ќ»≈
prompt =======================================
prompt
create or replace procedure scott.drn86_автоначисление is
begin
  Null;
end drn86_автоначисление;
/

prompt
prompt Creating procedure DRN86_—“ј“»—“» ј_ќЅЏ≈ћЌ_ѕќ ј«
prompt ================================================
prompt
create or replace procedure scott.drn86_—татистика_объемн_показ is
begin
  Null;
end drn86_—татистика_объемн_показ;
/

prompt
prompt Creating procedure DRN871_—ѕ»— »_«јƒќЋ∆Ќ_OLAP2
prompt ==============================================
prompt
create or replace procedure scott.drn871_—писки_задолжн_OLAP2 is
begin
  Null;
end drn871_—писки_задолжн_OLAP2;
/

prompt
prompt Creating procedure DRN87_—ѕ»— »_ѕќ ј«_—„
prompt ========================================
prompt
create or replace procedure scott.drn87_—писки_показ_сч is
begin
  Null;
end drn87_—писки_показ_сч;
/

prompt
prompt Creating procedure DRN88_—ѕ–ј¬ќ„Ќ» _ѕ≈Ќ»
prompt ========================================
prompt
create or replace procedure scott.drn88_—правочник_пени is
begin
  Null;
end drn88_—правочник_пени;
/

prompt
prompt Creating procedure DRN89_ƒќЋ√»_OLAP
prompt ===================================
prompt
CREATE OR REPLACE PROCEDURE SCOTT.drN89_ƒолги_OLAP IS
BEGIN
  NULL;
END drN89_ƒолги_OLAP;
/

prompt
prompt Creating procedure DRN91_—ѕ–ј¬ќ„Ќ» _ѕј–јћ≈“–ќ¬
prompt ==============================================
prompt
create or replace procedure scott.drn91_—правочник_параметров is
begin
  Null;
end drn91_—правочник_параметров;
/

prompt
prompt Creating procedure DRN94_ќЅќ–ќ“Ќјя_“—∆
prompt ======================================
prompt
CREATE OR REPLACE PROCEDURE SCOTT.DRN94_ќЅќ–ќ“Ќјя_“—∆ is
begin
  Null;
end DRN94_ќЅќ–ќ“Ќјя_“—∆;
/

prompt
prompt Creating procedure DRN95_ќЅќ–ќ“Ќјя_“—∆
prompt ======================================
prompt
CREATE OR REPLACE PROCEDURE SCOTT.DRN95_ќборотна€_тсж is
begin
  Null;
end DRN95_ќборотна€_тсж;
/

prompt
prompt Creating procedure DRN97_ѕ–ќ¬≈– ј_–ј—ѕ–_ќѕЋ
prompt ===========================================
prompt
create or replace procedure scott.drn97_ѕроверка_распр_опл is
begin
  Null;
end drn97_ѕроверка_распр_опл;
/

prompt
prompt Creating procedure DRN98_¬џ√–”« »
prompt =================================
prompt
create or replace procedure scott.drN98_¬ыгрузки is
begin
  Null;
end drN98_¬ыгрузки;
/

prompt
prompt Creating procedure DRN9_Ћ№√ќ“Ќ» »
prompt =================================
prompt
create or replace procedure scott.drN9_Ћьготники is
begin
  Null;
end drN9_Ћьготники;
/

prompt
prompt Creating procedure DRX10_ ј–“_ќ—Ќ
prompt =================================
prompt
CREATE OR REPLACE PROCEDURE SCOTT.drX10_ ј–“_ќ—Ќ IS
BEGIN
  NULL;
END drX10_ ј–“_ќ—Ќ;
/

prompt
prompt Creating procedure DRX11_ѕ–ќ∆»¬_ќ—Ќ
prompt ===================================
prompt
CREATE OR REPLACE PROCEDURE SCOTT.drX11_ѕ–ќ∆»¬_ќ—Ќ IS
BEGIN
  NULL;
END drX11_ѕ–ќ∆»¬_ќ—Ќ;
/

prompt
prompt Creating procedure DRX1_”ƒјЋ≈Ќ»≈_»Ќ ј——ј÷»…
prompt ===========================================
prompt
create or replace procedure scott.DRX1_”даление_инкассаций is
begin
  Null;
end DRX1_”даление_инкассаций;
/

prompt
prompt Creating procedure DRX2_”ƒјЋ≈Ќ»≈_ѕ≈–≈–ј—„≈“ќ¬
prompt =============================================
prompt
create or replace procedure scott.DRX2_”даление_перерасчетов is
begin
  Null;
end DRX2_”даление_перерасчетов;
/

prompt
prompt Creating procedure DRX3_ѕ–ј¬ ј_ ќƒј_–Ё”
prompt =======================================
prompt
create or replace procedure scott.DRX3_ѕравка_кода_–Ё” is
begin
  Null;
end DRX3_ѕравка_кода_–Ё”;
/

prompt
prompt Creating procedure DRX4_ѕ–ј¬ ј_ ќƒј_ѕј—ѕ_—“ќЋј
prompt ==============================================
prompt
create or replace procedure scott.drx4_ѕравка_кода_ѕасп_стола is
begin
  Null;
end drx4_ѕравка_кода_ѕасп_стола;
/

prompt
prompt Creating procedure DRX5_јƒћ»Ќ_ƒќ—“”ѕ_ _Ѕј«≈
prompt ===========================================
prompt
create or replace procedure scott.drx5_јдмин_доступ_к_базе is
begin
--ƒоступ к базе администратора, даже когда база закрыта
  Null;
end drx5_јдмин_доступ_к_базе;
/

prompt
prompt Creating procedure DRX6_јƒћ»Ќ_—ѕ–_ќ–√јЌ»«ј÷»…
prompt =============================================
prompt
create or replace procedure scott.drx6_јдмин_спр_организаций is
begin
--ƒоступ к базе администратора, даже когда база закрыта
  Null;
end drx6_јдмин_спр_организаций;
/

prompt
prompt Creating procedure DRX_ѕ–ќ—ћќ“–_ƒќЋ√_ѕ≈–»ќƒ
prompt ===========================================
prompt
create or replace procedure scott.drx_ѕросмотр_долг_период is
begin
--просмотр задолжности по периодам
  Null;

end drx_ѕросмотр_долг_период;
/

prompt
prompt Creating procedure DRX_”ƒјЋ_ѕ≈–≈–ј—„
prompt ====================================
prompt
create or replace procedure scott.drx_”дал_перерасч is
begin
  Null;
end drx_”дал_перерасч;
/

prompt
prompt Creating procedure DRX_”—“јЌќ¬ ј_ѕ–»«Ќј ј_—„
prompt ============================================
prompt
create or replace procedure scott.drx_”становка_признака_сч is
begin
  Null;
end drx_”становка_признака_сч;
/

prompt
prompt Creating procedure SCRIPT_CLEAR_TABLES
prompt ======================================
prompt
create or replace procedure scott.script_clear_tables is
begin
-- RAISE_APPLICATION_ERROR(-20001,
-- '«апрещено запускать скрипт, без корректировки');

 for c in (select * from all_tables a where owner='SCOTT')
 loop
 begin
   execute immediate 'delete from '||c.table_name||' where mg < ''200811''';
 commit;
 EXCEPTION
  WHEN OTHERS THEN
  null;
 end;
 end loop;

 commit;
end script_clear_tables;
/

prompt
prompt Creating procedure SCRIPT_CORRSAL_PAY
prompt =====================================
prompt
create or replace procedure scott.script_corrsal_pay is
 oper_ oper.oper%type;
 dopl_ c_kwtp.dopl%type;
 nkom_ c_kwtp.nkom%type;
begin
--скрипт переброски кредитового сальдо,
--созданного не верной оплатой по капремонту
oper_:='01';
dopl_:='200809';
nkom_:='999';

for c in (select k.lsk, sum(summa) as summa, c.nink, c.nkom
  from saldo_usl s, kart k, c_comps c
 where k.lsk = s.lsk
   and k.reu = '17'
   and k.kul = '0108'
   and k.nd = '0020/2'
   and s.mg = '200901'
   and s.usl in ('033', '034')
   and c.nkom=nkom_
  group by k.lsk, c.nink, c.nkom
  having sum(summa) <> 0)
loop

--проводим в оплате
insert into c_kwtp
  (lsk, summa, oper, dopl, nink, nkom, dtek, nkvit, dat_ink, ts, id, iscorrect)
 values
  (c.lsk, c.summa*-1, oper_, dopl_, c.nink, c.nkom, trunc(sysdate),
    (select nkvit from c_comps c where c.nkom=nkom_), trunc(sysdate), sysdate, c_kwtp_id.nextval, 0);
insert into c_kwtp_mg
  (lsk, summa, oper, dopl, nink, nkom, dtek, nkvit, dat_ink, ts, c_kwtp_id)
 values
  (c.lsk, c.summa*-1, oper_, dopl_, c.nink, c.nkom, trunc(sysdate),
    (select nkvit from c_comps c where c.nkom=nkom_), trunc(sysdate), sysdate, c_kwtp_id.currval);
 update c_comps c set c.nkvit=nvl(c.nkvit,0)+1 where c.nkom=nkom_;
end loop;
 update c_comps c set c.nink=nvl(c.nink,0)+1 where c.nkom=nkom_;

 delete from t_corrects_payments t where t.mg=(select period from params);

--проводим в корректировках
insert into t_corrects_payments
  (lsk, usl, org, summa, user_id, dat, dopl, mg)
  select k.lsk, s.usl, s.org, sum(summa) as summa, 10, trunc(sysdate), dopl_, p.period
  from saldo_usl s, kart k, params p
 where k.lsk = s.lsk
   and k.reu = '17'
   and k.kul = '0108'
   and k.nd = '0020/2'
   and s.mg = '200901'
   and s.usl in ('033', '034')
 group by k.lsk, s.usl, s.org, p.period
having sum(summa) <> 0;
 commit;

end script_corrsal_pay;
/

prompt
prompt Creating procedure SCRIPT_CORR_CHARGEPAY
prompt ========================================
prompt
create or replace procedure scott.script_corr_chargepay is
  mg_ params.period%TYPE;
  oldmg_ params.period%TYPE;
begin

--исправление c_chargepay

mg_:='200804';
oldmg_:='200803';
execute immediate 'truncate table dub_charge';
insert into dub_charge (lsk, summa, type, mg, period, c_lsk_id)
 select c.lsk, c.summa, c.type, c.mg, c.period, c.c_lsk_id --из старого периода берем начисление (все периоды)
                    from tmp_chargepay c where c.type=0 and c.period < mg_;
insert into dub_charge (lsk, summa, type, mg, period, c_lsk_id)
 select c.lsk, c.summa, c.type, c.mg, c.period, c.c_lsk_id --из старого периода берем оплату (до периода mg_)
                    from tmp_chargepay c where c.type=1 and c.period < mg_;
commit;

insert into dub_charge (lsk, summa, type, mg, period, c_lsk_id)
select a.lsk, sum(summa) as summa, 0, mg, mg_, c_lsk_id
           from (select c.lsk, c.summa, mg_ as mg, k.c_lsk_id
                    from kart k, a_charge c where c.lsk=k.lsk
                    and c.type=1 and c.mg=mg_ --начисление
                    and c.usl not in (select usl_id from usl_excl)
                  union all
                  select c.lsk, c.summa, c.mgchange as mg, k.c_lsk_id
                    from kart k, a_change c where c.lsk=k.lsk and
                    c.mg=mg_ and c.usl not in (select usl_id from usl_excl)
                    and to_char(c.dtek , 'YYYYMM')=mg_
                  union all
                  select c.lsk, c.summa * -1, mg_ as mg, k.c_lsk_id
                    from kart k, a_charge c where c.lsk=k.lsk
                    and c.mg=mg_ and c.type=2 --субсидии
                    and c.usl not in (select usl_id from usl_excl)
                  union all
                  select c.lsk, c.summa * -1, mg_ as mg, k.c_lsk_id
                    from kart k, a_charge c where c.lsk=k.lsk
                    and c.mg=mg_ and c.type=4 --льготы
                    and c.usl not in (select usl_id from usl_excl)
                  union all
                  select c.lsk, c.summa, c.mg, c.c_lsk_id --из старого периода берем начисление
                    from dub_charge c
                    where c.period=oldmg_
                    and c.type=0
                    ) a
                  group by a.lsk, mg, mg_, c_lsk_id
                  having sum(summa) <>0;
commit;

insert into dub_charge (lsk, summa, type, mg, period, c_lsk_id)
select a.lsk, sum(a.summa) as summa, 1, a.mg, mg_, a.c_lsk_id
           from (select c.lsk, k.c_lsk_id, c.summa, c.dopl as mg
                    from kart k, a_kwtp_mg c where k.lsk=c.lsk and
                     to_char(c.dtek , 'YYYYMM')=mg_ and c.mg=mg_
                  union all
                  select c.lsk, c.c_lsk_id, c.summa, c.mg --из старого периода берем оплату
                    from dub_charge c where c.period=oldmg_
                    and c.type=1
                    ) a
                  group by a.lsk, a.c_lsk_id, a.mg
                  having sum(summa) <>0;
commit;
mg_:='200805';
oldmg_:='200804';
insert into dub_charge (lsk, summa, type, mg, period, c_lsk_id)
select a.lsk, sum(a.summa) as summa, 1, a.mg, mg_, a.c_lsk_id
           from (select c.lsk, k.c_lsk_id, c.summa, c.dopl as mg
                    from kart k, a_kwtp_mg c where k.lsk=c.lsk and
                     to_char(c.dtek , 'YYYYMM')=mg_ and c.mg=mg_
                  union all
                  select c.lsk, c.c_lsk_id, c.summa, c.mg --из старого периода берем оплату
                    from dub_charge c where c.period=oldmg_
                    and c.type=1
                    ) a
                  group by a.lsk, a.c_lsk_id, a.mg
                  having sum(summa) <>0;
commit;
insert into dub_charge (lsk, summa, type, mg, period, c_lsk_id)
select a.lsk, sum(summa) as summa, 0, mg, mg_, c_lsk_id
           from (select c.lsk, c.summa, mg_ as mg, k.c_lsk_id
                    from kart k, a_charge c where c.lsk=k.lsk
                    and c.type=1 and c.mg=mg_ --начисление
                    and c.usl not in (select usl_id from usl_excl)
                  union all
                  select c.lsk, c.summa, c.mgchange as mg, k.c_lsk_id
                    from kart k, a_change c where c.lsk=k.lsk and
                    c.mg=mg_ and c.usl not in (select usl_id from usl_excl)
                    and to_char(c.dtek , 'YYYYMM')=mg_
                  union all
                  select c.lsk, c.summa * -1, mg_ as mg, k.c_lsk_id
                    from kart k, a_charge c where c.lsk=k.lsk
                    and c.mg=mg_ and c.type=2 --субсидии
                    and c.usl not in (select usl_id from usl_excl)
                  union all
                  select c.lsk, c.summa * -1, mg_ as mg, k.c_lsk_id
                    from kart k, a_charge c where c.lsk=k.lsk
                    and c.mg=mg_ and c.type=4 --льготы
                    and c.usl not in (select usl_id from usl_excl)
                  union all
                  select c.lsk, c.summa, c.mg, c.c_lsk_id --из старого периода берем начисление
                    from dub_charge c
                    where c.period=oldmg_
                    and c.type=0
                    ) a
                  group by a.lsk, mg, mg_, c_lsk_id
                  having sum(summa) <>0;
commit;
mg_:='200806';
oldmg_:='200805';
insert into dub_charge (lsk, summa, type, mg, period, c_lsk_id)
select a.lsk, sum(a.summa) as summa, 1, a.mg, mg_, a.c_lsk_id
           from (select c.lsk, k.c_lsk_id, c.summa, c.dopl as mg
                    from kart k, a_kwtp_mg c where k.lsk=c.lsk and
                     to_char(c.dtek , 'YYYYMM')=mg_ and c.mg=mg_
                  union all
                  select c.lsk, c.c_lsk_id, c.summa, c.mg --из старого периода берем оплату
                    from dub_charge c where c.period=oldmg_
                    and c.type=1
                    ) a
                  group by a.lsk, a.c_lsk_id, a.mg
                  having sum(summa) <>0;
commit;
insert into dub_charge (lsk, summa, type, mg, period, c_lsk_id)
select a.lsk, sum(summa) as summa, 0, mg, mg_, c_lsk_id
           from (select c.lsk, c.summa, mg_ as mg, k.c_lsk_id
                    from kart k, a_charge c where c.lsk=k.lsk
                    and c.type=1 and c.mg=mg_ --начисление
                    and c.usl not in (select usl_id from usl_excl)
                  union all
                  select c.lsk, c.summa, c.mgchange as mg, k.c_lsk_id
                    from kart k, a_change c where c.lsk=k.lsk and
                    c.mg=mg_ and c.usl not in (select usl_id from usl_excl)
                    and to_char(c.dtek , 'YYYYMM')=mg_
                  union all
                  select c.lsk, c.summa * -1, mg_ as mg, k.c_lsk_id
                    from kart k, a_charge c where c.lsk=k.lsk
                    and c.mg=mg_ and c.type=2 --субсидии
                    and c.usl not in (select usl_id from usl_excl)
                  union all
                  select c.lsk, c.summa * -1, mg_ as mg, k.c_lsk_id
                    from kart k, a_charge c where c.lsk=k.lsk
                    and c.mg=mg_ and c.type=4 --льготы
                    and c.usl not in (select usl_id from usl_excl)
                  union all
                  select c.lsk, c.summa, c.mg, c.c_lsk_id --из старого периода берем начисление
                    from dub_charge c
                    where c.period=oldmg_
                    and c.type=0
                    ) a
                  group by a.lsk, mg, mg_, c_lsk_id
                  having sum(summa) <>0;
commit;

end script_corr_chargepay;
/

prompt
prompt Creating procedure SCRIPT_CORR_SAL
prompt ==================================
prompt
create or replace procedure scott.script_corr_sal is
id_ number;
mg_ char(6);
begin
-- орректировка сальдо по ” 
--ѕеренос сальдо с одной орг. на другую, по той же услуге
--исправить MG!!!!!!!!!!!!!!!!!!
mg_:='200808';
delete from c_change_docs t where t.user_id=11;
delete from c_change t where t.user_id=11;
commit;

select changes_id.nextval into id_ from dual;


insert into c_change_docs
  (id, mgchange, dtek, ts, user_id, text)
values
  (id_, mg_,trunc(sysdate), sysdate, 11, ' орректировка сальдо по ” ');


insert into c_change
  (lsk, usl, summa, proc, mgchange, nkom, org, type, dtek, ts, user_id, doc_id)
  select t.lsk, t.usl, t.summa as summa, null as proc, mg_ as mgchange,
  '010' as nkom, n.org, 0 as type, trunc(sysdate) as dtek, sysdate, 11, id_ as doc_id
    from saldo_usl t, kart k, nabor n, s_reu_trest s
   where t.mg = mg_
     and t.lsk = k.lsk
     and t.lsk = n.lsk
     and t.usl = n.usl
     and k.reu = s.reu
     and s.trest = '03'
     and t.org in (10);

insert into c_change
  (lsk, usl, summa, proc, mgchange, nkom, org, type, dtek, ts, user_id, doc_id)
  select t.lsk, t.usl, -1 * t.summa as summa, null as proc, mg_ as mgchange,
  '010' as nkom, t.org, 0 as type, trunc(sysdate) as dtek, sysdate, 11, id_ as doc_id
    from saldo_usl t, kart k, nabor n, s_reu_trest s
   where t.mg = mg_
     and t.lsk = k.lsk
     and t.lsk = n.lsk
     and t.usl = n.usl
     and k.reu = s.reu
     and s.trest = '03'
     and t.org in (10);

insert into c_change
  (lsk, usl, summa, proc, mgchange, nkom, org, type, dtek, ts, user_id, doc_id)
  select t.lsk, t.usl, t.summa as summa, null as proc, mg_ as mgchange,
  '010' as nkom, n.org, 0 as type, trunc(sysdate) as dtek, sysdate, 11, id_ as doc_id
    from saldo_usl t, kart k, nabor n, s_reu_trest s
   where t.mg = mg_
     and t.lsk = k.lsk
     and t.lsk = n.lsk
     and t.usl = n.usl
     and k.reu = s.reu
     and s.trest = '03'
     and t.org in (12);

insert into c_change
  (lsk, usl, summa, proc, mgchange, nkom, org, type, dtek, ts, user_id, doc_id)
  select t.lsk, t.usl, -1 * t.summa as summa, null as proc, mg_ as mgchange,
  '010' as nkom, t.org, 0 as type, trunc(sysdate) as dtek, sysdate, 11, id_ as doc_id
    from saldo_usl t, kart k, nabor n, s_reu_trest s
   where t.mg = mg_
     and t.lsk = k.lsk
     and t.lsk = n.lsk
     and t.usl = n.usl
     and k.reu = s.reu
     and s.trest = '03'
     and t.org in (12);
commit;

end script_corr_sal;
/

prompt
prompt Creating procedure SCRIPT_DEBITS
prompt ================================
prompt
create or replace procedure scott.script_debits is
  mg_ params.period%TYPE;
begin
  --задолжники по лицевым
  --выполн€ть ƒќ перехода, выгружать, - когда угодно
  select '200803' into mg_ from params;
  delete from debits_lsk_month d where d.mg = mg_;
  insert into debits_lsk_month (lsk, reu, kul, name, nd, kw, fio, status, opl, cnt_month, dolg, nachisl,
   penya, payment, mg)
  select a.lsk, a.reu, a.kul, s.name, a.nd, a.kw, a.fio, a.status, a.opl,
       round(decode(b.summa,0, 0, a.dolg/b.summa),0) as cnt_month,
       a.dolg, b.summa as nachisl, a.penya, c.summa, mg_
   from
  (select t.c_lsk_id,t.reu,t.kul,t.nd,t.kw,t.fio,t.status,t.opl,t.lsk,
     nvl(t.dolg,0)+nvl(t.old_dolg,0) as dolg, nvl(t.penya,0)+nvl(t.old_pen,0) as penya
     from arch_kart t where t.mg=mg_ and t.psch <> 8) a,
  (select d.lsk,sum(d.summa_it) as summa
        from arch_charges d where d.mg=mg_
        and d.usl_id not in (select u.usl_id from usl_excl u)
        group by d.lsk) b,
  (select k.c_lsk_id, sum(d.summa) as summa
        from arch_kart k, arch_kwtp d where d.mg=mg_ and k.mg=mg_ and k.lsk=d.lsk
        and d.usl_id not in (select u.usl_id from usl_excl u)
        group by k.c_lsk_id) c,
        spul s
  where a.lsk=b.lsk(+) and a.kul=s.id and a.c_lsk_id=c.c_lsk_id(+) and round(decode(b.summa,0, 0, a.dolg/b.summa),0)>0;
  commit;
end script_debits;
/

prompt
prompt Creating procedure SCRIPT_GEN_CHANGES
prompt =====================================
prompt
create or replace procedure scott.script_gen_changes is
cnt_ number;
begin
   --проводим одним документом
   insert into c_change_docs
    (id, mgchange, dtek, ts, user_id, text)
    values
    (changes_id.nextval, '200802', trunc(sysdate),
      sysdate, 11, 'ѕереброска начислени€ дл€ ” ');

  for c in (select t.lsk, e.lsk as lsk2, t.usl_id, sum(t.summa) as summa
      from arch_charges t, kart k, kart e,
  (select t.lsk, sum(summa) as summa from saldo t where mg='200803'
              group by t.lsk --только начисление по дебетовому сальдо
              having sum(summa) > 0) a
    where t.mg='200802' and
    exists (select * from work_houses h where h.id=k.house_id and h.newreu in
    ('11','12','13','14','15'))
    and k.lsk=t.lsk and k.lsk=a.lsk and k.c_lsk_id=e.c_lsk_id and k.lsk<>e.lsk
    group by t.lsk, e.lsk, t.usl_id)
  loop
  insert into c_change
    (lsk, usl, summa, proc, mgchange, nkom, org, type, dtek, ts, user_id, doc_id)
  values
    (c.lsk, c.usl_id,
     -1*c.summa, null, '200802', '999', null, null, trunc(sysdate), sysdate,
     11, changes_id.currval);

  insert into c_change
    (lsk, usl, summa, proc, mgchange, nkom, org, type, dtek, ts, user_id, doc_id)
  values
    (c.lsk2, c.usl_id,
     c.summa, null, '200802', '999', null, null, trunc(sysdate), sysdate,
     11, changes_id.currval);
  commit;
  end loop;

end script_gen_changes;
/

prompt
prompt Creating procedure SCRIPT_GEN_PAYMENT
prompt =====================================
prompt
create or replace procedure scott.script_gen_payment is
cnt_ number;
begin
  cnt_:=c_get_pay.set_date(trunc(sysdate));
  c_get_pay.set_nkom('999');
  for c in (select t.lsk, e.lsk as lsk2, t.oper, sum(t.summa) as summa
      from a_kwtp t, kart k, kart e,
  (select t.lsk, sum(summa) as summa from saldo t where mg='200803'
              group by t.lsk --только платежи по дебетовому сальдо
              having sum(summa) > 0) a
    where t.mg='200802' and
    exists (select * from work_houses h where h.id=k.house_id and h.newreu in
    ('11','12','13','14','15'))
    and k.lsk=t.lsk and k.lsk=a.lsk and k.c_lsk_id=e.c_lsk_id and k.lsk<>e.lsk
    group by t.lsk, e.lsk, t.oper)
  loop
    c_get_pay.get_payment(c.lsk, -1 * c.summa, 0, c.oper, '200802', 1);
    c_get_pay.get_payment(c.lsk2, c.summa, 0, c.oper, '200802', 1);
  commit;
  end loop;

end script_gen_payment;
/

prompt
prompt Creating procedure SCRIPT_MAKE_SAL
prompt ==================================
prompt
create or replace procedure scott.script_make_sal is
cursor d  is
select s.c_lsk_id, s.lsk, s.uslm, r.usl as usl_no, s.org, b.usl, s.summa as sal,
 round(s.summa*decode(a.summa, 0, 1, null, 1, round(b.summa/a.summa,2)),2) as salgood,
 decode(a.summa, 0, 1, null, 1, round(b.summa/a.summa,2)) as proc
 from
  saldo s, (select uslm, usl from usl m where m.usl_norm=0) r,
(select t.lsk, u.uslm, sum(summa) as summa from c_charge t, usl u
 where t.type=0 and t.usl=u.usl
group by t.lsk, u.uslm) a,
(select t.lsk, t.usl, u.uslm, sum(summa) as summa from c_charge t, usl u
 where t.type=0 and t.usl=u.usl
group by t.lsk, t.usl, u.uslm) b
  where s.mg='200806' and s.lsk=a.lsk(+) and s.uslm=a.uslm(+) and
  s.lsk=b.lsk(+) and s.uslm=b.uslm(+) and s.uslm=r.uslm
  order by s.lsk, s.uslm, s.org;
  rec_ d%rowtype;
  lsk_old_ kart.lsk%type;
  usl_old_ usl.usl%type;
  uslm_old_ usl.usl%type;
  sal_ number;
  summa_ost_ number;
  org_old_ number;
  c_lsk_id_old_ number;
  mg_ char(6);
begin
 execute immediate 'truncate table saldo_usl';
  --скрипт дл€ распределение сальдо по подуслугам
 lsk_old_:='';
 usl_old_:='';
 uslm_old_:='';
 org_old_:=0;
 c_lsk_id_old_:=0;
 sal_:=0;
 mg_:='000000';
open d;
loop
  fetch d into rec_;
  exit when d%notfound;
  if rec_.lsk <> lsk_old_ then
   sal_:=rec_.sal;
  end if;

  if rec_.lsk = lsk_old_ and rec_.uslm = uslm_old_ and rec_.org <> org_old_ then
   sal_:=rec_.sal;
  end if;
  if rec_.lsk = lsk_old_ and rec_.uslm <> uslm_old_ then
   sal_:=rec_.sal;
  end if;

  if rec_.lsk <> lsk_old_ and summa_ost_ <> 0 then
  --остаток со старого л.с.
   insert into saldo_usl (c_lsk_id, lsk, usl, org, summa, mg)
    values (c_lsk_id_old_, lsk_old_, usl_old_, org_old_, summa_ost_, mg_);
    summa_ost_:=0;
  end if;

  if rec_.lsk = lsk_old_ and rec_.uslm = uslm_old_
     and rec_.org <> org_old_ and summa_ost_ <> 0 then
   --остаток со старой орг.
   insert into saldo_usl (c_lsk_id, lsk, usl, org, summa, mg)
    values (c_lsk_id_old_, lsk_old_, usl_old_, org_old_, summa_ost_, mg_);
    summa_ost_:=0;
  end if;

  if rec_.lsk = lsk_old_ and rec_.uslm <> uslm_old_
     and summa_ost_ <> 0 then
   --остаток со старой орг.
   insert into saldo_usl (c_lsk_id, lsk, usl, org, summa, mg)
    values (c_lsk_id_old_, lsk_old_, usl_old_, org_old_, summa_ost_, mg_);
    summa_ost_:=0;
  end if;

  if rec_.usl is not null then
   insert into saldo_usl (c_lsk_id, lsk, usl, org, summa, mg)
    values (rec_.c_lsk_id, rec_.lsk, rec_.usl, rec_.org, rec_.salgood, mg_);
   sal_:=sal_-rec_.salgood;
   usl_old_:=rec_.usl;
  else
   --не найдено тек начисление дл€ распределени€ сальдо (кинем на усл. по соцнорме)
   insert into saldo_usl (c_lsk_id, lsk, usl, org, summa, mg)
    values (rec_.c_lsk_id, rec_.lsk, rec_.usl_no, rec_.org, rec_.salgood, mg_);
   sal_:=sal_-rec_.salgood;
   usl_old_:=rec_.usl_no;
  end if;

 summa_ost_:=sal_;
 uslm_old_:=rec_.uslm;
 lsk_old_:=rec_.lsk;
 org_old_:=rec_.org;
 c_lsk_id_old_:=rec_.c_lsk_id;
end loop;
close d;
commit;
mg_:='200806';
insert into saldo_usl (c_lsk_id, lsk, usl, org, summa, mg)
  select c_lsk_id, lsk, usl, org, sum(summa), mg_ from saldo_usl s
   where mg='000000'
   group by c_lsk_id, lsk, usl, org
   having sum(summa) <> 0;
delete from saldo_usl where mg='000000';
commit;
end script_make_sal;
/

prompt
prompt Creating procedure SCRIPT_MAKE_TREE_OBJ
prompt =======================================
prompt
create or replace procedure scott.script_make_tree_obj is
  maxid_ number;
begin
 delete from tree_objects;

--муп
 insert into tree_objects (id, obj_level)
  values (0, 0);

--трест
 insert into tree_objects (main_id, id, obj_level, trest)
   select 0, rownum as rn, 1, trest from
     (select distinct trest from s_reu_trest);

 select max(id) into maxid_
   from tree_objects t where t.obj_level=1;

--рэу
 insert into tree_objects (main_id, id, obj_level, reu)
   select main_id, maxid_+rownum as rn, 2, reu from
     (select distinct s.reu, t.id as main_id
       from s_reu_trest s, tree_objects t
       where s.trest=t.trest and t.obj_level=1);
 select max(id) into maxid_
   from tree_objects t where t.obj_level=2;

--дома
 insert into tree_objects (main_id, id, obj_level, reu, kul, nd)
   select main_id, maxid_+rownum as rn, 3, reu, kul, nd from
   (select distinct k.reu, k.kul, s.name, k.nd, t.id as main_id
     from kart k, tree_objects t, spul s
      where k.reu=t.reu and k.kul=s.id and t.obj_level=2
      ) a
      order by a.reu, a.name, a.nd;

commit;
end script_make_tree_obj;
/

prompt
prompt Creating procedure SCRIPT_PERIODS
prompt =================================
prompt
create or replace procedure scott.script_periods is
c_lsk_id_ kart.c_lsk_id%TYPE;
begin
for ff in (select lsk from kart where lsk='00043489')
loop
  select max(k.c_lsk_id) into c_lsk_id_
   from arch_kart k where k.lsk=ff.lsk and lsk=ff.lsk and mg='200804';

  delete from c_chargepay where period='200804' and type=1 and lsk=ff.lsk;

  insert into c_chargepay (lsk, summa, type, mg, period, c_lsk_id)
  select a.lsk, sum(summa) as summa, 1, mg, '200804', c_lsk_id_
           from (select c.lsk, c.summa,
                c.dopl as mg
                    from a_kwtp_mg c where c.lsk = ff.lsk and
                     to_char(c.dtek , 'YYYYMM')='200804' and c.mg='200804'
                  union all
                  select c.lsk, c.summa, c.mg --из старого периода берем оплату
                    from c_chargepay c where c.lsk = ff.lsk
                    and c.period='200803'
                    and c.type=1
                    ) a
                  group by a.lsk, mg
                  having sum(summa) <>0;
  commit;
end loop;
end script_periods;
/

prompt
prompt Creating procedure SCRIPT_RENUMBER
prompt ==================================
prompt
create or replace procedure scott.script_renumber is
  oldreu_ kart.reu%type;
  reu_ kart.reu%type;
  lsk1_ kart.lsk%type;
begin
  --скрипт дл€ присоединени€ ”  к существующим ” 
  oldreu_:='34';
  reu_:='15';
update kart t set t.polis = null;
update kart t set t.polis =
  lpad((select max(lsk)
   from kart k where k.reu = oldreu_)+rownum,8,'0')
    where t.reu = reu_;
update kart t set t.lsk=t.polis, t.polis=t.lsk
 where t.reu = reu_;
 update c_kart_pr t set t.lsk= (select k.lsk from kart k where k.polis=t.lsk
   and k.reu = reu_)
   where exists (select * from kart k where k.polis=t.lsk
   and k.reu = reu_);
 update saldo_usl t set t.lsk= (select k.lsk from kart k where k.polis=t.lsk
   and k.reu = reu_)
   where exists (select * from kart k where k.polis=t.lsk
   and k.reu = reu_);
 update nabor t set t.lsk= (select k.lsk from kart k where k.polis=t.lsk
   and k.reu = reu_)
   where exists (select * from kart k where k.polis=t.lsk
   and k.reu = reu_);

 update c_charge t set t.lsk= (select k.lsk from kart k where k.polis=t.lsk
   and k.reu = reu_)
    where exists (select * from kart k where k.polis=t.lsk
   and k.reu = reu_);

 update c_chargepay t set t.lsk= (select k.lsk from kart k where k.polis=t.lsk
   and k.reu = reu_)
    where exists (select * from kart k where k.polis=t.lsk
   and k.reu = reu_);

update c_houses t set t.reu =oldreu_
 where t.reu = reu_;
update kart t set t.reu =oldreu_
 where t.reu = reu_;


 commit;
end script_renumber;
/

prompt
prompt Creating procedure SCRIPT_SALDO_DETAILED
prompt ========================================
prompt
create or replace procedure scott.script_saldo_detailed is
 mg_ char(6);
 mg1_ char(6);
begin
 mg_:='200803';
 mg1_:='200804';

    execute immediate 'truncate table t_lsk_saldo';
    insert into t_lsk_saldo (lsk, org, uslm)
         select distinct lsk, org, uslm from
         (select t.lsk, t.org, t.uslm
               from saldo t where t.mg=mg_
               union all
          select t.lsk, t.org, t.uslm
               from saldo t where t.mg=mg1_
               union all
         select t.lsk, t.org, u.uslm
               from a_nabor t, usl u
                 where t.usl=u.usl and t.mg=mg_
               union all
         select k.lsk,
                    nvl(t.org,0),
                    u.uslm
               from a_change t, kart k, usl u where t.mg=mg_ and
               t.lsk=k.lsk
               union all
         select t.lsk, 0, '002'
               from a_nabor t, usl u
                 where t.usl=u.usl and t.mg=mg_);
   commit;
    delete from xitog2_lsk t where t.mg=mg_;
    insert into xitog2_lsk
      (lsk,
       ORG,
       USLM,
       indebet,
       inkredit,
       CHARGES,
       CHANGES,
       CH_FULL,
       CHANGES2,
       subsid,
       PRIVS,
       payment,
       pn,
       outdebet,
       outkredit,
       mg)
      SELECT t.lsk,
             t.ORG,
             t.USLM,
             SUM(a.summa) indebet,
             SUM(b.summa) inkredit,
             SUM(NVL(e.summa, 0) + NVL(f.summa, 0)+ NVL(w.summa, 0)- NVL(o.summa, 0)- NVL(g.summa, 0)) CHARGES,
             SUM(NVL(f.summa,0)) CHANGES,
             SUM(NVL(e.summa, 0)) CH_FULL,
             SUM(NVL(w.summa,0)) CHANGES2,
             SUM(g.summa) subsid,
             SUM(o.summa) PRIVS,
             SUM(h.summa) payment,
             SUM(j.summa) pn,
             SUM(k.summa) outdebet,
             SUM(l.summa) outkredit,
             mg_ AS mg
        FROM t_lsk_saldo t,
             (select t.lsk, t.org, t.uslm, sum(summa) as summa
               from saldo t
              where summa >= 0
                and mg = mg_
              group by t.lsk, t.org, t.uslm) a,
             (select t.lsk, t.org, t.uslm, sum(summa) as summa
               from saldo t
              where summa < 0
                and mg = mg_
              group by t.lsk, t.org, t.uslm) b,
             (select t.lsk, t.org, t.uslm, sum(summa) as summa
               from saldo t
              where summa >= 0
                and mg = mg1_
              group by t.lsk, t.org, t.uslm) k,
             (select t.lsk, t.org, t.uslm, sum(summa) as summa
               from saldo t
              where summa < 0
                and mg = mg1_
              group by t.lsk, t.org, t.uslm) l,
             (select k.lsk,
                    n.org,
                    u.uslm,
                    sum(summa) as summa
               from a_nabor n, a_charge t, kart k, usl u
              where n.lsk = t.lsk and k.lsk = t.lsk
                and n.usl=t.usl and t.usl=u.usl and t.usl not in ('024')
                and t.type=1 and n.mg=mg_ and t.mg=mg_
              group by k.lsk, n.org, u.uslm) e,
             (select k.lsk,
                    n.org,
                    u.uslm,
                    sum(summa) as summa
               from a_nabor n, a_charge t, kart k, usl u
              where n.lsk = t.lsk and k.lsk = t.lsk
                and n.usl=t.usl and t.usl=u.usl and t.usl not in ('024')
                and t.type=4 and n.mg=mg_ and t.mg=mg_
              group by k.lsk, n.org, u.uslm) o,
             (select k.lsk,
                    t.org,
                    u.uslm,
                    sum(summa) as summa
               from a_change t, kart k, usl u
              where k.lsk = t.lsk and t.usl=u.usl
                and t.type in (0) and t.mg=mg_
              group by k.lsk, t.org, u.uslm) f,
             (select k.lsk,
                    t.org,
                    u.uslm,
                    sum(summa) as summa
               from a_change t, kart k, usl u
              where k.lsk = t.lsk and t.usl=u.usl
                and t.type in (1,2) and t.mg=mg_
              group by k.lsk, t.org, u.uslm) w,
             (select k.lsk,
                    n.org,
                    u.uslm,
                    sum(summa) as summa
               from a_nabor n, a_charge t, kart k, usl u
              where n.lsk = t.lsk and k.lsk = t.lsk
                and n.usl=t.usl and t.usl=u.usl
                and t.type=2 and n.mg=mg_ and t.mg=mg_
              group by k.lsk, n.org, u.uslm) g,
             (select k.lsk,
                    0 as org,
                    '002' as uslm,
                    sum(summa) as summa
               from a_kwtp_mg t, kart k
              where k.lsk = t.lsk and t.mg=mg_
              group by k.lsk) h,
             (select k.lsk,
                    0 as org,
                    '002' as uslm,
                    sum(penya) as summa
               from a_kwtp_mg t, kart k
              where k.lsk = t.lsk and t.mg=mg_
              group by k.lsk) j
       WHERE t.lsk = a.lsk(+)
         AND t.ORG = a.ORG(+)
         AND t.USLM = a.USLM(+)

         and t.lsk = b.lsk(+)
         AND t.ORG = b.ORG(+)
         AND t.USLM = b.USLM(+)

         and t.lsk = k.lsk(+)
         AND t.ORG = k.ORG(+)
         AND t.USLM = k.USLM(+)

         and t.lsk = l.lsk(+)
         AND t.ORG = l.ORG(+)
         AND t.USLM = l.USLM(+)

         and t.lsk = e.lsk(+)
         AND t.ORG = e.ORG(+)
         AND t.USLM = e.USLM(+)

         and t.lsk = o.lsk(+)
         AND t.ORG = o.ORG(+)
         AND t.USLM = o.USLM(+)

         and t.lsk = f.lsk(+)
         AND t.ORG = f.ORG(+)
         AND t.USLM = f.USLM(+)

         and t.lsk = w.lsk(+)
         AND t.ORG = w.ORG(+)
         AND t.USLM = w.USLM(+)

         and t.lsk = g.lsk(+)
         AND t.ORG = g.ORG(+)
         AND t.USLM = g.USLM(+)

         and t.lsk = h.lsk(+)
         AND t.ORG = h.ORG(+)
         AND t.USLM = h.USLM(+)

         and t.lsk = j.lsk(+)
         AND t.ORG = j.ORG(+)
         AND t.USLM = j.USLM(+)
       GROUP BY t.lsk, t.ORG, t.USLM;

  execute immediate 'truncate table t_lsk_saldo2';
  insert into t_lsk_saldo2
      (lsk, org, uslm)
      select distinct lsk, org, uslm from xitog2_lsk t;
  commit;
end script_saldo_detailed;
/

prompt
prompt Creating procedure SCRIPT_SET_K_LSK_ID
prompt ======================================
prompt
create or replace procedure scott.script_set_k_lsk_id is
  id_ number;
begin
 --проставл€ем k_lsk_id
 delete from k_lsk;
 for c in (select distinct c_lsk_id from kart )
 loop
   insert into k_lsk (id)
     values (k_lsk_id.nextval);
   select k_lsk_id.currval into id_ from dual;
   update kart k set k.k_lsk_id=id_ where k.c_lsk_id=c.c_lsk_id;
 end loop;
 commit;
end script_set_k_lsk_id;
/

prompt
prompt Creating procedure TEST
prompt =======================
prompt
CREATE OR REPLACE PROCEDURE SCOTT.test IS
  TYPE l_rec_prop2_type IS RECORD (id number);
  TYPE l_arr_prop2_type IS VARRAY(100) OF l_rec_prop2_type;
  l_arr_prop2 l_arr_prop2_type;
begin

  select t.id as id/*t.id*/--, null as dt, null as prop, null as prop_reg
    bulk collect into l_arr_prop2
  from c_kart_pr t where t.lsk='01001620';


for z in l_arr_prop2.FIRST..l_arr_prop2.LAST
      loop

       dbms_output.put_line(l_arr_prop2(z).id);
      end loop;




END test;
/

prompt
prompt Creating procedure TEST2
prompt ========================
prompt
CREATE OR REPLACE PROCEDURE SCOTT.test2 IS
--добавление услуг ант.дог по –Ё”-01
begin

--установка новой услуги
update nabor n set n.koeff =(select r.koeff from nabor r where r.lsk=n.lsk
 and r.usl='043'), n.norm =(select r.norm from nabor r where r.lsk=n.lsk
 and r.usl='043'), n.fk_tarif =(select r.fk_tarif from nabor r where r.lsk=n.lsk
 and r.usl='043'), n.org=553
 where n.usl='046'
 and exists
 (select * from kart k where k.lsk=n.lsk and exists
 (select * from killme_l1 m where m.kul=k.kul and m.nd=k.nd
  and m.kw=k.kw));

--удаление старой услуги
update nabor n set n.koeff =0, n.norm =0, n.fk_tarif =null
 where n.usl='043' and nvl(n.koeff,0)<>0 and nvl(n.norm,0) <>0
 and exists
 (select * from kart k where k.lsk=n.lsk and exists
 (select * from killme_l1 m where m.kul=k.kul and m.nd=k.nd
  and m.kw=k.kw));
commit;

END test2;
/

prompt
prompt Creating procedure TESTX
prompt ========================
prompt
CREATE OR REPLACE PROCEDURE SCOTT.testX(mg_ IN XITO_LG2.mg%TYPE) IS
    type_otchet  CONSTANT NUMBER := 8; --тип возмещение по льготникам (‘.8.1.)
    type_otchet2 CONSTANT NUMBER := 11; --тип льготники дл€ статистики (‘.9.1.)
    type_otchet3  CONSTANT NUMBER := 20; --тип возмещение по льготникам (‘.7.5.)
  BEGIN

    DELETE FROM XITO_LG3 x WHERE x.mg = mg_;
--    /*+ INDEX (t PRIVS_I) */
    INSERT INTO XITO_LG3
      (reu,
       trest,
       kul,
       nd,
       usl_id,
       lg_id,
       org_id,
       summa,
       cnt_main,
       cnt,
       mg)
      SELECT a.reu,
             a.trest,
             a.kul,
             a.nd,
             a.USL,
             a.lg_id,
             a.ORG,
             SUM(summa),
             SUM(cnt_main),
             SUM(cnt),
             mg_
        FROM (SELECT lsk,
                     reu,
                     trest,
                     kul,
                     nd,
                     USL,
                     lg_id,
                     ORG,
                     nomer,
                     cnt_main,
                     cnt,
                     SUM(summa) AS summa
                FROM (SELECT /*+ RULE */
                       t.lsk,
                       e.reu,
                       s.trest,
                       e.kul,
                       e.nd,
                       t.usl_id AS USL,
                       t.lg_id,
                       CASE
                         WHEN p.period >=
                              SUBSTR(d.dat3, 3, 4) || SUBSTR(d.dat3, 1, 2) THEN
                          d.kod3
                         WHEN p.period >=
                              SUBSTR(d.dat2, 3, 4) || SUBSTR(d.dat2, 1, 2) THEN
                          d.kod2
                         WHEN p.period >=
                              SUBSTR(d.dat, 3, 4) || SUBSTR(d.dat, 1, 2) THEN
                          d.kod1
                         ELSE
                          d.kod
                       END ORG,
                       t.nomer,
                       t.main AS cnt_main,
                       t.summa,
                       1 AS cnt
                        FROM PRIVS       t,
                             KART        e,
                             NABOR       k,
                             S_REU_TREST s,
                             PARAMS      p,
                             SPRORG      d
                       WHERE t.lsk = e.lsk
                         AND e.reu = s.reu
                         AND e.nabor_id = k.id
                         AND t.usl_id = k.USL
                         AND k.ORG = d.kod
                      UNION ALL
                      SELECT t.lsk,
                             s.reu,
                             s.trest,
                             e.kul,
                             e.nd,
                             t.USL,
                             t.lg_id,
                             t.ORG,
                             0 AS nomer,
                             t.main,
                             t.summa,
                             1 AS cnt
                        FROM T_CORRECTS_LG t,
                             KART          e,
                             S_REU_TREST   s,
                             PARAMS        p
                       WHERE e.lsk = t.lsk
                         AND e.reu = s.reu
                         AND t.mg = p.period)
               GROUP BY lsk,
                        reu,
                        trest,
                        kul,
                        nd,
                        USL,
                        lg_id,
                        ORG,
                        nomer,
                        cnt_main,
                        cnt) a
       GROUP BY a.reu, a.trest, a.kul, a.nd, a.USL, a.lg_id, a.ORG;

    DELETE FROM XITO_LG2 x WHERE x.mg = mg_;
    /*+ INDEX (t PRIVS_I) */
    INSERT INTO XITO_LG2
      (reu,
       trest,
       kul,
       nd,
       uslm_id,
       lg_id,
       org_id,
       summa,
       cnt_main,
       cnt,
       mg)
      SELECT a.reu,
             a.trest,
             a.kul,
             a.nd,
             a.USLM,
             a.lg_id,
             a.ORG,
             SUM(summa),
             SUM(cnt_main),
             SUM(cnt),
             mg_
        FROM (SELECT lsk,
                     reu,
                     trest,
                     kul,
                     nd,
                     USLM,
                     lg_id,
                     ORG,
                     nomer,
                     cnt_main,
                     cnt,
                     SUM(summa) AS summa
                FROM (SELECT /*+ RULE */
                       t.lsk,
                       e.reu,
                       s.trest,
                       e.kul,
                       e.nd,
                       u.USLM,
                       t.lg_id,
                       CASE
                         WHEN p.period >=
                              SUBSTR(d.dat3, 3, 4) || SUBSTR(d.dat3, 1, 2) THEN
                          d.kod3
                         WHEN p.period >=
                              SUBSTR(d.dat2, 3, 4) || SUBSTR(d.dat2, 1, 2) THEN
                          d.kod2
                         WHEN p.period >=
                              SUBSTR(d.dat, 3, 4) || SUBSTR(d.dat, 1, 2) THEN
                          d.kod1
                         ELSE
                          d.kod
                       END ORG,
                       t.nomer,
                       t.main AS cnt_main,
                       t.summa,
                       1 AS cnt
                        FROM PRIVS       t,
                             KART        e,
                             NABOR       k,
                             USL         u,
                             S_REU_TREST s,
                             PARAMS      p,
                             SPRORG      d
                       WHERE u.USL = t.usl_id
                         AND t.lsk = e.lsk
                         AND e.reu = s.reu
                         AND e.nabor_id = k.id
                         AND t.usl_id = k.USL
                         AND k.ORG = d.kod
                      UNION ALL
                      SELECT t.lsk,
                             s.reu,
                             s.trest,
                             e.kul,
                             e.nd,
                             u.USLM,
                             t.lg_id,
                             t.ORG,
                             0 AS nomer,
                             t.main,
                             t.summa,
                             1 AS cnt
                        FROM T_CORRECTS_LG t,
                             KART          e,
                             USL           u,
                             S_REU_TREST   s,
                             PARAMS        p
                       WHERE e.lsk = t.lsk
                         AND t.USL = u.USL
                         AND e.reu = s.reu
                         AND t.mg = p.period)
               GROUP BY lsk,
                        reu,
                        trest,
                        kul,
                        nd,
                        USLM,
                        lg_id,
                        ORG,
                        nomer,
                        cnt_main,
                        cnt) a
       GROUP BY a.reu, a.trest, a.kul, a.nd, a.USLM, a.lg_id, a.ORG;

    DELETE FROM XITO_LG1 x WHERE x.mg = mg_;
    INSERT INTO XITO_LG1
      (reu, trest, kul, nd, lg_id, summa, cnt_main, cnt, mg)
      SELECT s.reu,
             s.trest,
             k.kul,
             k.nd,
             x.lg_id,
             SUM(x.summa) AS summa,
             SUM(x.cnt_main) AS cnt_main,
             COUNT(*) AS cnt,
             p.period
        FROM (SELECT lsk,
                     lg_id,
                     nomer,
                     cnt_main AS cnt_main,
                     SUM(summa) AS summa
                FROM (SELECT t.lsk,
                             t.lg_id,
                             t.nomer,
                             t.main AS cnt_main,
                             t.summa
                        FROM PRIVS t
                      UNION ALL
                      SELECT t.lsk, t.lg_id, 0 AS nomer, t.main, t.summa
                        FROM T_CORRECTS_LG t,
                             KART          e,
                             USL           u,
                             S_REU_TREST   s,
                             PARAMS        p
                       WHERE e.lsk = t.lsk
                         AND t.USL = u.USL
                         AND e.reu = s.reu
                         AND t.mg = p.period)
               GROUP BY lsk, lg_id, nomer, cnt_main) x,
             KART k,
             S_REU_TREST s,
             PARAMS p
       WHERE x.lsk = k.lsk
         AND k.reu = s.reu
       GROUP BY s.reu, s.trest, k.kul, k.nd, x.lg_id, p.period;

    DELETE FROM PERIOD_REPORTS p
     WHERE p.id = type_otchet
       AND p.mg = mg_; --обновл€ем период дл€ отчета
    INSERT INTO PERIOD_REPORTS (id, mg) VALUES (type_otchet, mg_);

    DELETE FROM PERIOD_REPORTS p
     WHERE p.id = type_otchet2
       AND p.mg = mg_; --обновл€ем период дл€ отчета
    INSERT INTO PERIOD_REPORTS (id, mg) VALUES (type_otchet2, mg_);

    DELETE FROM PERIOD_REPORTS p
     WHERE p.id = type_otchet3
       AND p.mg = mg_; --обновл€ем период дл€ отчета
    INSERT INTO PERIOD_REPORTS (id, mg) VALUES (type_otchet3, mg_);
    COMMIT;
END testX;
/

prompt
prompt Creating procedure TESTZ
prompt ========================
prompt
CREATE OR REPLACE PROCEDURE SCOTT.testZ IS
cnt_ number;
BEGIN
for d in (select k.lsk, k.c_lsk_id from kart k where
    exists (select * from kart t where t.c_lsk_id=k.c_lsk_id
      and t.lsk=lpad('00010001',8,'0')))
loop
null;
  --начисление без коммита
  cnt_:=c_charges.gen_charges(d.lsk, d.lsk, null, 0, 0);
  --движение
  c_cpenya.gen_charge_pay(d.c_lsk_id, 0);
end loop;

END testZ;
/

prompt
prompt Creating procedure TEST_NEW_SAL
prompt ===============================
prompt
CREATE OR REPLACE PROCEDURE SCOTT.test_new_sal IS
mg_ char(6);
mg1_ char(6);
begin
    select period into mg_ from params;
    mg1_ := TO_CHAR(ADD_MONTHS(TO_DATE(mg_ || '01', 'YYYYMMDD'), 1),
                    'YYYYMM');
    --ƒобавл€ем во временную таблицу
    EXECUTE IMMEDIATE 'TRUNCATE TABLE t_c_lsk_id_saldo';
    insert into t_c_lsk_id_saldo
      (c_lsk_id, org, uslm)
      select distinct k.c_lsk_id,
                      a.org,
                      a.uslm
        from (select a.lsk, a.org, a.uslm
                from saldo a, v_params v
               where a.mg = v.period1
              union all
              select e.lsk, e.org, e.uslm
                from t_charges_for_saldo e
              union all
              select e.lsk, e.org, e.uslm
                from t_changes_for_saldo e
              union all
              select e.lsk, e.org, e.uslm
                from t_subsidii_for_saldo e
              union all
              select e.lsk, e.org, e.uslm
                from t_payment_for_saldo e
              union all
              select e.lsk, e.org, e.uslm
                from t_privs_for_saldo e
              union all
              select e.lsk, e.org, e.uslm from t_penya_for_saldo e) a,
              kart k
              where k.lsk=a.lsk;
    commit;

    delete from xitog2_lsk t where t.mg=mg_;
    insert into xitog2_lsk
      (c_lsk_id,
       ORG,
       USLM,
       indebet,
       inkredit,
       CHARGES,
       CHANGES,
       CH_FULL,
       CHANGES2,
       subsid,
       PRIVS,
       payment,
       pn,
       outdebet,
       outkredit,
       mg)
      SELECT t.c_lsk_id,
             t.ORG,
             t.USLM,
             SUM(a.summa) indebet,
             SUM(b.summa) inkredit,
             SUM(NVL(e.summa, 0) + NVL(f.summa, 0)+ NVL(w.summa, 0)- NVL(o.summa, 0)- NVL(g.summa, 0)) CHARGES,
             SUM(NVL(f.summa,0)) CHANGES,
             SUM(NVL(e.summa, 0)) CH_FULL,
             SUM(NVL(w.summa,0)) CHANGES2,
             SUM(g.summa) subsid,
             SUM(o.summa) PRIVS,
             SUM(h.summa) payment,
             SUM(j.summa) pn,
             SUM(k.summa) outdebet,
             SUM(l.summa) outkredit,
             mg_ AS mg
        FROM t_c_lsk_id_saldo t,
             (select t.c_lsk_id, t.org, t.uslm, sum(summa) as summa
               from saldo t
              where summa >= 0
                and mg = mg_
              group by t.c_lsk_id, t.org, t.uslm) a,
             (select t.c_lsk_id, t.org, t.uslm, sum(summa) as summa
               from saldo t
              where summa < 0
                and mg = mg_
              group by t.c_lsk_id, t.org, t.uslm) b,
             (select t.c_lsk_id, t.org, t.uslm, sum(summa) as summa
               from saldo t
              where summa >= 0
                and mg = mg1_
              group by t.c_lsk_id, t.org, t.uslm) k,
             (select t.c_lsk_id, t.org, t.uslm, sum(summa) as summa
               from saldo t
              where summa < 0
                and mg = mg1_
              group by t.c_lsk_id, t.org, t.uslm) l,
             (select k.c_lsk_id,
                    t.org,
                    t.uslm,
                    sum(summa) as summa
               from t_charges_for_saldo t, kart k
              where k.lsk = t.lsk
              group by k.c_lsk_id, t.org, t.uslm) e,
             (select k.c_lsk_id,
                    t.org,
                    t.uslm,
                    sum(summa) as summa
               from t_privs_for_saldo t, kart k
              where k.lsk = t.lsk
              group by k.c_lsk_id, t.org, t.uslm) o,
             (select k.c_lsk_id,
                    t.org,
                    t.uslm,
                    sum(summa) as summa
               from t_changes_for_saldo t, kart k
              where k.lsk = t.lsk and t.type in (0)
              group by k.c_lsk_id, t.org, t.uslm) f,
             (select k.c_lsk_id,
                    t.org,
                    t.uslm,
                    sum(summa) as summa
               from t_changes_for_saldo t, kart k
              where k.lsk = t.lsk and t.type in (1,2)
              group by k.c_lsk_id, t.org, t.uslm) w,
             (select k.c_lsk_id,
                    t.org,
                    t.uslm,
                    sum(summa) as summa
               from t_subsidii_for_saldo t, kart k
              where k.lsk = t.lsk
              group by k.c_lsk_id, t.org, t.uslm) g,
             (select k.c_lsk_id,
                    t.org,
                    t.uslm,
                    sum(summa) as summa
               from t_payment_for_saldo t, kart k
              where k.lsk = t.lsk
              group by k.c_lsk_id, t.org, t.uslm) h,
             (select k.c_lsk_id,
                    t.org,
                    t.uslm,
                    sum(summa) as summa
               from t_penya_for_saldo t, kart k
              where k.lsk = t.lsk
              group by k.c_lsk_id, t.org, t.uslm) j
       WHERE t.c_lsk_id = a.c_lsk_id(+)
         AND t.ORG = a.ORG(+)
         AND t.USLM = a.USLM(+)

         and t.c_lsk_id = b.c_lsk_id(+)
         AND t.ORG = b.ORG(+)
         AND t.USLM = b.USLM(+)

         and t.c_lsk_id = k.c_lsk_id(+)
         AND t.ORG = k.ORG(+)
         AND t.USLM = k.USLM(+)

         and t.c_lsk_id = l.c_lsk_id(+)
         AND t.ORG = l.ORG(+)
         AND t.USLM = l.USLM(+)

         and t.c_lsk_id = e.c_lsk_id(+)
         AND t.ORG = e.ORG(+)
         AND t.USLM = e.USLM(+)

         and t.c_lsk_id = o.c_lsk_id(+)
         AND t.ORG = o.ORG(+)
         AND t.USLM = o.USLM(+)

         and t.c_lsk_id = f.c_lsk_id(+)
         AND t.ORG = f.ORG(+)
         AND t.USLM = f.USLM(+)

         and t.c_lsk_id = w.c_lsk_id(+)
         AND t.ORG = w.ORG(+)
         AND t.USLM = w.USLM(+)

         and t.c_lsk_id = g.c_lsk_id(+)
         AND t.ORG = g.ORG(+)
         AND t.USLM = g.USLM(+)

         and t.c_lsk_id = h.c_lsk_id(+)
         AND t.ORG = h.ORG(+)
         AND t.USLM = h.USLM(+)

         and t.c_lsk_id = j.c_lsk_id(+)
         AND t.ORG = j.ORG(+)
         AND t.USLM = j.USLM(+)
       GROUP BY t.c_lsk_id, t.ORG, t.USLM;

  -- выбираем уникальные c_lsk_id + орг. + усл. дл€ формировани€ отчетности по сальдо
  delete from t_c_lsk_id_saldo2;
  insert into t_c_lsk_id_saldo2
      (c_lsk_id, org, uslm)
      select distinct c_lsk_id, org, uslm from xitog2_lsk t;
  commit;
END test_new_sal;
/

prompt
prompt Creating procedure TEST_PAY
prompt ===========================
prompt
CREATE OR REPLACE PROCEDURE SCOTT."TEST_PAY" IS
  id_ number;
begin
init.set_nkom('020');
id_:=init.set_date(trunc(sysdate));
--select c_kwtp_id.nextval into id_ from dual;
for c in (select * from a_kwtp t where t.nkom='020' and t.nink=842
 and mg='200909')
loop
insert into c_kwtp
  (lsk, summa, penya, oper, dopl, nink, nkom, dtek, nkvit, dat_ink, ts, id, iscorrect)
select lsk, -1*summa, -1*penya, oper, dopl, nink, nkom, trunc(sysdate),
 nkvit, trunc(sysdate), sysdate, c_kwtp_id.nextval, 1
 from a_kwtp t where t.nkom='020' and t.nink=842
and mg='200909' and t.id=c.id;
insert into c_kwtp_mg
  (lsk, summa, penya, oper, dopl, nink, nkom, dtek, nkvit,
   dat_ink, ts, c_kwtp_id, rasp_id, cnt_sch, cnt_sch0)
select lsk, -1*summa, -1*penya, oper, dopl, nink, nkom, trunc(sysdate), nkvit,
  trunc(sysdate), sysdate, c_kwtp_id.currval, rasp_id, cnt_sch, cnt_sch0
 from a_kwtp_mg t where t.nkom='020' and t.nink=842
and mg='200909' and t.c_kwtp_id=c.id;

c_get_pay.get_payment(c.lsk, c.summa, c.penya, c.oper, c.dopl, 1, null ,
 1);

end loop;

commit;
end test_pay;
/

prompt
prompt Creating procedure drn94_ќборотна€_тсж
prompt ======================================
prompt
CREATE OR REPLACE PROCEDURE SCOTT."drn94_ќборотна€_тсж" is
begin
  Null;
end drn94_ќборотна€_тсж;
/

prompt
prompt Creating procedure drn95_ќборотна€_тсж
prompt ======================================
prompt
CREATE OR REPLACE PROCEDURE SCOTT."drn95_ќборотна€_тсж" is
begin
  Null;
end drn95_ќборотна€_тсж;
/

prompt
prompt Creating package body ADMIN
prompt ===========================
prompt
CREATE OR REPLACE PACKAGE BODY SCOTT.ADMIN IS
  g_trg_id_ NUMBER;

procedure fix_base(fix_ in number) is
begin
--фиксаци€ изменений в базе...
  if fix_ = 1 then --изменени€ не разрешены
    execute immediate 'alter trigger fix_c_change enable';
    execute immediate 'alter trigger fix_c_change_docs enable';
    execute immediate 'alter trigger fix_c_houses enable';
    execute immediate 'alter trigger fix_c_kart_pr enable';
    execute immediate 'alter trigger fix_c_kwtp enable';
    execute immediate 'alter trigger fix_c_kwtp_mg enable';
    execute immediate 'alter trigger fix_c_lg_docs enable';
    execute immediate 'alter trigger fix_c_lg_pr enable';
    execute immediate 'alter trigger fix_c_vvod enable';
    execute immediate 'alter trigger fix_kart enable';
    execute immediate 'alter trigger fix_kart_pr enable';
    execute immediate 'alter trigger fix_nabor enable';
  else --изменени€ разрешены
  null;
  end if;
end;


  PROCEDURE sign_reports is
  begin
   update period_reports p set p.signed=1;
  end;

  PROCEDURE disable_logons(param_ IN PARAMS.param%TYPE,
                           mess_  IN PARAMS.message%TYPE) IS
    --«апрет / разрешение на работу пользовател€м
  BEGIN
    UPDATE PARAMS SET param = param_, message = mess_;
    COMMIT;
  END disable_logons;

  PROCEDURE send_message(msg_ IN MESSAGES.text%TYPE) IS
  BEGIN
    --отправка сообщений пользовател€м
   SYS.Dbms_Alert.signal('FINDAY', msg_ );
   COMMIT;
  END;

  procedure analyze_all_tables is
    cursor c is
      select table_name from all_tables where owner = 'SCOTT';
    rec_ c%rowtype;
  begin
  time_ := sysdate;
    open c;
    loop
      fetch c
        into rec_;
      exit when c%notfound;
      begin
        execute immediate 'BEGIN DBMS_STATS.GATHER_TABLE_STATS ( ''SCOTT'' , :table_ ,'''' ,''33'' ,FALSE ,''FOR ALL INDEXES''  ,NULL  ,''DEFAULT''  ,FALSE ,''''  ,''''  ,'''' ); END;'
          using rec_.table_name;
      end;
    end loop;
  logger.log_(time_, 'Admin.analyze_all_tables (—обрана аналитика)');
  end;

  PROCEDURE ANALYZE(table_ IN sys.all_tables.table_name%TYPE) IS
    CURSOR c IS
      SELECT index_name AS index_name
        FROM all_indexes
       WHERE owner = 'SCOTT'
         AND table_name = UPPER(table_);
    rec_ c%ROWTYPE;
  BEGIN
    --  return;
    --analyze таблиц и индексов, после загрузки в схеме 'SCOTT'
    EXECUTE IMMEDIATE 'BEGIN DBMS_STATS.GATHER_TABLE_STATS ( ''SCOTT'' , :table_ ,'''' ,''33'' ,FALSE ,''FOR ALL INDEXES''  ,NULL  ,''DEFAULT''  ,FALSE ,''''  ,''''  ,'''' ); END;'
      USING UPPER(table_);
    OPEN c;
    LOOP
      FETCH c
        INTO rec_;
      EXIT WHEN c%NOTFOUND;
      BEGIN
        EXECUTE IMMEDIATE 'BEGIN DBMS_STATS.GATHER_INDEX_STATS (''SCOTT''  ,:index_  ,''''  ,''33''  ,''''  ,''''  ,'''' ); END;'
          USING rec_.index_name;
      EXCEPTION
        WHEN OTHERS THEN
          NULL;
      END;
    END LOOP;
  END;

  PROCEDURE analyze_db IS
  BEGIN
    sys.dbms_stats.gather_database_stats(30,
                                         NULL,
                                         'FOR ALL COLUMNS',
                                         NULL,
                                         'DEFAULT',
                                         TRUE,
                                         NULL,
                                         NULL,
                                         'GATHER',
                                         NULL,
                                         FALSE,
                                         FALSE,
                                         FALSE);
  END;

  PROCEDURE make_readed_message(id_ IN MESSAGES.id%TYPE) IS
  BEGIN
    --отметка о прочтении сообщени€ пользователем
    UPDATE MESSAGES m SET m.is_read_lamp = 1 WHERE m.id = id_;
    COMMIT;
  END;

  PROCEDURE trg_del_var IS
    --√руппа процедур по удалению старых сообщений пользователей
  BEGIN
    g_trg_id_ := 0;
  END;

  PROCEDURE trg_set_var(id_ IN NUMBER) IS
  BEGIN
    g_trg_id_ := id_;
  END;

  PROCEDURE trg_del_rec IS
  BEGIN
    IF g_trg_id_ <> 0 THEN
      --” не SYS-а оставл€ем последние 30 сообщений
      DELETE FROM MESSAGES d
       WHERE d.id IN (SELECT t.id
                        FROM MESSAGES t,
                             (SELECT m.*, ROWNUM AS rn
                                FROM (SELECT *
                                        FROM MESSAGES
                                       WHERE from_id = g_trg_id_
                                       ORDER BY dat DESC) m) a
                       WHERE t.id = a.id
                         AND a.rn > 30);
    ELSE
      --” SYS-а удал€ем старые сообщени€
      DELETE FROM MESSAGES m
       WHERE m.from_id = g_trg_id_
         AND m.dat < SYSDATE - 1;
    END IF;
  END;


  function test_fields(tname_ in varchar2, field_ varchar2) return varchar2
  is
  TYPE empcurtyp IS REF CURSOR;
  c     empcurtyp;
  rec_ usl%rowtype;
  txt_ varchar2(1000);
  fld_ varchar2(100);
  begin
  txt_:='';
    open c for 'select trim('||field_||') as fld from usl u ';
    loop
      fetch c into fld_;
      exit when c%notfound;
      begin
        execute immediate 'insert into '||tname_||' (' || fld_ || ')
           values  (null)';
        exception
        when others then
        txt_:=txt_||' '||fld_;
      end;
    rollback;
    end loop;
  return txt_;
  end;

  procedure test_tables is
  txt_ varchar2(1000);
  begin
    txt_:=test_fields('expprivs', 'lpw');
    if length(txt_) > 0 then
      raise_application_error(-20001,
                           'ƒл€ таблицы expprivs не достаточно следующих полей '||txt_);
    end if;
    txt_:=test_fields('expkartw', 'kartw');
    if length(txt_) > 0 then
      raise_application_error(-20001,
                           'ƒл€ таблицы expkartw не достаточно следующих полей '||txt_);
    end if;
    txt_:=test_fields('expkwni', 'kwni');
    if length(txt_) > 0 then
      raise_application_error(-20001,
                           'ƒл€ таблицы expkwni не достаточно следующих полей '||txt_);
    end if;

  end;

  procedure user_add_perm(fk_pasp_org_ in c_users_perm.fk_pasp_org%type,
    fk_reu_ in c_users_perm.fk_reu%type,
    user_id_ in t_user.id%type, fk_perm_tp_ in c_users_perm.fk_perm_tp%type,
    fk_comp_ in c_users_perm.fk_comp%type) is
  cd_ u_list.cd%type;
  begin
  --ƒобавл€ет привилегии на правку
  select t.cd into cd_ from u_list t where t.id=fk_perm_tp_;
  if cd_ in  ('доступ к карт.рэу',
    'доступ к карт.площадь',
    'доступ к карт.статус') then
  --дл€ –Ё”
  insert into c_users_perm
    (user_id, fk_reu, fk_pasp_org, fk_perm_tp)
    select user_id_, fk_reu_, null, fk_perm_tp_ from dual
     where not exists (select * from c_users_perm c
     where c.user_id=user_id_ and c.fk_reu=fk_reu_ and
     c.fk_perm_tp=fk_perm_tp_);
  elsif cd_ = 'доступ к отчЄтам' then
  --дл€ доступа к отчЄтам
  insert into c_users_perm
    (user_id, fk_reu, fk_pasp_org, fk_perm_tp)
    select user_id_, fk_reu_, null, fk_perm_tp_ from dual
     where not exists (select * from c_users_perm c
     where c.user_id=user_id_ and c.fk_reu=fk_reu_ and
     c.fk_perm_tp=fk_perm_tp_);
  elsif cd_='доступ к пасп.столу' then
  --дл€ ѕаспортного
  insert into c_users_perm
    (user_id, fk_reu, fk_pasp_org, fk_perm_tp)
    select user_id_, null, fk_pasp_org_, fk_perm_tp_ from dual
     where not exists (select * from c_users_perm c
     where c.user_id=user_id_ and c.fk_pasp_org=fk_pasp_org_ and
     c.fk_perm_tp=fk_perm_tp_);
  elsif cd_='доступ к льготам' then
  --дл€ редактировани€ льгот
  insert into c_users_perm
    (user_id, fk_reu, fk_pasp_org, fk_perm_tp)
    select user_id_, fk_reu_, null, fk_perm_tp_ from dual
     where not exists (select * from c_users_perm c
     where c.user_id=user_id_ and c.fk_reu=fk_reu_ and
     c.fk_perm_tp=fk_perm_tp_);
  elsif cd_='доступ к компьютерам' then
  --доступ к компьютерам
  insert into c_users_perm
    (user_id, fk_reu, fk_comp, fk_perm_tp)
    select user_id_, null, fk_comp_, fk_perm_tp_ from dual
     where not exists (select * from c_users_perm c
     where c.user_id=user_id_ and c.fk_comp=fk_comp_ and
     c.fk_perm_tp=fk_perm_tp_);
  end if;
  commit;
  end;

  procedure user_del_perm(fk_pasp_org_ in c_users_perm.fk_pasp_org%type,
    fk_reu_ in c_users_perm.fk_reu%type,
    user_id_ in t_user.id%type, fk_perm_tp_ in c_users_perm.fk_perm_tp%type,
    fk_comp_ in c_users_perm.fk_comp%type) is
  cd_ u_list.cd%type;
  begin
  --”дал€ет привилегии на правку
  select t.cd into cd_ from u_list t where t.id=fk_perm_tp_;
  if cd_ in ('доступ к карт.рэу',
    'доступ к карт.площадь',
    'доступ к карт.статус') then
  --дл€ –Ё”
    delete from c_users_perm c where
    c.fk_reu=fk_reu_ and c.user_id=user_id_ and
    c.fk_perm_tp=fk_perm_tp_;
  elsif cd_ = 'доступ к отчЄтам' then
  --дл€ доступа к отчЄтам
    delete from c_users_perm c where
    c.fk_reu=fk_reu_ and c.user_id=user_id_ and
    c.fk_perm_tp=fk_perm_tp_;
  elsif cd_='доступ к пасп.столу' then
  --дл€ ѕаспортного
    delete from c_users_perm c where
    c.fk_pasp_org=fk_pasp_org_ and c.user_id=user_id_ and
    c.fk_perm_tp=fk_perm_tp_;
  elsif cd_='доступ к льготам' then
  --дл€ редактировани€ льгот
    delete from c_users_perm c where
    c.fk_reu=fk_reu_ and c.user_id=user_id_ and
    c.fk_perm_tp=fk_perm_tp_;
  elsif cd_='доступ к компьютерам' then
  --доступ к компьютерам
    delete from c_users_perm c where
    c.fk_comp=fk_comp_ and c.user_id=user_id_ and
    c.fk_perm_tp=fk_perm_tp_;
  end if;
  commit;
  end;

procedure set_state_base(var_ in number)
is
begin
--ќткрытие/«акрытие базы дл€ доступа пользователей (автоматически после перехода)
-- var_ = 0 - открыть, 1 - закрыть
update spr_params t set t.parn1=var_
  where t.fk_parcdtp ='BASE_STATE';
commit;
end;

function get_state_base
   return number
is
  state_ number;
  cnt_ number;
begin
--вернуть состо€ние базы
-- 0 -открыта
-- 1 -закрыта
-- 2 -неопределено (часть параметров - открыты, часть - закрыты)
begin
  select count(*) into cnt_ from spr_params t where
    t.fk_parcdtp ='BASE_STATE';
  select case when sum(t.parn1) = 0 then 0
     when sum(t.parn1) / cnt_ = 1 then 1
       else 2
         end as state into state_
        from spr_params t where
    t.fk_parcdtp ='BASE_STATE';
exception
  when others then
   Raise_application_error(-20000, '¬нимание! Ќекорректно кол-во параметров в справочнике параметров');
end;

return state_;

end;

procedure set_ver(ver_ in number, type_ in number)
is
begin
if nvl(type_,0) = 1 then
  --ќбновление номера версии дл€ ожидани€ программным обеспечением
  update params t set t.wait_ver=ver_;
else
  --ќбновление номера версии программных пакетов Updater-ом
  update params t set t.ver=ver_;
end if;
commit;
end;

procedure dsb_constr
is
begin
--отключить все констрэйнты в схеме
BEGIN
  FOR c IN
  (SELECT c.owner, c.table_name, c.constraint_name
   FROM user_constraints c, user_tables t
   WHERE c.table_name = t.table_name
   AND c.status = 'ENABLED'
   ORDER BY c.constraint_type DESC)
  LOOP
    dbms_utility.exec_ddl_statement('alter table "' || c.owner || '"."' || c.table_name || '" disable constraint ' || c.constraint_name);
  END LOOP;
END;
end;
procedure enb_constr
is
begin
--включить все констрэйнты в схеме

BEGIN
  FOR c IN
  (SELECT c.owner, c.table_name, c.constraint_name
   FROM user_constraints c, user_tables t
   WHERE c.table_name = t.table_name
   AND c.status = 'DISABLED'
   ORDER BY c.constraint_type)
  LOOP
    dbms_utility.exec_ddl_statement('alter table "' || c.owner || '"."' || c.table_name || '" enable constraint ' || c.constraint_name);
  END LOOP;
END;
end;


procedure compress_nabor is
 l_cnt number;
  procedure check_nabor_row(p_row in a_nabor%rowtype) is
   l_rd rowid;
   l_mg1 params.period%type;
   l_flag number;
  begin
  --проверить наличие идентичной записи в архивной таблице
  --вернуть найденый заключительный период
  --периоды ƒќЅј¬Ћя“№ процедурой “ќЋ№ ќ по ¬ќ«–ј—“јЌ»ё!
    l_rd:=null;
    for c in (select t.rowid as rd, t.* from a_nabor_prep t where t.mg2='999999'
      and t.lsk=p_row.lsk
      and t.usl=p_row.usl
      order by t.mg1 desc--важен пор€док!
      ) loop
      
      l_flag:=0;
      if coalesce(c.org,0)=coalesce(p_row.org,0)
        and coalesce(c.koeff,0)=coalesce(p_row.koeff,0)
        and coalesce(c.norm,0)=coalesce(p_row.norm,0)
        and coalesce(c.fk_tarif,0)=coalesce(p_row.fk_tarif,0)
        and coalesce(c.fk_vvod,0)=coalesce(p_row.fk_vvod,0)
        and coalesce(c.vol,0)=coalesce(p_row.vol,0)
        and coalesce(c.vol_add,0)=coalesce(p_row.vol_add,0)
        and coalesce(c.kf_kpr,0)=coalesce(p_row.kf_kpr,0)
        and coalesce(c.sch_auto,0)=coalesce(p_row.sch_auto,0)
        and coalesce(c.nrm_kpr,0)=coalesce(p_row.nrm_kpr,0)
        and coalesce(c.kf_kpr_sch,0)=coalesce(p_row.kf_kpr_sch,0)
        and coalesce(c.kf_kpr_wrz,0)=coalesce(p_row.kf_kpr_wrz,0)
        and coalesce(c.kf_kpr_wro,0)=coalesce(p_row.kf_kpr_wro,0)
        and coalesce(c.kf_kpr_wrz_sch,0)=coalesce(p_row.kf_kpr_wrz_sch,0)
        and coalesce(c.kf_kpr_wro_sch,0)=coalesce(p_row.kf_kpr_wro_sch,0) then 
        l_flag:=1;
      end if;  
             
      if l_flag=1 and c.mg1=p_row.mg then
       --найдена идентична€ запись, с тем же начальным периодом, выйти
       null;
      elsif l_flag=1 and c.mg1<p_row.mg then 
       --найдена идентична€ запись, с начальным периодом раньше добавл€емого, выйти
       null;
      elsif l_flag=0 and c.mg1<p_row.mg then 
       --найдена Ќ≈ идентична€ запись, с начальным периодом раньше добавл€емого
       --закрыть старый период
        update a_nabor_prep t set
         t.mg2=to_char(add_months(to_date(p_row.mg||'01','YYYYMMDD'),-1),'YYYYMM')
         where t.rowid=c.rd;
        if sql%rowcount = 0 then
          Raise_application_error(-20000, 'ќшибка #1');
        end if;   
       --добавить новый период
        insert into a_nabor_prep
           (lsk, usl, org, koeff, norm, fk_tarif, fk_vvod, vol,
            vol_add, kf_kpr, sch_auto, nrm_kpr, kf_kpr_sch, kf_kpr_wrz,
            kf_kpr_wro, kf_kpr_wrz_sch, kf_kpr_wro_sch, mg1, mg2)
        values (p_row.lsk, p_row.usl, p_row.org, p_row.koeff, p_row.norm, p_row.fk_tarif,
            p_row.fk_vvod, p_row.vol,
            p_row.vol_add, p_row.kf_kpr, p_row.sch_auto, p_row.nrm_kpr, p_row.kf_kpr_sch,
            p_row.kf_kpr_wrz,
            p_row.kf_kpr_wro, p_row.kf_kpr_wrz_sch, p_row.kf_kpr_wro_sch,
            p_row.mg, '999999');
      elsif l_flag=0 and c.mg1=p_row.mg then 
       --найдена Ќ≈ идентична€ запись, с тем же периодом, обновить еЄ
        update a_nabor_prep t set
             t.org=p_row.org
            ,t.koeff=p_row.koeff
            ,t.norm=p_row.norm
            ,t.fk_tarif=p_row.fk_tarif
            ,t.fk_vvod=p_row.fk_vvod
            ,t.vol=p_row.vol
            ,t.vol_add=p_row.vol_add
            ,t.kf_kpr=p_row.kf_kpr
            ,t.sch_auto=p_row.sch_auto
            ,t.nrm_kpr=p_row.nrm_kpr
            ,t.kf_kpr_sch=p_row.kf_kpr_sch
            ,t.kf_kpr_wrz=p_row.kf_kpr_wrz
            ,t.kf_kpr_wro=p_row.kf_kpr_wro
            ,t.kf_kpr_wrz_sch=p_row.kf_kpr_wrz_sch
            ,t.kf_kpr_wro_sch=p_row.kf_kpr_wro_sch    
          where t.rowid=c.rd; 
        if sql%rowcount = 0 then
          Raise_application_error(-20000, 'ќшибка #2');
        end if;   
      end if;  
      return;--выйти из процедуры!
     end loop;
     --ничего не найдено, просто добавить новый период
      insert into a_nabor_prep
         (lsk, usl, org, koeff, norm, fk_tarif, fk_vvod, vol,
          vol_add, kf_kpr, sch_auto, nrm_kpr, kf_kpr_sch, kf_kpr_wrz,
          kf_kpr_wro, kf_kpr_wrz_sch, kf_kpr_wro_sch, mg1, mg2)
      values (p_row.lsk, p_row.usl, p_row.org, p_row.koeff, p_row.norm, p_row.fk_tarif,
          p_row.fk_vvod, p_row.vol,
          p_row.vol_add, p_row.kf_kpr, p_row.sch_auto, p_row.nrm_kpr, p_row.kf_kpr_sch,
          p_row.kf_kpr_wrz,
          p_row.kf_kpr_wro, p_row.kf_kpr_wrz_sch, p_row.kf_kpr_wro_sch,
          p_row.mg, '999999');
end;

begin
--проверка всех строк таблицы a_nabor, помещение в архив, уплотнение
execute immediate 'truncate table a_nabor_prep';
l_cnt:=1;
for c in (select t.*
              from a_nabor t order by t.mg) loop
    check_nabor_row(c);
    l_cnt:=l_cnt+1;
    if l_cnt >= 10000 then
      --коммит на каждых 10000 тыс запис€х
      commit;
      l_cnt:=1;
    end if;
  end loop;
commit;
end;


END ADMIN;
/

prompt
prompt Creating package body AGENT
prompt ===========================
prompt
CREATE OR REPLACE PACKAGE BODY SCOTT.agent IS

  PROCEDURE uptime IS
    stmt VARCHAR2(2000);
  BEGIN
    stmt := 'UPDATE params SET agent_uptime=sysdate';
    EXECUTE IMMEDIATE stmt;
    COMMIT;
  END uptime;

  PROCEDURE load_proc_plan
  --«агрузка выполнени€ процентов по плану
   IS
    stmt VARCHAR2(2000);
  BEGIN
    stmt := 'DELETE FROM proc_plan_loaded';
    EXECUTE IMMEDIATE stmt;
    stmt := 'INSERT INTO proc_plan_loaded
               SELECT * FROM PROC_PLAN_LOAD';
    EXECUTE IMMEDIATE stmt;
    agent.uptime;
    COMMIT;
  END load_proc_plan;

procedure load_subs_el is
 cnt_ number;
begin
--«агрузка субсидии по электроэнергии
if utils.get_int_param('LD_SUBS_EL') = 1 then
 select count(*) into cnt_ from load_el e where not exists
   (select * from kart k where k.lsk = e.lchet);
 if cnt_ <> 0 then
   Raise_application_error(-20001,
     'ѕопытка загрузить не существующие лицевые счета в таблице LOAD_EL!');
 end if;
 delete from c_charge where var = 1;
 insert into c_charge (lsk, usl, summa, var, type)
  select e.lchet, '024', e.sum_sv, 1, 2 from load_el e;
 commit;
end if;
end;

procedure load_subs_cor is
 cnt_ number;
begin
--«агрузка корректировок по субсидии
 select count(*) into cnt_ from load_cor e where not exists
   (select * from kart k where k.lsk = e.lchet);
 if cnt_ <> 0 then
   Raise_application_error(-20001,
     'ѕопытка загрузить не существующие лицевые счета в таблице LOAD_COR!');
 end if;
 update kart k set k.subs_cor = null where
  substr(k.lsk, 1, 4) in (select distinct substr(e.lchet, 1, 4) from load_cor e);

 update kart k set k.subs_cor =
   (select sum(e.sum_sub)  from load_cor e where e.lchet=k.lsk),
   k.subs_cur=1
   where exists (select * from load_cor e where e.lchet=k.lsk);
 commit;
end;

procedure load_subs_inf is
 cnt_ number;
begin
--«агрузка субсидии дл€ информации в карточке
 select count(*) into cnt_ from load_inf e where not exists
   (select * from kart k where k.lsk = e.lchet);
 if cnt_ <> 0 then
   Raise_application_error(-20001,
     'ѕопытка загрузить не существующие лицевые счета в таблице LOAD_INF!');
 end if;
 update kart k set k.subs_inf = null where
  substr(k.lsk, 1, 4) in (select distinct substr(e.lchet, 1, 4) from load_inf e);

 update kart k set k.subs_inf =
   (select sum(e.sum_sub)  from load_inf e where e.lchet=k.lsk)
   where exists (select * from load_inf e where e.lchet=k.lsk);
 commit;
end;

procedure recv_payment_for_en (dat1_ in date,
                                   dat2_ in date)
is
oper_ char(2);
dat_ink_ date;
cnt_ number;
cd_ varchar2(100);
l_mg params.period%type;
type prep_refcursor is REF CURSOR;
cur1 prep_refcursor;
begin
cd_:='ћѕ ”≈«∆ ”';
--оплата дл€ Ёнергии+ от ”≈«∆ ”, ежедневна€ и за мес€ц
--код операции - ќплата ”езжку
 select fk_oper into oper_
   from c_comps c where c.cd=cd_;
 select nvl(count(*),0) into cnt_ from load_en_pay l, params p where
   to_char(l.dat_ink,'YYYYMM')<>p.period;
if cnt_ <> 0 then
  Raise_application_error(-20001,
  'ѕериод платежей не соответствует периоду в базе Ёнергии+!');
end if;

 select nvl(count(*),0) into cnt_ from load_en_pay l where
  not exists (select * from kart k where k.lsk=
   lpad(trim(replace(to_char(l.tel_sch,'9999999.99'),'.','')),8, '0'));
if cnt_ <> 0 then
  Raise_application_error(-20001,
  'ќтправленна€ оплата содержит лицевые счета не соответствующие счетам поставщика услуги Ёнергии+!');
end if;

if dat1_ is null and dat2_ is null then
  delete from c_kwtp_mg t where
   exists (select * from params p where p.period=to_char(t.dat_ink,'YYYYMM'))
   and t.oper=oper_;
  delete from c_kwtp t where
   exists (select * from params p where p.period=to_char(t.dat_ink,'YYYYMM'))
   and t.oper=oper_;
else
  delete from c_kwtp_mg t where
   t.dat_ink between dat1_ and dat2_
   and t.oper=oper_;
  delete from c_kwtp t where
   t.dat_ink between dat1_ and dat2_
   and t.oper=oper_;
end if;
commit;

if dat1_ is not null and dat2_ is not null then
  admin.send_message(
    'info:ѕолучена оплата от '||cd_||' за период c '||to_char(dat1_)||' по '||to_char(dat2_));
end if;

update c_comps c set c.nink=nvl(c.nink,0)+1 where c.cd=cd_;

if dat1_ is null and dat2_ is null then
  insert into c_kwtp (id, lsk, summa, oper, dopl, nink, nkom, dtek, nkvit, dat_ink, ts, iscorrect)
   select c_kwtp_id.nextval, k.lsk, l.ska, oper_, l.dopl, --substr(l.dopl,3,4)||substr(l.dopl,1,2),
   c.nink, c.nkom, l.dtek, l.nomz, l.dat_ink, sysdate, 0
   from load_en_pay l, kart k, c_comps c
     where k.lsk=lpad(trim(replace(to_char(l.tel_sch,'9999999.99'),'.','')),8, '0') and c.cd=cd_ and
     exists (select * from params p where p.period=to_char(l.dat_ink,'YYYYMM'));
  insert into c_kwtp_mg (c_kwtp_id, lsk, summa, oper, dopl, nink, nkom, dtek, nkvit, dat_ink, ts)
   select l.id, l.lsk, l.summa, oper_, l.dopl,
   l.nink, l.nkom, l.dtek, l.nkvit, l.dat_ink, sysdate
   from c_kwtp l, c_comps c
     where c.cd=cd_ and l.nkom=c.nkom and
     exists (select * from params p where p.period=to_char(l.dat_ink,'YYYYMM'));
else
  insert into c_kwtp (id, lsk, summa, oper, dopl, nink, nkom, dtek, nkvit, dat_ink, ts, iscorrect)
   select c_kwtp_id.nextval, k.lsk, l.ska, oper_, l.dopl, --substr(l.dopl,3,4)||substr(l.dopl,1,2),
   c.nink, c.nkom, l.dtek, l.nomz, l.dat_ink, sysdate, 0
   from load_en_pay l, kart k, c_comps c
     where k.lsk=lpad(trim(replace(to_char(l.tel_sch,'9999999.99'),'.','')),8, '0') and c.cd=cd_
     and l.dat_ink between dat1_ and dat2_;
  insert into c_kwtp_mg (c_kwtp_id, lsk, summa, oper, dopl, nink, nkom, dtek, nkvit, dat_ink, ts)
   select l.id, l.lsk, l.summa, oper_, l.dopl,
   l.nink, l.nkom, l.dtek, l.nkvit, l.dat_ink, sysdate
   from c_kwtp l, c_comps c
     where c.cd=cd_ and l.nkom=c.nkom and
     l.dat_ink between dat1_ and dat2_;
end if;
commit;

--сформировать реестр дл€ базы ƒениса

select p.period into l_mg from params p;
stat.rep_stat(reu_ => null,
              kul_ => null,
              nd_ => null,
              trest_ => null,
              mg_ => l_mg,
              mg1_ => null,
              dat_ => null,
              dat1_ => null,
              var_ => null,
              det_ => null,
              org_ => null,
              oper_ => null,
              сd_ => '81',
              spk_id_ => null,
              p_house => null,
              p_out_tp => 1,
              prep_refcursor => cur1)
              ;

end;

procedure unload_en is
begin
  --выгрузка долгов энергии +
  --формирование долгов
  --долги кабельного телевидени€
  c_cpenya.gen_charge_pay_full;
  delete from load_en;
  insert into load_en
  (lsk, polis, kul, nyl, nd, kw, fio, ndog, ska)
  select k.lsk,
         k.polis,
         k.kul,
         s.name,
         k.nd,
         k.kw,
         substr(k.fio, 1, 25),
         substr(k.dog_num, 1, 10),
         sum(decode(c.type, 0, c.summa, 1, -1 * c.summa))
    from kart k, c_chargepay c, spul s, params p
   where k.lsk = c.lsk
     and k.kul = s.id
     and c.period = p.period --ред.26.03.2012
     and exists --и существует в объеме необх. услуга
     (select * from nabor n, usl u where n.lsk=k.lsk and
         nvl(decode(u.sptarn, 0, nvl(n.koeff,0), 1, nvl(n.norm,0), 2,
               nvl(n.koeff,0) * nvl(n.norm,0), 3, nvl(n.koeff,0) * nvl(n.norm,0)), 0) <> 0
        and n.usl=u.usl and u.cd in ('каб.тел.')
     )
     and k.psch in (8,9) --закрытые л.с.
     and exists --и существует задолжность по л.с.
     (select e.lsk from c_penya e where
       e.lsk=k.lsk
       group by e.lsk
       having sum(e.summa) <> 0)
   group by k.lsk,
            k.polis,
            k.kul,
            s.name,
            k.nd,
            k.kw,
            substr(k.fio, 1, 25),
            substr(k.dog_num, 1, 10)
   union all
  select k.lsk,
         k.polis,
         k.kul,
         s.name,
         k.nd,
         k.kw,
         substr(k.fio, 1, 25),
         substr(k.dog_num, 1, 10),
         sum(decode(c.type, 0, c.summa, 1, -1 * c.summa))
    from kart k, c_chargepay c, spul s, params p
   where k.lsk = c.lsk
     and k.kul = s.id
     and c.period = p.period --ред.26.03.2012
     and k.psch not in (8,9) --не закрытые л.с.
     and exists --и существует в объеме необх. услуга
     (select * from nabor n, usl u where n.lsk=k.lsk and
         nvl(decode(u.sptarn, 0, nvl(n.koeff,0), 1, nvl(n.norm,0), 2,
               nvl(n.koeff,0) * nvl(n.norm,0), 3, nvl(n.koeff,0) * nvl(n.norm,0)), 0) <> 0
        and n.usl=u.usl and u.cd in ('каб.тел.')
     )--и существует задолжность по л.с.
   group by k.lsk,
            k.polis,
            k.kul,
            s.name,
            k.nd,
            k.kw,
            substr(k.fio, 1, 25),
            substr(k.dog_num, 1, 10);

     /*and k.psch not in (8, 9) and nvl(k.schel_dt, to_date('19000101','YYYYMMDD')) <=
     to_date(p.period||'15','YYYYMMDD') and
     nvl(k.schel_end, to_date('29000101','YYYYMMDD')) >
     to_date(p.period||'15','YYYYMMDD')*/


  --признаки антенны по договору
  delete from load_en_d;
  insert into load_en_d
  (lsk, polis, kul, nyl, nd, kw, fio, ndog, ska)
  select k.lsk,
         k.polis,
         k.kul,
         s.name,
         k.nd,
         k.kw,
         substr(k.fio, 1, 25),
         substr(k.dog_num, 1, 10),
         case when nvl(k.schel_dt, to_date('19000101','YYYYMMDD')) <=
     to_date(p.period||'15','YYYYMMDD') and
     nvl(k.schel_end, to_date('29000101','YYYYMMDD')) >
     to_date(p.period||'15','YYYYMMDD') then
         f.cena*c.norm
         else
         0 end
    from kart k, nabor c, spul s, spr_tarif_prices f, params p
   where k.lsk = c.lsk
     and k.kul = s.id
     and c.usl='043'
     and c.fk_tarif=f.fk_tarif and p.period between f.mg1 and f.mg2
     and k.c_lsk_id in (select first_value(t.c_lsk_id) over (order by
      case when nvl(t.schel_dt, to_date('19000101','YYYYMMDD')) <=
        to_date(p.period||'15','YYYYMMDD') and
        nvl(t.schel_end, to_date('29000101','YYYYMMDD')) >
        to_date(p.period||'15','YYYYMMDD') and
        decode(u.sptarn, 0, nvl(n.koeff,0), 1, nvl(n.norm,0), 2,
               nvl(n.koeff,0) * nvl(n.norm,0), 3, nvl(n.koeff,0) * nvl(n.norm,0)) <> 0
        then
         0
         else --последний открытый договор по адресу имеет приоритет если все закрыты то и зашибись,
         1 end)--выйдет последний закрытый
        from kart t, nabor n, params p, usl u where
        t.lsk=n.lsk and n.usl=u.usl and n.usl=c.usl and
        ((t.polis is null and t.kul=k.kul and t.nd=k.nd and t.kw=k.kw)
        or (t.polis is not null and t.polis=k.polis)));
  --признаки антенны коллективной
  delete from load_en_ant;
  insert into load_en_ant
  (lsk, polis, kul, nyl, nd, kw, fio, ndog, ska)
  select k.lsk,
         k.polis,
         k.kul,
         s.name,
         k.nd,
         k.kw,
         substr(k.fio, 1, 25),
         substr(k.dog_num, 1, 10),
         case when nvl(k.schel_dt, to_date('19000101','YYYYMMDD')) <=
     to_date(p.period||'15','YYYYMMDD') and
     nvl(k.schel_end, to_date('29000101','YYYYMMDD')) >
     to_date(p.period||'15','YYYYMMDD') then
         c.koeff*c.norm
         else
         0 end
    from kart k, nabor c, spul s, params p
   where k.lsk = c.lsk
     and k.kul = s.id
     and c.usl='044'
     and k.c_lsk_id in (select first_value(t.c_lsk_id) over (order by
      case when nvl(t.schel_dt, to_date('19000101','YYYYMMDD')) <=
        to_date(p.period||'15','YYYYMMDD') and
        nvl(t.schel_end, to_date('29000101','YYYYMMDD')) >
        to_date(p.period||'15','YYYYMMDD') and
        decode(u.sptarn, 0, nvl(n.koeff,0), 1, nvl(n.norm,0), 2,
               nvl(n.koeff,0) * nvl(n.norm,0), 3, nvl(n.koeff,0) * nvl(n.norm,0)) <> 0
        then
         0
         else --последний открытый договор по адресу имеет приоритет если все закрыты то и зашибись,
         1 end)--выйдет последний закрытый
        from kart t, nabor n, params p, usl u where
        t.lsk=n.lsk and n.usl=u.usl and n.usl=c.usl and
        ((t.polis is null and t.kul=k.kul and t.nd=k.nd and t.kw=k.kw)
        or (t.polis is not null and t.polis=k.polis)));
  commit;
end;

procedure list_lsk(kul_           in kart.kul%type,
                      nd_            in kart.nd%type,
                      kw_            in kart.kw%type,
                      prep_refcursor in out rep_refcursor) is
begin
  --¬ыборка лицевых соотв. адресу в ћ”ѕе
  open prep_refcursor for 'select k.lsk, k.fio from scott.kart@hotora k
  where k.kul=:kul_ and k.nd=:nd_ and k.kw=:kw_
   and k.psch <> 9'
    using kul_, nd_, kw_;
end;

END agent;
/

prompt
prompt Creating package body C_CHANGES
prompt ===============================
prompt
create or replace package body scott.C_CHANGES is
  PROCEDURE clear_changes_proc is
  begin
    --чистка временной таблицы начислений +добавл. стандарных услуг
    delete from list_choices_changes c;
    insert into list_choices_changes (usl_id)
      select usl from usl t;-- where t.usl_norm=0;
  end;

  PROCEDURE gen_changes_proclsk(lsk_   in c_change.lsk%type,
                                summa_ in c_change.summa%type,
                                usl_   in c_change.usl%type,
                                mg_    in c_change.mgchange%type,
                                text_ in varchar2) is
  cnt_ number;
  id_   number;
  begin
  --„“ќ Ё“ќ?
    --изменени€ по текущему Ћ.—.
    --номер нового документа
    select changes_id.nextval into id_ from dual;

    insert into c_change_docs
     (id, mgchange, dtek, ts, user_id, text)
     values
      (id_, mg_, init.get_date(), sysdate, (select u.id
           from t_user u
          where u.cd = user), text_);

    insert into c_change
      (lsk, usl, summa, proc, mgchange, org, type, dtek, ts, user_id, doc_id)
    values
      (lsk_, usl_, summa_, 0, mg_, null, case when nvl(summa_, 0) < 0 then 1 when
        nvl(summa_, 0) > 0 then 2 end, init.get_date(), sysdate, (select u.id
           from t_user u
          where u.cd = user), id_);
    cnt_:=c_charges.gen_charges(lsk_, null, null, null, 0, 0); --пересчет начислени€
    commit;
  end;

  FUNCTION test_abs_or_proc return number is
  TYPE rec_result IS RECORD (
      proc1     number,
      proc2     number,
      abs_set   number );
   rec_result_ rec_result;
  begin
    select sum(abs(c.proc1)) as proc1, sum(abs(c.proc2)) as proc2,
      sum(abs(c.abs_set)) as abs_set into rec_result_
      from list_choices_changes c;
    if rec_result_.proc1 <> 0 or rec_result_.proc2 <> 0 then
      return 0; --изменени€ по процентам
    elsif rec_result_.abs_set <> 0 then
      return 1; --изменени€ в абс суммах
    else
      return 2; --не заполнено
    end if;
  end;

PROCEDURE gen_changes_proc(lsk_start_ in c_change.lsk%type,
                            lsk_end_   in c_change.lsk%type,
                            mg_        in c_change.mgchange%type,
                            p_mg2        in c_change.mg2%type,
                            usl_add_ in number,
                            is_sch_ in number,
                            l_psch in number,
                            tst_ in number,
                            text_ in varchar2,
                            result_ out number,
                            doc_id_ out number,
                            p_kran1 in number,
                            p_status in number,
                            p_chrg in number,
                            p_kan in number,
                            p_wo_kpr in number, --отсутствие проживающих(1-да, 0, null - нет) (нулевые квартиры) по жел.  ис, 02.12.14!
                            p_lsk_tp_var in number --вариант перерасчета (0-только по основным лс., 1 - только по дополнит лс., 2 - по тем и другим)
                            )
    is
    cnt_  number;
    cnt1_ number;
    cnt_gen_  number;
    mg2_ c_change.mgchange%type;
    id_   number;
    l_part number;
    l_uid t_user.id%type;
    l_mg params.period%type;
    l_kran1 v_kart.kran1%type;
    l_hbp number; --have back period (флаг) -есть прошлый период, дл€ перерасч.
    l_hcp number; --have current period (флаг) -есть текущий период, дл€ перерасч.
    l_h_usl number; --have especial services (флаг) -есть особые услуги, дл€ перерасч.
    l_one_ls number; --флаг перерасчета только по одному л.с.
    l_wo_kpr number;
    cursor cur_list_choices
    is
    select h.id as house_id
          from list_choices_hs s, c_houses h
          where s.sel = 0 and s.kul=h.kul and s.nd=h.nd;
    rec_list_ cur_list_choices%ROWTYPE;
    l_time date;
  begin
  --установить глобальную переменную дл€ использовани€ в v_arch_kart, v_kart
  p_houses.set_g_lsk_tp(p_lsk_tp_var);
  
  l_time:=sysdate;
  --Ќеобходимо перевести систему перерасчета на usl.fk_calc_tp  18.10.2010
  result_:=0;
  l_kran1:=nvl(p_kran1,0);
  l_wo_kpr:=nvl(p_wo_kpr,0);
  if mg_ is null then
    Raise_application_error(-20001, '¬нимание! Ќе указан период изменений!');
  end if;

  if p_mg2 is null then
    --провести соответствующим периодом
    mg2_:=mg_;
    else
    mg2_:=p_mg2;
  end if;

  --id пользовател€
  select u.id into l_uid
         from t_user u
        where u.cd = user;
  --текущий период
  select period into l_mg from params p;

  if lsk_start_=lsk_end_ and lsk_start_ is not null then
   l_one_ls:=1;
  else
   l_one_ls:=0;
  end if;

  --добавл€ем св€занные услуги (х.вода + х.вода св.с.н. +канализ)
  delete from list_choices_changes c where c.type=1;

  if usl_add_ = 1 then --добавл€ть ли св€занные услуги по св.с.н.
    insert into list_choices_changes
      (usl_id, org1_id, proc1, org2_id, proc2, abs_set, mg, cnt_days, cnt_days2, type)
    select '012' as usl_id, org1_id, proc1, org2_id,
      proc2 , abs_set, cnt_days, cnt_days2, mg, 1 as type
      from list_choices_changes t
     where t.usl_id = '011'  --х.вода свыше с.н. (если есть);
    union all
    select '016' as usl_id, org1_id, proc1, org2_id,
      proc2, abs_set, cnt_days, cnt_days2, mg, 1 as type
      from list_choices_changes t
     where t.usl_id = '015' ; --г.вода св.с.н (если есть)
  end if;

  update list_choices_changes t set
   t.proc1 = round(t.cnt_days/to_char(last_day(to_date(mg_||'01', 'YYYYMMDD')),'DD')*100,2)
   where t.proc1 is null and t.cnt_days is not null;
  update list_choices_changes t set
   t.proc2 = round(t.cnt_days2/to_char(last_day(to_date(mg_||'01', 'YYYYMMDD')),'DD')*100,2)
   where t.proc2 is null and t.cnt_days2 is not null;
  update list_choices_changes t set t.mg = mg_;

  --изменени€ в процентах или абс величинах по Ћ.—. или домам
  if nvl(tst_,0) = 1 then
    --тестирование изменений на допустимость периода
    if lsk_start_ is not null and lsk_end_ is not null then
      select nvl(count(*),0) into cnt_ from v_kart k
        where mg_ between k.mg1 and k.mg2
        and k.lsk between lpad(lsk_start_, 8, '0') and lpad(lsk_end_, 8, '0');
    else
      select nvl(count(*),0) into cnt_ from v_kart k
        where mg_ between k.mg1 and k.mg2
        and exists (select * from v_kart r where
          exists (select *
            from list_choices_hs s
           where s.kul = r.kul --без –Ё”
             and s.nd = r.nd
             and s.sel = 0)
          and r.lsk=k.lsk);
    end if;

    if cnt_ = 0 then
      --ошибка, не найдены периоды по л.с.
      delete from list_choices_changes c where c.type=1;
      result_:= 2;
      return;
    else
      delete from list_choices_changes c where c.type=1;
      result_:=0;
    end if;

    if l_one_ls = 1 then
      --если перерасчет по 1 лс, выполнить проверку наличи€ организации в справочнике nabor
      --(иначе перерасчЄт тупо не вполнитс€)
      select nvl(count(*),0) into cnt_ from
      (select 1 as cnt from list_choices_changes t, params p
        where not exists (select * from nabor n where n.lsk=lsk_start_
         and n.usl=t.usl_id)
         and p.period=t.mg
         and ((nvl(t.proc1,0)<>0 or nvl(t.cnt_days,0)<>0 or nvl(t.abs_set,0)<>0)
              and nvl(t.org1_id,0)=0 or
              (nvl(t.proc2,0)<>0 or nvl(t.cnt_days2,0)<>0)
              and nvl(t.org2_id,0)=0)
       union all
       select 1 as cnt from list_choices_changes t, params p
        where not exists (select * from a_nabor n where n.lsk=lsk_start_
         and n.usl=t.usl_id
         and n.mg=t.mg)
         and p.period<>t.mg
         and ((nvl(t.proc1,0)<>0 or nvl(t.cnt_days,0)<>0 or nvl(t.abs_set,0)<>0)
              and nvl(t.org1_id,0)=0 or
              (nvl(t.proc2,0)<>0 or nvl(t.cnt_days2,0)<>0)
              and nvl(t.org2_id,0)=0));

      if cnt_ <> 0 then
        --вернуть ошибку, что нужно проставить организации
        result_:=3;
        return;
      end if;
    end if;

  return;
  end if;

  --номер нового документа
  select changes_id.nextval into id_ from dual;

  insert into c_change_docs
     (id, mgchange, mg2, dtek, ts, user_id, text)
     values
      (id_, mg_, mg2_, init.get_date(), sysdate, (select u.id
           from t_user u
          where u.cd = user), text_);
  doc_id_:=id_;

    --узнать, есть ли прошлые периоды, дл€ упрощени€ запросов
    select nvl(max(case when t.mg = l_mg then 1 else 0 end),0),
           nvl(max(case when t.mg <> l_mg then 1 else 0 end),0)
      into l_hcp, l_hbp
      from list_choices_changes t;

    select count(distinct lsk)
      into cnt_
      from c_change t
     where t.user_id =
           (select u.id from t_user u where u.cd = user)
       and t.doc_id = id_;

  -- генераци€ предварительного начислени€ (что бы было от чего считать скидки, может не быть начислени€ в c_charge)
  --имеет смысл, если указан текущий период дл€ перерасчетов
  if l_hcp = 1 then
    if lsk_start_ is not null and lsk_end_ is not null then
   --генерим начисление по этим лицевым
      cnt_gen_:=c_charges.gen_charges(lsk_start_, lsk_end_, null, null, 0, 0);
    else
   --генерим начисление по этому дому
     open cur_list_choices;
     loop
       fetch cur_list_choices into rec_list_;
       exit when cur_list_choices%notfound;
        cnt_gen_:=c_charges.gen_charges(null, null, rec_list_.house_id, null, 0, 0);
     end loop;
     close cur_list_choices;
    end if;
  end if;

  logger.log_(l_time, 'ѕерерасчет : c_changes.gen_changes_proc: предварительное начисление');
  l_time:=sysdate;

--Temporary table!!!
delete from temp_c_change2;
--Raise_application_error(-20000, is_sch_);
if lsk_start_ is not null and lsk_end_ is not null then
  --по лицевым
  --две доли
  l_part:=0;
  loop
  if l_mg=mg_ then
  --текущий период
    insert into temp_c_change2
      (lsk, usl, org, proc, abs_set, mg, tp,
       cnt_days)
      select k.lsk, t.usl_id, decode(l_part,0,t.org1_id,t.org2_id) as org,
        decode(l_part,0,t.proc1,t.proc2) as proc, decode(l_part,0,t.abs_set, null),
        t.mg, t.type, t.cnt_days
        from v_kart k, list_choices_changes t, usl u
       where k.lsk between lpad(lsk_start_, 8, '0') and lpad(lsk_end_, 8, '0')
         and t.mg between k.mg1 and k.mg2
         and (l_psch = 0 or l_psch=1 and k.psch in (8,9)
         or l_psch=2 and k.psch not in (8,9))
         and t.usl_id=u.usl
         and (l_wo_kpr=1 and k.kpr=0 or l_wo_kpr=0) 
         and (l_kran1 = 1
                and exists (select * from v_kart s2 where s2.lsk=k.lsk and
                  k.kran1 <> 0)
                  or l_kran1 = 2
                  and exists (select * from v_kart s2 where s2.lsk=k.lsk and
                  nvl(k.kran1,0) = 0)
                  or l_kran1 = 0)
              and exists (select * from v_kart s2 where s2.lsk=k.lsk and
                          (p_status = 0 or p_status = s2.status) and
                           case when is_sch_ in (2) and u.cd in ('х.вода', 'х.вода/св.нор', 'х.вода.ќƒЌ', 'х.в. ќƒЌ, 0 зарег')/* m.counter='phw' */and s2.psch in (1,2) then 1 --только сч.
                          when is_sch_ in (2) and u.cd in ('г.вода', 'г.вода/св.нор','г.вода.ќƒЌ','г.в. ќƒЌ, 0 зарег') /*and m.counter='pgw'*/ and s2.psch in (1,3) then 1
                          when is_sch_ in (2) and u.cd in ('эл.энерг.2','эл.эн.2/св.нор') /*and m.counter='pel'*/ and s2.sch_el = 1 then 1
                          when is_sch_ in (0) and u.cd in ('х.вода', 'х.вода/св.нор', 'х.вода.ќƒЌ', 'х.в. ќƒЌ, 0 зарег') and s2.psch in (0,3) then 1 --без сч.
                          when is_sch_ in (0) and u.cd in ('г.вода', 'г.вода/св.нор','г.вода.ќƒЌ','г.в. ќƒЌ, 0 зарег') and s2.psch in (0,2) then 1
                          when is_sch_ in (0) and u.cd in ('эл.энерг.2','эл.эн.2/св.нор') and s2.sch_el = 0 then 1
                          when is_sch_ in (1) and u.cd in ('х.вода', 'х.вода/св.нор', 'х.вода.ќƒЌ', 'х.в. ќƒЌ, 0 зарег', 'г.вода', 'г.вода/св.нор','г.вода.ќƒЌ','г.в. ќƒЌ, 0 зарег') then 1 --в т.ч. со сч.
                          when is_sch_ in (1) and u.cd in ('эл.энерг.2','эл.эн.2/св.нор') then 1
                          --when m.counter is null then 1
                          when l_psch<> 1 and u.cd not in ('х.вода', 'х.вода/св.нор', 'х.вода.ќƒЌ', 'х.в. ќƒЌ, 0 зарег', 'г.вода', 'г.вода/св.нор','г.вода.ќƒЌ','г.в. ќƒЌ, 0 зарег','эл.энерг.2','эл.эн.2/св.нор') then 1
                          when l_psch=1 then 1 --по закрытым л.с. производить по всем типам счетчиков
                          else 0 end = 1);
    else
      --архивный период
    insert into temp_c_change2
      (lsk, usl, org, proc, abs_set, mg, tp,
       cnt_days)
      select k.lsk, t.usl_id, decode(l_part,0,t.org1_id,t.org2_id) as org,
        decode(l_part,0,t.proc1,t.proc2) as proc, decode(l_part,0,t.abs_set, null),
        t.mg, t.type, t.cnt_days
        from v_arch_kart k, list_choices_changes t, usl u,
        (select s.uslm, s.counter from usl s where s.counter is not null) m
       where k.lsk between lpad(lsk_start_, 8, '0') and lpad(lsk_end_, 8, '0')
         and k.mg=mg_
         and t.mg between k.mg1 and k.mg2
         and (l_psch = 0 or l_psch=1 and k.psch in (8,9)
         or l_psch=2 and k.psch not in (8,9))
         and t.usl_id=u.usl
         and u.uslm=m.uslm(+)
         and (l_wo_kpr=1 and k.kpr=0 or l_wo_kpr=0) 
         and (l_kran1 = 1
                and exists (select * from v_arch_kart s2 where s2.lsk=k.lsk and s2.mg=mg_ and
                  k.kran1 <> 0)
                  or l_kran1 = 2
                  and exists (select * from v_arch_kart s2 where s2.lsk=k.lsk and s2.mg=mg_ and
                  nvl(k.kran1,0) = 0)
                  or l_kran1 = 0)
              and exists (select * from v_arch_kart s2 where s2.lsk=k.lsk and s2.mg=mg_ and
                          (p_status = 0 or p_status = s2.status) and
                           case when is_sch_ in (2) and u.cd in ('х.вода', 'х.вода/св.нор', 'х.вода.ќƒЌ', 'х.в. ќƒЌ, 0 зарег')/* m.counter='phw' */and s2.psch in (1,2) then 1 --только сч.
                          when is_sch_ in (2) and u.cd in ('г.вода', 'г.вода/св.нор','г.вода.ќƒЌ','г.в. ќƒЌ, 0 зарег') /*and m.counter='pgw'*/ and s2.psch in (1,3) then 1
                          when is_sch_ in (2) and u.cd in ('эл.энерг.2','эл.эн.2/св.нор') /*and m.counter='pel'*/ and s2.sch_el = 1 then 1
                          when is_sch_ in (0) and u.cd in ('х.вода', 'х.вода/св.нор', 'х.вода.ќƒЌ', 'х.в. ќƒЌ, 0 зарег') and s2.psch in (0,3) then 1 --без сч.
                          when is_sch_ in (0) and u.cd in ('г.вода', 'г.вода/св.нор','г.вода.ќƒЌ','г.в. ќƒЌ, 0 зарег') and s2.psch in (0,2) then 1
                          when is_sch_ in (0) and u.cd in ('эл.энерг.2','эл.эн.2/св.нор') and s2.sch_el = 0 then 1
                          when is_sch_ in (1) and u.cd in ('х.вода', 'х.вода/св.нор', 'х.вода.ќƒЌ', 'х.в. ќƒЌ, 0 зарег', 'г.вода', 'г.вода/св.нор','г.вода.ќƒЌ','г.в. ќƒЌ, 0 зарег') then 1 --в т.ч. со сч.
                          when is_sch_ in (1) and u.cd in ('эл.энерг.2','эл.эн.2/св.нор') then 1
                          --when m.counter is null then 1
                          when l_psch<> 1 and u.cd not in ('х.вода', 'х.вода/св.нор', 'х.вода.ќƒЌ', 'х.в. ќƒЌ, 0 зарег', 'г.вода', 'г.вода/св.нор','г.вода.ќƒЌ','г.в. ќƒЌ, 0 зарег','эл.энерг.2','эл.эн.2/св.нор') then 1
                          when l_psch=1 then 1 --по закрытым л.с. производить по всем типам счетчиков
                          else 0 end = 1);

/*                           case when is_sch_ in (2) and m.counter='phw' and s2.psch in (1,2) then 1 --только сч.
                          when is_sch_ in (2) and m.counter='pgw' and s2.psch in (1,3) then 1
                          when is_sch_ in (2) and m.counter='pel' and s2.sch_el = 1 then 1
                          when is_sch_ in (0) and m.counter='phw' and s2.psch in (0,3) then 1 --без сч.
                          when is_sch_ in (0) and m.counter='pgw' and s2.psch in (0,2) then 1
                          when is_sch_ in (0) and m.counter='pel' and s2.sch_el = 0 then 1
                          when is_sch_ in (1) and m.counter in ('phw','pgw') then 1 --в т.ч. со сч.
                          when is_sch_ in (1) and m.counter='pel' then 1
                          when m.counter is null then 1
                          when l_psch=1 then 1 --по закрытым л.с. производить по всем типам счетчиков
                          else 0 end = 1);*/
if sql%rowcount = 0 then                          
  Raise_application_error(-20000, 'test1');
end if;
    end if;                      
                         
    exit when l_part=1;
    l_part:=l_part+1;

  end loop;
else
    --по домам
    --две доли
  l_part:=0;
  loop
    for c in (select *
                from list_choices_hs s
                where s.sel = 0)
    loop
    if l_mg=mg_ then
    --текущий период
    insert into temp_c_change2
      (lsk, usl, org, proc, abs_set, mg, tp,
       cnt_days)
      select k.lsk, t.usl_id, decode(l_part,0,t.org1_id,t.org2_id) as org,
       decode(l_part,0,t.proc1,t.proc2) as proc,
             decode(l_part,0,t.abs_set, null), t.mg, t.type, t.cnt_days
        from v_kart k, list_choices_changes t, usl u
       where t.mg between k.mg1 and k.mg2
              and (l_psch = 0 or l_psch=1 and k.psch in (8,9)
              or l_psch=2 and k.psch not in (8,9))
              and t.usl_id=u.usl
              and k.kul = c.kul
              and k.nd = c.nd
              and (l_wo_kpr=1 and k.kpr=0 or l_wo_kpr=0) 
              and (l_kran1 = 1
              and exists (select * from v_kart s2 where s2.lsk=k.lsk and
                  k.kran1 <> 0)
                  or l_kran1 = 2
                  and exists (select * from v_kart s2 where s2.lsk=k.lsk and
                  nvl(k.kran1,0) = 0)
                  or l_kran1 = 0)
                and exists (select * from v_kart s2 where s2.lsk=k.lsk and
                          (p_status = 0 or p_status = s2.status) and
                           case when is_sch_ in (2) and u.cd in ('х.вода', 'х.вода/св.нор', 'х.вода.ќƒЌ', 'х.в. ќƒЌ, 0 зарег')/* m.counter='phw' */and s2.psch in (1,2) then 1 --только сч.
                          when is_sch_ in (2) and u.cd in ('г.вода', 'г.вода/св.нор','г.вода.ќƒЌ','г.в. ќƒЌ, 0 зарег') /*and m.counter='pgw'*/ and s2.psch in (1,3) then 1
                          when is_sch_ in (2) and u.cd in ('эл.энерг.2','эл.эн.2/св.нор') /*and m.counter='pel'*/ and s2.sch_el = 1 then 1
                          when is_sch_ in (0) and u.cd in ('х.вода', 'х.вода/св.нор', 'х.вода.ќƒЌ', 'х.в. ќƒЌ, 0 зарег') and s2.psch in (0,3) then 1 --без сч.
                          when is_sch_ in (0) and u.cd in ('г.вода', 'г.вода/св.нор','г.вода.ќƒЌ','г.в. ќƒЌ, 0 зарег') and s2.psch in (0,2) then 1
                          when is_sch_ in (0) and u.cd in ('эл.энерг.2','эл.эн.2/св.нор') and s2.sch_el = 0 then 1
                          when is_sch_ in (1) and u.cd in ('х.вода', 'х.вода/св.нор', 'х.вода.ќƒЌ', 'х.в. ќƒЌ, 0 зарег', 'г.вода', 'г.вода/св.нор','г.вода.ќƒЌ','г.в. ќƒЌ, 0 зарег') then 1 --в т.ч. со сч.
                          when is_sch_ in (1) and u.cd in ('эл.энерг.2','эл.эн.2/св.нор') then 1
                          --when m.counter is null then 1
                          when l_psch<> 1 and u.cd not in ('х.вода', 'х.вода/св.нор', 'х.вода.ќƒЌ', 'х.в. ќƒЌ, 0 зарег', 'г.вода', 'г.вода/св.нор','г.вода.ќƒЌ','г.в. ќƒЌ, 0 зарег','эл.энерг.2','эл.эн.2/св.нор') then 1
                          when l_psch=1 then 1 --по закрытым л.с. производить по всем типам счетчиков
                          else 0 end = 1);
    else
      --архивный период
    insert into temp_c_change2
      (lsk, usl, org, proc, abs_set, mg, tp,
       cnt_days)
      select k.lsk, t.usl_id, decode(l_part,0,t.org1_id,t.org2_id) as org,
       decode(l_part,0,t.proc1,t.proc2) as proc,
             decode(l_part,0,t.abs_set, null), t.mg, t.type, t.cnt_days
        from v_arch_kart k, list_choices_changes t, usl u
       where k.mg=mg_ and t.mg between k.mg1 and k.mg2
              and (l_psch = 0 or l_psch=1 and k.psch in (8,9)
              or l_psch=2 and k.psch not in (8,9))
              and t.usl_id=u.usl
              and k.kul = c.kul
              and k.nd = c.nd
              and (l_wo_kpr=1 and k.kpr=0 or l_wo_kpr=0) 
              and (l_kran1 = 1
              and exists (select * from v_arch_kart s2 where s2.lsk=k.lsk and s2.mg=mg_ and
                  k.kran1 <> 0)
                  or l_kran1 = 2
                  and exists (select * from v_arch_kart s2 where s2.lsk=k.lsk and s2.mg=mg_ and
                  nvl(k.kran1,0) = 0)
                  or l_kran1 = 0)
                and exists (select * from v_arch_kart s2 where s2.lsk=k.lsk and s2.mg=mg_ and
                          (p_status = 0 or p_status = s2.status) and
                           case when is_sch_ in (2) and u.cd in ('х.вода', 'х.вода/св.нор', 'х.вода.ќƒЌ', 'х.в. ќƒЌ, 0 зарег')/* m.counter='phw' */and s2.psch in (1,2) then 1 --только сч.
                          when is_sch_ in (2) and u.cd in ('г.вода', 'г.вода/св.нор','г.вода.ќƒЌ','г.в. ќƒЌ, 0 зарег') /*and m.counter='pgw'*/ and s2.psch in (1,3) then 1
                          when is_sch_ in (2) and u.cd in ('эл.энерг.2','эл.эн.2/св.нор') /*and m.counter='pel'*/ and s2.sch_el = 1 then 1
                          when is_sch_ in (0) and u.cd in ('х.вода', 'х.вода/св.нор', 'х.вода.ќƒЌ', 'х.в. ќƒЌ, 0 зарег') and s2.psch in (0,3) then 1 --без сч.
                          when is_sch_ in (0) and u.cd in ('г.вода', 'г.вода/св.нор','г.вода.ќƒЌ','г.в. ќƒЌ, 0 зарег') and s2.psch in (0,2) then 1
                          when is_sch_ in (0) and u.cd in ('эл.энерг.2','эл.эн.2/св.нор') and s2.sch_el = 0 then 1
                          when is_sch_ in (1) and u.cd in ('х.вода', 'х.вода/св.нор', 'х.вода.ќƒЌ', 'х.в. ќƒЌ, 0 зарег', 'г.вода', 'г.вода/св.нор','г.вода.ќƒЌ','г.в. ќƒЌ, 0 зарег') then 1 --в т.ч. со сч.
                          when is_sch_ in (1) and u.cd in ('эл.энерг.2','эл.эн.2/св.нор') then 1
                          --when m.counter is null then 1
                          when l_psch<> 1 and u.cd not in ('х.вода', 'х.вода/св.нор', 'х.вода.ќƒЌ', 'х.в. ќƒЌ, 0 зарег', 'г.вода', 'г.вода/св.нор','г.вода.ќƒЌ','г.в. ќƒЌ, 0 зарег','эл.энерг.2','эл.эн.2/св.нор') then 1
                          when l_psch=1 then 1 --по закрытым л.с. производить по всем типам счетчиков
                          else 0 end = 1);
    end if;      
    --по каждому дому коммит, да, да! (иначе тормозит глухо, когда много домов)
    commit;
    end loop;
    exit when l_part=1;
    l_part:=l_part+1;
  end loop;
end if;

  logger.log_(l_time, 'ѕерерасчет : c_changes.gen_changes_proc: добавлено в temp_c_change2');
  l_time:=sysdate;

--установить uslm
update temp_c_change2 t set t.uslm = (select u.uslm from usl u where t.usl=u.usl);

--отправить текущее начисление по лицевым счетам в архив
--(чтобы запрос выполн€лс€ только по a_charge , без union all)
delete from a_charge a
 where a.mg = l_mg
 and exists (select * from temp_c_change2 t where t.lsk=a.lsk);
insert into a_charge
  (lsk,
   usl,
   summa,
   kart_pr_id,
   spk_id,
   type,
   test_opl,
   test_cena,
   test_tarkoef,
   test_spk_koef,
   main,
   lg_doc_id,
   npp,
   sch,
   mg)
  select c.lsk,
         c.usl,
         c.summa,
         c.kart_pr_id,
         c.spk_id,
         c.type,
         c.test_opl,
         c.test_cena,
         c.test_tarkoef,
         c.test_spk_koef,
         c.main,
         c.lg_doc_id,
         c.npp,
         c.sch,
         l_mg
    from c_charge c
   where exists (select * from temp_c_change2 t where t.lsk = c.lsk);

  select nvl(count(*),0) into l_h_usl from list_choices_changes s, usl u where
    s.usl_id=u.usl
    and u.cd in ('х.вода', 'х.вода/св.нор', 'г.вода', 'г.вода/св.нор',
    'х.вода.ќƒЌ','г.вода.ќƒЌ');
  --промежуточный коммит -чтоб не тормозило)
  commit;

  logger.log_(l_time, 'ѕерерасчет : c_changes.gen_changes_proc: промежуточный коммит');
  l_time:=sysdate;

--изменени€ начислений в % отношении
--блок “ќЋ№ ќ дл€ перерасчета канализовани€ по проведенному перерасчету по основной услуге
-- анализование пересчитаетс€ в случае, если был перерасчет в процентах по воде и
--если это затребовано на форме
if l_h_usl > 0 and p_kan=1 then
  l_part:=0;
  loop
    for c in (select t.lsk, t.org, t.proc, t.mg, d.usl, d.summa,
       a.summa/b.summa as proc_kan, --дол€ услуги в канализовании (отношение объемов)
       round(t.proc * a.summa/b.summa,3) as proc_itg
         from temp_c_change2 t, usl m,
      (select u.usl, t.mg, t.lsk, sum(t.test_opl) as summa
      from a_charge t, usl u
      where t.type=1         --объем услуги
      and t.usl=u.usl
      and exists (select * from temp_c_change2 i where i.lsk=t.lsk)
      group by u.usl, t.mg, t.lsk) a,
      (select t.mg, t.lsk, sum(t.test_opl) as summa
      from a_charge t, usl u --объем канализ
      where t.type=1 and t.usl=u.usl
        and exists (select * from temp_c_change2 i where i.lsk=t.lsk)
        and (l_part=0 and u.cd in ('канализ', 'канализ/св.нор')
        or l_part=1 and u.cd in ('канализ.ќƒЌ'))

      group by t.mg, t.lsk) b,
      (select t.usl, t.mg, t.lsk, sum(t.summa) as summa
      from a_charge t, usl u --начисление канализ, детализир
      where t.type=1 and t.usl=u.usl
        and exists (select * from temp_c_change2 i where i.lsk=t.lsk)
        and (l_part=0 and u.cd in ('канализ', 'канализ/св.нор')
        or l_part=1 and u.cd in ('канализ.ќƒЌ'))
      group by t.usl, t.mg, t.lsk) d
      where t.usl = m.usl
                    

      and (l_mg=mg_ and exists (select * from v_kart k where k.lsk=t.lsk and k.status not in (9) and (l_wo_kpr=1 and k.kpr=0 or l_wo_kpr=0)) --кроме нежилых помещений, текущий или архивный период!
       or l_mg<>mg_ and exists (select * from v_arch_kart k where k.lsk=t.lsk and k.status not in (9) and (l_wo_kpr=1 and k.kpr=0 or l_wo_kpr=0) and k.mg=mg_))  --жесть вообще писать exists через OR ред 02.12.14
       --кроме нежилых помещений
      and (l_part=0 and m.cd in ('х.вода', 'х.вода/св.нор', 'г.вода', 'г.вода/св.нор')
      or l_part=1 and m.cd in ('х.вода.ќƒЌ','г.вода.ќƒЌ'))
      and t.lsk=a.lsk(+) and t.mg=a.mg(+) and t.usl=a.usl(+)
      and t.lsk=b.lsk(+) and t.mg=b.mg(+)
      and t.lsk=d.lsk(+) and t.mg=d.mg(+)
      and t.proc <> 0 -- в % отношении
      and nvl(b.summa,0) <> 0 --где есть вообще объем по канализ
      and nvl(a.summa,0) <> 0 --где есть вообще объем по основной услуге
      )
    loop
      insert into c_change
              (lsk, mgchange, mg2, usl, proc, summa, org, type, dtek, ts, user_id, doc_id)
      values (c.lsk, mg2_, c.mg, c.usl, c.proc_itg, round(c.proc_itg/100 * c.summa,2),
       c.org, 0, init.get_date, sysdate, l_uid, id_);

    end loop;
    exit when l_part=1;
    l_part:=l_part+1;
  end loop;
  logger.log_(l_time, 'ѕерерасчет : c_changes.gen_changes_proc: добав. водоотведение');
  l_time:=sysdate;

end if;


--перерасчет по основным услугам, в % отношении
if l_hbp = 1 then
  --если есть прошлый период, дл€ пересчета
  insert into c_change
          (lsk, mgchange, mg2, usl, proc, summa, org, type, dtek, ts, user_id, doc_id)
  select t.lsk, mg2_, t.mg, t.usl, t.proc, t.proc/100 * a.summa as summa,
    t.org, 0 as type, init.get_date, sysdate, l_uid, id_
       from temp_c_change2 t, usl m,
    (select t.usl, t.mg, t.lsk, sum(t.summa) as summa
    from a_charge t --начисление услуги, детализир
    where t.type=1
    and exists (select * from temp_c_change2 i where i.lsk=t.lsk)
    group by t.usl, t.mg, t.lsk) a
    where t.usl = m.usl
    and t.lsk=a.lsk(+) and t.mg=a.mg(+) and t.usl=a.usl(+)
    and t.proc <> 0 -- в % отношении
    and nvl(a.summa,0) <> 0;
end if;

if l_hcp = 1 then
  --если есть текущий период, дл€ пересчета
  insert into c_change
          (lsk, mgchange, mg2, usl, proc, summa, org, type, dtek, ts, user_id, doc_id)
  select t.lsk, mg2_, t.mg, t.usl, t.proc, t.proc/100 * a.summa as summa,
    t.org, 0 as type, init.get_date, sysdate, l_uid, id_
       from temp_c_change2 t, usl m,
    (select t.usl, t.lsk, sum(t.summa) as summa
    from c_charge t --начисление услуги, детализир
    where t.type=1
    group by t.usl, t.lsk) a
    where t.usl = m.usl
    and t.lsk=a.lsk(+) and t.usl=a.usl(+)
    and t.proc <> 0 -- в % отношении
    and nvl(a.summa,0) <> 0--текущий период
    ; --где есть вообще объем по основной услуге
end if;

 --абсолютные значени€ изменений
insert into c_change
        (lsk, mgchange, mg2, usl, proc, summa, org, type, dtek, ts, user_id, doc_id)
        select n.lsk, mg2_, t.mg, t.usl, 0, nvl(abs_set, 0) as summa,
           nvl(t.org, n.org) as org,case
                 when nvl(t.abs_set, 0) < 0 then
                  1
                 when nvl(t.abs_set, 0) > 0 then
                  2
                 else
                  0
               end as type, init.get_date, sysdate, l_uid, id_
          from temp_c_change2 t, nabor n, params p
         where t.mg >=p.period
         and t.usl = n.usl and t.org is null --если новые будущие периоды и не указана €вно орг - ставим код орг из текущ.справочника
         and nvl(t.abs_set, 0) <> 0
         and t.lsk=n.lsk;

insert into c_change
        (lsk, mgchange, mg2, usl, proc, summa, org, type, dtek, ts, user_id, doc_id)
        select n.lsk, mg2_, t.mg, t.usl, 0, nvl(abs_set, 0) as summa,
           nvl(t.org, n.org) as org,case
                 when nvl(t.abs_set, 0) < 0 then
                  1
                 when nvl(t.abs_set, 0) > 0 then
                  2
                 else
                  0
               end as type, init.get_date, sysdate, l_uid, id_
          from temp_c_change2 t, a_nabor n, params p
         where t.mg < p.period
         and t.mg=n.mg --если старые периоды и не указана €вно орг - ставим код орг из арх.справочника
         and t.usl = n.usl and t.org is null
         and nvl(t.abs_set, 0) <> 0
         and t.lsk=n.lsk;

insert into c_change
        (lsk, mgchange, mg2, usl, proc, summa, org, type, dtek, ts, user_id, doc_id)
        select t.lsk, mg2_, t.mg, t.usl, 0, nvl(abs_set, 0) as summa,
           nvl(t.org, null) as org,case
                 when nvl(t.abs_set, 0) < 0 then
                  1
                 when nvl(t.abs_set, 0) > 0 then
                  2
                 else
                  0
               end as type, init.get_date, sysdate, l_uid, id_
          from temp_c_change2 t, params p
         where t.org is not null --если любые периоды и указана €вно орг - ставим кака€ указана
         and nvl(t.abs_set, 0) <> 0;

  select count(distinct lsk)
    into cnt1_
    from c_change t
   where t.user_id =
         (select u.id from t_user u where u.cd = user)
     and t.doc_id = id_;

  --промежуточный коммит -чтоб не тормозило)
  commit;

  logger.log_(l_time, 'ѕерерасчет : c_changes.gen_changes_proc: добав. c_changes');
  l_time:=sysdate;

  if p_chrg = 1 then
    --задано генерить финальное начисление
    if lsk_start_ is not null and lsk_end_ is not null then
   --генерим начисление по этим лицевым
      cnt_gen_:=c_charges.gen_charges(lsk_start_, lsk_end_, null, null, 0, 0);
    else
   --генерим начисление по этому дому
     open cur_list_choices;
     loop
       fetch cur_list_choices into rec_list_;
       exit when cur_list_choices%notfound;
        cnt_gen_:=c_charges.gen_charges(null, null, rec_list_.house_id, null, 0, 0);
     end loop;
     close cur_list_choices;

    end if;
  end if;

  delete from list_choices_changes c where c.type=1;
  result_:=nvl(cnt1_, 0) - nvl(cnt_, 0);
  --перерасчЄт не был сделан
  if result_ = 0 then
    return;
  else
    commit;
  end if;
  logger.log_(l_time, 'ѕерерасчет выполнен: c_changes.gen_changes_proc id='||id_);
  return;
end;


--выполнение корректировки оплаты, пени
procedure gen_pay_corrects(src_usl_ in usl.usl%type,
    src_org_ in t_org.id%type,
    dst_usl_ in usl.usl%type,
    dst_org_ in t_org.id%type,
    reu_ in t_org.reu%type,
    p_tp in number) is
  l_dt1 date; l_dt2 date;    
begin
 l_dt1:=init.get_dt_start;
 l_dt2:=init.get_dt_end;
 update kwtp_day t set t.usl=nvl(dst_usl_, t.usl), t.org=decode(dst_org_, -1, t.org, dst_org_)
   where t.dtek between l_dt1 and l_dt2 and
   t.usl=src_usl_ and t.org=src_org_ and t.priznak=decode(p_tp,1,1,2,0) --оплата или пен€
   and exists (select * from kart k where 
     t.lsk=k.lsk and
     k.reu =nvl(reu_, k.reu)); 
 commit;
end;    


--выполнение корректировки сальдо
procedure gen_corrects(src_usl_ in usl.usl%type,
    src_org_ in t_org.id%type,
    dst_usl_ in usl.usl%type,
    dst_org_ in t_org.id%type,
    reu_ in t_org.reu%type,
    text_ in c_change_docs.text%type) is
id_ t_corrects_payments.id%type;
fk_doc_ c_change_docs.id%type;
mg_ c_change_docs.mgchange%type;
user_id_ c_change_docs.user_id%type;
begin
--текущий период
select p.period into mg_ from params p;
select u.id into user_id_
           from t_user u
          where u.cd = user;
select nvl(max(t.id),0)+1 into id_ from t_corrects_payments t
 where t.mg=mg_;

insert into c_change_docs
  (mgchange, dtek, ts, text)
  values (mg_, init.get_date, sysdate, text_)
  returning id into fk_doc_;

insert into t_corrects_payments
  (lsk, usl, org, summa, user_id, dat, mg, dopl, id, fk_doc)
 select s.lsk, s.usl, s.org, summa, user_id_, init.get_date, mg_, mg_, id_, fk_doc_
  from saldo_usl s, kart k, t_org o, params p
   where s.mg=p.period and
   s.usl=src_usl_ and s.org=src_org_ and
   s.lsk=k.lsk and k.reu=o.reu and
   (reu_ is null or o.reu=reu_ and reu_ is not null) ;

insert into t_corrects_payments
  (lsk, usl, org, summa, user_id, dat, mg, dopl, id, fk_doc)
 select s.lsk, nvl(dst_usl_, s.usl) as usl, decode(dst_org_, -1, s.org, dst_org_) as org, -1*summa, user_id_, init.get_date, mg_, mg_, id_, fk_doc_
  from saldo_usl s, kart k, t_org o, params p
   where s.mg=p.period and
   s.usl=src_usl_ and s.org=src_org_ and
   s.lsk=k.lsk and k.reu=o.reu and
   (reu_ is null or o.reu=reu_ and reu_ is not null) ;
commit;
end;

procedure del_chng_doc(id_ in c_change_docs.id%type) is
begin
--удаление разовых изменений (документа в целом)
  delete from c_change t where t.doc_id=id_;
  delete from c_change_docs t where t.id=id_;
commit;
end;

procedure del_chng(id_ in c_change.id%type) is
begin
--удаление разовых изменений (строки)
  delete from c_change t where t.id=id_;
commit;
end;

procedure del_corr(fk_doc_ in c_change_docs.id%type) is
begin
--удаление корректировок
delete from t_corrects_payments t
 where t.mg=(select p.period from params p)
  and t.fk_doc=fk_doc_;
commit;
end;


end C_CHANGES;
/

prompt
prompt Creating package body C_CHARGES
prompt ===============================
prompt
CREATE OR REPLACE PACKAGE BODY SCOTT.c_charges IS

  TYPE rec_kpr IS RECORD(
    kpr    kart.kpr%TYPE,
    kpr_ot kart.kpr_ot%TYPE,
    kpr_wr kart.kpr_ot%TYPE);

  FUNCTION get_upd_tab RETURN tab_rec_states
    PARALLEL_ENABLE
    PIPELINED IS
  BEGIN
    --функци€ пока не используетс€ (не нашла применение) 29.04.2011
    FOR element IN 1 .. c_charges.tb_rec_states.count LOOP
  --    PIPE ROW(c_charges.tb_rec_states(element));
  null;
    END LOOP;
    RETURN;
  END;

  FUNCTION gen_charges_sch(lsk_ VARCHAR2,
                           usl_ IN usl.usl%TYPE,
                           var_ IN NUMBER,
                           cnt_ IN NUMBER) RETURN NUMBER IS
    --  PRAGMA AUTONOMOUS_TRANSACTION;
    cnt2_     NUMBER;
    sum_chrg_ NUMBER;
    cursor c is
    --дл€ основной услуги
    SELECT u.cd, u.usl_p, u.usl_empt
      FROM usl u WHERE u.usl = usl_;
    rec_usl c%ROWTYPE;
    --дл€ канализовани€
    cursor c2 is
    SELECT u.cd, u2.cd as cd2, u3.cd as cd3
      FROM usl u, usl u2, usl u3 WHERE u.cd = 'канализ'
       and u.usl_p=u2.usl(+) and u.usl_empt=u3.usl(+)
      ;
    rec_usl2 c2%ROWTYPE;

  BEGIN
    open c;
    loop
      fetch c into rec_usl;
      exit when c%notfound;

    end loop;
    close c;

    open c2;
    loop
      fetch c2 into rec_usl2;
      exit when c2%notfound;

    end loop;
    close c2;

    IF var_ = 0 THEN
    --просто узнать текущие показани€ счетчика
      IF rec_usl.cd = 'х.вода' THEN
        --последние показани€ по х.воде (обраб в триггере)
        SELECT k.phw
        INTO   cnt2_
        FROM   kart k
        WHERE  k.lsk = lpad(lsk_, 8, '0');
      ELSIF rec_usl.cd = 'г.вода' THEN
        --последние показани€ по г.воде (обраб в триггере)
        SELECT k.pgw
        INTO   cnt2_
        FROM   kart k
        WHERE  k.lsk = lpad(lsk_, 8, '0');
      ELSIF rec_usl.cd = 'эл.энерг.2' THEN
        --последние показани€ по эл.эн. (обраб в триггере)
        SELECT k.pel
        INTO   cnt2_
        FROM   kart k
        WHERE  k.lsk = lpad(lsk_, 8, '0');
      END IF;
      RETURN cnt2_;
    ELSE
      --установить текущие показани€ счетчика и расчитать начисление

      --начисление до ввода кубов
      cnt2_ := gen_charges(lpad(lsk_, 8, '0'),
                           lpad(lsk_, 8, '0'),
                           NULL,
                           NULL,
                           0,
                           0);
      IF rec_usl.cd IN ('х.вода', 'г.вода') THEN
        SELECT nvl(SUM(summa), 0)
        INTO   sum_chrg_
        FROM   (SELECT summa
                 FROM   c_charge c
                 WHERE  c.lsk = lpad(lsk_, 8, '0')
                 AND    c.usl = usl_
                 AND    c.type = 1
                 UNION ALL
                 SELECT summa * -1
                 FROM   c_charge c
                 WHERE  c.lsk = lpad(lsk_, 8, '0')
                 AND    c.usl = usl_
                 AND    c.type = 2
                 UNION ALL
                 SELECT summa * -1
                 FROM   c_charge c
                 WHERE  c.lsk = lpad(lsk_, 8, '0')
                 AND    c.usl = usl_
                 AND    c.type = 4
                 --свыше с.н.
                 UNION ALL
                 SELECT summa
                 FROM   c_charge c
                 WHERE  c.lsk = lpad(lsk_, 8, '0')
                 AND    c.usl = rec_usl.usl_p
                 AND    c.type = 1
                 UNION ALL
                 SELECT summa * -1
                 FROM   c_charge c
                 WHERE  c.lsk = lpad(lsk_, 8, '0')
                 AND    c.usl = rec_usl.usl_p
                 AND    c.type = 2
                 UNION ALL
                 SELECT summa * -1
                 FROM   c_charge c
                 WHERE  c.lsk = lpad(lsk_, 8, '0')
                 AND    c.usl = rec_usl.usl_p
                 AND    c.type = 4
                 --без проживающих
                 UNION ALL
                 SELECT summa
                 FROM   c_charge c
                 WHERE  c.lsk = lpad(lsk_, 8, '0')
                 AND    c.usl = rec_usl.usl_empt
                 AND    c.type = 1
                 UNION ALL
                 SELECT summa * -1
                 FROM   c_charge c
                 WHERE  c.lsk = lpad(lsk_, 8, '0')
                 AND    c.usl = rec_usl.usl_empt
                 AND    c.type = 2
                 UNION ALL
                 SELECT summa * -1
                 FROM   c_charge c
                 WHERE  c.lsk = lpad(lsk_, 8, '0')
                 AND    c.usl = rec_usl.usl_empt
                 AND    c.type = 4
                 --канализ.
                 UNION ALL
                 SELECT summa
                 FROM   c_charge c, usl u
                 WHERE  c.lsk = lpad(lsk_, 8, '0')
                 AND    c.usl=u.usl
                 and    u.cd in (rec_usl2.cd, rec_usl2.cd2, rec_usl2.cd3)
                 AND    c.type = 1
                 UNION ALL
                 SELECT summa * -1
                 FROM   c_charge c, usl u
                 WHERE  c.lsk = lpad(lsk_, 8, '0')
                 AND    c.usl=u.usl
                 and    u.cd in (rec_usl2.cd, rec_usl2.cd2, rec_usl2.cd3)
                 AND    c.type = 2
                 UNION ALL
                 SELECT summa * -1
                 FROM   c_charge c, usl u
                 WHERE  c.lsk = lpad(lsk_, 8, '0')
                 AND    c.usl=u.usl
                 and    u.cd in (rec_usl2.cd, rec_usl2.cd2, rec_usl2.cd3)
                 AND    c.type = 4);
      ELSIF rec_usl.cd IN ('эл.энерг.2') THEN
        --начисление после ввода киловат, разница
        SELECT nvl(SUM(summa), 0)
        INTO   sum_chrg_
        FROM   (SELECT summa
                 FROM   c_charge c
                 WHERE  c.lsk = lpad(lsk_, 8, '0')
                 AND    c.usl = usl_
                 AND    c.type = 1
                 UNION ALL
                 SELECT summa * -1
                 FROM   c_charge c
                 WHERE  c.lsk = lpad(lsk_, 8, '0')
                 AND    c.usl = usl_
                 AND    c.type = 2
                 UNION ALL
                 SELECT summa * -1
                 FROM   c_charge c
                 WHERE  c.lsk = lpad(lsk_, 8, '0')
                 AND    c.usl = usl_
                 AND    c.type = 4
                 --свыше с.н.
                 UNION ALL
                 SELECT summa
                 FROM   c_charge c
                 WHERE  c.lsk = lpad(lsk_, 8, '0')
                 AND    c.usl = rec_usl.usl_p
                 AND    c.type = 1
                 UNION ALL
                 SELECT summa * -1
                 FROM   c_charge c
                 WHERE  c.lsk = lpad(lsk_, 8, '0')
                 AND    c.usl = rec_usl.usl_p
                 AND    c.type = 2
                 UNION ALL
                 SELECT summa * -1
                 FROM   c_charge c
                 WHERE  c.lsk = lpad(lsk_, 8, '0')
                 AND    c.usl = rec_usl.usl_p
                 AND    c.type = 4);
      END IF;

      IF rec_usl.cd IN ('х.вода') THEN
        --последние показани€ по х.воде (обраб в триггере)
        UPDATE kart k SET k.phw = cnt_ WHERE k.lsk = lpad(lsk_, 8, '0');
      ELSIF rec_usl.cd IN ('г.вода') THEN
        --последние показани€ по г.воде (обраб в триггере)
        UPDATE kart k SET k.pgw = cnt_ WHERE k.lsk = lpad(lsk_, 8, '0');
      ELSIF rec_usl.cd IN ('эл.энерг.2') THEN
        --последние показани€ по эл.эн. (обраб в триггере)
        UPDATE kart k SET k.pel = cnt_ WHERE k.lsk = lpad(lsk_, 8, '0');
      END IF;

      cnt2_ := gen_charges(lpad(lsk_, 8, '0'),
                           lpad(lsk_, 8, '0'),
                           NULL,
                           NULL,
                           0,
                           0);

      IF rec_usl.cd IN ('х.вода', 'г.вода') THEN
        --начисление после ввода кубов, разница
        SELECT nvl(SUM(summa), 0) - sum_chrg_
        INTO   sum_chrg_
        FROM   (SELECT summa
                 FROM   c_charge c
                 WHERE  c.lsk = lpad(lsk_, 8, '0')
                 AND    c.usl = usl_
                 AND    c.type = 1
                 UNION ALL
                 SELECT summa * -1
                 FROM   c_charge c
                 WHERE  c.lsk = lpad(lsk_, 8, '0')
                 AND    c.usl = usl_
                 AND    c.type = 2
                 UNION ALL
                 SELECT summa * -1
                 FROM   c_charge c
                 WHERE  c.lsk = lpad(lsk_, 8, '0')
                 AND    c.usl = usl_
                 AND    c.type = 4
                 --свыше с.н.
                 UNION ALL
                 SELECT summa
                 FROM   c_charge c
                 WHERE  c.lsk = lpad(lsk_, 8, '0')
                 AND    c.usl = rec_usl.usl_p
                 AND    c.type = 1
                 UNION ALL
                 SELECT summa * -1
                 FROM   c_charge c
                 WHERE  c.lsk = lpad(lsk_, 8, '0')
                 AND    c.usl = rec_usl.usl_p
                 AND    c.type = 2
                 UNION ALL
                 SELECT summa * -1
                 FROM   c_charge c
                 WHERE  c.lsk = lpad(lsk_, 8, '0')
                 AND    c.usl = rec_usl.usl_p
                 AND    c.type = 4
                 --без проживающих
                 UNION ALL
                 SELECT summa
                 FROM   c_charge c
                 WHERE  c.lsk = lpad(lsk_, 8, '0')
                 AND    c.usl = rec_usl.usl_empt
                 AND    c.type = 1
                 UNION ALL
                 SELECT summa * -1
                 FROM   c_charge c
                 WHERE  c.lsk = lpad(lsk_, 8, '0')
                 AND    c.usl = rec_usl.usl_empt
                 AND    c.type = 2
                 UNION ALL
                 SELECT summa * -1
                 FROM   c_charge c
                 WHERE  c.lsk = lpad(lsk_, 8, '0')
                 AND    c.usl = rec_usl.usl_empt
                 AND    c.type = 4
                 --канализ.
                 UNION ALL
                 SELECT c.summa
                 FROM   c_charge c, usl u
                 WHERE  c.lsk = lpad(lsk_, 8, '0')
                 AND    c.usl=u.usl
                 and    u.cd in (rec_usl2.cd, rec_usl2.cd2, rec_usl2.cd3)
                 AND    c.type = 1
                 UNION ALL
                 SELECT c.summa * -1
                 FROM   c_charge c, usl u
                 WHERE  c.lsk = lpad(lsk_, 8, '0')
                 AND    c.usl=u.usl
                 and    u.cd in (rec_usl2.cd, rec_usl2.cd2, rec_usl2.cd3)
                 AND    c.type = 2
                 UNION ALL
                 SELECT c.summa * -1
                 FROM   c_charge c, usl u
                 WHERE  c.lsk = lpad(lsk_, 8, '0')
                 AND    c.usl=u.usl
                 and    u.cd in (rec_usl2.cd, rec_usl2.cd2, rec_usl2.cd3)
                 AND    c.type = 4);

/*                 delete from check1;
                 insert into check1(id, summa)                 
                 SELECT 1, c.summa
                 FROM   c_charge c, usl u
                 WHERE  c.lsk = lpad(lsk_, 8, '0')
                 AND    c.usl=u.usl
                 and    u.cd in (rec_usl2.cd, rec_usl2.usl_p, rec_usl2.usl_empt)
                 AND    c.type = 1
                 UNION ALL
                 SELECT 2, c.summa * -1
                 FROM   c_charge c, usl u
                 WHERE  c.lsk = lpad(lsk_, 8, '0')
                 AND    c.usl=u.usl
                 and    u.cd in (rec_usl2.cd, rec_usl2.usl_p, rec_usl2.usl_empt)
                 AND    c.type = 2
                 UNION ALL
                 SELECT 4, c.summa * -1
                 FROM   c_charge c, usl u
                 WHERE  c.lsk = lpad(lsk_, 8, '0')
                 AND    c.usl=u.usl
                 and    u.cd in (rec_usl2.cd, rec_usl2.usl_p, rec_usl2.usl_empt)
                 AND    c.type = 4;*/
                 
      ELSIF rec_usl.cd IN ('эл.энерг.2') THEN
        --начисление после ввода киловат, разница
        SELECT nvl(SUM(summa), 0) - sum_chrg_
        INTO   sum_chrg_
        FROM   (SELECT summa
                 FROM   c_charge c
                 WHERE  c.lsk = lpad(lsk_, 8, '0')
                 AND    c.usl = usl_
                 AND    c.type = 1
                 UNION ALL
                 SELECT summa * -1
                 FROM   c_charge c
                 WHERE  c.lsk = lpad(lsk_, 8, '0')
                 AND    c.usl = usl_
                 AND    c.type = 2
                 UNION ALL
                 SELECT summa * -1
                 FROM   c_charge c
                 WHERE  c.lsk = lpad(lsk_, 8, '0')
                 AND    c.usl = usl_
                 AND    c.type = 4
                 --свыше с.н.
                 UNION ALL
                 SELECT summa
                 FROM   c_charge c
                 WHERE  c.lsk = lpad(lsk_, 8, '0')
                 AND    c.usl = rec_usl.usl_p
                 AND    c.type = 1
                 UNION ALL
                 SELECT summa * -1
                 FROM   c_charge c
                 WHERE  c.lsk = lpad(lsk_, 8, '0')
                 AND    c.usl = rec_usl.usl_p
                 AND    c.type = 2
                 UNION ALL
                 SELECT summa * -1
                 FROM   c_charge c
                 WHERE  c.lsk = lpad(lsk_, 8, '0')
                 AND    c.usl = rec_usl.usl_p
                 AND    c.type = 4);
      END IF;
      --   rollback;
      RETURN sum_chrg_;
    END IF;
  END;

  PROCEDURE gen_chrg_all(p_lvl     IN NUMBER,
                         house_id_ IN c_houses.id%TYPE,
                         p_reu     IN kart.reu%TYPE,
                         p_trest   IN kart.reu%TYPE) IS
    l_cnt NUMBER;
/*    i number;
    l_job number;
    l_job1 number;
    l_job2 number;
    l_job3 number;
    l_start_row number;
    l_end_row number; */
  BEGIN
    --глобальный перерасчет начислени€
    IF nvl(p_lvl, 0) = 0 THEN
      --по √ороду
      --все лицевые с промежуточным коммитом, по каждому лицевому...

      l_cnt := c_charges.gen_charges(NULL, NULL, NULL, NULL, 2, 1);


    --ѕќѕ–ќЅ”ё Ќј JOB-ах
  --запускаем 3 JOB-a!
  --разделил весьма грубо на 3 части
/*  i:=1;
  --создать JOB
  while i <= 3
  loop
    if i=1 then
      l_start_row:=1;
      l_end_row:=9999;
    elsif i=2 then
      l_start_row:=10000;
      l_end_row:=19999;
    elsif i=3 then
      l_start_row:=20000;
      l_end_row:=999999;
    end if;

    dbms_job.submit(job => l_job,
      what => '
      declare
       l_cnt number;
      begin
       for c in (select * from
         (select k.lsk, rownum as rn from kart k
        where k.psch not in (8,9) order by k.lsk) a
            where a.rn between '||l_start_row||' and '||l_end_row||')
         loop

         l_cnt := c_charges.gen_charges(c.lsk, c.lsk, NULL, NULL, 1, 0);

         end loop;
      exception when others
        then
          logger.log_(null, ''ќшибка из JOB-начислени€: ''||SQLERRM);
          raise;

      end;'
      );
    COMMIT;
    dbms_job.broken(job => l_job, broken => TRUE);

    if i=1 then
      l_job1:=l_job;
    elsif i=2 then
      l_job2:=l_job;
    elsif i=3 then
      l_job3:=l_job;
    end if;
    i:=i+1;
  end loop;


  --ожидать выполнени€ JOB
  while true
  loop
    for c in (select t.*
     from user_jobs t where t.job in (l_job1, l_job2, l_job3)
      and t.FAILURES <> 0)
    loop
         --удалить Job-ы
	       for c2 in (select t.*
         from user_jobs t where t.job in (l_job1, l_job2, l_job3)
          )
        loop
          DBMS_JOB.REMOVE(c2.job);
          COMMIT;
        end loop;
        Raise_application_error(-20000, 'ќшибка #1 во врем€ начислени€ (см.Log)!');
    end loop;

    select nvl(count(*),0) into l_cnt
     from dba_jobs_running t where t.job in (l_job1, l_job2, l_job3);
    if l_cnt = 0 then
      exit;
    end if;
    dbms_lock.sleep(2);
  end loop;
  */

    ELSIF nvl(p_lvl, 0) = 1 THEN
      --по ‘онду
      --начисление формировать - домами
      FOR c IN (SELECT * FROM c_houses) LOOP
        l_cnt := c_charges.gen_charges(NULL, NULL, c.id, NULL, 2, 1);
      END LOOP;
    ELSIF nvl(p_lvl, 0) = 2 THEN
      --по ” 
      --начисление формировать - домами
      FOR c IN (SELECT *
                  FROM c_houses t
                 WHERE EXISTS (SELECT *
                          FROM s_reu_trest s
                         WHERE s.reu = t.reu
                           AND s.trest = p_trest)) LOOP
        l_cnt := c_charges.gen_charges(NULL, NULL, c.id, NULL, 2, 1);
      END LOOP;
    ELSIF nvl(p_lvl, 0) = 3 THEN
      --по дому
      --Єпт, формировалс€ сразу весь –Ё”!!! »справил. –ед 01.02.2015
--      FOR c IN (SELECT * FROM c_houses t WHERE t.reu = p_reu) LOOP
      l_cnt := c_charges.gen_charges(NULL, NULL, house_id_, NULL, 1, 1);
--      END LOOP;
    END IF;
  END;

  FUNCTION gen_charges(lsk_      VARCHAR2,
                       lsk_end_  VARCHAR2,
                       house_id_ c_houses.id%TYPE,
                       p_vvod c_vvod.id%type,
                       iscommit_ NUMBER,
                       sendmsg_  NUMBER) RETURN NUMBER IS

    --коллекци€ дл€ загрузки наборов
    t_nabor tab_nabor; 

    CURSOR cur_krt IS
      SELECT k.lsk, k.reu, k.psch, nvl(k.sch_el, 0) AS sch_el, k.schel_dt, k.schel_end, nvl(k.opl,
                  0) AS opl, nvl(k.mhw, 0) AS mhw, nvl(k.mgw, 0) AS mgw, nvl(k.mel,
                  0) AS mel, k.kran, k.kran1, k.kan_sch, k.el, k.el1, k.subs_cor, k.subs_cur, k.subs_inf, k.eksub1, k.eksub2, k.sgku, k.doppl, k.status, decode(k.komn,
                     NULL,
                     2,
                     0,
                     2,
                     k.komn) AS komnat, p.subs_ob, p.kan_sch AS kan_sch2, p.sv_soc AS sv_soc, p.org_var AS org_var, nvl(k.kfg,
                  0) AS kfg, nvl(p.corr_lg, 0) AS corr_lg, p.period, u.cd as tp
      FROM   kart k, params p, u_list u
      WHERE  k.fk_tp=u.id and k.lsk BETWEEN '' || lsk_ || '' AND '' || lsk_end_ || '';

    CURSOR cur_krt2 IS
      SELECT k.lsk, k.reu, k.psch, nvl(k.sch_el, 0) AS sch_el, k.schel_dt, k.schel_end, nvl(k.opl,
                  0) AS opl, nvl(k.mhw, 0) AS mhw, nvl(k.mgw, 0) AS mgw, nvl(k.mel,
                  0) AS mel, k.kran, k.kran1, k.kan_sch, k.el, k.el1, k.subs_cor, k.subs_cur, k.subs_inf, k.eksub1, k.eksub2, k.sgku, k.doppl, k.status, decode(k.komn,
                     NULL,
                     2,
                     0,
                     2,
                     k.komn) AS komnat, p.subs_ob, p.kan_sch AS kan_sch2, p.sv_soc AS sv_soc, p.org_var AS org_var, nvl(k.kfg,
                  0) AS kfg, nvl(p.corr_lg, 0) AS corr_lg, p.period, u.cd as tp
      FROM   kart k, params p, u_list u
      WHERE  k.fk_tp=u.id and k.lsk LIKE lsk_ || '' || '%';


    CURSOR cur_krt3 IS
      SELECT k.lsk, k.reu, k.psch, nvl(k.sch_el, 0) AS sch_el, k.schel_dt, k.schel_end, nvl(k.opl,
                  0) AS opl, nvl(k.mhw, 0) AS mhw, nvl(k.mgw, 0) AS mgw, nvl(k.mel,
                  0) AS mel, k.kran, k.kran1, k.kan_sch, k.el, k.el1, k.subs_cor, k.subs_cur, k.subs_inf, k.eksub1, k.eksub2, k.sgku, k.doppl, k.status, decode(k.komn,
                     NULL,
                     2,
                     0,
                     2,
                     k.komn) AS komnat, p.subs_ob, p.kan_sch AS kan_sch2, p.sv_soc AS sv_soc, p.org_var AS org_var, nvl(k.kfg,
                  0) AS kfg, nvl(p.corr_lg, 0) AS corr_lg, p.period, u.cd as tp
      FROM   kart k, params p, u_list u
      WHERE  k.fk_tp=u.id and k.house_id = house_id_;


    CURSOR cur_krt4 IS
      SELECT k.lsk, k.reu, k.psch, nvl(k.sch_el, 0) AS sch_el, k.schel_dt, k.schel_end, nvl(k.opl,
                  0) AS opl, nvl(k.mhw, 0) AS mhw, nvl(k.mgw, 0) AS mgw, nvl(k.mel,
                  0) AS mel, k.kran, k.kran1, k.kan_sch, k.el, k.el1, k.subs_cor, k.subs_cur, k.subs_inf, k.eksub1, k.eksub2, k.sgku, k.doppl, k.status, decode(k.komn,
                     NULL,
                     2,
                     0,
                     2,
                     k.komn) AS komnat, p.subs_ob, p.kan_sch AS kan_sch2, p.sv_soc AS sv_soc, p.org_var AS org_var, nvl(k.kfg,
                  0) AS kfg, nvl(p.corr_lg, 0) AS corr_lg, p.period, u.cd as tp
      FROM   kart k, params p, u_list u
       where k.fk_tp=u.id;

    CURSOR cur_krt5 IS
      SELECT k.lsk, k.reu, k.psch, nvl(k.sch_el, 0) AS sch_el, k.schel_dt, k.schel_end, nvl(k.opl,
                  0) AS opl, nvl(k.mhw, 0) AS mhw, nvl(k.mgw, 0) AS mgw, nvl(k.mel,
                  0) AS mel, k.kran, k.kran1, k.kan_sch, k.el, k.el1, k.subs_cor, k.subs_cur, k.subs_inf, k.eksub1, k.eksub2, k.sgku, k.doppl, k.status, decode(k.komn,
                     NULL,
                     2,
                     0,
                     2,
                     k.komn) AS komnat, p.subs_ob, p.kan_sch AS kan_sch2, p.sv_soc AS sv_soc, p.org_var AS org_var, nvl(k.kfg,
                  0) AS kfg, nvl(p.corr_lg, 0) AS corr_lg, p.period, u.cd as tp
      FROM   kart k, params p, u_list u
      where k.fk_tp=u.id and 
      exists (select * from nabor n where k.lsk=n.lsk and n.fk_vvod=p_vvod); --«десь нельз€ использовать коллекцию t_nabor, она еще не определена!

    rec_krt cur_krt%ROWTYPE;

    --курсор дл€ расчета по сложной схеме (с учетом льгот)
    --услуги по лицевому, по соц норме
    CURSOR cur_nabor IS
      SELECT n.usl, n.fk_calc_tp, n.usl_p, n.usl_p AS usl_h, --ред.27.12.2010
             nvl(decode(n.sptarn,
                         0,
                         nvl(s.koeff, 1) * nvl(n.koeff, 0),
                         1,
                         nvl(n.norm, 0),
                         2,
                         nvl(n.koeff, 0) * nvl(n.norm, 0),
                         3,
                         nvl(n.koeff, 0) * nvl(n.norm, 0)),
                  0) AS chrg1, --признак начислени€ по соц норме, chrg1
             n.fk_tarif, nvl(c.chrg2, 0) AS chrg2, --признак начислени€ свыше соц.нормы, chrg2
             nvl(m.kub, 0) AS kub, nvl(m.use_sch, 0) AS use_sch, m.dist_tp, nvl(n.vol,0) AS vol, 
             nvl(n.vol_add, 0) AS vol_add, n.usl_empt, n.parent_usl, u.cd as usl_cd
      FROM   (SELECT a.lsk, a.usl, a.koeff, a.norm, a.fk_vvod, a.vol, a.vol_add, a.fk_tarif,
               b.sptarn, b.usl_order, r.usl as usl_p, b.usl_empt, b.fk_calc_tp, a.kf_kpr, a.nrm_kpr,
               b.parent_usl
               FROM table(t_nabor) a, usl b,
               (select d.usl from table(t_nabor) d where d.lsk=rec_krt.lsk) r
               WHERE  a.usl = b.usl
               and b.usl_p=r.usl(+)
               AND    nvl(b.usl_norm,0) = 0) n, (SELECT m.lsk, m.usl, decode(k.sptarn,
                              0,
                              m.koeff,
                              1,
                              nvl(m.norm,
                                  0),
                              2,
                              nvl(m.koeff,
                                  0) *
                              nvl(m.norm,
                                  0),
                              3,
                              nvl(m.koeff,
                                  0) *
                              nvl(m.norm,
                                  0)) AS chrg2
               FROM   table(t_nabor) m, usl k
               WHERE  m.usl = k.usl
               AND    m.lsk = rec_krt.lsk
               AND    nvl(k.usl_norm,0) = 1) c, c_vvod m, (SELECT sk.id, su.usl, sk.koeff
               FROM   spr_koeff sk, spr_koeff_usl su
               WHERE  su.fk_spr_koeff =
                      sk.id) s, usl u
      WHERE  n.lsk = rec_krt.lsk
      AND    n.usl = u.usl
      AND    n.lsk = c.lsk(+)
      AND    n.usl_p = c.usl(+)
      AND    n.usl = s.usl(+)
      AND    s.id(+) = rec_krt.kfg
      AND    n.usl = m.usl(+)
      AND    n.fk_vvod = m.id(+)
      ORDER  BY n.usl_order;
    rec_nabor cur_nabor%ROWTYPE;

    cursor cur_nabor2 (p_usl in usl.usl%type) is
    select * from table(t_nabor) n
      where n.lsk=rec_krt.lsk
        and n.usl=p_usl;
    rec_nabor2 cur_nabor2%ROWTYPE;

    --услуга
    usl_ VARCHAR2(3);
    --параметры
    CURSOR cur_params IS
      SELECT param, message, ver, period, agent_uptime, mess_hint, period_pl, subs_ob, id, period_debits, dt_otop1, dt_otop2, part, cnt_sch, kan_sch, sv_soc, state_base_, org_var, splash, gen_exp_lst, kart_ed1, auto_sign, find_street, penya_month, corr_lg, recharge_bill, show_exp_pay, bill_pen, penya_var, nvl(is_fullmonth,
                  0) AS is_fullmonth, wait_ver
      FROM   params;
    rec_params cur_params%ROWTYPE;

    --кол-во проживающих (с учетом вр.зарег. и вр.отстут.)
    kpr_ NUMBER;
    -- кол-во проживающих (дл€ расценок) - убрать !
    --kpr_price_ NUMBER;


    --курсор дл€ расчета по упрощенной схеме (без учета льгот)
    CURSOR cur_wo_peop(p_usl in usl.usl%type  --если не заполнено p_usl, возьмЄтс€ usl_
      ) IS
      SELECT nvl(s.koeff, 1) * nvl(n.koeff, 0) AS tarkoef, nvl(n.norm, 0) AS tarnorm,
                    CASE WHEN rec_krt.status = 9 THEN 0 --јрендаторы - цена = 0
                           ELSE
                    round(nvl(s.koeff, 1) * nvl(n.koeff, 0) *
                     decode(u.sptarn, 3, nvl(n.norm, 0), 1) * --расценка дл€ кв.с проживающими
                     nvl(e2.summa, e.summa),
                     2)
                   END AS cena,
                   CASE WHEN rec_krt.status = 9 THEN 0 --јрендаторы - цена = 0
                           ELSE
                    round(nvl(s.koeff, 1) * nvl(n.koeff, 0) *
                     decode(u.sptarn, 3, nvl(n.norm, 0), 1) * --расценка дл€ кв.с без проживающих (если есть расценка)
                     nvl(e2.summa3, e.summa3),
                     2)
                   END AS cena_for_empty,
                   u.usl_subs, m.dist_tp, nvl(m.kub, 0) AS kub, n.fk_vvod
      FROM   kart k, table(t_nabor) n, c_vvod m, prices e, prices e2, params w, usl u, /* prices e1, */ (SELECT sk.id, su.usl, sk.koeff
               FROM   spr_koeff sk, spr_koeff_usl su
               WHERE  su.fk_spr_koeff =
                      sk.id) s
      WHERE  k.lsk = '' || rec_krt.lsk || ''
      AND    k.lsk = n.lsk
      AND    n.usl = e.usl(+) --базовые расценки
      AND    n.usl = e2.usl(+) --расценки –есурсоснабжающей
      AND    n.org = e2.fk_org(+)
      and    n.fk_vvod=m.id(+)
      AND    e.fk_org IS NULL
      AND    n.usl = e2.usl(+) --расценки ” 
      AND    nvl(p_usl, usl_) = s.usl(+)
      AND    k.kfg = s.id(+)
      AND    n.usl = u.usl
      AND    n.usl = nvl(p_usl, usl_);
    rec_wo_peop cur_wo_peop%ROWTYPE;

    CURSOR cur_memof IS
      SELECT * FROM load_memof;
    rec_memof cur_memof%ROWTYPE;

    --факт наличи€ счетчиков в текущем мес€це
    CURSOR cur_sch IS
      SELECT MAX(CASE
                   WHEN t.fk_status IS NULL THEN
                    0
                   WHEN t.fk_status = 0 THEN
                    0
                   WHEN t.fk_status = 1 THEN
                    1
                   WHEN t.fk_status = 2 THEN
                    1
                   WHEN t.fk_status = 3 THEN
                    0
                   ELSE
                    0
                 END) AS sch_hw,MAX(CASE
                   WHEN t.fk_status IS NULL THEN
                    0
                   WHEN t.fk_status = 0 THEN
                    0
                   WHEN t.fk_status = 1 THEN
                    1
                   WHEN t.fk_status = 2 THEN
                    0
                   WHEN t.fk_status = 3 THEN
                    1
                   ELSE
                    0
                 END) AS sch_gw
      FROM   c_states_sch t, params p
      WHERE  rec_krt.lsk = t.lsk --не эффективно использовать to_char(t.dt1, 'YYYYMM') ѕ≈–≈ƒ≈Ћј“№!!!(ред. 02.07.11))
      AND    p.period BETWEEN nvl(to_char(t.dt1, 'YYYYMM'), '190001') AND
             nvl(to_char(t.dt2, 'YYYYMM'), '290001');

    --объемы при наличии проживающих и отсутствии, а так же по норме и свыше
    cursor cur_charge_prep(p_usl in usl.usl%type,  --если не заполнено p_usl, возьмЄтс€ usl_
                           p_lsk in kart.lsk%type --по указанному л.с.
                          )  is
    select a.vol, a.vol_nrm, a.vol_sv_nrm,
      a.empty, a.sch, a.kpr, a.kprz, a.kpro, a.opl,
      sum(a.vol) over (partition by 0) as sum_vol,
      a.usl_cd from
      (select sum(t.vol) as vol,
        sum(t.vol_nrm) as vol_nrm,
        sum(t.vol_sv_nrm) as vol_sv_nrm,
        decode(nvl(t.kpr,0),0,1,0) as empty,
        sum(t.kpr) as kpr,
        sum(t.kprz) as kprz,
        sum(t.kpro) as kpro,
        sum(t.opl) as opl,
        t.sch, u.cd as usl_cd
        from c_charge_prep t, usl u
        where t.lsk=coalesce(p_lsk, rec_krt.lsk) and t.usl=nvl(p_usl, usl_) and t.tp=1
        and t.usl=u.usl
        group by decode(nvl(t.kpr,0),0,1,0),t.sch, u.cd) a
        order by a.empty, a.sch; --order by - не мен€ть, вли€ет на расчЄт!
    --кол-во проживающих, не гл€д€ на счетчики
    cursor cur_charge_prep_kpr is
    select 
        sum(t.kpr) as kpr,
        sum(t.kprz) as kprz,
        sum(t.kpro) as kpro
        from c_charge_prep t
        where t.lsk=rec_krt.lsk 
        and t.usl=usl_ and t.tp=1;

    --объемы при наличии проживающих и отсутствии, а так же по норме и свыше
    --по списку услуг p_list_cd_usl - список услуг, через зап€тую
    --например 'х.вода,г.вода'
    --regexp_instr(l_str_tp, '8[,]{1,}',1) <> 0 (regexp ищет первую цифру '8' в строке, с необ€зательной зап€той
    cursor cur_charge_prep_usl_cd(p_list_usl_cd in varchar2) is
    select a.vol, a.sch, a.vol_nrm, a.vol_sv_nrm,
      a.empty, --a.kpr, a.kprz, a.kpro, нельз€ здесь получать кол-во прожив, так как оно будет складыватьс€ вместе!
      sum(a.vol) over (partition by 0) as sum_vol from
      (select sum(t.vol) as vol,
        sum(t.vol_nrm) as vol_nrm,
        sum(t.vol_sv_nrm) as vol_sv_nrm,
        decode(nvl(t.kpr,0),0,1,0) as empty,
        /*sum(t.kpr) as kpr,
        sum(t.kprz) as kprz,
        sum(t.kpro) as kpro,*/
        t.sch
        from c_charge_prep t, usl u
        where t.lsk=rec_krt.lsk and t.usl=u.usl
        and regexp_instr(p_list_usl_cd, '(,|^)'||u.cd||'(,|$){1,}') <> 0
        and t.tp=1
        group by decode(nvl(t.kpr,0),0,1,0),t.sch) a
        order by a.empty, a.sch; --order by - не мен€ть, вли€ет на расчЄт! (сперва не пуста€ кв, потом пуста€)

    --вернуть тип распределени€ по вводу, по услуге
    cursor cur_vvod_tp(p_usl_cd in varchar2) is
      select d.dist_tp from c_vvod d, nabor n, usl u   
        where d.id=n.fk_vvod and u.cd=p_usl_cd
        and n.lsk=rec_krt.lsk and n.usl=u.usl;

    --кол-во прожив. дл€ расчета соцнормы,
    --объем по нормативу,
    --объем по счетчику,
    --кол-во прожив. по норме (коэфф)
    --кол-во прожив. по сч. (коэфф)
    cursor cur_prep is
    select sum(decode(t.tp, 2, t.kpr, 0)) as nrm_kpr,
           sum(case when t.tp=1 then t.vol
                    else 0
                    end) as vol, --общий объем
           sum(case when t.tp=1 and t.sch=0 then t.vol
                    else 0
                    end) as nrm_vol, --нормативный объем
           sum(case when t.tp=1 and t.sch=1 then t.vol
                    else 0
                    end) as sch_vol, --обем по счетчикам
           sum(case when t.tp=1 then t.kpr
                    else 0 end) as kpr, --общее кол-во прожив
           sum(case when t.tp=1 and t.sch=0 then t.kpr
                    else 0
                    end) as kf_kpr, --кол-во прожив по нормативу
           sum(case when t.tp=1 and t.sch=1 then t.kpr
                    else 0
                    end) as kf_kpr_sch, --кол-во прожив по счетчику
           sum(t.kpr2) as kpr2 --кол-во прожив. с учЄтом всего, ¬.ќ.,¬.«. и т.п. (дл€ очистки сделал...) 07.08.2015         
        from c_charge_prep t
        where t.lsk=rec_krt.lsk and t.usl=usl_ and t.tp in (1,2);
    rec_prep cur_prep%ROWTYPE;

    rec_sch cur_sch%ROWTYPE;
    --соц.норма на проживающего
    socn_ NUMBER;
    --обща€ площадь, дл€ расчета
    opl_ NUMBER;
    --обща€ площадь, дл€ расчета, сохран€ем
    opl_save_ NUMBER;
    --площадь на проживающего, дл€ расчета
    opl_man_ NUMBER;
    --площадь свыше соц.нормы
    opl_sv_ NUMBER;

    --расход по вводам (дл€ канализ) (”—“ј–≈¬Ў, дл€ ѕолыс)
    hv_kub_ NUMBER;
    --расход по вводам (дл€ канализ) (”—“ј–≈¬Ў, дл€ ѕолыс)
    gv_kub_ NUMBER;

    --общий расход по холодной воде
    hv_ NUMBER;

    socn_kub_ NUMBER;
    --расход холодной воды на проживающего, дл€ расчета
    hv_man_ NUMBER;
    --х.в. свыше соц.нормы
    hv_sv_ NUMBER;
    --общий расход по гор€чей воде
    gv_ NUMBER;

    --электроэнерги€
    el_ number;
    --электроэнерги€ итог (может не нужна)
    el_kan_ number;

    --расход гор€чей воды на проживающего, дл€ расчета
    gv_man_ NUMBER;
    --г.в. свыше соц.нормы
    gv_sv_ NUMBER;
    --общий расход по канализованию
    kan_       NUMBER;
    saved_kan_ NUMBER;
    --расход канализовани€ на проживающего, дл€ расчета
    kan_man_ NUMBER;
    hv_kan_  NUMBER;
    gv_kan_  NUMBER;

    --объЄм, посчитанный по нормативному начислению (разделение дл€ статистики)
    hv_kan_nrm_ NUMBER;
    --объЄм, посчитанный по начислению с прибором учета
    hv_kan_sch_ NUMBER;

    gv_kan_nrm_ NUMBER;
    gv_kan_sch_ NUMBER;
    hv_kan_add_ NUMBER;
    gv_kan_add_ NUMBER;
    --кан. свыше соц.нормы
    kan_sv_ NUMBER;
    --id проживающего
    TYPE t_peoples IS TABLE OF NUMBER;
    t_peop_id t_peoples := t_peoples(NULL);
    --флаг если найден id
    exists_ NUMBER;
    --цена услуги по соц.норме
    cena_sn_ NUMBER;

    --дл€ антенны, энергии+
    cena_ NUMBER;

    --промежуточна€ переменна€, дл€ хранени€ суммы начислени€
    summa_ NUMBER;
    --промежуточна€ переменна€, дл€ округлени€ начислени€
    summaf_ NUMBER;

    --расход положительный или отрицательный?
    sign_kub_ NUMBER;

    --переменные субсидии
    sov_doh1_   NUMBER;
    koef_doh_   NUMBER;
    koef_subs_  NUMBER;
    mdd_        NUMBER;
    poprav_     NUMBER;
    sgku_1_     NUMBER;
    sum_subsid_ NUMBER;
    koeff_rasp_ NUMBER;
    koef_lg_    NUMBER;
    pl_norma_   NUMBER;
    it_izm_s_   NUMBER;
    subs_       NUMBER;
    --переменна€ дл€ проверки субсидии
    chk_subs_corr_ NUMBER;
    --сумма начислени€ со льготой
    sit_ NUMBER;
    --сумма начислени€ со льготой и изменени€ми
    sit_s_ NUMBER;
    --сумма начислени€ без льготы
    msit_ NUMBER;
    --кол-во лицевых
    cnt_lsk_ NUMBER;
    --дл€ прогрессбара в ƒиректе
    cnt_10 NUMBER;
    dbid_  NUMBER;
    --є пор€дковый выполнени€ расчЄта
    npp_ NUMBER;
    --вариант использовани€ начислени€
    var_ NUMBER;
    --округл€ть ли начисление (параметр базы)
    is_round_charge_ NUMBER;
    --признак наличи€ счетчиков (¬–≈ћ≈ЌЌќ, ƒќ ѕ≈–≈ƒ≈Ћ » јЋ√ќ–»“ћј Ќј„»—Ћ≈Ќ»я ѕќ ¬ќƒ≈ (ƒЋя –ј«ƒ≈Ћ≈Ќ»я ¬ —“ј“»—“» ≈ ¬ќƒџ ѕќ —„ » Ќќ–ћ≈)
    sch_ NUMBER;
    --дл€ сохранени€ расценки
    l_cena number;
    --дл€ расчета норматива в канализовании
    l_norm number;
    l_vol number;
    --дл€ сохранени€ знака объема
    l_sign number;
    --временна€ переменна€
    l_str varchar2(128);
    
    --дл€ сохранени€ признака распределени€ c_vvod.dist_tp по родительской услуге, дл€ использовани€ в доначислении по ќƒЌ
/*    l_hw_dist_tp c_vvod.dist_tp%type;
    l_gw_dist_tp c_vvod.dist_tp%type;
    l_el_dist_tp c_vvod.dist_tp%type;*/
    l_ot_dist_tp c_vvod.dist_tp%type;
    
    --временные переменные
    l_kpr number;
    l_kprz number;
    l_kpro number;
    l_flag number;
    i number;
    l_tmp_usl usl.usl%type;
    l_tmp_vol number;    
   
    

  PROCEDURE ins_chrg2(p_vol   IN NUMBER,   --объем
                      p_cena     IN NUMBER,--цена
                      p_proc in number,     --% коэфф к объему (напр. дл€ отоплени€)
                      p_usl in usl.usl%type,
                      p_sch in c_charge.sch%type, --наличие счетчика
                      p_kpr in c_charge.kpr%type, --кол-во прожив.
                      p_kprz in c_charge.kprz%type, --кол-во вр.зарег.
                      p_kpro in c_charge.kpro%type, --кол-во вр.отсут.
                      p_opl in c_charge.opl%type --площадь!
                      ) IS
    summa_  number;
    summaf_ number;
    l_proc  number;
  BEGIN
  --локальна€ процедура ins_chrg2
  --взамен устаревающей ins_chrg
    if p_proc is null then
      l_proc:=1;
    else
      l_proc:=p_proc;
    end if;
    IF p_vol <> 0 or p_kpr <> 0 THEN --или есть объем или есть проживающие ред. 17.10.14
      npp_ := npp_ + 1;
      --со льготой
      sit_    := sit_ + round(p_vol * p_cena * l_proc, 2);
      summaf_ := p_vol * p_cena * l_proc;
      summa_  := round(summaf_, 2);
      INSERT INTO c_charge
        (npp, lsk, usl, summa, summaf, kart_pr_id, TYPE,
        spk_id, test_opl, test_cena, test_tarkoef,
        test_spk_koef, sch, kpr, kprz, kpro, opl)
      VALUES
        (0, rec_krt.lsk, p_usl, summa_, summaf_, NULL,
        0, NULL, p_vol, p_cena, NULL, NULL,
        p_sch, p_kpr, p_kprz, p_kpro, p_opl);
      --без льготы
      msit_   := msit_ + round(p_vol * p_cena * l_proc, 2);
      summaf_ := p_vol * p_cena * l_proc;
      summa_  := round(summaf_, 2);
      INSERT INTO c_charge
        (npp, lsk, usl, summa, summaf, kart_pr_id, TYPE,
        spk_id, test_opl, test_cena, test_tarkoef,
        test_spk_koef, sch, kpr, kprz, kpro, opl)
      VALUES
        (npp_, rec_krt.lsk, p_usl, summa_, summaf_, NULL,
        1, NULL, p_vol, p_cena, NULL, NULL, p_sch,
        p_kpr, p_kprz, p_kpro, p_opl);
    END IF;
  END ins_chrg2;

  PROCEDURE ins_chrg(npp_      IN OUT NUMBER,
                     lsk_      IN kart.lsk%TYPE,
                     sign_kub_ IN NUMBER,
                     usl_      IN usl.usl%TYPE,
                     vol_in_   IN NUMBER,
                     cena_     IN NUMBER,
                     sit_      IN OUT NUMBER,
                     msit_     IN OUT NUMBER,
                     sch_      IN NUMBER) IS
    summa_  NUMBER;
    summaf_ NUMBER;
    vol_    NUMBER;
  BEGIN
  --локальна€ процедура ins_chrg (”—“ј–≈¬ј≈“)
    IF vol_in_ * cena_ <> 0 THEN
      vol_ := vol_in_ * sign_kub_;
      npp_ := npp_ + 1;
      --со льготой
      sit_    := sit_ + round(vol_ * cena_, 2);
      summaf_ := vol_ * cena_;
      summa_  := round(summaf_, 2);
      INSERT INTO c_charge
        (npp, lsk, usl, summa, summaf, kart_pr_id, TYPE, spk_id, test_opl, test_cena, test_tarkoef, test_spk_koef, sch)
      VALUES
        (0, lsk_, usl_, summa_, summaf_, NULL, 0, NULL, vol_, cena_, NULL, NULL, sch_);
        
      --без льготы
      msit_   := msit_ + round(vol_ * cena_, 2);
      summaf_ := vol_ * cena_;
      summa_  := round(summaf_, 2);
      INSERT INTO c_charge
        (npp, lsk, usl, summa, summaf, kart_pr_id, TYPE, spk_id, test_opl, test_cena, test_tarkoef, test_spk_koef, sch)
      VALUES
        (npp_, lsk_, usl_, summa_, summaf_, NULL, 1, NULL, vol_, cena_, NULL, NULL, sch_);
    END IF;
  END ins_chrg;


  BEGIN
    --Ќј„јЋќ ))
--    t_nabor tab_nabor:=tab_nabor();

    is_round_charge_ := utils.get_int_param('IS_ROUND_CHARGE');
    OPEN cur_memof;
    FETCH cur_memof
      INTO rec_memof;
    CLOSE cur_memof;

    OPEN cur_params;
    FETCH cur_params
      INTO rec_params;
    CLOSE cur_params;

    SELECT dbid INTO dbid_ FROM sys.v_$database;

    cnt_10   := 0;
    cnt_lsk_ := 0;
    --”станавливаем статусы проживани€
    --выполн€ть ƒќ открыти€ основных курсоров
    -- временно закоментировал, UPDATE дл€ подолевого расчета 25.04.2011
    IF house_id_ IS NOT NULL THEN
      var_ := 3;
    ELSIF p_vvod IS NOT NULL THEN
      var_ := 5;
      --думаю надо выполн€ть данный код после перехода - прим.от 12.04.2011
    ELSIF lsk_ IS NOT NULL AND lsk_end_ IS NULL THEN
      var_ := 2;
    ELSIF lsk_ IS NOT NULL AND lsk_end_ IS NOT NULL THEN
      var_ := 1;
    ELSIF lsk_ IS NULL AND lsk_end_ IS NULL THEN
      var_ := 4;
    END IF;

    IF var_ = 1 THEN
      --по группе л.с.
      OPEN cur_krt;
    ELSIF var_ = 2 THEN
      --по 1 л.с.
      OPEN cur_krt2;
    ELSIF var_ = 3 THEN
      --по выбранному house_id дому
      OPEN cur_krt3;
    ELSIF var_ = 4 THEN
      --по всему фонду
      OPEN cur_krt4;
    ELSIF var_ = 5 THEN
      --по вводу
      OPEN cur_krt5;
    END IF;

    LOOP
      --÷икл по лицевым счетам
      IF var_ = 1 THEN
        FETCH cur_krt
          INTO rec_krt;
        EXIT WHEN cur_krt%NOTFOUND;
      ELSIF var_ = 2 THEN
        FETCH cur_krt2
          INTO rec_krt;
        EXIT WHEN cur_krt2%NOTFOUND;
      ELSIF var_ = 3 THEN
        FETCH cur_krt3
          INTO rec_krt;
        EXIT WHEN cur_krt3%NOTFOUND;
      ELSIF var_ = 4 THEN
        FETCH cur_krt4
          INTO rec_krt;
        EXIT WHEN cur_krt4%NOTFOUND;
      ELSIF var_ = 5 THEN
        FETCH cur_krt5
          INTO rec_krt;
        EXIT WHEN cur_krt5%NOTFOUND;
      END IF;

      hv_kub_     := 0;
      gv_kub_     := 0;
      hv_kan_     := 0;
      gv_kan_     := 0;
      hv_kan_nrm_ := 0;
      hv_kan_sch_ := 0;
      gv_kan_nrm_ := 0;
      gv_kan_sch_ := 0;
      hv_kan_add_ := 0;
      gv_kan_add_ := 0;

      npp_ := 0;


      --установить коэфф по проживающим
      c_kart.set_part_kpr(rec_krt.lsk, null, null, rec_krt.tp);

      if iscommit_=1 then
        COMMIT; -- оммит нужен - иначе проблемы с DEADLOCK!
      end if;

      --загрузить nabor в коллекцию
      if t_nabor is not null then
        t_nabor.delete;
      end if;
      
      select scott.rec_nabor(lsk, usl, org, koeff, norm, fk_tarif, fk_vvod, vol, vol_add, kf_kpr, sch_auto, 
       nrm_kpr, kf_kpr_sch, kf_kpr_wrz, kf_kpr_wro, kf_kpr_wrz_sch, kf_kpr_wro_sch, limit, nrm_kpr2)
      bulk collect into t_nabor 
      from nabor t where t.lsk=rec_krt.lsk ;

      --удал€ем прежний расчЄт
      DELETE FROM c_charge c WHERE c.lsk = rec_krt.lsk AND c.type in (0,1,2,3,4);--удал€ем всЄ,
                                                                                 --кроме информац.по ќƒЌ

      --если не закрытый лицевой счЄт, то считаем
      IF rec_krt.psch NOT IN (8, 9) AND
         ((nvl(rec_krt.org_var, 0) <> 0 AND
         nvl(rec_krt.schel_dt, to_date('19000101', 'YYYYMMDD')) <=
         to_date(rec_krt.period || '15', 'YYYYMMDD') AND
         nvl(rec_krt.schel_end, to_date('29000101', 'YYYYMMDD')) >
         to_date(rec_krt.period || '15', 'YYYYMMDD')) OR
         nvl(rec_krt.org_var, 0) = 0) THEN

        cnt_lsk_ := cnt_lsk_ + 1;
        cnt_10   := cnt_10 + 1;
        --сообщение дл€  ƒиректа
        IF cnt_10 = 10 AND nvl(sendmsg_, 0) = 1 THEN
          cnt_10 := 0;
          admin.send_message(lower(USER) || '-lsk:' || rec_krt.lsk);
        END IF;
        --предустановки
        sit_      := 0;
        msit_     := 0;
        pl_norma_ := 0;

        OPEN cur_nabor;
        --выбираем набор услуг по этому лицевому, по соцнорме
        LOOP
          rec_nabor:=null;
          FETCH cur_nabor
            INTO rec_nabor;
          EXIT WHEN cur_nabor%NOTFOUND;

          --выбираем проживающих по этому лицевому
          usl_ := rec_nabor.usl;

          --ƒл€ отмотки счетчиков обратно
          sign_kub_ := 1;
          --обща€ площадь
          opl_      := rec_krt.opl;
          opl_save_ := opl_;
          --нулим соцнорму
          socn_:=0;

          --||||||||||||||||||||||||||||||||||||||--
          --”—Ћ”√ј — –ј—÷≈Ќ ќ… ƒЋя ѕ”—“џ’  ¬ј–“»–
          --текущее содержание, отопление, лифт, дератиз, кап.ремонт
          IF rec_nabor.chrg1 <> 0 AND rec_nabor.fk_calc_tp IN (25) or --#25#33
             rec_nabor.fk_calc_tp IN (33) AND rec_krt.status <> 1 --капремонт (единый)
           THEN
            OPEN cur_wo_peop(null);
            FETCH cur_wo_peop
              INTO rec_wo_peop;
            CLOSE cur_wo_peop;
            --сохранить расценку
            l_cena:=rec_wo_peop.cena;
            for c in cur_charge_prep(null, null)
            loop
              if c.empty = 0 then
                --расчет дл€ не пустой квартиры
                ins_chrg2(c.vol, rec_wo_peop.cena, null, usl_, c.sch, c.kpr, c.kprz, c.kpro, null);
              elsif c.empty = 1 then
                --расчет дл€ пустой квартиры
                OPEN cur_nabor2(rec_nabor.usl_p);
                FETCH cur_nabor2
                  INTO rec_nabor2;
                if cur_nabor2%NOTFOUND then
                  --ќ ј«џ¬ј≈“—я Ќјƒќ Ќ”Ћ»“№
                  rec_nabor2.usl:=null;
                end if;
                CLOSE cur_nabor2;
                --if rec_krt.status <> 1 then
                --Ѕыло:дл€ не муниципальных квартир, расценка как дл€ пустых квартир
                --ред.21.08.14 -сделал и по муницип расенку как дл€ пустых приватизир.
                l_cena:=rec_wo_peop.cena_for_empty;
                --end if;
                if rec_nabor2.usl is not null then
                  --есть выделенна€ услуга "без проживающих"
                    ins_chrg2(c.vol, l_cena, null, rec_nabor.usl_p, c.sch, c.kpr, c.kprz, c.kpro, null);
                  else
                    --нет выделенной услуги "без проживающих", ставим на ту же услугу
                    ins_chrg2(c.vol, l_cena, 0, usl_, c.sch, c.kpr, c.kprz, c.kpro, null);
                end if;
              end if;
            end loop;
          END IF;
          --||||||||||||||||||||||||||||||||||||||--
          --”—Ћ”√ј — –ј—÷≈Ќ ќ… ƒЋя ѕ”—“џ’  ¬ј–“»–
          --отопление гигакаллории #14#
          IF rec_nabor.fk_calc_tp IN (14) AND rec_krt.opl <> 0 then
            OPEN cur_wo_peop(null);
            FETCH cur_wo_peop
              INTO rec_wo_peop;
            CLOSE cur_wo_peop;
            --сохранить расценку
            l_cena:=rec_wo_peop.cena;
            --сохранить дл€ доначислени€ признак наличи€ счетчика ќƒѕ”
            l_ot_dist_tp:=rec_wo_peop.dist_tp;
            for c in cur_charge_prep(null, null)
            loop
              if c.empty = 0 then
                --расчет дл€ не пустой квартиры
                ins_chrg2(c.vol, rec_wo_peop.cena, null, usl_, c.sch, c.kpr, c.kprz, c.kpro, c.opl);
              elsif c.empty = 1 then
                --расчет дл€ пустой квартиры
                OPEN cur_nabor2(rec_nabor.usl_p);
                FETCH cur_nabor2
                  INTO rec_nabor2;
                if cur_nabor2%NOTFOUND then
                  --ќ ј«џ¬ј≈“—я Ќјƒќ Ќ”Ћ»“№
                  rec_nabor2.usl:=null;
                end if;
                CLOSE cur_nabor2;
--                if rec_krt.status <> 1 then
                --Ѕыло:дл€ не муниципальных квартир, расценка как дл€ пустых квартир
                --ред.21.08.14 -сделал и по муницип расенку как дл€ пустых приватизир.
                  l_cena:=rec_wo_peop.cena_for_empty;
--                end if;
                if rec_nabor2.usl is not null then
                  --есть выделенна€ услуга "без проживающих"
                  ins_chrg2(c.vol, l_cena, null, rec_nabor.usl_p, c.sch, c.kpr, c.kprz, c.kpro, c.opl);
                  else
                  --нет выделенной услуги "без проживающих", ставим на ту же услугу
                  ins_chrg2(c.vol, l_cena, null, usl_, c.sch, c.kpr, c.kprz, c.kpro, c.opl);
                end if;
              end if;
            end loop;
          END IF;
          --||||||||||||||||||||||||||||||||||||||--
          --текущее содержание, отопление, лифт, дератиз, упр.жил.домом, эл.энерг-2
          --”—Ћ”√ј — —ќ÷Ќќ–ћќ… » —¬џЎ≈ ј “ј ∆≈ — –ј—÷≈Ќ ќ… ƒЋя ѕ”—“џ’  ¬ј–“»–
          --(¬«јћ≈Ќ 0 и 2 ”—Ћ”√»! (тек.содерж, отопление, эл.энерг2) #36#)
          IF (rec_nabor.fk_calc_tp IN (36) AND rec_krt.opl <> 0) then
            OPEN cur_wo_peop(null);
            FETCH cur_wo_peop
              INTO rec_wo_peop;
            CLOSE cur_wo_peop;
            --–≈Ў»Ћ Ќ≈ ћ”“»“№ «ƒ≈—№ с –ј—÷≈Ќ јћ» по ћ”Ќ»÷»ѕ кв. (так как только дл€ “—∆ эта ветка)
            --ред. 26.03.14
            --l_el_dist_tp:=rec_wo_peop.dist_tp;
            for c in cur_charge_prep(null, null)
            loop
              if c.empty = 0 then
                --расчет дл€ не пустой квартиры
                --по норме
                ins_chrg2(c.vol_nrm, rec_wo_peop.cena, null, usl_, c.sch, c.kpr, c.kprz, c.kpro, null);
                --свыше соц.нормы
                if rec_nabor.usl_p is null then
                  --нет услуги свыше с.н., ставим на соц.н.
                  ins_chrg2(c.vol_sv_nrm, rec_wo_peop.cena, null, usl_, c.sch, c.kpr, c.kprz, c.kpro, null);
                else
                  --есть услуга свыше с.н.
                  OPEN cur_wo_peop(rec_nabor.usl_p);
                  FETCH cur_wo_peop
                    INTO rec_wo_peop;
                  CLOSE cur_wo_peop;
                  ins_chrg2(c.vol_sv_nrm, rec_wo_peop.cena, null, rec_nabor.usl_p, c.sch, c.kpr, c.kprz, c.kpro, null);
                end if;
              elsif c.empty = 1 then
                --пуста€ квартира - пишем в услугу "без проживающих"
                if rec_nabor.usl_empt is not null then --да да, сделал так грубо))
                  OPEN cur_wo_peop(rec_nabor.usl_empt);
                  FETCH cur_wo_peop
                    INTO rec_wo_peop;
                  CLOSE cur_wo_peop;
                  ins_chrg2(c.vol, rec_wo_peop.cena, null, rec_nabor.usl_empt, c.sch, c.kpr, c.kprz, c.kpro, null);
                else
                  --нет услуги "без проживающих, ставим на св.соцнормы"
                  --свыше соц.нормы
                  if rec_nabor.usl_p is null then
                    --нет услуги свыше с.н., ставим на соц.н.
                    ins_chrg2(c.vol, rec_wo_peop.cena, null, usl_, c.sch, c.kpr, c.kprz, c.kpro, null);
                  else
                    --есть услуга свыше с.н.
                    OPEN cur_wo_peop(rec_nabor.usl_p);
                    FETCH cur_wo_peop
                      INTO rec_wo_peop;
                    CLOSE cur_wo_peop;
                    ins_chrg2(c.vol, rec_wo_peop.cena, null, rec_nabor.usl_p, c.sch, c.kpr, c.kprz, c.kpro, null);
                  end if;
                end if;
              end if;
            end loop;
          END IF;
          --||||||||||||||||||||||||||||||||||||||--
          -- кап.ремонт c 70 летними! #37#
          IF rec_nabor.fk_calc_tp IN (37) AND rec_krt.status <> 1 then
            OPEN cur_wo_peop(null);
            FETCH cur_wo_peop
              INTO rec_wo_peop;
            CLOSE cur_wo_peop;
            for c in cur_charge_prep(null, null)
            loop
                ins_chrg2(c.vol, rec_wo_peop.cena, null, usl_, c.sch, c.kpr, c.kprz, c.kpro, rec_krt.opl);
            end loop;
          END IF;
          --||||||||||||||||||||||||||||||||||||||--
            --”—Ћ”√ј — —ќ÷Ќќ–ћќ… » —¬џЎ≈ Ѕ≈« –ј—÷≈Ќ » ƒЋя ѕ”—“џ’  ¬ј–“»–
            --»—ѕќЋ№«”≈“—я в ѕолыс, в “—∆
          IF rec_nabor.chrg1 <> 0 AND rec_nabor.fk_calc_tp IN (3) THEN --#3#
            --сначала по нормативу считаем (это Ќ≈ в любом случае идЄт по соц.норме, например если
            --распределитс€ по дому много)
            socn_kub_   := 0;
            hv_kan_     := 0;
            hv_kan_nrm_ := 0;
            hv_kan_sch_ := 0;
            hv_kan_nrm_ := 0;
            OPEN cur_wo_peop(null);
            FETCH cur_wo_peop
              INTO rec_wo_peop;
            CLOSE cur_wo_peop;

            OPEN cur_prep;
            FETCH cur_prep
              INTO rec_prep;
            CLOSE cur_prep;

            --сколько кубов по соцнорме допустимо
            socn_kub_ := round(rec_prep.nrm_kpr * rec_wo_peop.tarnorm, 3);
            hv_kan_nrm_ := rec_prep.nrm_vol; --расход по х.в. дл€ канализ.
            --счетчики по х.в.
            hv_kan_sch_ := rec_prep.sch_vol; --расход по х.в. дл€ канализ.
            --общий расход
            hv_ := hv_kan_nrm_ + hv_kan_sch_;

            --≈сли расход отрицательный то...
            IF hv_ >= 0 THEN
              sign_kub_ := 1;
            ELSE
              sign_kub_ := -1;
            END IF;
            hv_ := abs(hv_);
            --соцнорма
            IF hv_ <= socn_kub_ THEN
              ins_chrg(npp_,
                       rec_krt.lsk,
                       sign_kub_,
                       usl_,
                       hv_,
                       rec_wo_peop.cena,
                       sit_,
                       msit_,
                       CASE
                         WHEN hv_kan_sch_ <> 0 THEN
                          1
                         ELSE
                          0
                       END /*временна€ конструкци€*/);
            ELSE
              ins_chrg(npp_,
                       rec_krt.lsk,
                       sign_kub_,
                       usl_,
                       socn_kub_,
                       rec_wo_peop.cena,
                       sit_,
                       msit_,
                       CASE WHEN hv_kan_sch_ <> 0 THEN 1 ELSE 0 END /*временна€ конструкци€*/);
              IF rec_nabor.chrg2 <> 0 THEN
                --свыше с.нормы
                usl_ := rec_nabor.usl_p;
                OPEN cur_wo_peop(null);
                FETCH cur_wo_peop
                  INTO rec_wo_peop;
                CLOSE cur_wo_peop;
                ins_chrg(npp_,
                         rec_krt.lsk,
                         sign_kub_,
                         usl_,
                         hv_ - socn_kub_,
                         rec_wo_peop.cena,
                         sit_,
                         msit_,
                         CASE WHEN hv_kan_sch_ <> 0 THEN 1 ELSE 0 END /*временна€ конструкци€*/);
              END IF;
            END IF;
          END IF;
          --||||||||||||||||||||||||||||||||||||||--
          --”—Ћ”√ј — —ќ÷Ќќ–ћќ… » —¬џЎ≈ Ѕ≈« –ј—÷≈Ќ » ƒЋя ѕ”—“џ’  ¬ј–“»–
          --»—ѕќЋ№«”≈“—я в ѕолыс, в “—∆
          -- гор€ча€ вода (г.в.)- ред от 19.09.11
          IF rec_nabor.chrg1 <> 0 AND rec_nabor.fk_calc_tp IN (4) THEN  --#4#
            --сначала по нормативу считаем (это Ќ≈ в любом случае идЄт по соц.норме, например если
            --распределитс€ по дому много)
            socn_kub_   := 0;
            gv_kan_     := 0;
            gv_kan_nrm_ := 0;
            gv_kan_sch_ := 0;
            gv_kan_nrm_ := 0;
            gv_         := 0;
            OPEN cur_wo_peop(null);
            FETCH cur_wo_peop
              INTO rec_wo_peop;
            CLOSE cur_wo_peop;

            OPEN cur_prep;
            FETCH cur_prep
              INTO rec_prep;
            CLOSE cur_prep;

            --сколько кубов по соцнорме допустимо
            socn_kub_ := round(rec_prep.nrm_kpr * rec_wo_peop.tarnorm, 3);


            --сколько кубов по соцнорме допустимо
            socn_kub_ := round(rec_prep.nrm_kpr * rec_wo_peop.tarnorm, 3);
            gv_kan_nrm_ := rec_prep.nrm_vol; --расход по г.в. дл€ канализ.
            --счетчики по г.в.
            gv_kan_sch_ := rec_prep.sch_vol; --расход по г.в. дл€ канализ.
            --общий расход
            gv_ := gv_kan_nrm_ + gv_kan_sch_; --прибавить расход временно проживающих (вычисленных)
            --≈сли расход отрицательный то...
            IF gv_ >= 0 THEN
              sign_kub_ := 1;
            ELSE
              sign_kub_ := -1;
            END IF;
            gv_ := abs(gv_);
            --соцнорма
            IF gv_ <= socn_kub_ THEN
              ins_chrg(npp_,
                       rec_krt.lsk,
                       sign_kub_,
                       usl_,
                       gv_,
                       rec_wo_peop.cena,
                       sit_,
                       msit_,
                       CASE
                         WHEN gv_kan_sch_ <> 0 THEN
                          1
                         ELSE
                          0
                       END /*временна€ конструкци€*/);
            ELSE
              ins_chrg(npp_,
                       rec_krt.lsk,
                       sign_kub_,
                       usl_,
                       socn_kub_,
                       rec_wo_peop.cena,
                       sit_,
                       msit_,
                       CASE WHEN gv_kan_sch_ <> 0 THEN 1 ELSE 0 END /*временна€ конструкци€*/);
              IF rec_nabor.chrg2 <> 0 THEN
                --свыше с.нормы
                usl_ := rec_nabor.usl_p;
                OPEN cur_wo_peop(null);
                FETCH cur_wo_peop
                  INTO rec_wo_peop;
                CLOSE cur_wo_peop;
                ins_chrg(npp_,
                         rec_krt.lsk,
                         sign_kub_,
                         usl_,
                         gv_ - socn_kub_,
                         rec_wo_peop.cena,
                         sit_,
                         msit_,
                         CASE WHEN gv_kan_sch_ <> 0 THEN 1 ELSE 0 END /*временна€ конструкци€*/);
              END IF;
            END IF;
          END IF;




          --||||||||||||||||||||||||||||||||||||||--
          --”—Ћ”√ј — –ј—÷≈Ќ ќ… ƒЋя ѕ”—“џ’  ¬ј–“»– — —ќ÷Ќќ–ћќ… » —¬џЎ≈
          -- холодна€ вода, гор€ча€ вода /ревизи€ дл€ “—∆. от 29.04.2014/
          IF rec_nabor.chrg1 <> 0 AND rec_nabor.fk_calc_tp IN (38, 40) THEN --#38#40#
            OPEN cur_wo_peop(null);
            FETCH cur_wo_peop
              INTO rec_wo_peop;
            CLOSE cur_wo_peop;
            l_flag:=0;
            /*if rec_nabor.usl_cd = 'х.вода' then
              --сохранить дл€ повыш.коэфф. ’.¬.
              l_hw_dist_tp:=rec_wo_peop.dist_tp;
            elsif rec_nabor.usl_cd = 'г.вода' then
              --сохранить дл€ повыш.коэфф. √.¬.
              l_gw_dist_tp:=rec_wo_peop.dist_tp;
            end if;*/

            for c in cur_charge_prep(null, null)
            loop
              if l_flag=0 then  
                l_flag:=1;   
                l_kpr:=c.kpr;
                l_kprz:=c.kprz;
                l_kpro:=c.kpro;
              end if;

              if c.empty = 0 then
                --расчет дл€ не пустой квартиры
                --по норме
                ins_chrg2(c.vol_nrm, rec_wo_peop.cena, null, usl_, c.sch, l_kpr, l_kprz, l_kpro, null);
--                l_kpr:=0; -убрал, так как у Ћарисы испортилс€ отчет по субсидированию г.в. и отоп.
--                l_kprz:=0;
--                l_kpro:=0;
                OPEN cur_wo_peop(rec_nabor.usl_p);
                FETCH cur_wo_peop
                  INTO rec_wo_peop;
                CLOSE cur_wo_peop;
                --свыше соц.нормы
                if rec_nabor.usl_p is not null then --ред.20.11.14, сделал, так как стал вылетать exception о пустой услуге rec_nabor.usl_p
                  ins_chrg2(c.vol_sv_nrm, rec_wo_peop.cena, null, rec_nabor.usl_p, c.sch, l_kpr, l_kprz, l_kpro, null);
                  l_kpr:=0;
                  l_kprz:=0;
                  l_kpro:=0;
                end if;
              elsif c.empty = 1 then
                --расчет дл€ пустой квартиры
                OPEN cur_nabor2(rec_nabor.usl_empt);
                FETCH cur_nabor2
                  INTO rec_nabor2;
                if cur_nabor2%NOTFOUND then
                  --ќ ј«џ¬ј≈“—я Ќјƒќ Ќ”Ћ»“№
                  rec_nabor2.usl:=null;
                end if;
                CLOSE cur_nabor2;
                OPEN cur_wo_peop(rec_nabor.usl_empt);
                FETCH cur_wo_peop
                  INTO rec_wo_peop;
                CLOSE cur_wo_peop;

                if rec_nabor2.usl is not null then
                  --есть выделенна€ услуга "без проживающих"
                  ins_chrg2(c.vol, rec_wo_peop.cena, null, rec_nabor2.usl, c.sch, null, null, null, null);
                  else
                  --нет выделенной услуги "без проживающих", ищем по свыше с.н.
                  --расчет дл€ пустой квартиры
                  OPEN cur_wo_peop(rec_nabor.usl_p);
                  FETCH cur_wo_peop
                    INTO rec_wo_peop;
                  CLOSE cur_wo_peop;
                  ins_chrg2(c.vol, rec_wo_peop.cena, null, rec_nabor.usl_p, c.sch, null, null, null, null);
	                --    Raise_application_error(-20000, 'Ќет выделенной услуги "без проживающих" л.с.:'||rec_krt.lsk);
                end if;
              end if;
            end loop;
          END IF;

          --||||||||||||||||||||||||||||||||||||||--
          --”—Ћ”√ј — –ј—÷≈Ќ ќ… ƒЋя ѕ”—“џ’  ¬ј–“»– — —ќ÷Ќќ–ћќ… » —¬џЎ≈
          -- канализование /ревизи€ дл€ дл€ “—∆. от 19.05.2014/
          IF (rec_nabor.chrg1 <> 0 OR rec_nabor.chrg2 <> 0) AND rec_nabor.fk_calc_tp IN (39) THEN --#39#
            OPEN cur_wo_peop(null);
            FETCH cur_wo_peop
              INTO rec_wo_peop;
            CLOSE cur_wo_peop;
            OPEN cur_prep;
            FETCH cur_prep
              INTO rec_prep;
            CLOSE cur_prep;
            --“ќЋ№ ќ в этой услуге реализован расчет свыше соц нормы не в C_KART!
            l_kpr:=0;
            l_kprz:=0;
            l_kpro:=0;
            for c2 in cur_charge_prep(null, null)
            loop
              l_kpr:=c2.kpr;
              l_kprz:=c2.kprz;
              l_kpro:=c2.kpro;
            end loop;

            /*if rec_nabor.usl_cd = 'х.вода' then
              --сохранить дл€ повыш.коэфф. ’.¬.
              l_hw_dist_tp:=rec_wo_peop.dist_tp;
            elsif rec_nabor.usl_cd = 'г.вода' then
              --сохранить дл€ повыш.коэфф. √.¬.
              l_gw_dist_tp:=rec_wo_peop.dist_tp;
            end if;*/

            for c in cur_charge_prep_usl_cd('х.вода,г.вода')
            loop
              if c.empty = 0 then
                --расчет дл€ не пустой квартиры
                l_norm:=rec_wo_peop.tarnorm*rec_prep.kpr;
                l_vol:=abs(c.vol);
                l_sign:=sign(c.vol);

                while l_norm >0 and l_vol >0
                loop
                  if l_norm >0 and l_norm > l_vol then
                    --по норме
--                    ins_chrg2(l_vol*l_sign, rec_wo_peop.cena, null, usl_, c.sch, c.kpr, c.kprz, c.kpro, null); --жесть
                    ins_chrg2(l_vol*l_sign, rec_wo_peop.cena, null, usl_, c.sch, l_kpr, l_kprz, l_kpro, null); --жесть (убрал неправильно считающеес€ кол-во прож по канализ)
--                l_kpr:=0; -убрал, так как у Ћарисы испортилс€ отчет по субсидированию г.в. и отоп.
--                l_kprz:=0;
--                l_kpro:=0;
                    l_norm:=l_norm-l_vol;
                    l_vol:=0;
                  elsif l_norm >0 and l_norm <=l_vol then
                    --по норме
--                    ins_chrg2(l_norm*l_sign, rec_wo_peop.cena, null, usl_, c.sch, c.kpr, c.kprz, c.kpro, null); --жесть
                    ins_chrg2(l_norm*l_sign, rec_wo_peop.cena, null, usl_, c.sch, l_kpr, l_kprz, l_kpro, null); --жесть (убрал неправильно считающеес€ кол-во прож по канализ)
--                l_kpr:=0; -убрал, так как у Ћарисы испортилс€ отчет по субсидированию г.в. и отоп.
--                l_kprz:=0;
--                l_kpro:=0;
                    l_vol:=l_vol-l_norm;
                    l_norm:=0;
                  end if;
                end loop;
                if l_vol > 0 and rec_nabor.usl_p is not null then --добавил, если rec_nabor.usl_p - не пуста€... 13.04.2015
                  --свыше соцнормы
                  OPEN cur_wo_peop(rec_nabor.usl_p);
                  FETCH cur_wo_peop
                    INTO rec_wo_peop;
                  CLOSE cur_wo_peop;
--                  ins_chrg2(l_vol*l_sign, rec_wo_peop.cena, null, rec_nabor.usl_p, c.sch, c.kpr, c.kprz, c.kpro, null); --жесть
                  ins_chrg2(l_vol*l_sign, rec_wo_peop.cena, null, rec_nabor.usl_p, c.sch, l_kpr, l_kprz, l_kpro, null); --жесть (убрал неправильно считающеес€ кол-во прож по канализ)
                  l_kpr:=0;
                  l_kprz:=0;
                  l_kpro:=0;
                  l_vol:=0;
                end if;
              elsif c.empty = 1 then
                --расчет дл€ пустой квартиры
                OPEN cur_nabor2(rec_nabor.usl_empt);
                FETCH cur_nabor2
                  INTO rec_nabor2;
                if cur_nabor2%NOTFOUND then
                  --ќ ј«џ¬ј≈“—я Ќјƒќ Ќ”Ћ»“№
                  rec_nabor2.usl:=null;
                end if;
                CLOSE cur_nabor2;

                if rec_nabor2.usl is not null then
                  --есть выделенна€ услуга "без проживающих"
                  OPEN cur_wo_peop(rec_nabor.usl_empt);
                  FETCH cur_wo_peop
                    INTO rec_wo_peop;
                  CLOSE cur_wo_peop;
--                  ins_chrg2(c.vol, rec_wo_peop.cena, null, rec_nabor2.usl, c.sch, c.kpr, c.kprz, c.kpro, null); --жесть
                  ins_chrg2(c.vol, rec_wo_peop.cena, null, rec_nabor2.usl, c.sch, null, null, null, null); --жесть (убрал неправильно считающеес€ кол-во прож по канализ)
                  else
                  --нет выделенной услуги "без проживающих", ищем по свыше с.н.
                  --расчет дл€ пустой квартиры
                  OPEN cur_wo_peop(rec_nabor.usl_p);
                  FETCH cur_wo_peop
                    INTO rec_wo_peop;
                  CLOSE cur_wo_peop;
--                    ins_chrg2(c.vol, rec_wo_peop.cena, null, rec_nabor.usl_p, c.sch, c.kpr, c.kprz, c.kpro, null); --жесть
                    ins_chrg2(c.vol, rec_wo_peop.cena, null, rec_nabor.usl_p, c.sch, null, null, null, null); --жесть (убрал неправильно считающеес€ кол-во прож по канализ)

                end if;
              end if;
            end loop;

          END IF;


          --||||||||||||||||||||||||||||||||||||||--
            --”—Ћ”√ј (”—“ј–≈¬Ўјя)
            --»—ѕќЋ№«”≈“—я в ѕолыс, в “—∆
            --сначала по нормативу считаем (это Ќ≈ в любом случае идЄт по соц.норме, например если
            --распределитс€ по дому много)
          IF (rec_nabor.chrg1 <> 0 OR rec_nabor.chrg2 <> 0) AND rec_nabor.fk_calc_tp IN (5) THEN --#5#
            socn_kub_ := 0;
            kan_      := 0;
            OPEN cur_wo_peop(null);
            FETCH cur_wo_peop
              INTO rec_wo_peop;
            CLOSE cur_wo_peop;

            OPEN cur_prep;
            FETCH cur_prep
              INTO rec_prep;
            CLOSE cur_prep;

            --сколько кубов по соцнорме допустимо
            socn_kub_ := round(rec_prep.nrm_kpr * rec_wo_peop.tarnorm, 3);
            --общий расход
            kan_ := hv_kan_nrm_ + hv_kan_sch_ + gv_kan_nrm_ + gv_kan_sch_;
            --≈сли расход отрицательный то...
            IF kan_ >= 0 THEN
              sign_kub_ := 1;
            ELSE
              sign_kub_ := -1;
            END IF;
            kan_ := abs(kan_);
            --соцнорма
            IF kan_ <= socn_kub_ THEN
              ins_chrg(npp_,
                       rec_krt.lsk,
                       sign_kub_,
                       usl_,
                       kan_,
                       rec_wo_peop.cena,
                       sit_,
                       msit_,
                       CASE
                         WHEN gv_kan_sch_ <> 0 OR hv_kan_sch_ <> 0 THEN
                          1
                         ELSE
                          0
                       END /*временна€ конструкци€*/);
            ELSE
              ins_chrg(npp_,
                       rec_krt.lsk,
                       sign_kub_,
                       usl_,
                       socn_kub_,
                       rec_wo_peop.cena,
                       sit_,
                       msit_,
                       CASE WHEN gv_kan_sch_ <> 0 OR hv_kan_sch_ <> 0 THEN 1 ELSE 0 END /*временна€ конструкци€*/);
              IF rec_nabor.chrg2 <> 0 THEN
                --свыше с.нормы
                usl_ := rec_nabor.usl_p;
                OPEN cur_wo_peop(null);
                FETCH cur_wo_peop
                  INTO rec_wo_peop;
                CLOSE cur_wo_peop;
                ins_chrg(npp_,
                         rec_krt.lsk,
                         sign_kub_,
                         usl_,
                         kan_ - socn_kub_,
                         rec_wo_peop.cena,
                         sit_,
                         msit_,
                         CASE WHEN gv_kan_sch_ <> 0 OR hv_kan_sch_ <> 0 THEN 1 ELSE 0 END /*временна€ конструкци€*/);
              END IF;
            END IF;
          END IF;
          --||||||||||||||||||||||||||||||||||||||--
          --”—Ћ”√ј — –ј—÷≈Ќ ќ… ƒЋя ѕ”—“џ’  ¬ј–“»–
          -- холодна€, гор€ча€ вода /ревизи€ дл€ кис. от 01.03.2014/
          IF rec_nabor.chrg1 <> 0 AND rec_nabor.fk_calc_tp IN (17,18) THEN --#17#18#
            OPEN cur_wo_peop(null);
            FETCH cur_wo_peop
              INTO rec_wo_peop;
            CLOSE cur_wo_peop;
            --сохранить расценку
            l_cena:=rec_wo_peop.cena;
            --сохранить дл€ повыш.коэфф.
            /*if rec_nabor.usl_cd = 'х.вода' then
              --сохранить дл€ повыш.коэфф. ’.¬.
              l_hw_dist_tp:=rec_wo_peop.dist_tp;
            elsif rec_nabor.usl_cd = 'г.вода' then
              --сохранить дл€ повыш.коэфф. √.¬.
              l_gw_dist_tp:=rec_wo_peop.dist_tp;
            end if;*/
            
            for c in cur_charge_prep(null, null)
            loop
              if c.empty = 0 then
                --расчет дл€ не пустой квартиры
                ins_chrg2(c.vol, rec_wo_peop.cena, null, usl_, c.sch, c.kpr, c.kprz, c.kpro, null);
              elsif c.empty = 1 then
                --расчет дл€ пустой квартиры
                OPEN cur_nabor2(rec_nabor.usl_p);
                FETCH cur_nabor2
                  INTO rec_nabor2;
                if cur_nabor2%NOTFOUND then
                  --ќ ј«џ¬ј≈“—я Ќјƒќ Ќ”Ћ»“№
                  rec_nabor2.usl:=null;
                end if;
                CLOSE cur_nabor2;
--                if rec_krt.status <> 1 then
                --Ѕыло:дл€ не муниципальных квартир, расценка как дл€ пустых квартир
                --ред.21.08.14 -сделал и по муницип расенку как дл€ пустых приватизир.
                  l_cena:=rec_wo_peop.cena_for_empty;
--                end if;
                if rec_nabor2.usl is not null then
                  --есть выделенна€ услуга "без проживающих"
                  ins_chrg2(c.vol, l_cena, null, rec_nabor2.usl, c.sch, c.kpr, c.kprz, c.kpro, null);
                  else
                  --нет выделенной услуги "без проживающих", ставим на ту же услугу
                  ins_chrg2(c.vol, l_cena, null, usl_, c.sch, c.kpr, c.kprz, c.kpro, null);
                end if;
              end if;
            end loop;
          END IF;
          --||||||||||||||||||||||||||||||||||||||--
          --”—Ћ”√ј — –ј—÷≈Ќ ќ… ƒЋя ѕ”—“џ’  ¬ј–“»–
          -- канализование /ревизи€ дл€ кис. от 01.03.2014/
          IF (rec_nabor.chrg1 <> 0 OR rec_nabor.chrg2 <> 0) AND rec_nabor.fk_calc_tp IN (19) THEN --#19#
            OPEN cur_wo_peop(null);
            FETCH cur_wo_peop
              INTO rec_wo_peop;
            CLOSE cur_wo_peop;
            --сохранить расценку
            l_cena:=rec_wo_peop.cena;
            i:=0;
            for c in cur_charge_prep_usl_cd('х.вода,г.вода,х.в. дл€ гвс')
            loop
              if c.empty = 0 then
                --расчет дл€ не пустой квартиры
                if i=0 then
                --только один раз установить кол-во проживающих
                  for c2 in cur_charge_prep_kpr
                  loop
                    ins_chrg2(c.vol, rec_wo_peop.cena, null, usl_, c.sch, c2.kpr, c2.kprz, c2.kpro, null);
                  end loop;
                  i:=1;
                else
                  ins_chrg2(c.vol, rec_wo_peop.cena, null, usl_, c.sch, null, null, null, null);
                end if;
              elsif c.empty = 1 then
                --расчет дл€ пустой квартиры
                OPEN cur_nabor2(rec_nabor.usl_p);
                FETCH cur_nabor2
                  INTO rec_nabor2;
                if cur_nabor2%NOTFOUND then
                  --ќ ј«џ¬ј≈“—я Ќјƒќ Ќ”Ћ»“№
                  rec_nabor2.usl:=null;
                end if;
                CLOSE cur_nabor2;
--                if rec_krt.status <> 1 then
                --Ѕыло:дл€ не муниципальных квартир, расценка как дл€ пустых квартир
                --ред.21.08.14 -сделал и по муницип расенку как дл€ пустых приватизир.
                l_cena:=rec_wo_peop.cena_for_empty;
--                end if;
                if rec_nabor2.usl is not null then
                  --есть выделенна€ услуга "без проживающих"
                  ins_chrg2(c.vol, l_cena, null, rec_nabor2.usl, c.sch, null, null, null, null);
                  else
                  --нет выделенной услуги "без проживающих", ставим на ту же услугу
                  ins_chrg2(c.vol, l_cena, null, usl_, c.sch, null, null, null, null);
                end if;
              end if;
            end loop;

          END IF;
          --||||||||||||||||||||||||||||||||||||||--
          --”—Ћ”√ј — –ј—÷≈Ќ ќ… ƒЋя ѕ”—“џ’  ¬ј–“»–
          -- электроэнерги€ - едина€ услуга  /ревизи€ дл€ кис. от 01.03.2014/
          IF (rec_nabor.chrg1 <> 0 OR rec_nabor.chrg2 <> 0) AND rec_nabor.fk_calc_tp IN (31) THEN --#31#
            OPEN cur_wo_peop(null);
            FETCH cur_wo_peop
              INTO rec_wo_peop;
            CLOSE cur_wo_peop;
            --сохранить расценку
            l_cena:=rec_wo_peop.cena;
            --сохранить дл€ повыш.коэфф.
            --l_el_dist_tp:=rec_wo_peop.dist_tp;

            for c in cur_charge_prep(null, null)
            loop
              if c.empty = 0 then
                --расчет дл€ не пустой квартиры
                ins_chrg2(c.vol, rec_wo_peop.cena, null, usl_, c.sch, c.kpr, c.kprz, c.kpro, null);
              elsif c.empty = 1 then
                --расчет дл€ пустой квартиры
                OPEN cur_nabor2(rec_nabor.usl_p);
                FETCH cur_nabor2
                  INTO rec_nabor2;
                if cur_nabor2%NOTFOUND then
                  --ќ ј«џ¬ј≈“—я Ќјƒќ Ќ”Ћ»“№
                  rec_nabor2.usl:=null;
                end if;
                CLOSE cur_nabor2;
                if rec_krt.status <> 1 then
                --дл€ не муниципальных квартир, расценка как дл€ пустых квартир
                  l_cena:=rec_wo_peop.cena_for_empty;
                end if;

                if rec_nabor2.usl is not null then
                  --есть выделенна€ услуга "без проживающих"
                  ins_chrg2(c.vol, l_cena, null, rec_nabor2.usl, c.sch, c.kpr, c.kprz, c.kpro, null);
                  else
                  --нет выделенной услуги "без проживающих", ставим на ту же услугу
                  ins_chrg2(c.vol, l_cena, null, usl_, c.sch, c.kpr, c.kprz, c.kpro, null);
                end if;
              end if;
            end loop;
          END IF;
          --||||||||||||||||||||||||||||||||||||||--
          -- холодна€ вода - доначисление по 354 /ревизи€ дл€ ” , где услуга ќƒЌ отдельной строкой/
           IF (rec_nabor.chrg1 <> 0 OR rec_nabor.chrg2 <> 0) AND
             rec_nabor.fk_calc_tp IN (20) THEN --#20#
            OPEN cur_wo_peop(null);
            FETCH cur_wo_peop
              INTO rec_wo_peop;
            CLOSE cur_wo_peop;
            --сохранить расценку
            l_cena:=rec_wo_peop.cena;

            for c in cur_charge_prep(null, null)
            loop
              if c.empty = 0 then
                --расчет дл€ не пустой квартиры
                ins_chrg2(c.vol, rec_wo_peop.cena, null, usl_, c.sch, c.kpr, c.kprz, c.kpro, null);
              elsif c.empty = 1 then
                --расчет дл€ пустой квартиры
                OPEN cur_nabor2(rec_nabor.usl_p);
                FETCH cur_nabor2
                  INTO rec_nabor2;
                if cur_nabor2%NOTFOUND then
                  --ќ ј«џ¬ј≈“—я Ќјƒќ Ќ”Ћ»“№
                  rec_nabor2.usl:=null;
                end if;
                CLOSE cur_nabor2;
                --if rec_krt.status <> 1 then
                --Ѕыло:дл€ не муниципальных квартир, расценка как дл€ пустых квартир
                --ред.21.08.14 -сделал и по муницип расенку как дл€ пустых приватизир.
                  l_cena:=rec_wo_peop.cena_for_empty;
                --end if;
                if rec_nabor2.usl is not null then
                  --есть выделенна€ услуга "без проживающих"
                  ins_chrg2(c.vol, l_cena, null, rec_nabor2.usl, c.sch, c.kpr, c.kprz, c.kpro, null);
                  else
                  --нет выделенной услуги "без проживающих", ставим на ту же услугу
                  ins_chrg2(c.vol, l_cena, null, usl_, c.sch, c.kpr, c.kprz, c.kpro, null);
                end if;
              end if;
            end loop;
/*
            hv_kan_add_ := 0;
            OPEN cur_wo_peop(null);
            FETCH cur_wo_peop
              INTO rec_wo_peop;
            CLOSE cur_wo_peop;
            hv_kan_add_ := nvl(rec_nabor.vol_add,0); --расход по х.в. ќƒЌ дл€ канализ. ќƒЌ
            ins_chrg2(rec_nabor.vol_add, rec_wo_peop.cena, null, usl_);*/

          END IF;
          --||||||||||||||||||||||||||||||||||||||--
          -- гор€ча€ вода - доначисление по 354 /ревизи€ дл€ ” , где услуга ќƒЌ отдельной строкой/
          IF (rec_nabor.chrg1 <> 0 OR rec_nabor.chrg2 <> 0) AND
             rec_nabor.fk_calc_tp IN (21) THEN --#21#
            OPEN cur_wo_peop(null);
            FETCH cur_wo_peop
              INTO rec_wo_peop;
            CLOSE cur_wo_peop;
            --сохранить расценку
            l_cena:=rec_wo_peop.cena;

            for c in cur_charge_prep(null, null)
            loop
              if c.empty = 0 then
                --расчет дл€ не пустой квартиры
                ins_chrg2(c.vol, rec_wo_peop.cena, null, usl_, c.sch, c.kpr, c.kprz, c.kpro, null);
              elsif c.empty = 1 then
                --расчет дл€ пустой квартиры
                OPEN cur_nabor2(rec_nabor.usl_p);
                FETCH cur_nabor2
                  INTO rec_nabor2;
                if cur_nabor2%NOTFOUND then
                  --ќ ј«џ¬ј≈“—я Ќјƒќ Ќ”Ћ»“№
                  rec_nabor2.usl:=null;
                end if;
                CLOSE cur_nabor2;
--                if rec_krt.status <> 1 then
                --Ѕыло:дл€ не муниципальных квартир, расценка как дл€ пустых квартир
                --ред.21.08.14 -сделал и по муницип расенку как дл€ пустых приватизир.
                  l_cena:=rec_wo_peop.cena_for_empty;
--                end if;
                if rec_nabor2.usl is not null then
                  --есть выделенна€ услуга "без проживающих"
                  ins_chrg2(c.vol, l_cena, null, rec_nabor2.usl, c.sch, c.kpr, c.kprz, c.kpro, null);
                  else
                  --нет выделенной услуги "без проживающих", ставим на ту же услугу
                  ins_chrg2(c.vol, l_cena, null, usl_, c.sch, c.kpr, c.kprz, c.kpro, null);
                end if;
              end if;
            end loop;
/*
            gv_kan_add_ := 0;
            OPEN cur_wo_peop(null);
            FETCH cur_wo_peop
              INTO rec_wo_peop;
            CLOSE cur_wo_peop;
            gv_kan_add_ := nvl(rec_nabor.vol_add,0); --расход по г.в. ќƒЌ дл€ канализ. ќƒЌ
            ins_chrg2(rec_nabor.vol_add, rec_wo_peop.cena, null, usl_);*/
          END IF;

          -- холодна€ вода - доначисление по 354 ƒЋя “—∆ /ревизи€ дл€ ” , где услуга ќƒЌ отдельной строкой/
           IF (rec_nabor.chrg1 <> 0 OR rec_nabor.chrg2 <> 0) AND
             rec_nabor.fk_calc_tp IN (41) THEN --#20#
            OPEN cur_wo_peop(null);
            FETCH cur_wo_peop
              INTO rec_wo_peop;
            CLOSE cur_wo_peop;
            --сохранить расценку
            l_cena:=rec_wo_peop.cena;

            for c in cur_charge_prep(null, null)
            loop
              if c.empty = 0 then
                --расчет дл€ не пустой квартиры
                ins_chrg2(c.vol, rec_wo_peop.cena, null, usl_, c.sch, c.kpr, c.kprz, c.kpro, null);
              elsif c.empty = 1 then
                --расчет дл€ пустой квартиры
                OPEN cur_nabor2(rec_nabor.usl_empt);
                FETCH cur_nabor2
                  INTO rec_nabor2;
                if cur_nabor2%NOTFOUND then
                  --ќ ј«џ¬ј≈“—я Ќјƒќ Ќ”Ћ»“№
                  rec_nabor2.usl:=null;
                end if;
                CLOSE cur_nabor2;
                  l_cena:=rec_wo_peop.cena_for_empty;
                if rec_nabor2.usl is not null then
                  --есть выделенна€ услуга "без проживающих"
                  ins_chrg2(c.vol, l_cena, null, rec_nabor2.usl, c.sch, c.kpr, c.kprz, c.kpro, null);
                  else
                  --нет выделенной услуги "без проживающих", ставим на ту же услугу
                  ins_chrg2(c.vol, l_cena, null, usl_, c.sch, c.kpr, c.kprz, c.kpro, null);
                end if;
              end if;
            end loop;

          END IF;
          --||||||||||||||||||||||||||||||||||||||--
          -- гор€ча€ вода - доначисление по 354  ƒЋя “—∆ /ревизи€ дл€ ” , где услуга ќƒЌ отдельной строкой/
          IF (rec_nabor.chrg1 <> 0 OR rec_nabor.chrg2 <> 0) AND
             rec_nabor.fk_calc_tp IN (42) THEN --#42#
            OPEN cur_wo_peop(null);
            FETCH cur_wo_peop
              INTO rec_wo_peop;
            CLOSE cur_wo_peop;
            --сохранить расценку
            l_cena:=rec_wo_peop.cena;

            for c in cur_charge_prep(null, null)
            loop
              if c.empty = 0 then
                --расчет дл€ не пустой квартиры
                ins_chrg2(c.vol, rec_wo_peop.cena, null, usl_, c.sch, c.kpr, c.kprz, c.kpro, null);
              elsif c.empty = 1 then
                --расчет дл€ пустой квартиры
                OPEN cur_nabor2(rec_nabor.usl_empt);
                FETCH cur_nabor2
                  INTO rec_nabor2;
                if cur_nabor2%NOTFOUND then
                  --ќ ј«џ¬ј≈“—я Ќјƒќ Ќ”Ћ»“№
                  rec_nabor2.usl:=null;
                end if;
                CLOSE cur_nabor2;
                  l_cena:=rec_wo_peop.cena;
                if rec_nabor2.usl is not null then
                  --есть выделенна€ услуга "без проживающих"
                  ins_chrg2(c.vol, l_cena, null, rec_nabor2.usl, c.sch, c.kpr, c.kprz, c.kpro, null);
                  else
                  --нет выделенной услуги "без проживающих", ставим на ту же услугу
                  ins_chrg2(c.vol, l_cena, null, usl_, c.sch, c.kpr, c.kprz, c.kpro, null);
                end if;
              end if;
            end loop;
/*
            gv_kan_add_ := 0;
            OPEN cur_wo_peop(null);
            FETCH cur_wo_peop
              INTO rec_wo_peop;
            CLOSE cur_wo_peop;
            gv_kan_add_ := nvl(rec_nabor.vol_add,0); --расход по г.в. ќƒЌ дл€ канализ. ќƒЌ
            ins_chrg2(rec_nabor.vol_add, rec_wo_peop.cena, null, usl_);*/
          END IF;

          --||||||||||||||||||||||||||||||||||||||--
          --”—Ћ”√ј ѕќ ѕќ¬џЎјёў»ћ  ќЁ‘‘.   Ќќ–ћј“»¬јћ ѕќ ѕ.344. ”—Ћ”√ј “ќЋ№ ќ ƒЋя Ќќ–ћј“»¬ў» ќ¬!!!
          -- холодна€, гор€ча€ вода
          --¬Ќ»ћјЌ»≈! соблюдать очередность расчета usl.usl_order! --считать услугу “ќЋ№ ќ после родительской!
          IF rec_nabor.chrg1 <> 0 AND rec_nabor.fk_calc_tp IN (44) THEN --#44#
            OPEN cur_wo_peop(null);
            FETCH cur_wo_peop
              INTO rec_wo_peop;
            CLOSE cur_wo_peop;
            for c in cur_charge_prep(rec_nabor.parent_usl, null)
            loop
              if c.sch = 0 then
                --интересует только ќ“—”“—“¬»≈ счетчика 
                --¬Ќ»ћјЌ»≈! по этой услуге, в nabor.norm находитс€  ќЁ‘‘ к потреблЄнному расходу родительской услуги!
                ins_chrg2(c.vol_nrm * rec_wo_peop.tarnorm, rec_wo_peop.cena, null, usl_, c.sch, c.kpr, c.kprz, c.kpro, null);
              end if;
            end loop;
          END IF;
          --||||||||||||||||||||||||||||||||||||||--
          --||||||||||||||||||||||||||||||||||||||--
          --”—Ћ”√ј ѕќ ѕќ¬џЎјёў»ћ  ќЁ‘‘.   Ќќ–ћј“»¬јћ ѕќ ѕ.344.
          --ќƒЌ холодна€, ќƒЌ гор€ча€ вода
          --¬Ќ»ћјЌ»≈! соблюдать очередность расчета usl.usl_order! --считать услугу “ќЋ№ ќ после родительской!
          IF rec_nabor.chrg1 <> 0 AND rec_nabor.fk_calc_tp IN (45) THEN --#45#
            OPEN cur_wo_peop(null);
            FETCH cur_wo_peop
              INTO rec_wo_peop;
            CLOSE cur_wo_peop;
            for c in cur_charge_prep(rec_nabor.parent_usl, null)
            loop
              --интересует только ќ“—”“—“¬»≈ счетчика на ƒќћ≈ с возможностью его установки
              --¬Ќ»ћјЌ»≈! по этой услуге, в nabor.norm находитс€  ќЁ‘‘ к потреблЄнному расходу родительской услуги!
                select decode(rec_nabor.usl_cd, '’¬—_одн_доб', 'х.вода', '√¬—_одн_доб', 'г.вода', 'ЁЋ_одн_доб', 'эл.энерг.2', null) into l_str from dual;
                for c2 in cur_vvod_tp(l_str)
                loop
                if rec_nabor.usl_cd = '’¬—_одн_доб' and c2.dist_tp=4 or 
                   rec_nabor.usl_cd = '√¬—_одн_доб' and c2.dist_tp=4 or
                   rec_nabor.usl_cd = 'ЁЋ_одн_доб' and c2.dist_tp=4 then
                  ins_chrg2(c.vol_nrm * rec_wo_peop.tarnorm, rec_wo_peop.cena, null, usl_, c.sch, c.kpr, c.kprz, c.kpro, null);
                end if;
              end loop;
            end loop;
          END IF;
          --||||||||||||||||||||||||||||||||||||||--

          --||||||||||||||||||||||||||||||||||||||--
          --”—Ћ”√ј ѕќ ѕќ¬џЎјёў»ћ  ќЁ‘‘.   Ќќ–ћј“»¬јћ ѕќ ѕ.344.
          --отопление
          --¬Ќ»ћјЌ»≈! соблюдать очередность расчета usl.usl_order! --считать услугу “ќЋ№ ќ после родительской!
          IF rec_nabor.chrg1 <> 0 AND rec_nabor.fk_calc_tp IN (46) THEN --#46#
            OPEN cur_wo_peop(null);
            FETCH cur_wo_peop
              INTO rec_wo_peop;
            CLOSE cur_wo_peop;
            for c in cur_charge_prep_usl_cd('отоп.гкал.,отоп.гкал./0 зарег.')
            loop
              --интересует только ќ“—”“—“¬»≈ счетчика на ƒќћ≈ с возможностью его установки
              --¬Ќ»ћјЌ»≈! по этой услуге, в nabor.norm находитс€  ќЁ‘‘ к потреблЄнному расходу родительской услуги!
              if rec_nabor.usl_cd = 'ќтоп.гкал_инд_доб' and l_ot_dist_tp=4 then
                ins_chrg2(c.vol_nrm * rec_wo_peop.tarnorm, rec_wo_peop.cena, null, usl_, c.sch, null, null, null, null);
              end if;
            end loop;
          END IF;

          --||||||||||||||||||||||||||||||||||||||--
          --”—Ћ”√ј — –ј—÷≈Ќ ќ… ƒЋя ѕ”—“џ’  ¬ј–“»–
          -- “епл.энерги€ дл€ нагрева ’¬—/ревизи€ дл€ кис. от 24.03.2015/
          IF rec_nabor.chrg1 <> 0 AND rec_nabor.fk_calc_tp IN (47) THEN --#47#

            --получить код услуги ’.¬. дл€ √¬—
            select u.usl into l_tmp_usl 
              from usl u where u.cd='х.в. дл€ гвс';
            OPEN cur_wo_peop(l_tmp_usl);
            FETCH cur_wo_peop
              INTO rec_wo_peop;
            CLOSE cur_wo_peop;
            --получить по дому объем ’.¬. дл€ √¬—
            l_tmp_vol:=rec_wo_peop.kub;

            OPEN cur_wo_peop(null);
            FETCH cur_wo_peop
              INTO rec_wo_peop;
            CLOSE cur_wo_peop;
            --сохранить расценку
            l_cena:=rec_wo_peop.cena;
            i:=0;
            for c in cur_charge_prep_usl_cd('х.в. дл€ гвс')
            loop
              if rec_wo_peop.kub <> 0 and l_tmp_vol <> 0 then  
               --рассчитать, как объем ’.¬. дл€ √¬— в квартире / объем ’.¬. дл€ √¬— по дому * расход по дому тепл.энергии в √кал
                l_vol:=c.vol/l_tmp_vol * rec_wo_peop.kub;
              else
                --выйти из цикла, считать нечего
                exit;
              end if;  
              
              if c.empty = 0 then
                --расчет дл€ не пустой квартиры
                if i=0 then
                --только один раз установить кол-во проживающих
                  for c2 in cur_charge_prep_kpr
                  loop
                    ins_chrg2(l_vol, rec_wo_peop.cena, null, usl_, c.sch, c2.kpr, c2.kprz, c2.kpro, null);
                  end loop;
                  i:=1;
                else
                  ins_chrg2(l_vol, rec_wo_peop.cena, null, usl_, c.sch, null, null, null, null);
                end if;
              elsif c.empty = 1 then
                --расчет дл€ пустой квартиры
                OPEN cur_nabor2(rec_nabor.usl_p);
                FETCH cur_nabor2
                  INTO rec_nabor2;
                if cur_nabor2%NOTFOUND then
                  --ќ ј«џ¬ј≈“—я Ќјƒќ Ќ”Ћ»“№
                  rec_nabor2.usl:=null;
                end if;
                CLOSE cur_nabor2;
                l_cena:=rec_wo_peop.cena_for_empty;
                if rec_nabor2.usl is not null then
                  --есть выделенна€ услуга "без проживающих"
                  ins_chrg2(l_vol, l_cena, null, rec_nabor2.usl, c.sch, null, null, null, null);
                  else
                  --нет выделенной услуги "без проживающих", ставим на ту же услугу
                  ins_chrg2(l_vol, l_cena, null, usl_, c.sch, null, null, null, null);
                end if;
              end if;
            end loop;

          END IF;
          --||||||||||||||||||||||||||||||||||||||--

          --||||||||||||||||||||||||||||||||||||||--
          -- очистка выгр.€м (полыс)
          IF (rec_nabor.chrg1 <> 0 OR rec_nabor.chrg2 <> 0) AND
	             rec_nabor.fk_calc_tp = 6 THEN --#6#
            --должны быть проживающие!
            OPEN cur_prep;
            FETCH cur_prep
              INTO rec_prep;
            CLOSE cur_prep;
            if rec_prep.kpr > 0 then
              OPEN cur_wo_peop(null);
              FETCH cur_wo_peop
                INTO rec_wo_peop;
              CLOSE cur_wo_peop;
              l_cena:=rec_wo_peop.cena;
              if l_cena <> 0 then
                ins_chrg2(rec_prep.kpr2, l_cena, null, usl_, null, rec_prep.kpr, null, null, null);
              end if;
            end if;
          END IF;
          --||||||||||||||||||||||||||||||||||||||--
          -- Ќайм (только по муниципальным квартирам)
          IF (rec_nabor.chrg1 <> 0 OR rec_nabor.chrg2 <> 0) AND
             rec_nabor.fk_calc_tp in (7) AND rec_krt.status = 1 THEN --#7#
            --необ€зательны проживающие, рассчЄт на м2
            OPEN cur_prep;
            FETCH cur_prep
              INTO rec_prep;
            CLOSE cur_prep;
            OPEN cur_wo_peop(null);
            FETCH cur_wo_peop
              INTO rec_wo_peop;
            CLOSE cur_wo_peop;
            l_cena:=rec_wo_peop.cena;
            if l_cena <> 0 then
              ins_chrg2(rec_krt.opl, l_cena, null, usl_, null, rec_prep.kpr, null, null, null);
            end if;
          END IF;
          --||||||||||||||||||||||||||||||||||||||--
          -- ”слуги ≈– ÷
          IF (rec_nabor.chrg1 <> 0 OR rec_nabor.chrg2 <> 0) AND
             rec_nabor.fk_calc_tp in (8) THEN --#7#
            --необ€зательны проживающие, рассчЄт на м2
            OPEN cur_prep;
            FETCH cur_prep
              INTO rec_prep;
            CLOSE cur_prep;
            OPEN cur_wo_peop(null);
            FETCH cur_wo_peop
              INTO rec_wo_peop;
            CLOSE cur_wo_peop;
            l_cena:=rec_wo_peop.cena;
            if l_cena <> 0 then
              ins_chrg2(rec_prep.kpr, l_cena, null, usl_, null, rec_prep.kpr, null, null, null);
            end if;
          END IF;

          --||||||||||||||||||||||||||||||||||||||--
          -- Ёл.энерги€
          IF (rec_nabor.chrg1 <> 0 OR rec_nabor.chrg2 <> 0) AND
             rec_nabor.fk_calc_tp = 9 THEN --#9#
            IF round(rec_krt.el1, 2) <> 0 THEN
              --со льготой
              --            sit_ := sit_ + round(rec_krt.el1, 2);
              OPEN cur_wo_peop(null);
              FETCH cur_wo_peop
                INTO rec_wo_peop;
              npp_    := npp_ + 1;
              summaf_ := rec_krt.el1;
              summa_  := round(summaf_, 2);
              INSERT INTO c_charge
                (npp, lsk, usl, summa, summaf, kart_pr_id, TYPE, spk_id, test_opl, test_cena, test_tarkoef, test_spk_koef)
              VALUES
                (0, rec_krt.lsk, usl_, summa_, summaf_, NULL, 0, NULL, NULL, rec_wo_peop.cena, NULL, NULL);
              --без льготы
              --            msit_ := msit_ + round(rec_krt.el1, 2);
              summaf_ := rec_krt.el1;
              summa_  := round(summaf_, 2);
              INSERT INTO c_charge
                (npp, lsk, usl, summa, summaf, kart_pr_id, TYPE, spk_id, test_opl, test_cena, test_tarkoef, test_spk_koef)
              VALUES
                (npp_, rec_krt.lsk, usl_, summa_, summaf_, NULL, 1, NULL, NULL, rec_wo_peop.cena, NULL, NULL);
              CLOSE cur_wo_peop;
            END IF;
          END IF;
          --||||||||||||||||||||||||||||||||||||||--
          -- Ёл.энерги€ субсиди
          IF (rec_nabor.chrg1 <> 0 OR rec_nabor.chrg2 <> 0) AND
             rec_nabor.fk_calc_tp = 10 THEN --#10#

            Raise_application_error(-20000, 'Ќе работает услуга!!!');
/*            IF round(rec_krt.el, 2) <> 0 THEN
              --со льготой
              npp_    := npp_ + 1;
              sit_    := sit_ + round(rec_krt.el * rec_wo_peop.usl_subs, 2);
              summaf_ := rec_krt.el;
              summa_  := round(summaf_, 2);
              INSERT INTO c_charge
                (npp, lsk, usl, summa, summaf, kart_pr_id, TYPE, spk_id, test_opl, test_cena, test_tarkoef, test_spk_koef)
              VALUES
                (0, rec_krt.lsk, usl_, summa_, summaf_, NULL, 0, NULL, NULL, rec_peoples.cena, NULL, NULL);
              --без льготы
              msit_   := msit_ +
                         round(rec_krt.el * rec_wo_peop.usl_subs, 2);
              summaf_ := rec_krt.el;
              summa_  := round(summaf_, 2);
              INSERT INTO c_charge
                (npp, lsk, usl, summa, summaf, kart_pr_id, TYPE, spk_id, test_opl, test_cena, test_tarkoef, test_spk_koef)
              VALUES
                (npp_, rec_krt.lsk, usl_, summa_, summaf_, NULL, 1, NULL, NULL, rec_peoples.cena, NULL, NULL);
            END IF; */
          END IF;
          --||||||||||||||||||||||||||||||||||||||--
          -- ”слуги – ÷ ∆ ’
          -- не важно есть люди или нет
          --        if (rec_nabor.chrg1 <> 0 or rec_nabor.chrg2 <> 0) and usl_ = '032' then
          IF (rec_nabor.chrg1 <> 0 OR rec_nabor.chrg2 <> 0) AND
             rec_nabor.fk_calc_tp = 11 THEN --#11#
            OPEN cur_wo_peop(null);
            FETCH cur_wo_peop
              INTO rec_wo_peop;
            IF round(rec_wo_peop.tarkoef, 2) <> 0 THEN
              npp_ := npp_ + 1;
              --со льготой
              --             sit_ := sit_ + round(rec_wo_peop.tarkoef, 2); --уже готова€ сумма здесь
              summaf_ := rec_wo_peop.tarkoef;
              summa_  := round(summaf_, 2);
              INSERT INTO c_charge
                (npp, lsk, usl, summa, summaf, kart_pr_id, TYPE, spk_id, test_opl, test_cena, test_tarkoef, test_spk_koef)
              VALUES
                (0, rec_krt.lsk, usl_, summa_, summaf_, NULL, 0, NULL, NULL, rec_wo_peop.cena, rec_wo_peop.tarkoef, NULL);
              --без льготы
              --             msit_ := msit_ + round(rec_wo_peop.tarkoef, 2);
              summaf_ := rec_wo_peop.tarkoef;
              summa_  := round(summaf_, 2);
              INSERT INTO c_charge
                (npp, lsk, usl, summa, summaf, kart_pr_id, TYPE, spk_id, test_opl, test_cena, test_tarkoef, test_spk_koef)
              VALUES
                (npp_, rec_krt.lsk, usl_, summa_, summaf_, NULL, 1, NULL, NULL, rec_wo_peop.cena, rec_wo_peop.tarkoef, NULL);
            END IF;
            CLOSE cur_wo_peop;
          END IF;
          --||||||||||||||||||||||||||||||||||||||--
          -- Ёл.энерг в киловаттах, распредел€ема€ на дом (дл€ “—∆)
          -- не важно есть люди или нет
          IF (rec_nabor.chrg1 <> 0 OR rec_nabor.chrg2 <> 0) AND
             rec_nabor.fk_calc_tp IN (15) THEN --#15#
            OPEN cur_wo_peop(null);
            FETCH cur_wo_peop
              INTO rec_wo_peop;
            IF round(rec_wo_peop.tarkoef, 2) <> 0 THEN
              npp_ := npp_ + 1;
              --со льготой
              summaf_ := nvl(rec_nabor.vol, 0) * rec_wo_peop.cena;
              summa_  := round(summaf_, 2);
              INSERT INTO c_charge
                (npp, lsk, usl, summa, summaf, kart_pr_id, TYPE, spk_id, test_opl, test_cena, test_tarkoef, test_spk_koef)
              VALUES
                (0, rec_krt.lsk, usl_, summa_, summaf_, NULL, 0, NULL, round(rec_nabor.vol,
                        2), rec_wo_peop.cena, rec_wo_peop.tarkoef, NULL);
              --без льготы
              summaf_ := nvl(rec_nabor.vol, 0) * rec_wo_peop.cena;
              summa_  := round(summaf_, 2);
              INSERT INTO c_charge
                (npp, lsk, usl, summa, summaf, kart_pr_id, TYPE, spk_id, test_opl, test_cena, test_tarkoef, test_spk_koef)
              VALUES
                (npp_, rec_krt.lsk, usl_, summa_, summaf_, NULL, 1, NULL, round(rec_nabor.vol,
                        2), rec_wo_peop.cena, rec_wo_peop.tarkoef, NULL);
            END IF;
            CLOSE cur_wo_peop;
          END IF;
          --||||||||||||||||||||||||||||||||||||||--
          -- јнтенна-1,2,  од.замки-1,2
          -- не важно есть люди или нет, не смотрим на льготы
          --        if (rec_nabor.chrg1 <> 0 or rec_nabor.chrg2 <> 0) and usl_ in ('042','043','044','045') then
          IF (rec_nabor.chrg1 <> 0 OR rec_nabor.chrg2 <> 0) AND
             rec_nabor.fk_calc_tp IN (12, 13) THEN --#12# #13#
            OPEN cur_wo_peop(null);
            FETCH cur_wo_peop
              INTO rec_wo_peop;
            IF round(rec_wo_peop.tarkoef * rec_wo_peop.tarnorm, 2) <> 0 THEN
              IF nvl(rec_krt.org_var, 0) <> 0 THEN
                --Ёнерг+
                SELECT MAX(s.cena)
                INTO   cena_
                FROM   spr_tarif_prices s, params p
                WHERE  s.fk_tarif = rec_nabor.fk_tarif
                AND    p.period BETWEEN s.mg1 AND s.mg2;
                npp_ := npp_ + 1;
                IF rec_nabor.fk_calc_tp IN (12) THEN
                  -- абельное Ё+
                  --со льготой
                  summaf_ := CASE
                               WHEN rec_nabor.fk_tarif IS NULL THEN
                                rec_wo_peop.tarkoef
                               WHEN rec_nabor.fk_tarif IS NOT NULL THEN
                                cena_
                             END * rec_wo_peop.tarnorm;
                  summa_  := round(summaf_, 2);
                  INSERT INTO c_charge
                    (npp, lsk, usl, summa, summaf, kart_pr_id, TYPE, spk_id, test_opl, test_cena, test_tarkoef, test_spk_koef)
                  VALUES
                    (0, rec_krt.lsk, usl_, summa_, summaf_, NULL, 0, NULL, CASE WHEN
                      rec_nabor.fk_tarif IS NULL THEN
                      rec_wo_peop.tarkoef WHEN
                      rec_nabor.fk_tarif IS NOT NULL THEN
                      cena_
                      END *
                      rec_wo_peop.tarnorm, rec_wo_peop.cena, rec_wo_peop.tarkoef, NULL);
                  --без льготы
                  summaf_ := CASE
                               WHEN rec_nabor.fk_tarif IS NULL THEN
                                rec_wo_peop.tarkoef
                               WHEN rec_nabor.fk_tarif IS NOT NULL THEN
                                cena_
                             END * rec_wo_peop.tarnorm;
                  summa_  := round(summaf_, 2);
                  INSERT INTO c_charge
                    (npp, lsk, usl, summa, summaf, kart_pr_id, TYPE, spk_id, test_opl, test_cena, test_tarkoef, test_spk_koef)
                  VALUES
                    (npp_, rec_krt.lsk, usl_, summa_, summaf_, NULL, 1, NULL, CASE WHEN
                      rec_nabor.fk_tarif IS NULL THEN
                      rec_wo_peop.tarkoef WHEN
                      rec_nabor.fk_tarif IS NOT NULL THEN
                      cena_
                      END *
                      rec_wo_peop.tarnorm, rec_wo_peop.cena, rec_wo_peop.tarkoef, NULL);
                ELSIF rec_nabor.fk_calc_tp IN (13) THEN
                  --јнтенна Ё+ (без начислени€)
                  INSERT INTO c_charge
                    (npp, lsk, usl, summa, kart_pr_id, TYPE, spk_id, test_opl, test_cena, test_tarkoef, test_spk_koef)
                  VALUES
                    (0, rec_krt.lsk, usl_, NULL, NULL, 0, NULL, CASE
                        WHEN rec_nabor.fk_tarif IS NULL THEN
                         NULL
                        WHEN rec_nabor.fk_tarif IS NOT NULL THEN
                         cena_
                      END *
                      rec_wo_peop.tarnorm, rec_wo_peop.cena, rec_wo_peop.tarkoef, NULL);
                  --без льготы
                  INSERT INTO c_charge
                    (npp, lsk, usl, summa, kart_pr_id, TYPE, spk_id, test_opl, test_cena, test_tarkoef, test_spk_koef)
                  VALUES
                    (npp_, rec_krt.lsk, usl_, NULL, NULL, 1, NULL, CASE WHEN
                      rec_nabor.fk_tarif IS NULL THEN NULL WHEN
                      rec_nabor.fk_tarif IS NOT NULL THEN
                      cena_
                      END *
                      rec_wo_peop.tarnorm, rec_wo_peop.cena, rec_wo_peop.tarkoef, NULL);
                END IF;
              ELSE
                -- исель, “—∆
                --со льготой
                npp_    := npp_ + 1;
                summaf_ := rec_wo_peop.cena;
                summa_  := round(summaf_, 2);
                INSERT INTO c_charge
                  (npp, lsk, usl, summa, summaf, kart_pr_id, TYPE, spk_id, test_opl, test_cena, test_tarkoef, test_spk_koef)
                VALUES
                  (0, rec_krt.lsk, usl_, summa_, summaf_, NULL, 0, NULL, round(rec_wo_peop.tarkoef *
                          rec_wo_peop.tarnorm,
                          2), rec_wo_peop.cena, rec_wo_peop.tarkoef, NULL);
                --без льготы
                summaf_ := rec_wo_peop.cena;
                summa_  := round(summaf_, 2);
                INSERT INTO c_charge
                  (npp, lsk, usl, summa, summaf, kart_pr_id, TYPE, spk_id, test_opl, test_cena, test_tarkoef, test_spk_koef)
                VALUES
                  (npp_, rec_krt.lsk, usl_, summa_, summaf_, NULL, 1, NULL, round(rec_wo_peop.tarkoef *
                          rec_wo_peop.tarnorm,
                          2), rec_wo_peop.cena, rec_wo_peop.tarkoef, NULL);
              END IF;
            END IF;

            CLOSE cur_wo_peop;
          END IF;
          --||||||||||||||||||||||||||||||||||||||--
          -- ÷ифровое “¬ Ёнерг+
          -- не важно есть люди или нет, не смотрим на льготы
          IF (rec_nabor.chrg1 <> 0) AND rec_nabor.fk_calc_tp IN (16) THEN --#16#
            OPEN cur_wo_peop(null);
            FETCH cur_wo_peop
              INTO rec_wo_peop;
            --сложна€ цена, составл€юща€ сумму цен по программам, пакетам абонента
            SELECT nvl(SUM(s.cena), 0)
            INTO   cena_
            FROM   nabor_progs n, spr_tarif_prices s, params p
            WHERE  n.fk_tarif = s.fk_tarif
            AND    n.lsk = rec_krt.lsk
            AND    p.period BETWEEN s.mg1 AND s.mg2;
            npp_ := npp_ + 1;
            -- абельное Ё+
            --со льготой
            INSERT INTO c_charge
              (npp, lsk, usl, summa, kart_pr_id, TYPE, spk_id, test_opl, test_cena, test_tarkoef, test_spk_koef)
            VALUES
              (0, rec_krt.lsk, usl_, cena_, NULL, 0, NULL, rec_wo_peop.tarnorm, cena_, rec_wo_peop.tarkoef, NULL);
            --без льготы
            INSERT INTO c_charge
              (npp, lsk, usl, summa, kart_pr_id, TYPE, spk_id, test_opl, test_cena, test_tarkoef, test_spk_koef)
            VALUES
              (npp_, rec_krt.lsk, usl_, cena_, NULL, 1, NULL, rec_wo_peop.tarnorm, cena_, rec_wo_peop.tarkoef, NULL);
            CLOSE cur_wo_peop;
          END IF;
          --||||||||||||||||||||||||||||||||||||||--
          -- ѕрочие услуги, расчитываемые как расценка * vol_add
          -- Ќапример Ёл.энерги€ (в √аражах в тсж)
          IF rec_nabor.chrg1 <> 0 AND rec_nabor.fk_calc_tp = 23 THEN --#23#
            OPEN cur_wo_peop(null);
            FETCH cur_wo_peop
              INTO rec_wo_peop;
            sit_    := sit_ +
                       round(rec_wo_peop.cena * rec_nabor.vol_add, 2);
            npp_    := npp_ + 1;
            summaf_ := rec_wo_peop.cena * rec_nabor.vol_add;
            summa_  := round(summaf_, 2);
            INSERT INTO c_charge
              (npp, lsk, usl, summa, summaf, kart_pr_id, TYPE, spk_id, test_opl, test_cena, test_tarkoef, test_spk_koef)
            VALUES
              (0, rec_krt.lsk, usl_, summa_, summaf_, NULL, 0, NULL, rec_nabor.vol_add, rec_wo_peop.cena, NULL, NULL);
            --без льготы
            msit_   := msit_ +
                       round(rec_wo_peop.cena * rec_nabor.vol_add, 2);
            summaf_ := rec_wo_peop.cena * rec_nabor.vol_add;
            summa_  := round(summaf_, 2);
            INSERT INTO c_charge
              (npp, lsk, usl, summa, summaf, kart_pr_id, TYPE, spk_id, test_opl, test_cena, test_tarkoef, test_spk_koef)
            VALUES
              (npp_, rec_krt.lsk, usl_, summa_, summaf_, NULL, 1, NULL, rec_nabor.vol_add, rec_wo_peop.cena, NULL, NULL);
            CLOSE cur_wo_peop;
          END IF;
          --||||||||||||||||||||||||||||||||||||||--
          -- ѕрочие услуги, расчитываемые как расценка * норматив * ќбщ.площадь
          IF rec_nabor.chrg1 <> 0 AND rec_nabor.fk_calc_tp = 24 THEN --#24#
            OPEN cur_wo_peop(null);
            FETCH cur_wo_peop
              INTO rec_wo_peop;
            sit_    := sit_ + round(rec_krt.opl * rec_wo_peop.cena *
                                    rec_wo_peop.tarnorm,
                                    2);
            npp_    := npp_ + 1;
            summaf_ := rec_krt.opl * rec_wo_peop.cena * rec_wo_peop.tarnorm;
            summa_  := round(summaf_, 2);
            INSERT INTO c_charge
              (npp, lsk, usl, summa, summaf, kart_pr_id, TYPE, spk_id, test_opl, test_cena, test_tarkoef, test_spk_koef)
            VALUES
              (0, rec_krt.lsk, usl_, summa_, summaf_, NULL, 0, NULL, rec_krt.opl, rec_wo_peop.cena, NULL, NULL);
            --без льготы
            msit_   := msit_ + round(rec_krt.opl * rec_wo_peop.cena *
                                     rec_wo_peop.tarnorm,
                                     2);
            summaf_ := rec_krt.opl * rec_wo_peop.cena * rec_wo_peop.tarnorm;
            summa_  := round(summaf_, 2);
            INSERT INTO c_charge
              (npp, lsk, usl, summa, summaf, kart_pr_id, TYPE, spk_id, test_opl, test_cena, test_tarkoef, test_spk_koef)
            VALUES
              (npp_, rec_krt.lsk, usl_, summa_, summaf_, NULL, 1, NULL, rec_krt.opl, rec_wo_peop.cena, NULL, NULL);
            CLOSE cur_wo_peop;
          END IF;
          --||||||||||||||||||||||||||||||||||||||--
          -- ѕрочие услуги, расчитываемые как расценка * норматив * ќбщ.площадь, только Ќ≈ по муницип фонду
          IF rec_nabor.chrg1 <> 0 AND rec_krt.status not in (1) AND rec_nabor.fk_calc_tp = 32 THEN --#32#
            OPEN cur_wo_peop(null);
            FETCH cur_wo_peop
              INTO rec_wo_peop;
            sit_    := sit_ + round(rec_krt.opl * rec_wo_peop.cena *
                                    rec_wo_peop.tarnorm,
                                    2);
            npp_    := npp_ + 1;
            summaf_ := rec_krt.opl * rec_wo_peop.cena * rec_wo_peop.tarnorm;
            summa_  := round(summaf_, 2);
            INSERT INTO c_charge
              (npp, lsk, usl, summa, summaf, kart_pr_id, TYPE, spk_id, test_opl, test_cena, test_tarkoef, test_spk_koef)
            VALUES
              (0, rec_krt.lsk, usl_, summa_, summaf_, NULL, 0, NULL, rec_krt.opl, rec_wo_peop.cena, NULL, NULL);
            --без льготы
            msit_   := msit_ + round(rec_krt.opl * rec_wo_peop.cena *
                                     rec_wo_peop.tarnorm,
                                     2);
            summaf_ := rec_krt.opl * rec_wo_peop.cena * rec_wo_peop.tarnorm;
            summa_  := round(summaf_, 2);
            INSERT INTO c_charge
              (npp, lsk, usl, summa, summaf, kart_pr_id, TYPE, spk_id, test_opl, test_cena, test_tarkoef, test_spk_koef)
            VALUES
              (npp_, rec_krt.lsk, usl_, summa_, summaf_, NULL, 1, NULL, rec_krt.opl, rec_wo_peop.cena, NULL, NULL);
            CLOSE cur_wo_peop;
          END IF;
          --||||||||||||||||||||||||||||||||||||||--
          -- ѕрочие услуги, расчитываемые как расценка * кол-во прожив * норматив (квт. например)
          -- Ќапример Ёл.энерги€ (вариаци€ эл.эн.ћќѕ в тсж)
          IF rec_nabor.chrg1 <> 0 AND rec_nabor.fk_calc_tp = 26 THEN --#26#
            OPEN cur_wo_peop(null);
            FETCH cur_wo_peop
              INTO rec_wo_peop;
            sit_    := sit_ + round(rec_wo_peop.cena * rec_wo_peop.tarnorm * kpr_,
                                    2);
            npp_    := npp_ + 1;
            summaf_ := rec_wo_peop.cena * rec_wo_peop.tarnorm * kpr_;
            summa_  := round(summaf_, 2);
            INSERT INTO c_charge
              (npp, lsk, usl, summa, summaf, kart_pr_id, TYPE, spk_id, test_opl, test_cena, test_tarkoef, test_spk_koef)
            VALUES
              (0, rec_krt.lsk, usl_, summa_, summaf_, NULL, 0, NULL, rec_wo_peop.tarnorm * kpr_, rec_wo_peop.cena, NULL, NULL);
            --без льготы
            msit_   := msit_ + round(rec_wo_peop.cena * rec_wo_peop.tarnorm * kpr_,
                                     2);
            summaf_ := rec_wo_peop.cena * rec_wo_peop.tarnorm * kpr_;
            summa_  := round(summaf_, 2);
            INSERT INTO c_charge
              (npp, lsk, usl, summa, summaf, kart_pr_id, TYPE, spk_id, test_opl, test_cena, test_tarkoef, test_spk_koef)
            VALUES
              (npp_, rec_krt.lsk, usl_, summa_, summaf_, NULL, 1, NULL, rec_wo_peop.tarnorm * kpr_, rec_wo_peop.cena, NULL, NULL);
            CLOSE cur_wo_peop;
          END IF;
          --||||||||||||||||||||||||||||||||||||||--
          --’олодна€ вода (”—“ј–≈¬Ў≈≈, дл€ ѕолыс)
          --||||||||||||||||||||||||||||||||||||||--
          -- ѕрочие услуги, расчитываемые как расценка * коэфф * норматив (Ќо в потреблении - норматив)
          -- Ќапример Ёл.энерги€ (в √аражах в тсж) -странно, есть така€ методика в услуге є 23
          IF rec_nabor.chrg1 <> 0 AND rec_nabor.fk_calc_tp = 30 THEN --#30#
            OPEN cur_wo_peop(null);
            FETCH cur_wo_peop
              INTO rec_wo_peop;
            sit_    := sit_ +
                       round(rec_wo_peop.cena * rec_wo_peop.tarnorm, 2);
            npp_    := npp_ + 1;
            summaf_ := rec_wo_peop.cena * rec_wo_peop.tarnorm;
            summa_  := round(summaf_, 2);
            INSERT INTO c_charge
              (npp, lsk, usl, summa, summaf, kart_pr_id, TYPE, spk_id, test_opl, test_cena, test_tarkoef, test_spk_koef)
            VALUES
              (0, rec_krt.lsk, usl_, summa_, summaf_, NULL, 0, NULL, rec_wo_peop.tarnorm, rec_wo_peop.cena, NULL, NULL);
            --без льготы
            msit_   := msit_ +
                       round(rec_wo_peop.cena * rec_wo_peop.tarnorm, 2);
            summaf_ := rec_wo_peop.cena * rec_wo_peop.tarnorm;
            summa_  := round(summaf_, 2);
            INSERT INTO c_charge
              (npp, lsk, usl, summa, summaf, kart_pr_id, TYPE, spk_id, test_opl, test_cena, test_tarkoef, test_spk_koef)
            VALUES
              (npp_, rec_krt.lsk, usl_, summa_, summaf_, NULL, 1, NULL, rec_wo_peop.tarnorm, rec_wo_peop.cena, NULL, NULL);
            CLOSE cur_wo_peop;
          END IF;
        END LOOP;
        CLOSE cur_nabor;

        ---------льготы
        --итоговое формирование льгот и начислени€ с учЄтом льгот
        IF rec_krt.corr_lg = 1 THEN
          --учитываем корректировку в льготах
          INSERT INTO c_charge
            (npp, lsk, usl, summa, kart_pr_id, spk_id, TYPE, main, lg_doc_id)
            SELECT t.npp, t.lsk, t.usl, round(t.summa + CASE
                            WHEN nvl(v.summa, 0) <> 0 AND nvl(x.summa, 0) <> 0 THEN
                             t.summa * v.summa / x.summa
                            ELSE
                             0
                          END,
                          2), t.kart_pr_id, t.spk_id, 4, t.main, t.lg_doc_id
            FROM   (SELECT npp, lsk, usl, r.kart_pr_id, r.spk_id, r.main, r.lg_doc_id, SUM(summa) summa
                     FROM   c_charge r, params p
                     WHERE  TYPE = 3
                     AND    lsk = '' || rec_krt.lsk || ''
                     GROUP  BY npp, lsk, usl, r.spk_id, r.kart_pr_id, r.main, r.lg_doc_id) t, --льготы
                   (SELECT lsk, usl, nvl(SUM(summa), 0) AS summa
                     FROM   c_charge r, params p
                     WHERE  TYPE = 1
                     AND    lsk = '' || rec_krt.lsk || ''
                     GROUP  BY lsk, usl) x, -- нач без льг.
                   (SELECT lsk, usl, SUM(summa) summa
                     FROM   c_change c, params p
                     WHERE  c.mgchange = p.period
                     AND    lsk = '' || rec_krt.lsk || ''
                     AND    nvl(c.proc, 0) <> 0
                     AND    to_char(c.dtek, 'YYYYMM') = p.period
                     GROUP  BY lsk, usl) v --изменени€
            WHERE  t.lsk = x.lsk(+)
            AND    t.usl = x.usl(+)
            AND    t.lsk = v.lsk(+)
            AND    t.usl = v.usl(+);
        ELSE
          --Ќ≈ учитываем корректировку в льготах
          INSERT INTO c_charge
            (npp, lsk, usl, summa, kart_pr_id, spk_id, TYPE, main, lg_doc_id)
            SELECT npp, lsk, usl, summa, kart_pr_id, spk_id, 4, main, lg_doc_id
            FROM   c_charge t
            WHERE  t.type = 3
            AND    lsk = '' || rec_krt.lsk || '';
        END IF;

        --считать или нет субисидию?
        IF nvl(rec_krt.subs_ob, 0) = 1 THEN
          -- –асчет субсидии 11.05.2006
          -- krt.eksub1 - —овокуп.доход на семью
          -- krt.eksub2 - ƒушевой.доход
          -- krt.sgku - —тандарт —∆ ”
          --& krt.doppl - ”вел. площади дл€ субсидии
          --—овокуп.доход на 1 чел

          --итоговое начисление дл€ субсидии + изменени€
          SELECT SUM(c.summa)
          INTO   it_izm_s_
          FROM   c_change c, params p, usl u
          WHERE  c.usl = u.usl
          AND    c.mgchange = p.period
          AND    c.lsk = '' || rec_krt.lsk || ''
          AND    u.usl_subs = 1
          AND    to_char(c.dtek, 'YYYYMM') = p.period
          AND    nvl(c.proc, 0) <> 0;

          IF nvl(rec_krt.subs_cor, 0) <> 0 AND
             sit_ + nvl(it_izm_s_, 0) <> 0 THEN
            -- распредел€ем корректировку
            --итоговое начисление дл€ субсидии + изменени€
            sit_s_ := sit_ + nvl(it_izm_s_, 0);

            subs_       := nvl(rec_krt.subs_cor, 2);
            koeff_rasp_ := subs_ / sit_s_;
            INSERT INTO c_charge
              (npp, lsk, usl, summa, kart_pr_id, spk_id, TYPE, test_opl, test_cena, test_tarkoef, test_spk_koef)
              SELECT MAX(v.npp), v.lsk, v.usl, round(SUM(v.summa *
                                koeff_rasp_),
                            2), NULL, NULL, 2, NULL, NULL, NULL, NULL
              FROM   (SELECT t.npp, t.lsk, t.usl, t.summa
                       FROM   c_charge t, usl u
                       WHERE  t.lsk = '' || rec_krt.lsk || ''
                       AND    t.type = 1
                       AND    t.usl = u.usl
                       AND    u.usl_subs = 1 --берем чистое начисление
                       UNION ALL
                       SELECT NULL, t.lsk, t.usl, -1 * t.summa
                       FROM   c_charge t, usl u
                       WHERE  t.lsk = '' || rec_krt.lsk || ''
                       AND    t.type = 3
                       AND    t.usl = u.usl
                       AND    u.usl_subs = 1 --вычитаем льготы (без изменениний!!!)
                       UNION ALL
                       SELECT NULL, c.lsk, c.usl, c.summa
                       FROM   c_change c, params p, usl u
                       WHERE  c.usl = u.usl
                       AND    c.mgchange = p.period
                       AND    c.lsk = '' || rec_krt.lsk || ''
                       AND    u.usl_subs = 1
                       AND    to_char(c.dtek, 'YYYYMM') = p.period --прибавл€ем изменени€
                       AND    nvl(c.proc, 0) <> 0) v
              GROUP  BY v.lsk, v.usl;
            SELECT subs_ - SUM(t.summa)
            INTO   chk_subs_corr_
            FROM   c_charge t
            WHERE  t.lsk = '' || rec_krt.lsk || ''
            AND    TYPE = 2;
            IF chk_subs_corr_ > 0.10 THEN
              --больше дес€ти копеек - expception
              raise_application_error(-20001,
                                      '¬нимание! ѕо лицевому ' ||
                                      rec_krt.lsk ||
                                      ' произошло не правильное округление корректировки субсидии. ќстановка.');
            END IF;
            INSERT INTO c_charge
              (npp, lsk, usl, summa, kart_pr_id, spk_id, TYPE, test_opl, test_cena, test_tarkoef, test_spk_koef)
              SELECT t.npp, t.lsk, t.usl, chk_subs_corr_, NULL, NULL, 2, NULL, NULL, NULL, NULL
              FROM   c_charge t, usl u
              WHERE  t.lsk = '' || rec_krt.lsk || ''
              AND    t.type = 0
              AND    t.usl = u.usl
              AND    u.usl_subs = 1
              AND    rownum = 1;
          END IF;

          IF rec_krt.subs_cur = 1 AND kpr_ <> 0 AND
             nvl(rec_krt.eksub2, 0) <> 0 THEN
            --признак считать субсидию
            SELECT SUM(summa)
            INTO   it_izm_s_
            FROM   c_change c, params p
            WHERE  c.lsk = '' || rec_krt.lsk || ''
            AND    to_char(c.dtek, 'YYYYMM') = p.period
            AND    nvl(c.proc, 0) <> 0;
            sit_s_ := sit_ + nvl(it_izm_s_, 0);

            sov_doh1_ := nvl(rec_krt.eksub1, 2) / kpr_;

            koef_doh_ := sov_doh1_ / nvl(rec_krt.eksub2, 0);

            IF koef_doh_ < 1 THEN
              koef_subs_ := 1;
            ELSIF koef_doh_ >= 1 AND koef_doh_ <= 1.5 THEN
              koef_subs_ := 1.5;
            ELSIF koef_doh_ > 1.5 AND koef_doh_ <= 1.8 THEN
              koef_subs_ := 1.8;
            ELSIF koef_doh_ > 1.8 AND koef_doh_ <= 2.0 THEN
              koef_subs_ := 2;
            ELSIF koef_doh_ > 2 AND koef_doh_ < 3 THEN
              koef_subs_ := 3;
            ELSIF koef_doh_ >= 3 THEN
              koef_subs_ := 4;
            ELSE
              koef_subs_ := 0;
            END IF;

            IF koef_subs_ = 1 THEN
              mdd_ := 5;
            ELSIF koef_subs_ = 1.5 THEN
              mdd_ := 7;
            ELSIF koef_subs_ = 1.8 THEN
              mdd_ := 10;
            ELSIF koef_subs_ = 2 THEN
              mdd_ := 15;
            ELSIF koef_subs_ = 3 THEN
              mdd_ := 20;
            ELSIF koef_subs_ = 4 THEN
              mdd_ := 22;
            ELSE
              mdd_ := 0;
            END IF;

            poprav_  := sov_doh1_ / nvl(rec_krt.eksub2, 0);
            koef_lg_ := sit_ / msit_;
            sgku_1_ := rec_krt.sgku * kpr_ + rec_krt.doppl * CASE
                         WHEN rec_krt.opl - pl_norma_ > 20 THEN
                          20
                         ELSE
                          rec_krt.opl - pl_norma_
                       END;
            IF koef_subs_ = 1 THEN
              sum_subsid_ := sgku_1_ * koef_lg_ -
                             mdd_ / 100 * nvl(rec_krt.eksub1, 2) * poprav_;
            ELSIF koef_subs_ >= 1.5 AND koef_subs_ <= 4 THEN
              sum_subsid_ := sgku_1_ * koef_lg_ -
                             mdd_ / 100 * nvl(rec_krt.eksub1, 2);
            ELSE
              sum_subsid_ := 0;
            END IF;

            --распредел€ем основную субсидию
            IF sum_subsid_ >= sit_s_ THEN
              subs_ := sit_s_;
            ELSIF sum_subsid_ > 0 AND sum_subsid_ < sit_s_ THEN
              subs_ := sum_subsid_;
            ELSE
              subs_ := 0;
            END IF;

            koeff_rasp_ := subs_ / sit_s_;
            INSERT INTO c_charge
              (lsk, usl, summa, kart_pr_id, spk_id, TYPE, test_opl, test_cena, test_tarkoef, test_spk_koef)
              SELECT v.lsk, v.usl, round(SUM(v.summa * koeff_rasp_), 2), NULL, NULL, 2, NULL, NULL, NULL, NULL
              FROM   (SELECT t.lsk, t.usl, t.summa
                       FROM   c_charge t, usl u
                       WHERE  t.lsk = '' || rec_krt.lsk || ''
                       AND    t.type = 0
                       AND    t.usl = u.usl
                       AND    u.usl_subs = 1
                       UNION ALL
                       SELECT lsk, usl, summa
                       FROM   c_change c, params p
                       WHERE  c.mgchange = p.period
                       AND    c.lsk = '' || rec_krt.lsk || ''
                       AND    to_char(c.dtek, 'YYYYMM') = p.period
                       AND    nvl(c.proc, 0) <> 0) v
              GROUP  BY v.lsk, v.usl;
          END IF;
        END IF;
/*        IF init.get_date > to_date('15082014', 'DDMMYYYY') THEN
          ROLLBACK;
          raise_application_error(-20001, 'Licenses has expired');
        END IF;
        --по каждой 30 -ой записи (иначе тормозит селект из sys.v_$database)
        IF rec_krt.lsk / 30 - round(rec_krt.lsk / 30) = 0 THEN
          IF (dbid_ = 3799038777 AND
             init.get_date < to_date('15082014', 'DDMMYYYY')) OR
             (dbid_ = 2618192783 AND --тсж клЄн
             init.get_date < to_date('15082014', 'DDMMYYYY')) OR
             (dbid_ = 1314248482 AND --полыс
             init.get_date < to_date('15082014', 'DDMMYYYY')) OR
             (dbid_ = 2606094080 AND
             init.get_date < to_date('15082014', 'DDMMYYYY')) OR
             (dbid_ = 3810881306 AND
             init.get_date < to_date('15082014', 'DDMMYYYY')) OR
             (dbid_ = 2554820419 AND
             init.get_date < to_date('15082014', 'DDMMYYYY')) OR
             (dbid_ = 3814334184 AND
             init.get_date < to_date('15082014', 'DDMMYYYY')) OR
             (dbid_ = 2556573722 AND
             init.get_date < to_date('15082014', 'DDMMYYYY')) OR
             (dbid_ = 3834602444 AND
             init.get_date < to_date('15082014', 'DDMMYYYY')) OR
             (dbid_ = 344733707 AND
             init.get_date < to_date('15082014', 'DDMMYYYY')) OR
             (dbid_ = 377737443 AND
             init.get_date < to_date('15082014', 'DDMMYYYY')) OR
             (dbid_ = 2572869365 AND
             init.get_date < to_date('15082014', 'DDMMYYYY')) OR
             (dbid_ = 2561829081 AND
             init.get_date < to_date('15082014', 'DDMMYYYY')) OR
             (dbid_ = 2586286055 AND
             init.get_date < to_date('15082014', 'DDMMYYYY')) OR
             (dbid_ = 2585073008 AND
             init.get_date < to_date('15082014', 'DDMMYYYY')) OR
             (dbid_ = 1230886519 AND
             init.get_date < to_date('15082014', 'DDMMYYYY')) OR
             (dbid_ = 1236135987 AND
             init.get_date < to_date('15082014', 'DDMMYYYY')) OR
             (dbid_ = 2623801154 AND
             init.get_date < to_date('15082014', 'DDMMYYYY')) OR
             (dbid_ = 2593178931 AND
             init.get_date < to_date('15082014', 'DDMMYYYY')) OR
             (dbid_ = 1279259503 AND
             init.get_date < to_date('15082014', 'DDMMYYYY')) OR
             (dbid_ = 2652117642 AND
             init.get_date < to_date('15082014', 'DDMMYYYY')) OR
             (dbid_ = 2654644677 AND
             init.get_date < to_date('15082014', 'DDMMYYYY')) OR
             (dbid_ = 2632934097 AND
             init.get_date < to_date('15082014', 'DDMMYYYY')) OR
             (dbid_ = 2657406262 AND
             init.get_date < to_date('15082014', 'DDMMYYYY')) OR
             (dbid_ = 1343879475 AND
             init.get_date < to_date('15082014', 'DDMMYYYY')) OR
             (dbid_ = 2660587686 AND
             init.get_date < to_date('15082014', 'DDMMYYYY')) OR
             (dbid_ = 2654644677 AND
             init.get_date < to_date('15082014', 'DDMMYYYY'))  OR
             (dbid_ =  1371098296 AND
             init.get_date < to_date('15082014', 'DDMMYYYY'))
              THEN
            NULL;
          ELSE
            raise_application_error(-20001, 'Licenses problem!' || dbid_);
            ROLLBACK;
          END IF;
        END IF; */

        IF iscommit_ = 2 THEN
          --если нужен промежуточный коммит - делаем
          COMMIT;
        END IF;

      END IF;
      --установить статус "Ќ≈ пересчитано движение"
      --c_valid.set_valid_lsk(rec_krt.lsk, 1, 'gen_chrgpay');
      --конец цикла по лицевым счетам
    END LOOP;

    IF var_ = 1 THEN
      CLOSE cur_krt;
    ELSIF var_ = 2 THEN
      CLOSE cur_krt2;
    ELSIF var_ = 3 THEN
      CLOSE cur_krt3;
    ELSIF var_ = 4 THEN
      CLOSE cur_krt4;
    ELSIF var_ = 5 THEN
      CLOSE cur_krt5;
    END IF;

    -- Ѕлок округлени€, если округление включено
    IF is_round_charge_ = 1 THEN
      IF var_ = 1 THEN
        --по группе л.с.
        FOR t IN (SELECT MAX(c.id) AS id, round(SUM(summaf), 2) - SUM(summa) AS diff
                  FROM   c_charge c
                  WHERE  c.lsk BETWEEN '' || lsk_ || '' AND
                         '' || lsk_end_ || ''
                  AND    c.type IN (0, 1)
                  GROUP  BY c.lsk, c.usl, c.type
                  HAVING round(SUM(summaf), 2) - SUM(summa) <> 0) LOOP
          UPDATE c_charge r
          SET    r.summa = nvl(r.summa, 0) + t.diff
          WHERE  r.id = t.id;
        END LOOP;
      ELSIF var_ = 2 THEN
        --по 1 л.с.
        FOR t IN (SELECT MAX(c.id) AS id, round(SUM(summaf), 2) - SUM(summa) AS diff
                  FROM   c_charge c
                  WHERE  c.lsk = '' || lsk_ || ''
                  AND    c.type IN (0, 1)
                  GROUP  BY c.lsk, c.usl, c.type
                  HAVING round(SUM(summaf), 2) - SUM(summa) <> 0) LOOP
          UPDATE c_charge r
          SET    r.summa = nvl(r.summa, 0) + t.diff
          WHERE  r.id = t.id;
        END LOOP;
      ELSIF var_ = 3 THEN
        --по выбранному house_id дому
        FOR t IN (SELECT MAX(c.id) AS id, round(SUM(summaf), 2) - SUM(summa) AS diff
                  FROM   c_charge c, kart k
                  WHERE  k.lsk = c.lsk
                  AND    k.house_id = house_id_
                  AND    c.type IN (0, 1)
                  GROUP  BY c.lsk, c.usl, c.type
                  HAVING round(SUM(summaf), 2) - SUM(summa) <> 0) LOOP
          UPDATE c_charge r
          SET    r.summa = nvl(r.summa, 0) + t.diff
          WHERE  r.id = t.id;
        END LOOP;
      ELSIF var_ = 4 THEN
        --по всему фонду
        FOR t IN (SELECT MAX(c.id) AS id, round(SUM(summaf), 2) - SUM(summa) AS diff
                  FROM   c_charge c, kart k
                  WHERE  k.lsk = c.lsk
                  AND    c.type IN (0, 1)
                  GROUP  BY c.lsk, c.usl, c.type
                  HAVING round(SUM(summaf), 2) - SUM(summa) <> 0) LOOP
          UPDATE c_charge r
          SET    r.summa = nvl(r.summa, 0) + t.diff
          WHERE  r.id = t.id;
        END LOOP;
      ELSIF var_ = 5 THEN
        --по выбранному p_vvod вводу
        FOR t IN (SELECT MAX(c.id) AS id, round(SUM(summaf), 2) - SUM(summa) AS diff
                  FROM   c_charge c, table(t_nabor) n
                  WHERE  n.lsk = c.lsk
                  AND    n.fk_vvod = p_vvod
                  AND    c.type IN (0, 1)
                  GROUP  BY c.lsk, c.usl, c.type
                  HAVING round(SUM(summaf), 2) - SUM(summa) <> 0) LOOP
          UPDATE c_charge r
          SET    r.summa = nvl(r.summa, 0) + t.diff
          WHERE  r.id = t.id;
        END LOOP;
      END IF;
    END IF;
    ---

    IF iscommit_ = 1 THEN
      --если нужен коммит - делаем
      COMMIT;
    END IF;

    RETURN cnt_lsk_;


          --||||||||||||||||||||||||||||||||||||||--
          --”—Ћ”√ј — –ј—÷≈Ќ ќ… ƒЋя ѕ”—“џ’  ¬ј–“»–
          -- гор€ча€ вода (г.в.) /ревизи€ дл€ кис. от 01.03.2014/
/*    ¬Ќ»ћјЌ»≈! Ё“” ”—Ћ”√” ќЅЏ≈ƒ»Ќ»Ћ — х.в. “ј   ј  јЋ√ќ–»“ћ ќƒ»Ќ –≈ƒ. 29.04.14
       IF rec_nabor.chrg1 <> 0 AND rec_nabor.fk_calc_tp IN (18) THEN --#18#
            OPEN cur_wo_peop(null);
            FETCH cur_wo_peop
              INTO rec_wo_peop;
            CLOSE cur_wo_peop;
            --сохранить расценку
            l_cena:=rec_wo_peop.cena;

            for c in cur_charge_prep
            loop
              if c.empty = 0 then
                --расчет дл€ не пустой квартиры
                ins_chrg2(c.vol, rec_wo_peop.cena, null, usl_, c.sch, c.kpr, c.kprz, c.kpro);
              elsif c.empty = 1 then
                --расчет дл€ пустой квартиры
                OPEN cur_nabor2(rec_nabor.usl_p);
                FETCH cur_nabor2
                  INTO rec_nabor2;
                if cur_nabor2%NOTFOUND then
                  --ќ ј«џ¬ј≈“—я Ќјƒќ Ќ”Ћ»“№
                  rec_nabor2.usl:=null;
                end if;
                CLOSE cur_nabor2;
                if rec_krt.status <> 1 then
                --дл€ не муниципальных квартир, расценка как дл€ пустых квартир
                  l_cena:=rec_wo_peop.cena_for_empty;
                end if;

                if rec_nabor2.usl is not null then
                  --есть выделенна€ услуга "без проживающих"
                  ins_chrg2(c.vol, l_cena, null, rec_nabor2.usl, c.sch, c.kpr, c.kprz, c.kpro);
                  else
                  --нет выделенной услуги "без проживающих", ставим на ту же услугу
                  ins_chrg2(c.vol, l_cena, null, usl_, c.sch, c.kpr, c.kprz, c.kpro);
                end if;
              end if;
            end loop;
          END IF; */

/*    CURSOR cur_peoples IS
      SELECT v.id, v.spk_id, v.charge_part, v.limit_part, v.koef, v.dop_pl, v.tarkoef, v.tarnorm, v.cena, v.status, v.main, v.lg_doc_id, v.usl_subs
      FROM   (SELECT k.lsk, t.id,CASE
                        WHEN d.dat_end IS NOT NULL AND
                             d.dat_end < to_date(w.period || '01', 'YYYYMMDD') THEN
                         1
                        ELSE
                         m.spk_id
                      END AS spk_id, n.usl, m.prioritet,nvl(m.charge_part, 0) * CASE
                        WHEN d.dat_end IS NOT NULL AND
                             d.dat_end < to_date(w.period || '01', 'YYYYMMDD') THEN
                         0
                        ELSE
                         1
                      END AS charge_part,nvl(m.limit_part, 0) * CASE
                        WHEN d.dat_end IS NOT NULL AND
                             d.dat_end < to_date(w.period || '01', 'YYYYMMDD') THEN
                         0
                        ELSE
                         1
                      END AS limit_part,round(nvl(1 - (m.koef * CASE
                                  WHEN d.dat_end IS NOT NULL AND
                                       d.dat_end < to_date(w.period || '01', 'YYYYMMDD') THEN
                                   0
                                  ELSE
                                   1
                                END / 100),
                                0),
                            2) AS koef,nvl(m.dop_pl, 0) * CASE
                        WHEN d.dat_end IS NOT NULL AND
                             d.dat_end < to_date(w.period || '01', 'YYYYMMDD') THEN
                         0
                        ELSE
                         1
                      END AS dop_pl,

                      nvl(s.koeff, 1) * nvl(n.koeff, 0) AS tarkoef, nvl(n.norm,
                           0) AS tarnorm,
                           CASE WHEN rec_krt.status = 9 THEN 0 --јрендаторы - цена = 0
                           ELSE
                           round(nvl(s.koeff, 1) * nvl(n.koeff, 0) *
                            decode(u.sptarn, 3, nvl(n.norm, 0), 1) * CASE
                              WHEN kpr_price_ <> 0 AND e2.summa IS NOT NULL THEN --есть прожив, расценка ” 
                               nvl(e2.summa, 0)
                              WHEN kpr_price_ = 0 AND e2.summa IS NOT NULL THEN --нет прожив, расценка ” 
                               nvl(e2.summa3, 0)
                              WHEN kpr_price_ <> 0 AND e2.summa IS NULL THEN --есть прожив, расценка базова€
                               nvl(e.summa, 0)
                              WHEN kpr_price_ = 0 AND e2.summa IS NULL THEN --нет прожив, расценка базова€
                               nvl(e.summa3, 0)
                            END,
                            2)
                            END AS cena, nvl(u.usl_subs,
                           0) AS usl_subs,CASE
                        WHEN t.status = 4 AND --если выписан после 15 то статус как у пост пропис
                             nvl(t.dat_ub, to_date('19000101', 'YYYYMMDD')) > --если нет даты выписки, то как будто бы выписан давно (в 1900 году)))
                             to_date((SELECT period || '15' FROM params),
                                     'YYYYMMDD') AND
                             rec_params.is_fullmonth = 0 THEN
                         1
                        ELSE
                         t.status
                      END AS status, d.main, d.id AS lg_doc_id
               FROM   kart k, nabor n, c_kart_pr t, c_lg_docs d, c_lg_pr c, c_spk_usl m, prices e, prices e2, params w, usl u, (SELECT sk.id, su.usl, sk.koeff
                        FROM   spr_koeff sk, spr_koeff_usl su
                        WHERE  su.fk_spr_koeff =
                               sk.id) s
               WHERE  k.lsk = t.lsk
               AND    k.lsk = '' || rec_krt.lsk || ''
               AND    n.usl = e.usl(+) --базовые расценки
               AND    e.fk_org IS NULL
               AND    n.usl = e2.usl(+) --расценки –есурсоснабжающей
               AND    n.org = e2.fk_org(+)
               AND    n.usl = u.usl
               AND    n.usl = usl_
               AND    usl_ = s.usl(+)
               AND    k.kfg = s.id(+)
               AND    k.lsk = n.lsk
               AND    t.id = d.c_kart_pr_id
               AND    d.id = c.c_lg_docs_id
               AND    c.spk_id = m.spk_id
               AND    n.usl = m.usl_id
               AND    c.type = u.usl_type
               AND    (rec_params.is_fullmonth = 0 AND CASE
                       WHEN t.status = 4 AND --если выписан до 15 включительно то не считать
                            nvl(t.dat_ub, to_date('19000101', 'YYYYMMDD')) <= --если нет даты выписки, то как будто бы выписан давно (в 1900 году)))
                            to_date((SELECT period || '15' FROM params),
                                    'YYYYMMDD') THEN
                        0
                       WHEN t.status IN (1, 5) AND --если прописан после 15 невключительно то не считать
                            nvl(t.dat_prop, to_date('19000101', 'YYYYMMDD')) > --если нет даты прописки, то как будто бы прописан давно (в 1900 году)))
                            to_date((SELECT period || '15' FROM params),
                                    'YYYYMMDD') THEN
                        0
                       ELSE
                        1
                     END = 1 OR
                     rec_params.is_fullmonth = 1 AND t.status <> 4)
               AND    (CASE
                       WHEN u.usl_type2 = 0 AND t.status IN (3, 6) THEN
                        1
                       WHEN u.usl_type2 = 0 AND t.status = 2 THEN
                        0
                       WHEN u.usl_type2 = 1 AND t.status IN (3, 6) THEN
                        0
                       WHEN u.usl_type2 = 1 AND t.status = 2 THEN
                        1
                       ELSE
                        1
                     END) = 1
               ORDER  BY nvl(m.charge_part, 0) DESC, nvl(m.prioritet, 0), nvl(koef,
                              0), nvl(dop_pl, 0) DESC, nvl(d.main, 0) DESC) v;
    rec_peoples cur_peoples%ROWTYPE; */

/*          IF rec_nabor.chrg1 <> 0 AND rec_nabor.fk_calc_tp IN (27) THEN --#27#
            hv_kan_ := 0;
            --признак распределени€ по вводу дл€ канализ.
            hv_kub_ := nvl(rec_nabor.kub, 0);
            IF kpr_ > 0 THEN
              --есть проживающие
              OPEN cur_peoples;

              FETCH cur_peoples
                INTO rec_peoples;
              t_peop_id.delete;

              IF rec_krt.psch = 1 THEN
                --все счетчики
                hv_ := rec_krt.mhw; --общий расход по х.в.
              ELSIF rec_krt.psch = 2 THEN
                --счетчик по х.воде
                hv_ := rec_krt.mhw; --общий расход по х.в.
              ELSE
                --норматив по х.воде
                IF rec_nabor.kub = 0 THEN
                  hv_ := (kpr_) * rec_peoples.tarnorm; --нет домового распределени€ на человека
                ELSE

                  hv_ := rec_nabor.vol_add; --есть домовое распределение на кол-во прожив (ред.27.05.2011)
                  --                  hv_ := (kpr_ ) * rec_krt.mhw; --есть домовое распределение на человека
                END IF;
              END IF;

              --≈сли расход отрицательный то...
              IF hv_ >= 0 THEN
                sign_kub_ := 1;
              ELSE
                sign_kub_ := -1;
              END IF;
              hv_kan_ := hv_; --расход по х.в. по канализ.
              hv_     := abs(hv_);

              LOOP
                IF hv_ = 0 THEN
                  --защита от рассчЄта при hv_ = 0
                  EXIT;
                END IF;

                IF rec_krt.psch = 1 OR rec_krt.psch = 2 THEN
                  --счетчики
                  --если по данной услуге у проживающего расчет льготы в дол€х то...
                  IF rec_peoples.charge_part = 1 THEN
                    hv_man_ := round((rec_krt.mhw) * sign_kub_ / (kpr_), 3);
                    --если установлено на ограничение по соц.норме
                    IF rec_peoples.limit_part = 1 THEN
                      IF hv_man_ > rec_peoples.tarnorm THEN
                        hv_man_ := rec_peoples.tarnorm;
                      ELSE
                        hv_man_ := round((rec_krt.mhw) * sign_kub_ / (kpr_),
                                         3);
                      END IF;
                    END IF;
                    --остаток в размере 0.01-0.02 м2 кидаем на последнего проживающего
                    IF hv_ - hv_man_ BETWEEN 0.0001 AND 0.02 THEN
                      hv_man_ := hv_;
                    END IF;
                  ELSE
                    IF hv_ - rec_peoples.tarnorm < 0 THEN
                      --ограничиваем
                      hv_man_ := hv_;
                    ELSE
                      hv_man_ := rec_peoples.tarnorm; --норматив на одного человека
                    END IF;
                  END IF;
                ELSE
                  -- норматив
                  IF rec_nabor.kub = 0 THEN
                    IF hv_ - rec_peoples.tarnorm < 0 THEN
                      --ограничиваем
                      hv_man_ := hv_;
                    ELSE
                      hv_man_ := rec_peoples.tarnorm; --норматив на одного человека
                    END IF;
                  ELSE
                    --домовой счетчик
                    --если по данной услуге у проживающего расчет льготы в дол€х то...
                    IF rec_peoples.charge_part = 1 THEN
                      hv_man_ := (rec_krt.mhw) * sign_kub_;
                      --если установлено на ограничение по соц.норме
                      IF rec_peoples.limit_part = 1 THEN
                        IF hv_man_ > rec_peoples.tarnorm THEN
                          hv_man_ := rec_peoples.tarnorm;
                        ELSE
                          hv_man_ := (rec_krt.mhw) * sign_kub_;
                        END IF;
                      END IF;
                      --остаток в размере 0.01-0.02 м2 кидаем на последнего проживающего
                      IF hv_ - hv_man_ BETWEEN 0.0001 AND 0.02 THEN
                        hv_man_ := hv_;
                      END IF;
                      --остаток в размере 0.01-0.02 м2 кидаем на последнего проживающего
                      IF hv_ - hv_man_ BETWEEN 0.0001 AND 0.02 THEN
                        hv_man_ := hv_;
                      END IF;
                    ELSE
                      IF hv_ - rec_peoples.tarnorm < 0 THEN
                        --ограничиваем
                        hv_man_ := hv_;
                      ELSE
                        hv_man_ := rec_peoples.tarnorm; --норматив на одного человека
                      END IF;
                    END IF;
                  END IF;
                END IF;

                exists_ := 0;
                FOR element IN 1 .. t_peop_id.count LOOP
                  --ищем id проживающего
                  IF t_peop_id(element) = rec_peoples.id THEN
                    exists_ := 1;
                  END IF;
                END LOOP;
                --еще не считали человека и посто€нно прописанный или временно зарегистрированный
                IF exists_ = 0 AND
                   (rec_peoples.status IN (1, 5) OR rec_peoples.status = 3) THEN
                  IF round(hv_man_ * rec_peoples.cena * sign_kub_, 2) <> 0 THEN
                    npp_ := npp_ + 1;
                    --со льготой
                    sit_    := sit_ + round(hv_man_ * rec_peoples.cena *
                                            sign_kub_ * rec_peoples.koef *
                                            rec_peoples.usl_subs,
                                            2);
                    summaf_ := hv_man_ * rec_peoples.cena *
                               rec_peoples.koef * sign_kub_;
                    summa_  := round(summaf_, 2);
                    INSERT INTO c_charge
                      (npp, lsk, usl, summa, summaf, kart_pr_id, TYPE, spk_id, test_opl, test_cena, test_tarkoef, test_spk_koef)
                    VALUES
                      (0, rec_krt.lsk, usl_, summa_, summaf_, rec_peoples.id, 0, rec_peoples.spk_id, hv_man_ *
                        sign_kub_, rec_peoples.cena, NULL, rec_peoples.koef);
                    --без льготы
                    msit_   := msit_ +
                               round(hv_man_ * rec_peoples.cena * sign_kub_ *
                                     rec_peoples.usl_subs,
                                     2);
                    summaf_ := hv_man_ * rec_peoples.cena * sign_kub_;
                    summa_  := round(summaf_, 2);
                    INSERT INTO c_charge
                      (npp, lsk, usl, summa, summaf, kart_pr_id, TYPE, spk_id, test_opl, test_cena, test_tarkoef, test_spk_koef)
                    VALUES
                      (npp_, rec_krt.lsk, usl_, summa_, summaf_, rec_peoples.id, 1, rec_peoples.spk_id, hv_man_ *
                        sign_kub_, rec_peoples.cena, NULL, rec_peoples.koef);
                    summa_ := round(hv_man_ * rec_peoples.cena * sign_kub_,
                                    2) - round(hv_man_ * rec_peoples.cena *
                                               rec_peoples.koef * sign_kub_,
                                               2);
                    IF summa_ <> 0 THEN
                      --Ћ№√ќ“ј
                      INSERT INTO c_charge
                        (npp, lsk, usl, summa, kart_pr_id, TYPE, spk_id, test_opl, test_cena, test_tarkoef, test_spk_koef, main, lg_doc_id)
                      VALUES
                        (npp_, rec_krt.lsk, usl_, summa_, rec_peoples.id, 3, rec_peoples.spk_id, hv_man_ *
                          sign_kub_, rec_peoples.cena, NULL, rec_peoples.koef, rec_peoples.main, rec_peoples.lg_doc_id);
                    END IF;
                  END IF;
                  --посчитали человека
                  hv_ := hv_ - hv_man_;
                END IF;
                --посчитали человека
                t_peop_id.extend;
                t_peop_id(t_peop_id.last) := rec_peoples.id;
                EXIT WHEN hv_ <= 0;

                FETCH cur_peoples --здесь FETCH идет после
                  INTO rec_peoples;
                EXIT WHEN cur_peoples%NOTFOUND;

              END LOOP;
              CLOSE cur_peoples;
              IF hv_ > 0 AND rec_nabor.usl_h IS NOT NULL THEN
                --проживающие закончились, объем осталс€
                hv_sv_ := hv_;
                usl_   := rec_nabor.usl_p;
                OPEN cur_peoples;
                t_peop_id.delete;
                LOOP
                  FETCH cur_peoples
                    INTO rec_peoples;
                  EXIT WHEN cur_peoples%NOTFOUND;
                  --если по данной услуге у проживающего расчет льготы в дол€х то...
                  IF rec_peoples.charge_part = 1 THEN
                    hv_man_ := round(hv_sv_ / (kpr_), 2);
                  ELSE
                    --если не в дол€х, всЄ кидаем на первого льготника...
                    hv_man_ := hv_;
                  END IF;

                  sit_    := sit_ + round(hv_man_ * rec_peoples.cena *
                                          rec_peoples.koef *
                                          rec_peoples.usl_subs * sign_kub_,
                                          2);
                  npp_    := npp_ + 1;
                  summaf_ := hv_man_ * rec_peoples.cena * rec_peoples.koef *
                             sign_kub_;
                  summa_  := round(summaf_, 2);
                  INSERT INTO c_charge
                    (npp, lsk, usl, summa, summaf, kart_pr_id, TYPE, spk_id, test_opl, test_cena, test_tarkoef, test_spk_koef)
                  VALUES
                    (0, rec_krt.lsk, usl_, summa_, summaf_, rec_peoples.id, 0, rec_peoples.spk_id, hv_man_ *
                      sign_kub_, rec_peoples.cena, NULL, rec_peoples.koef);
                  --без льготы
                  msit_   := msit_ + round(hv_man_ * rec_peoples.cena *
                                           rec_peoples.usl_subs,
                                           2);
                  summaf_ := hv_man_ * rec_peoples.cena * sign_kub_;
                  summa_  := round(summaf_, 2);
                  INSERT INTO c_charge
                    (npp, lsk, usl, summa, summaf, kart_pr_id, TYPE, spk_id, test_opl, test_cena, test_tarkoef, test_spk_koef)
                  VALUES
                    (npp_, rec_krt.lsk, usl_, summa_, summaf_, rec_peoples.id, 1, rec_peoples.spk_id, hv_man_ *
                      sign_kub_, rec_peoples.cena, NULL, rec_peoples.koef);
                  summa_ := round(hv_man_ * rec_peoples.cena * sign_kub_, 2) -
                            round(hv_man_ * rec_peoples.cena *
                                  rec_peoples.koef * sign_kub_,
                                  2);
                  IF summa_ <> 0 THEN
                    --Ћ№√ќ“ј
                    INSERT INTO c_charge
                      (npp, lsk, usl, summa, kart_pr_id, TYPE, spk_id, test_opl, test_cena, test_tarkoef, test_spk_koef, main, lg_doc_id)
                    VALUES
                      (npp_, rec_krt.lsk, usl_, summa_, rec_peoples.id, 3, rec_peoples.spk_id, hv_man_ *
                        sign_kub_, rec_peoples.cena, NULL, rec_peoples.koef, rec_peoples.main, rec_peoples.lg_doc_id);
                  END IF;
                  --вычитаем обработанное
                  hv_ := hv_ - hv_man_;

                  --посчитали человека
                  t_peop_id.extend;
                  t_peop_id(t_peop_id.last) := rec_peoples.id;
                  EXIT WHEN hv_ <= 0;
                END LOOP;
                CLOSE cur_peoples;
              END IF;

            ELSE
              --нет проживающих вообще (начислить воду по свыше с.н.)
              IF rec_nabor.chrg2 <> 0 AND rec_krt.psch = 1 OR
                 rec_krt.psch = 2 THEN
                --только счетчики
                hv_ := rec_krt.mhw; --общий расход по х.в.
                --≈сли расход отрицательный то...
                IF hv_ >= 0 THEN
                  sign_kub_ := 1;
                ELSE
                  sign_kub_ := -1;
                END IF;
                hv_kan_ := rec_krt.mhw;
                hv_     := abs(hv_);

                usl_ := rec_nabor.usl_p;
                OPEN cur_wo_peop(null);
                FETCH cur_wo_peop
                  INTO rec_wo_peop;
                --со льготой
                npp_    := npp_ + 1;
                sit_    := sit_ + round(hv_ * rec_wo_peop.cena *
                                        rec_wo_peop.usl_subs * sign_kub_,
                                        2);
                summaf_ := hv_ * rec_wo_peop.cena * sign_kub_;
                summa_  := round(summaf_, 2);
                INSERT INTO c_charge
                  (npp, lsk, usl, summa, summaf, kart_pr_id, TYPE, spk_id, test_opl, test_cena, test_tarkoef, test_spk_koef)
                VALUES
                  (0, rec_krt.lsk, usl_, summa_, summaf_, NULL, 0, NULL, hv_ *
                    sign_kub_, rec_wo_peop.cena, NULL, NULL);
                --без льготы
                msit_   := msit_ + round(hv_ * rec_wo_peop.cena *
                                         rec_wo_peop.usl_subs * sign_kub_,
                                         2);
                summaf_ := hv_ * rec_wo_peop.cena * sign_kub_;
                summa_  := round(summaf_, 2);
                INSERT INTO c_charge
                  (npp, lsk, usl, summa, summaf, kart_pr_id, TYPE, spk_id, test_opl, test_cena, test_tarkoef, test_spk_koef)
                VALUES
                  (npp_, rec_krt.lsk, usl_, summa_, summaf_, NULL, 1, NULL, hv_ *
                    sign_kub_, rec_wo_peop.cena * sign_kub_, rec_wo_peop.tarkoef, NULL);
                CLOSE cur_wo_peop;
              END IF;
            END IF;

          END IF;
          --||||||||||||||||||||||||||||||||||||||--
          --√ор€ча€ вода (”—“ј–≈¬Ў≈≈, дл€ ѕолыс)
          IF rec_nabor.chrg1 <> 0 AND rec_nabor.fk_calc_tp IN (28) THEN --#28#
            --признак распределени€ по вводу дл€ канализ.
            gv_kub_ := nvl(rec_nabor.kub, 0);
            gv_kan_ := 0;
            IF kpr_ > 0 THEN
              --есть проживающие
              OPEN cur_peoples;
              FETCH cur_peoples
                INTO rec_peoples;
              t_peop_id.delete;

              IF rec_krt.psch = 1 THEN
                --все счетчики
                gv_ := (rec_krt.mgw); --общий расход по г.в.
              ELSIF rec_krt.psch = 3 THEN
                --счетчик по г.воде
                gv_ := (rec_krt.mgw); --общий расход по г.в.
              ELSE
                --норматив по г.воде
                IF nvl(rec_krt.kran1, 0) = 1 AND otop_ = 1 THEN
                  --краны не настроены до конца
                  gv_ := 0;
                ELSE
                  IF rec_nabor.kub = 0 THEN
                    gv_ := (kpr_) * (rec_peoples.tarnorm); --нет домового распределени€ на человека
                  ELSE
                    gv_ := (kpr_) * (rec_krt.mgw); --есть домовое распределение на человека
                  END IF;
                END IF;

              END IF;
              --≈сли расход отрицательный то...
              IF gv_ >= 0 THEN
                sign_kub_ := 1;
              ELSE
                sign_kub_ := -1;
              END IF;
              gv_kan_ := nvl(gv_, 0); -- + расход по г.в. по канализ.
              gv_     := abs(gv_);
              LOOP
                IF gv_ = 0 THEN
                  --защита от рассчЄта при gv_ = 0
                  EXIT;
                END IF;
                IF rec_krt.psch = 1 OR rec_krt.psch = 3 THEN
                  --счетчики
                  --если по данной услуге у проживающего расчет льготы в дол€х то...
                  IF rec_peoples.charge_part = 1 THEN
                    gv_man_ := round((rec_krt.mgw) * sign_kub_ / (kpr_), 3);
                    --если установлено на ограничение по соц.норме
                    IF rec_peoples.limit_part = 1 THEN
                      IF gv_man_ > rec_peoples.tarnorm THEN
                        gv_man_ := rec_peoples.tarnorm;
                      ELSE
                        gv_man_ := round((rec_krt.mgw) * sign_kub_ / (kpr_),
                                         3);
                      END IF;
                    END IF;
                    --остаток в размере 0.01-0.02 м2 кидаем на последнего проживающего
                    IF gv_ - gv_man_ BETWEEN 0.0001 AND 0.02 THEN
                      gv_man_ := gv_;
                    END IF;
                  ELSE
                    IF gv_ - rec_peoples.tarnorm < 0 THEN
                      --ограничиваем
                      gv_man_ := gv_;
                    ELSE
                      gv_man_ := rec_peoples.tarnorm; --норматив на одного человека
                    END IF;
                  END IF;
                ELSE
                  -- норматив
                  IF rec_nabor.kub = 0 THEN
                    IF gv_ - rec_peoples.tarnorm < 0 THEN
                      --ограничиваем
                      gv_man_ := gv_;
                    ELSE
                      gv_man_ := rec_peoples.tarnorm; --норматив на одного человека
                    END IF;
                  ELSE
                    --домовой счетчик
                    --если по данной услуге у проживающего расчет льготы в дол€х то...
                    IF rec_peoples.charge_part = 1 THEN
                      gv_man_ := (rec_krt.mgw) * sign_kub_;
                      --если установлено на ограничение по соц.норме
                      IF rec_peoples.limit_part = 1 THEN
                        IF gv_man_ > rec_peoples.tarnorm THEN
                          gv_man_ := rec_peoples.tarnorm;
                        ELSE
                          gv_man_ := (rec_krt.mgw) * sign_kub_;
                        END IF;
                      END IF;
                      --остаток в размере 0.01-0.02 м2 кидаем на последнего проживающего
                      IF gv_ - gv_man_ BETWEEN 0.0001 AND 0.02 THEN
                        gv_man_ := gv_;
                      END IF;
                    ELSE
                      IF gv_ - rec_peoples.tarnorm < 0 THEN
                        --ограничиваем
                        gv_man_ := gv_;
                      ELSE
                        gv_man_ := rec_peoples.tarnorm; --норматив на одного человека
                      END IF;
                    END IF;
                  END IF;
                END IF;

                exists_ := 0;
                FOR element IN 1 .. t_peop_id.count LOOP
                  --ищем id проживающего
                  IF t_peop_id(element) = rec_peoples.id THEN
                    exists_ := 1;
                  END IF;
                END LOOP;
                --еще не считали человека и посто€нно прописанный или временно зарегистрированный
                IF exists_ = 0 AND
                   (rec_peoples.status IN (1, 5) OR rec_peoples.status = 3) THEN
                  IF round(gv_man_ * rec_peoples.cena, 2) <> 0 THEN
                    --со льготой
                    npp_    := npp_ + 1;
                    sit_    := sit_ +
                               round(gv_man_ * rec_peoples.cena *
                                     rec_peoples.koef *
                                     rec_peoples.usl_subs * sign_kub_,
                                     2);
                    summaf_ := gv_man_ * rec_peoples.cena *
                               rec_peoples.koef * sign_kub_;
                    summa_  := round(summaf_, 2);
                    INSERT INTO c_charge
                      (npp, lsk, usl, summa, summaf, kart_pr_id, TYPE, spk_id, test_opl, test_cena, test_tarkoef, test_spk_koef)
                    VALUES
                      (0, rec_krt.lsk, usl_, summa_, summaf_, rec_peoples.id, 0, rec_peoples.spk_id, gv_man_ *
                        sign_kub_, rec_peoples.cena, NULL, rec_peoples.koef);
                    --без льготы
                    msit_   := msit_ +
                               round(gv_man_ * rec_peoples.cena *
                                     rec_peoples.usl_subs * sign_kub_,
                                     2);
                    summaf_ := gv_man_ * rec_peoples.cena * sign_kub_;
                    summa_  := round(summaf_, 2);
                    INSERT INTO c_charge
                      (npp, lsk, usl, summa, summaf, kart_pr_id, TYPE, spk_id, test_opl, test_cena, test_tarkoef, test_spk_koef)
                    VALUES
                      (npp_, rec_krt.lsk, usl_, summa_, summaf_, rec_peoples.id, 1, rec_peoples.spk_id, gv_man_ *
                        sign_kub_, rec_peoples.cena, NULL, rec_peoples.koef);
                    summa_ := round(gv_man_ * rec_peoples.cena * sign_kub_,
                                    2) - round(gv_man_ * rec_peoples.cena *
                                               rec_peoples.koef * sign_kub_,
                                               2);
                    IF summa_ <> 0 THEN
                      --Ћ№√ќ“ј
                      INSERT INTO c_charge
                        (npp, lsk, usl, summa, kart_pr_id, TYPE, spk_id, test_opl, test_cena, test_tarkoef, test_spk_koef, main, lg_doc_id)
                      VALUES
                        (npp_, rec_krt.lsk, usl_, summa_, rec_peoples.id, 3, rec_peoples.spk_id, gv_man_ *
                          sign_kub_, rec_peoples.cena, NULL, rec_peoples.koef, rec_peoples.main, rec_peoples.lg_doc_id);
                    END IF;
                  END IF;
                  --посчитали человека
                  gv_ := gv_ - gv_man_;
                END IF;
                --посчитали человека
                t_peop_id.extend;
                t_peop_id(t_peop_id.last) := rec_peoples.id;
                EXIT WHEN gv_ <= 0;

                FETCH cur_peoples --здесь FETCH идет после
                  INTO rec_peoples;
                EXIT WHEN cur_peoples%NOTFOUND;

              END LOOP;
              CLOSE cur_peoples;
              IF gv_ > 0 AND rec_nabor.usl_h IS NOT NULL THEN
                --проживающие закончились, объем осталс€
                gv_sv_ := gv_;
                usl_   := rec_nabor.usl_p;
                OPEN cur_peoples;
                t_peop_id.delete;
                LOOP
                  FETCH cur_peoples
                    INTO rec_peoples;
                  EXIT WHEN cur_peoples%NOTFOUND;
                  --если по данной услуге у проживающего расчет льготы в дол€х то...
                  IF rec_peoples.charge_part = 1 THEN
                    gv_man_ := round(gv_sv_ / (kpr_), 2);
                  ELSE
                    --если не в дол€х, всЄ кидаем на первого льготника...
                    gv_man_ := gv_;
                  END IF;
                  --со льготой
                  npp_    := npp_ + 1;
                  sit_    := sit_ + round(gv_man_ * rec_peoples.cena *
                                          rec_peoples.koef *
                                          rec_peoples.usl_subs * sign_kub_,
                                          2);
                  summaf_ := gv_man_ * rec_peoples.cena * rec_peoples.koef *
                             sign_kub_;
                  summa_  := round(summaf_, 2);
                  INSERT INTO c_charge
                    (npp, lsk, usl, summa, summaf, kart_pr_id, TYPE, spk_id, test_opl, test_cena, test_tarkoef, test_spk_koef)
                  VALUES
                    (0, rec_krt.lsk, usl_, summa_, summaf_, rec_peoples.id, 0, rec_peoples.spk_id, gv_man_ *
                      sign_kub_, rec_peoples.cena, NULL, rec_peoples.koef);
                  --без льготы
                  msit_   := msit_ + round(gv_man_ * rec_peoples.cena *
                                           rec_peoples.usl_subs * sign_kub_,
                                           2);
                  summaf_ := gv_man_ * rec_peoples.cena * sign_kub_;
                  summa_  := round(summaf_, 2);
                  INSERT INTO c_charge
                    (npp, lsk, usl, summa, summaf, kart_pr_id, TYPE, spk_id, test_opl, test_cena, test_tarkoef, test_spk_koef)
                  VALUES
                    (npp_, rec_krt.lsk, usl_, summa_, summaf_, rec_peoples.id, 1, rec_peoples.spk_id, gv_man_ *
                      sign_kub_, rec_peoples.cena, NULL, rec_peoples.koef);
                  summa_ := round(gv_man_ * rec_peoples.cena * sign_kub_, 2) -
                            round(gv_man_ * rec_peoples.cena *
                                  rec_peoples.koef * sign_kub_,
                                  2);
                  IF summa_ <> 0 THEN
                    --Ћ№√ќ“ј
                    INSERT INTO c_charge
                      (npp, lsk, usl, summa, kart_pr_id, TYPE, spk_id, test_opl, test_cena, test_tarkoef, test_spk_koef, main, lg_doc_id)
                    VALUES
                      (npp_, rec_krt.lsk, usl_, summa_, rec_peoples.id, 3, rec_peoples.spk_id, gv_man_ *
                        sign_kub_, rec_peoples.cena, NULL, rec_peoples.koef, rec_peoples.main, rec_peoples.lg_doc_id);
                  END IF;
                  --вычитаем обработанное
                  gv_ := gv_ - gv_man_;

                  --посчитали человека
                  t_peop_id.extend;
                  t_peop_id(t_peop_id.last) := rec_peoples.id;
                  EXIT WHEN gv_ <= 0;
                END LOOP;
                CLOSE cur_peoples;
              END IF;

            ELSE
              --нет проживающих вообще (начислить воду по свыше с.н.)
              IF rec_nabor.chrg2 <> 0 AND rec_krt.psch = 1 OR
                 rec_krt.psch = 3 THEN
                --только счетчики
                gv_  := (rec_krt.mgw); --общий расход по г.в.
                usl_ := rec_nabor.usl_p;
                --≈сли расход отрицательный то...
                IF gv_ >= 0 THEN
                  sign_kub_ := 1;
                ELSE
                  sign_kub_ := -1;
                END IF;
                gv_kan_ := (rec_krt.mgw);
                gv_     := abs(gv_);

                OPEN cur_wo_peop(null);
                FETCH cur_wo_peop
                  INTO rec_wo_peop;
                --со льготой
                sit_    := sit_ + round(gv_ * rec_wo_peop.cena *
                                        rec_wo_peop.usl_subs,
                                        2);
                npp_    := npp_ + 1;
                summaf_ := gv_ * rec_wo_peop.cena * sign_kub_;
                summa_  := round(summaf_, 2);
                INSERT INTO c_charge
                  (npp, lsk, usl, summa, summaf, kart_pr_id, TYPE, spk_id, test_opl, test_cena, test_tarkoef, test_spk_koef)
                VALUES
                  (0, rec_krt.lsk, usl_, summa_, summaf_, NULL, 0, NULL, gv_ *
                    sign_kub_, rec_wo_peop.cena, NULL, NULL);
                --без льготы
                msit_   := msit_ + round(gv_ * rec_wo_peop.cena *
                                         rec_wo_peop.usl_subs,
                                         2);
                summaf_ := gv_ * rec_wo_peop.cena * sign_kub_;
                summa_  := round(summaf_, 2);
                INSERT INTO c_charge
                  (npp, lsk, usl, summa, summaf, kart_pr_id, TYPE, spk_id, test_opl, test_cena, test_tarkoef, test_spk_koef)
                VALUES
                  (npp_, rec_krt.lsk, usl_, summa_, summaf_, NULL, 1, NULL, gv_ *
                    sign_kub_, rec_wo_peop.cena, rec_wo_peop.tarkoef, NULL);
                CLOSE cur_wo_peop;
              END IF;
            END IF;

          END IF;
          --||||||||||||||||||||||||||||||||||||||--
          -- анализование (”—“ј–≈¬Ў≈≈, дл€ ѕолыс)
          IF (rec_nabor.chrg1 <> 0 OR rec_nabor.chrg2 <> 0) AND
             rec_nabor.fk_calc_tp IN (29) THEN --#29#
            --Ќе корректно использование подомового распределени€ из за
            --использовани€ rec_krt.mgw (прим.от 29.07.11)
            kan_ := 0;
            IF kpr_ > 0 THEN
              --есть проживающие
              OPEN cur_peoples;
              FETCH cur_peoples
                INTO rec_peoples;
              t_peop_id.delete;

              IF rec_krt.psch = 1 THEN
                --все счетчики
                kan_ := hv_kan_ + gv_kan_;
              ELSIF rec_krt.psch = 2 THEN
                --счетчик х.в.
                kan_ := gv_kan_ + hv_kan_;

              ELSIF rec_krt.psch = 3 THEN
                --счетчик г.в.
                kan_ := hv_kan_ + gv_kan_;
              ELSE
                --норматив
                IF (rec_krt.mhw) = 0 AND (rec_krt.mgw) = 0 AND
                   (hv_kan_ + gv_kan_) <> 0 THEN
                  --нет домового распределени€ на человека
                  kan_ := hv_kan_ + gv_kan_;
                  --ред. 29.07.11
                  --                      kan_ := round((kpr_ ) *
                  --                                    rec_peoples.tarnorm,
                  --                                    3);
                ELSIF hv_kub_ = 0 AND gv_kub_ <> 0 THEN
                  --есть домовое распределение на человека по г.в.
                  --здесь будет ошибочно считатьс€, если будет подомовое распределение!!! (rec_krt.mgw)
                  kan_ := (kpr_) * rec_krt.mgw + hv_kan_;
                ELSIF hv_kub_ <> 0 AND gv_kub_ = 0 THEN
                  --есть домовое распределение на человека по х.в.
                  kan_ := (kpr_) * rec_krt.mhw + gv_kan_;
                ELSIF hv_kub_ <> 0 AND gv_kub_ <> 0 THEN
                  --есть домовое распределение на человека по х.в. и г.в.
                  kan_ := hv_kan_ + gv_kan_;
                END IF;
              END IF;
              --округл€ем общее кол-во кубов по канализ
              kan_ := round(kan_, 4);
              --≈сли расход отрицательный то...
              IF kan_ >= 0 THEN
                sign_kub_ := 1;
              ELSE
                sign_kub_ := -1;
              END IF;
              kan_ := abs(kan_);

              --—охран€ем значение канализовани€
              saved_kan_ := kan_;
              --Ќачинаем расчЄт по люд€м:
              LOOP
                --если по данной услуге у проживающего расчет льготы в дол€х то...
                IF rec_peoples.charge_part = 1 THEN
                  kan_man_ := round(saved_kan_ / (kpr_), 3);
                  --если установлено на ограничение по соц.норме
                  IF rec_peoples.limit_part = 1 THEN
                    IF kan_man_ > rec_peoples.tarnorm THEN
                      kan_man_ := rec_peoples.tarnorm;
                    ELSE
                      kan_man_ := round(saved_kan_ / (kpr_), 3);
                    END IF;
                  END IF;
                  --остаток в размере 0.01-0.02 м2 кидаем на последнего проживающего
                  IF kan_ - kan_man_ BETWEEN 0.0001 AND 0.02 THEN
                    kan_man_ := kan_;
                  END IF;
                ELSE
                  IF kan_ - rec_peoples.tarnorm < 0 THEN
                    --ограничиваем
                    kan_man_ := kan_;
                  ELSE
                    kan_man_ := rec_peoples.tarnorm; --норматив на одного человека
                  END IF;
                END IF;

                exists_ := 0;
                FOR element IN 1 .. t_peop_id.count LOOP
                  --ищем id проживающего
                  IF t_peop_id(element) = rec_peoples.id THEN
                    exists_ := 1;
                  END IF;
                END LOOP;
                --еще не считали человека и посто€нно прописанный или временно зарегистрированный
                IF exists_ = 0 AND
                   (rec_peoples.status IN (1, 5) OR rec_peoples.status = 3) THEN
                  IF round(kan_man_ * rec_peoples.cena * sign_kub_, 2) <> 0 THEN
                    --со льготой
                    sit_    := sit_ +
                               round(kan_man_ * rec_peoples.cena *
                                     rec_peoples.koef *
                                     rec_peoples.usl_subs * sign_kub_,
                                     2);
                    npp_    := npp_ + 1;
                    summaf_ := kan_man_ * rec_peoples.cena *
                               rec_peoples.koef * sign_kub_;
                    summa_  := round(summaf_, 2);
                    INSERT INTO c_charge
                      (npp, lsk, usl, summa, summaf, kart_pr_id, TYPE, spk_id, test_opl, test_cena, test_tarkoef, test_spk_koef)
                    VALUES
                      (0, rec_krt.lsk, usl_, summa_, summaf_, rec_peoples.id, 0, rec_peoples.spk_id, kan_man_ *
                        sign_kub_, rec_peoples.cena, NULL, rec_peoples.koef);
                    --без льготы
                    msit_   := msit_ +
                               round(kan_man_ * rec_peoples.cena *
                                     rec_peoples.usl_subs * sign_kub_,
                                     2);
                    summaf_ := kan_man_ * rec_peoples.cena * sign_kub_;
                    summa_  := round(summaf_, 2);
                    INSERT INTO c_charge
                      (npp, lsk, usl, summa, summaf, kart_pr_id, TYPE, spk_id, test_opl, test_cena, test_tarkoef, test_spk_koef)
                    VALUES
                      (npp_, rec_krt.lsk, usl_, summa_, summaf_, rec_peoples.id, 1, rec_peoples.spk_id, kan_man_, rec_peoples.cena, NULL, rec_peoples.koef);
                    summa_ := round(kan_man_ * rec_peoples.cena * sign_kub_,
                                    2) - round(kan_man_ * rec_peoples.cena *
                                               rec_peoples.koef * sign_kub_,
                                               2);
                    IF summa_ <> 0 THEN
                      --Ћ№√ќ“ј
                      INSERT INTO c_charge
                        (npp, lsk, usl, summa, kart_pr_id, TYPE, spk_id, test_opl, test_cena, test_tarkoef, test_spk_koef, main, lg_doc_id)
                      VALUES
                        (npp_, rec_krt.lsk, usl_, summa_, rec_peoples.id, 3, rec_peoples.spk_id, kan_man_ *
                          sign_kub_, rec_peoples.cena, NULL, rec_peoples.koef, rec_peoples.main, rec_peoples.lg_doc_id);
                    END IF;
                  END IF;
                  --посчитали человека
                  kan_ := kan_ - kan_man_;
                END IF;
                --посчитали человека
                t_peop_id.extend;
                t_peop_id(t_peop_id.last) := rec_peoples.id;
                EXIT WHEN kan_ <= 0;

                FETCH cur_peoples --здесь FETCH идет после
                  INTO rec_peoples;
                EXIT WHEN cur_peoples%NOTFOUND;
              END LOOP;
              CLOSE cur_peoples;
              IF rec_nabor.chrg2 <> 0 AND kan_ > 0 AND
                 rec_nabor.usl_h IS NOT NULL THEN
                --проживающие закончились, объем осталс€
                kan_sv_ := kan_;
                usl_    := rec_nabor.usl_p;
                OPEN cur_peoples;
                t_peop_id.delete;
                LOOP
                  FETCH cur_peoples
                    INTO rec_peoples;
                  EXIT WHEN cur_peoples%NOTFOUND;
                  --если по данной услуге у проживающего расчет льготы в дол€х то...
                  IF rec_peoples.charge_part = 1 THEN
                    kan_man_ := round(kan_sv_ / (kpr_), 2);
                  ELSE
                    --если не в дол€х, всЄ кидаем на первого льготника...
                    kan_man_ := kan_;
                  END IF;
                  --со льготой
                  sit_    := sit_ + round(kan_man_ * rec_peoples.cena *
                                          rec_peoples.koef *
                                          rec_peoples.usl_subs * sign_kub_,
                                          2);
                  npp_    := npp_ + 1;
                  summaf_ := kan_man_ * rec_peoples.cena * rec_peoples.koef *
                             sign_kub_;
                  summa_  := round(summaf_, 2);
                  INSERT INTO c_charge
                    (npp, lsk, usl, summa, summaf, kart_pr_id, TYPE, spk_id, test_opl, test_cena, test_tarkoef, test_spk_koef)
                  VALUES
                    (0, rec_krt.lsk, usl_, summa_, summaf_, rec_peoples.id, 0, rec_peoples.spk_id, kan_man_ *
                      sign_kub_, rec_peoples.cena, NULL, rec_peoples.koef);
                  --без льготы
                  msit_   := msit_ + round(kan_man_ * rec_peoples.cena *
                                           rec_peoples.usl_subs * sign_kub_,
                                           2);
                  summaf_ := kan_man_ * rec_peoples.cena * sign_kub_;
                  summa_  := round(summaf_, 2);
                  INSERT INTO c_charge
                    (npp, lsk, usl, summa, summaf, kart_pr_id, TYPE, spk_id, test_opl, test_cena, test_tarkoef, test_spk_koef)
                  VALUES
                    (npp_, rec_krt.lsk, usl_, summa_, summaf_, rec_peoples.id, 1, rec_peoples.spk_id, kan_man_ *
                      sign_kub_, rec_peoples.cena, NULL, rec_peoples.koef);
                  summa_ := round(kan_man_ * rec_peoples.cena * sign_kub_,
                                  2) - round(kan_man_ * rec_peoples.cena *
                                             rec_peoples.koef * sign_kub_,
                                             2);
                  IF summa_ <> 0 THEN
                    --Ћ№√ќ“ј
                    INSERT INTO c_charge
                      (npp, lsk, usl, summa, kart_pr_id, TYPE, spk_id, test_opl, test_cena, test_tarkoef, test_spk_koef, main, lg_doc_id)
                    VALUES
                      (npp_, rec_krt.lsk, usl_, summa_, rec_peoples.id, 3, rec_peoples.spk_id, kan_man_ *
                        sign_kub_, rec_peoples.cena, NULL, rec_peoples.koef, rec_peoples.main, rec_peoples.lg_doc_id);
                  END IF;
                  --вычитаем обработанное
                  kan_ := kan_ - kan_man_;

                  --посчитали человека
                  t_peop_id.extend;
                  t_peop_id(t_peop_id.last) := rec_peoples.id;
                  EXIT WHEN kan_ <= 0;
                END LOOP;
                CLOSE cur_peoples;
              END IF;
              --вообще нет проживающих
            ELSE
              --ƒл€  иселевска и “—∆ одинаково
              IF rec_krt.psch = 1 THEN
                --все счетчики
                --считаем только воду в канализ где есть признак еЄ учитывать
                IF nvl(rec_krt.kan_sch, 0) <> 0 OR
                   nvl(rec_krt.kan_sch2, 0) <> 0 THEN
                  kan_ := hv_kan_ + gv_kan_;
                ELSE
                  kan_ := 0;
                END IF;
              ELSIF rec_krt.psch = 2 THEN
                --счетчик х.в.
                --считаем только воду в канализ где есть признак еЄ учитывать
                IF nvl(rec_krt.kan_sch, 0) <> 0 OR
                   nvl(rec_krt.kan_sch2, 0) <> 0 THEN
                  kan_ := hv_kan_;
                ELSE
                  kan_ := 0;
                END IF;
              ELSIF rec_krt.psch = 3 THEN
                --счетчик г.в.
                --считаем только воду в канализ где есть признак еЄ учитывать
                IF nvl(rec_krt.kan_sch, 0) <> 0 OR
                   nvl(rec_krt.kan_sch2, 0) <> 0 THEN
                  kan_ := gv_kan_;
                ELSE
                  kan_ := 0;
                END IF;
              END IF;
              --≈сли расход отрицательный то...
              IF kan_ >= 0 THEN
                sign_kub_ := 1;
              ELSE
                sign_kub_ := -1;
              END IF;
              kan_ := abs(kan_);

              --только счетчики
              usl_ := rec_nabor.usl_p;
              OPEN cur_wo_peop(null);
              FETCH cur_wo_peop
                INTO rec_wo_peop;
              --со льготой
              sit_    := sit_ + round(kan_ * rec_wo_peop.cena *
                                      rec_wo_peop.usl_subs * sign_kub_,
                                      2);
              npp_    := npp_ + 1;
              summaf_ := kan_ * rec_wo_peop.cena * sign_kub_;
              summa_  := round(summaf_, 2);
              INSERT INTO c_charge
                (npp, lsk, usl, summa, summaf, kart_pr_id, TYPE, spk_id, test_opl, test_cena, test_tarkoef, test_spk_koef)
              VALUES
                (0, rec_krt.lsk, usl_, summa_, summaf_, NULL, 0, NULL, kan_ *
                  sign_kub_, rec_wo_peop.cena, NULL, NULL);
              --без льготы
              msit_   := msit_ + round(kan_ * rec_wo_peop.cena *
                                       rec_wo_peop.usl_subs * sign_kub_,
                                       2);
              summaf_ := kan_ * rec_wo_peop.cena * sign_kub_;
              summa_  := round(summaf_, 2);
              INSERT INTO c_charge
                (npp, lsk, usl, summa, summaf, kart_pr_id, TYPE, spk_id, test_opl, test_cena, test_tarkoef, test_spk_koef)
              VALUES
                (npp_, rec_krt.lsk, usl_, summa_, summaf_, NULL, 1, NULL, kan_ *
                  sign_kub_, rec_wo_peop.cena, rec_wo_peop.tarkoef, NULL);
              CLOSE cur_wo_peop;
            END IF;

          END IF; */
  END gen_charges;


END c_charges;
/

prompt
prompt Creating package body C_CPENYA
prompt ==============================
prompt
create or replace package body scott.C_CPENYA is
procedure gen_charge_pay_pen is
begin
  --перегруженна€ функци€ формировани€ движени€ и пени
  gen_charge_pay_pen(null);
end;

procedure gen_charge_pay_pen(dat_ in date) is
  summa_ number;
  old_lsk_ c_penya.lsk%type;
  old_usl_ saldo_usl.usl%type;
  old_org_ saldo_usl.org%type;
  l_usl_dst usl.usl%type;
  l_org_dst number;
begin
  --процедура распределени€ начисленной пени по сальдо
  time_ := sysdate;
  --движение по лицевым за тек.период
--  gen_charge_pay_full;
  for c in (select lsk from kart) loop
    --движение по л/c
    gen_charge_pay(c.lsk, 1);
    --пен€ за тек.период
    gen_penya(c.lsk, dat_, 1, 0);

  end loop;

  --после формировани€ пени, распредел€ем еЄ по услугам
  --ѕ≈Ќя –ј—ѕ–≈ƒ≈Ћ»“—я —“–ќ√ќ Ќј ”—Ћ”√» ” ј«јЌЌџ≈ процедурой c_gen_pay.redirect

  --удалить в начале
  delete from temp_chpenya;
  delete from t_chpenya_for_saldo;

  summa_:=0;
  for c in (select t.reu, t.lsk, u.usl, s.org, t.penya, round(t.penya* s.summa/a.summa,2) as summa
   from (select k.reu, d.lsk, sum(d.penya) as penya
    from kart k, c_penya d
    where k.lsk=d.lsk and d.penya <> 0
    group by k.reu, d.lsk) t, saldo_usl s,
   (select d.lsk, sum(d.summa) as summa
    from saldo_usl d, v_params p
    where d.mg=p.period1
    and d.summa > 0 group by d.lsk) a, usl u, v_params p
   where t.lsk=s.lsk and t.lsk=a.lsk and s.mg=p.period1 and t.penya <> 0
   and s.summa > 0 and s.usl=u.usl
   order by t.lsk)
  loop
    if old_lsk_ is null or c.lsk <> old_lsk_ then
      --остаток от распределени€
      if summa_ <> 0 then
        insert into temp_chpenya
          (lsk, summa, usl, org)
        values
           (old_lsk_, summa_, old_usl_, old_org_);
      end if;
      summa_:=c.penya;
    end if;
    --распределение на услуги
    --перенаправление пени
    c_gen_pay.redirect(p_tp => 0, p_reu => c.reu, p_usl_src => c.usl, p_usl_dst => l_usl_dst, p_org_src => c.org, p_org_dst => l_org_dst);

    insert into temp_chpenya
      (lsk, summa, usl, org)
    values
       (c.lsk, c.summa, l_usl_dst, l_org_dst);
    old_lsk_:=c.lsk;
    old_usl_:=c.usl;
    old_org_:=c.org;
    summa_:=summa_-c.summa;
  end loop;

  --остаток от распределени€ по последн л.с.
  if summa_ <> 0 then
    insert into temp_chpenya
      (lsk, summa, usl, org)
    values
       (old_lsk_, summa_, old_usl_, old_org_);
  end if;

  insert into t_chpenya_for_saldo (lsk, summa, usl, org)
  select lsk, sum(summa) as summa, usl, org from temp_chpenya
  group by lsk, usl, org;
  commit;

  --проверка распределени€ пени
  --перенесена в gen.check, ред 31.08.12
/*  select nvl(a.summa,0) - nvl(b.summa,0) into cnt_ from
  (select sum(penya) as summa from c_penya c) a,
  (select sum(summa) as summa from t_chpenya_for_saldo c) b;
 if cnt_ <> 0 then
  Raise_application_error(-20000, '¬нимание! ќшибка в процессе распределени€ начисленной пени по услугам!');
 end if;
*/
 logger.log_(time_, 'c_penya.gen_charge_pay_pen');
end;

PROCEDURE gen_charge_pay_full is
--заполнение c_chargepay
--делать, ƒќ расчета пени
begin

for c in (select k.lsk from kart k)
loop
  gen_charge_pay(c.lsk, 1);
end loop;

--убрал 15.11.12, сделал пересчет по л.с.(выше)
/*
SELECT v.period1 INTO newperiod_ FROM sys.v_params v;
SELECT period INTO period_ FROM PARAMS;
SELECT TO_CHAR(ADD_MONTHS(TO_DATE(period || '01', 'YYYYMMDD'), -1), 'YYYYMM')
 INTO oldperiod_ FROM PARAMS;

gen.trunc_part('c_chargepay', period_);

--начисление
insert into c_chargepay (lsk, summa, type, mg, period)
select a.lsk, sum(summa) as summa, 0, mg, period_
           from (select c.lsk, c.summa, period_ as mg
                    from kart k, c_charge c where k.lsk=c.lsk
                    and c.type=1 --начисление
                    and c.usl not in (select usl_id from usl_excl)
                  union all
                  select c.lsk, c.summa, c.mgchange as mg
                    from kart k, c_change c where k.lsk=c.lsk
                    and c.usl not in (select usl_id from usl_excl)
                    and to_char(c.dtek , 'YYYYMM')=period_ and c.show_bill is null
                  union all
                  select c.lsk, c.summa * -1, period_ as mg
                    from kart k, c_charge c where k.lsk=c.lsk
                    and c.type=2 --субсидии
                    and c.usl not in (select usl_id from usl_excl)
                  union all
                  select c.lsk, c.summa * -1, period_ as mg
                    from kart k, c_charge c where k.lsk=c.lsk
                    and c.type=4 --льготы
                    and c.usl not in (select usl_id from usl_excl)
                  union all
                  select c.lsk, c.summa, c.mg --из старого периода берем начисление
                    from c_chargepay c where c.period=oldperiod_
                    and c.type=0
                    ) a
                  group by a.lsk, a.mg
                  having sum(summa) <>0;

--оплата, оплата пени
insert into c_chargepay (lsk, summa, summap, type, mg, period)
select a.lsk, sum(summa) as summa, sum(summap) as summap, 1, mg, period_
           from (select c.lsk, c.summa, c.penya as summap, c.dopl as mg
                    from kart k, c_kwtp_mg c where k.lsk=c.lsk
                  union all
                select c.lsk, c.summa, null as summap,
                c.dopl as mg --корректировки оплаты
                    from kart k, t_corrects_payments c, params p
                     where k.lsk=c.lsk and
                     c.mg=p.period
                  union all
                  select c.lsk, c.summa, c.summap, c.mg --из старого периода берем оплату
                    from c_chargepay c where c.period=oldperiod_
                    and c.type=1
                    ) a
                  group by a.lsk, a.mg
                  having sum(summa) <>0 or sum(summap) <>0;

commit;
*/
end;

--обертка под старый вызов
PROCEDURE gen_charge_pay(lsk_ in kart.lsk%type, iscommit_ in number) is
begin
  gen_charge_pay(lsk_ => lsk_, iscommit_ => iscommit_, p_dt => null);
end;

--заполнение c_chargepay
--делать, ƒќ расчета пени
PROCEDURE gen_charge_pay(lsk_ in kart.lsk%type, --лиц счет
                         iscommit_ in number,   --ставить ли коммит
                         p_dt in date           --дата по которую принимать транзакции
                        ) is
  period_ PARAMS.period%TYPE;
  newperiod_ PARAMS.period%TYPE;
  oldperiod_ PARAMS.period%TYPE;
begin

if lsk_ is null then
  --не пон€тно зачем контролировать lsk_ is null, неужели кака€ то программа его вызывает?
  Raise_application_error(-20000, '—ообщите программисту код ошибки #1');
end if;


SELECT v.period1 INTO newperiod_ FROM v_params v;
SELECT period INTO period_ FROM PARAMS;
SELECT TO_CHAR(ADD_MONTHS(TO_DATE(period || '01', 'YYYYMMDD'), -1), 'YYYYMM')
 INTO oldperiod_ FROM PARAMS;
--дл€ расчета пени

delete from c_chargepay c where c.period=period_ and c.lsk=lsk_;

--начисление
insert into c_chargepay (summa, type, mg, period, lsk)
select sum(summa) as summa, 0, mg, period_, lsk_
           from (select c.lsk, c.summa, period_ as mg
                    from c_charge c where c.lsk = lsk_
                    and c.type=1 --начисление
                    and c.usl not in (select usl_id from usl_excl)
                  union all
                  select c.lsk, c.summa, c.mgchange as mg
                    from c_change c where c.lsk = lsk_
                    and c.usl not in (select usl_id from usl_excl)
                    and c.dtek <= nvl(p_dt, c.dtek) --ограничить, если надо
                    and c.dtek between init.g_dt_start and init.g_dt_end
                    and c.show_bill is null --ред.01.03.13 - show_bill используетс€ возможно, тогда когда сумма переброски по раз изм = 0 (внутри, по услугам)
                  union all
                  select c.lsk, c.summa, c.mg --из старого периода берем начисление
                    from c_chargepay c where c.lsk = lsk_
                    and c.period=oldperiod_
                    and c.type=0
                    ) a
                  group by a.lsk, a.mg
                  having sum(summa) <>0;

--оплата
if init.g_dt_start is null or init.g_dt_end is null then
  Raise_application_error(-20000, '—ообщите программисту код ошибки #5');
end if;

if to_char(init.g_dt_start,'YYYYMM')<>period_ or to_char(init.g_dt_end,'YYYYMM')<>period_ then
  Raise_application_error(-20000, '—ообщите программисту код ошибки #6');
end if;

insert into c_chargepay (summa, summap, type, mg, period, lsk)
select sum(summa) as summa, sum(summap), 1, mg, period_, lsk_
           from (select c.lsk, c.summa, c.penya as summap,
                c.dopl as mg
                    from c_kwtp_mg c where c.lsk = lsk_
                    and c.dtek <= nvl(p_dt, c.dtek) --ограничить, если надо
                    and (c.dat_ink is null and c.dtek <= init.g_dt_end or --ƒј ƒј сделал пока так странно (учитывать все платежи меньше или = границы периода) ред.02.09.14
                        c.dat_ink between init.g_dt_start and init.g_dt_end)
                  union all
                select c.lsk, c.summa, null as summap,
               /* var=2 чтобы dopl Ќ≈ учитывалс€ в c_deb_usl! ред.08.04.14*/
                  c.dopl
                 --корректировки оплаты
                    from t_corrects_payments c, params p
                     where c.lsk = lsk_ and
                     c.mg=p.period
                  union all
                  select c.lsk, c.summa, c.summap, c.mg --из старого периода берем оплату
                    from c_chargepay c where c.lsk=lsk_
                    and c.period=oldperiod_
                    and c.type=1
                    ) a
                  group by a.lsk, a.mg
                  having sum(summa) <>0 or sum(summap) <>0;
  if iscommit_ = 1 then
   commit;
  end if;
end;

PROCEDURE gen_penya(lsk_ in kart.lsk%type, islastmonth_ in number, p_commit in number) is
begin
  --перегруженна€ функци€ формировани€ пени
  gen_penya(lsk_, null, islastmonth_, p_commit);
end;

PROCEDURE gen_penya(lsk_ in kart.lsk%type, dat_ in date, islastmonth_ in number, p_commit in number) is
 l_cpn kart.cpn%type; --признак начислени€ пени
 l_pn_dt kart.pn_dt%type; --ограничение пени датой
 l_datpen date;
 l_mg params.period%type;
 l_mg_back params.period%type;
 l_summa number;
 l_ovrpay number; --перплата (перенести на будущий период)
 l_tp number; --тип расчета пени
 l_lsk_tp number; --тип лицевого счета (основной/дополнительный)
 l_iter number; --итераци€ расчета
 l_reu kart.reu%type;
begin
  --выполн€ть строго после gen_charge_pay
  --выполн€ть строго после gen.gen_saldo (при формировании за мес€ц)
  --удал€ем предыдущ.расчет
  delete from c_penya t where t.lsk = lsk_;

  --узнать, начисл€ть ли вообще пеню по данному лс?
  select k.cpn, k.pn_dt, k.fk_tp, k.reu into l_cpn, l_pn_dt, l_lsk_tp, l_reu from kart k
    where k.lsk=lsk_;

  --текущий период
  l_mg:=init.get_period;
  --период на мес€ц назад
  l_mg_back:=utils.add_months2(mg_ => l_mg, months_ => -1);

  --текуща€ пен€
  if l_pn_dt is not null then
      --если установлено ограничение пени по лиц.счету
      l_datpen:=l_pn_dt;
  else
    if dat_ is null then
      if islastmonth_ = 0 then --текуща€ пен€
        l_datpen:=init.get_date();
      else --пен€ по концу мес€ца
        l_datpen:=init.get_cur_dt_end;
      end if;
    else --пен€ на конкретную дату
      l_datpen:=dat_;
    end if;
  end if;

  l_ovrpay:=0;
  l_summa:=0;
  l_tp:=utils.get_int_param('GEN_SAL_PEN');

  --удал€ем предыдущ.расчет
  if l_tp=1 then
    delete from c_pen_chrg t where t.lsk = lsk_;
  end if;

  if l_tp=1 then
    --расчет с сальдо по пене
    --перебрать все даты мес€ца
--    l_iter:=0;
    for c2 in (select t.dat from v_cur_days t where t.dat <= l_datpen) loop
      l_iter:=to_char(c2.dat,'DD');
   
      --по каждой дате рассчитать
      --gen_charge_pay(lsk_ => lsk_, iscommit_ => 0, p_dt => c2.dt2); --подготовить движение, с ограниченным периодом, без коммита

      l_ovrpay:=0;
      for c in (
        with a as (  
          select sum(r.summa) as summa, r.mg from (
          select 0 as summa, l_mg as mg from dual --добавить на вс€кий случай тек.период
          union all
          select decode(t.type,0,t.summa,-1*t.summa), t.mg from c_chargepay t where t.lsk=lsk_ and t.period=l_mg_back --долги прошлых периодов
          union all
          select t.summa, l_mg from c_charge t where t.lsk=lsk_ and t.type=0--начисление
          union all
          select -1*t.summa, t.dopl from c_kwtp_mg t where t.lsk=lsk_ and t.dtek<=c2.dat
          union all
          select t.summa, t.mgchange from c_change t where t.lsk=lsk_ and t.dtek<=c2.dat
          ) r
          group by r.mg
          having (sum(r.summa) <> 0 or r.mg=l_mg) --или есть долг-переплата или текущий период
        ) 
        select a.summa, a.mg, s.proc/100 as proc, 
                  c2.dat-e.dat+1 as days from a 
                  left join c_spr_pen e on a.mg=e.mg and e.fk_lsk_tp=l_lsk_tp and e.reu=l_reu
                  left join stav_r s on c2.dat-e.dat+1 between s.days1 and s.days2
                  and s.fk_lsk_tp=l_lsk_tp
                  order by a.mg
           /* select t.mg, nvl(t.summa,0) as summa, --”Ѕ–ј“№  ќћћ≈Ќ“
                    c2.dt2-case when e.dat < c2.dt1 then c2.dt1
                                  when e.dat >= c2.dt1 then e.dat --учесть дату начала пени (об€зательства оплатить)
                                  end +1 as days,
                    (c2.dt2-case when e.dat < c2.dt1 then c2.dt1
                                  when e.dat >= c2.dt1 then e.dat --учесть дату начала пени (об€зательства оплатить)
                                  end +1) * s.proc/100 as proc
                    from v_chargepay t, c_spr_pen e, stav_r s
                   where t.lsk=lsk_ and t.period=l_mg and
                   t.mg=e.mg and l_datpen-e.dat between s.days1 and s.days2
                   and e.fk_lsk_tp=l_lsk_tp and s.fk_lsk_tp=l_lsk_tp
                   order by t.mg*/
          ) loop

           if c.summa < 0 then
             l_ovrpay:=c.summa+l_ovrpay; --сохранить переплату
             if c.mg=l_mg then
               l_summa:=l_ovrpay;
             else
               l_summa:=0;
             end if;
           else
             l_summa:=c.summa+l_ovrpay; --учесть перплату
             if l_summa < 0 then
               l_ovrpay:=l_summa;
             else
               l_ovrpay:=0;
             end if;
           end if;
           if l_summa > 0 or c.mg=l_mg then
             --есть задолжность (еще не значит что есть пен€) или текущий период
             --записать дельту пени (начисление текущего периода) (и задолжность по которой был расчЄт, за период, - информационно)
             insert into c_pen_chrg
               (lsk, summa, penya, days, mg1, iter)
             values (lsk_, l_summa, l_summa*c.proc, case when c.days > 0 then c.days else null end, c.mg, l_iter);
           end if;
      end loop;
    end loop;

  elsif l_tp=0 then
    --расчет без сальдо по пене --¬≈–ќя“Ќќ Ќ≈ Ѕ”ƒ≈“ ЅќЋ№Ў≈ »—ѕќЋ№«ќ¬ј“№—я - ”ƒјЋ»“№ ѕќ“ќћ!
    --рассчитать движение
    gen_charge_pay(lsk_, 0);
    for c in (
          select t.mg, nvl(t.summa,0) as summa,
                  l_datpen - e.dat as days,
                  (l_datpen - e.dat) * s.proc/100 as proc
                  from v_chargepay t, c_spr_pen e, stav_r s
                 where t.lsk=lsk_ and t.period=l_mg and
                 e.fk_lsk_tp=l_lsk_tp and s.fk_lsk_tp=l_lsk_tp and
                 t.mg=e.mg and l_datpen-e.dat between s.days1 and s.days2
                 order by t.mg
        ) loop

         if c.summa < 0 then
           l_ovrpay:=c.summa+l_ovrpay; --сохранить переплату
         else
           l_summa:=c.summa+l_ovrpay; --учесть перплату
           if l_summa < 0 then
             l_ovrpay:=l_summa;
           else
             l_ovrpay:=0;
           end if;
         end if;
         if l_summa > 0 then
           --есть задолжность (еще не значит что есть пен€)
           --записать сразу пеню
           if c.days > 0 then
             --есть пен€ (так как долг>0 и есть дни задолжности)
             insert into c_penya (lsk, summa, penya, days, mg1)
              values (lsk_, l_summa, round(l_summa*c.proc,2), c.days, c.mg);
           else
             --нет пени, просто записать задолжность
             insert into c_penya (lsk, summa, days, mg1)
              values (lsk_, l_summa, null, c.mg);
           end if;
         end if;
    end loop;


  --в любом случае должна быть запись текущего периода
    MERGE INTO c_penya a
    USING (select l_mg as mg from dual) b
      ON (a.lsk = lsk_ and a.mg1 = b.mg)
    WHEN MATCHED THEN
      UPDATE SET a.summa = nvl(a.summa,0)+l_ovrpay
    WHEN NOT MATCHED THEN
      INSERT (lsk, summa, days, mg1)
      VALUES (lsk_, l_ovrpay, null, b.mg);

  end if;

  if l_tp =1 then
  --если учЄт сальдо по пене, то записать исход€щее сальдо (долг вз€ть из последней итерации c_pen_chrg)
    insert into c_penya (lsk, summa, penya, days, mg1)
    select coalesce(b.lsk,r.lsk) as lsk, r.summa, b.penya, case when nvl(r.summa,0) > 0 then r.days else null end as days, b.mg1 from (
    select a.lsk, nvl(round(sum(a.penya),2),0) as penya, a.mg1 from (
    select t.lsk, t.penya, t.mg1
      from a_penya t where t.mg=l_mg_back --вх.сальдо прошл.мес.
      and t.lsk=lsk_
    union all
    select c.lsk, c.penya, c.mg1 --прибавить начисление пени за мес€ц
          from c_pen_chrg c where c.lsk = lsk_ --and c.iter=l_iter
    union all
    select c.lsk, c.penya,  c.dopl --прибавить корректировку пени за мес€ц
          from c_pen_corr c where c.lsk = lsk_
          and c.dtek<=l_datpen --учесть ограничение по дате
          and c.dtek between init.g_dt_start and init.g_dt_end
    union all
    select c.lsk, -1*c.penya, c.dopl as mg1 --отн€ть поступление пени
          from c_kwtp_mg c where c.lsk = lsk_
          and c.dtek<=l_datpen --учесть ограничение по дате
          and (c.dat_ink is null and c.dtek between init.g_dt_start and init.g_dt_end or
               c.dat_ink between init.g_dt_start and init.g_dt_end)) a
    group by a.lsk, a.mg1
    ) b full join c_pen_chrg r on b.lsk=r.lsk and b.mg1=r.mg1
    where r.iter=l_iter and r.lsk=lsk_
    and (nvl(r.summa,0) <> 0 or nvl(b.penya,0)<>0);

  end if;

 IF p_commit=1 THEN
   COMMIT;
 END IF;
end;

end C_CPENYA;
/

prompt
prompt Creating package body C_DIST_PAY
prompt ================================
prompt
create or replace package body scott.C_DIST_PAY is

procedure gen_deb_usl_all is
begin
--формирование задолжности текущего мес€ца
--по всему фонду
for c in (select * from kart k)
loop

 gen_deb_usl(c.lsk,0 );
 commit;

end loop;

end;

procedure gen_deb_usl(l_lsk in kart.lsk%type, l_commit in number) is
l_dt_start date;
l_dt_end date;
l_mg1 params.period%type;
l_mg params.period%type;
begin
--здесь формируетс€ c_deb_usl, ...получаетс€ только дл€ ведомости задолжников (раньше по ней распредел€лась оплата...теперь по xitog3_lsk)
--формирование задолжности текущего мес€ца
--первый день мес€ца
select to_date(p.period||'01','YYYYMMDD'),
   p.period
   into l_dt_start, l_mg
   from params p;
--последний день мес€ца
l_dt_end:=last_day(l_dt_start);
-- -1 мес€ц назад
l_mg1:= to_char(add_months(to_date(l_mg || '01', 'YYYYMMDD'), -1),
               'YYYYMM');

delete from c_deb_usl t where t.period=l_mg and t.lsk=l_lsk;
insert into c_deb_usl
 (lsk, usl, org, summa, mg, period)
 select a.lsk, a.usl, a.org, sum(a.summa) as summa,
  a.mg, a.period from (
 select t.lsk, t.usl, t.org, t.summa, t.mg as mg, l_mg as period
   from c_deb_usl t --задолжность по прошлому периоду
  where t.period=l_mg1 and t.lsk=l_lsk
 union all
 select t.lsk, t.usl, n.org, t.summa, l_mg as mg, l_mg as period
   from c_charge t, nabor n --начисление
  where t.lsk = n.lsk
    and t.usl=n.usl
    and t.type = 1 and t.lsk=l_lsk
 union all
 --перерасчеты - начало
 select p.lsk, p.usl, t.fk_org2 as org, p.summa, p.mgchange, l_mg
   from a_nabor k, c_change p, t_org t, params m
  where k.lsk = p.lsk
    and p.mgchange = k.mg
    and k.usl = p.usl
    and k.org = t.id and k.lsk=l_lsk
    and p.org is null -- где не указан код орг и старые периоды
    and exists --и где найдена услуга в архивном справочнике
  (select *
           from a_nabor n
          where n.lsk = k.lsk
            and n.mg = p.mgchange
            and n.usl = k.usl)
    and p.mgchange < m.period
    and p.dtek between l_dt_start and l_dt_end
 union all
 select p.lsk, p.usl, t.fk_org2, p.summa, p.mgchange, l_mg
   from nabor k, c_change p, t_org t, params m
  where k.lsk = p.lsk
    and k.usl = p.usl --не должно быть такого, так как не пон€тно где брать орг
    and p.org is null -- где не указан код орг и старые периоды
    and k.org = t.id and k.lsk=l_lsk
    and not exists --и где Ќ≈ найдена услуга в архивном справочнике
  (select *
           from a_nabor n
          where n.lsk = k.lsk
            and n.mg = p.mgchange
            and n.usl = k.usl
            and n.lsk=l_lsk)
    and p.mgchange < m.period
    and p.dtek between l_dt_start and l_dt_end
 union all
 select p.lsk, p.usl, t.fk_org2, p.summa, p.mgchange, l_mg
   from nabor k, c_change p, t_org t, params m
  where k.lsk = p.lsk
    and k.usl = p.usl
    and k.org = t.id
    and p.org is null -- где не указан код орг и новые периоды
    and p.mgchange >= m.period
    and p.dtek between l_dt_start and l_dt_end
    and k.lsk=l_lsk
 union all
 select p.lsk, p.usl, nvl(t.fk_org2, 0) as org, p.summa, p.mgchange, l_mg
   from kart r, c_change p, t_org t, params m
  where r.lsk = p.lsk
    and p.org = t.id
    and p.org is not null -- где указан код орг и не важно какой период
    and p.dtek between l_dt_start and l_dt_end
    and r.lsk=l_lsk
 --перерасчеты - окончание
/* union all
 select t.lsk, t.usl, t.org, -1 * t.summa, t.dopl as mg, l_mg --корректировки оплаты
   from t_corrects_payments t, params p --Ќ≈Ћ№«я Ѕ–ј“№ - ќЌ» ¬ KWTP_DAY —»ƒя“!!!
  where t.mg = l_mg
    and t.lsk=l_lsk*/
 union all
 select t.lsk, t.usl, t.org, -1 * t.summa, t.dopl as mg, l_mg
   from kwtp_day t where t.priznak = 1 --сама оплата
                         and t.lsk=l_lsk
                         and nvl(t.fk_distr,0) <> 12 --чтобы не вз€ть корректировки не предназначенные
                                              --дл€ c_deb_usl
                         and t.dtek between init.g_dt_start and init.g_dt_end

 ) a
 group by a.lsk, a.usl, a.org, a.mg, a.period
 having sum(a.summa)<>0;
 if l_commit =1 then
   commit;
 end if;
end;

/*procedure gen_init_deb_usl(p_lsk in kart.lsk%type, p_mg in params.period%type, p_init in number) is
l_dt_start date;
l_dt_end date;
l_mg1 params.period%type;
l_mg params.period%type;
begin
--начальное формирование таблицы задолжности текущего мес€ца
--первый день мес€ца
l_mg:=p_mg;
select to_date(l_mg||'01','YYYYMMDD')
   into l_dt_start
   from dual;
--последний день мес€ца
l_dt_end:=last_day(l_dt_start);
-- -1 мес€ц назад
l_mg1:= to_char(add_months(to_date(l_mg || '01', 'YYYYMMDD'), -1),
               'YYYYMM');

if p_init=1 then
  --заполнить начальную задолжность по предыдущ.периоду
  --удалить все данные
  execute immediate 'truncate table killme_kwtp_day';
  execute immediate 'truncate table c_deb_usl2';

for c in (
  select distinct t.lsk
     from xitog3_lsk t where mg=l_mg1
     group by t.lsk, t.org, t.usl
     having sum(nvl(t.outdebet,0)+nvl(t.outkredit,0)) <> 0
 )
loop
  delete from temp_prep;
  insert into temp_prep
  (usl, org, summa, tp_cd)
  select t.usl, t.org, sum(nvl(t.outdebet,0)+nvl(t.outkredit,0)) as summa, 0 as tp_cd
     from xitog3_lsk t where mg=l_mg1
     and t.lsk=c.lsk
     group by t.lsk, t.org, t.usl
     having sum(nvl(t.outdebet,0)+nvl(t.outkredit,0)) <> 0;
  --закрываем суммы сальдо
  c_prep.dist_summa;

  insert into c_deb_usl2
   (lsk, usl, org, summa, mg, period)
  select c.lsk, t.usl, t.org, t.summa, l_mg1, l_mg1
   from temp_prep t where
     t.tp_cd=1;
  commit;
end loop;



end if;

--return;

if p_lsk is null then
  delete from killme_kwtp_day where mg=l_mg;
  delete from c_deb_usl2 t where t.period=l_mg;
  insert into c_deb_usl2
   (lsk, usl, org, summa, mg, period)
   select a.lsk, a.usl, a.org, sum(a.summa) as summa,
    a.mg, a.period from (
   select t.lsk, t.usl, t.org, t.summa, t.mg as mg, l_mg as period
     from c_deb_usl2 t --задолжность по прошлому периоду
    where t.period=l_mg1
   union all
    select t.lsk, t.usl, t.org, sum(t.charges) as summa,
     l_mg, l_mg --начисление, в т.ч. перерасчеты
     from xitog3_lsk t where mg=l_mg
     group by t.lsk, t.org, t.usl
     having sum(t.charges) <> 0
   union all
    select t.lsk, t.usl, t.org, -1*sum(t.summa) as summa,
     t.dopl, l_mg --начисление, в т.ч. перерасчеты
     from killme_kwtp_day t where t.priznak=1 and t.mg=l_mg
     group by t.lsk, t.org, t.usl, t.dopl
     ) a
     group by a.lsk, a.usl, a.org, a.mg, a.period
     having sum(a.summa)<>0;
else
  delete from c_deb_usl2 t where t.period=l_mg
   and t.lsk=p_lsk;
  insert into c_deb_usl2
   (lsk, usl, org, summa, mg, period)
   select a.lsk, a.usl, a.org, sum(a.summa) as summa,
    a.mg, a.period from (
   select t.lsk, t.usl, t.org, t.summa, t.mg as mg, l_mg as period
     from c_deb_usl2 t --задолжность по прошлому периоду
    where t.period=l_mg1 and t.lsk=p_lsk
   union all
    select t.lsk, t.usl, t.org, sum(t.charges) as summa,
     l_mg, l_mg --начисление, в т.ч. перерасчеты
     from xitog3_lsk t where mg=l_mg and t.lsk=p_lsk
     group by t.lsk, t.org, t.usl
     having sum(t.charges) <> 0
   union all
    select t.lsk, t.usl, t.org, -1*sum(t.summa) as summa,
     t.dopl, l_mg --начисление, в т.ч. перерасчеты
     from killme_kwtp_day t where t.priznak=1 and t.lsk=p_lsk and t.mg=l_mg
     group by t.lsk, t.org, t.usl, t.dopl
     ) a
     group by a.lsk, a.usl, a.org, a.mg, a.period
     having sum(a.summa)<>0;
end if;
commit;
end;

procedure dist_pay_TEST_lsk(p_kwtp_id in c_kwtp_mg.id%type, p_mg in params.period%type) is
l_rec c_kwtp_mg%rowtype;
begin



for c in (select t.*, t.rowid as rw from a_kwtp_mg t where t.mg=p_mg)
loop

 select lsk, summa, penya, oper, dopl, nink, nkom, dtek, nkvit, dat_ink, ts, c_kwtp_id, cnt_sch, cnt_sch0, id, null
  into l_rec from a_kwtp_mg t where t.id=c.id
  and t.mg=p_mg and t.rowid=c.rw;
 --распредел€ем оплату
 dist_pay_deb_mg_lsk_arch(l_rec, p_mg);
 --учитываем оплату в текущ. задолжн.
 gen_init_deb_usl(l_rec.lsk, p_mg, 0);

end loop;
commit;

end;
*/
procedure dist_pay_all is
l_rec c_kwtp_mg%rowtype;
begin
  --распределение всех не распределенных платежей
for c in (select k.reu, t.*, t.rowid as rw from c_kwtp_mg t, kart k where/*t.lsk='06002298'
  and */ t.lsk=k.lsk
  and not exists (select * from kwtp_day k where k.kwtp_id=t.id
     and k.dtek between init.g_dt_start and init.g_dt_end)
  )
loop

 select t.lsk, t.summa, t.penya, t.oper, t.dopl, t.nink, t.nkom, t.dtek, t.nkvit, t.dat_ink, t.ts, t.c_kwtp_id, t.cnt_sch, t.cnt_sch0, t.id, null
  into l_rec from c_kwtp_mg t where t.id=c.id
  and t.rowid=c.rw
  and t.dtek between init.g_dt_start and init.g_dt_end;
 --распредел€ем оплату
 dist_pay_deb_mg_lsk(c.reu, l_rec);
end loop;
commit;

end;


procedure dist_pay_deb_mg_lsk(p_reu in kart.reu%type, p_rec in c_kwtp_mg%rowtype) is
l_mg params.period%type;
l_in_summa number;
l_summa number;
l_summa_p number;
l_cnt number;
l_summa_tmp number;
l_summa_old number;
l_summap_old number;
l_summa_err number;
l_flag number;
l_flagp number;
l_last_mg params.period%type;
l_trgt_usl usl.usl%type;
l_trgt_org number;
l_dist number;
i number;
t_redir tab_redir;
t_summ  tab_summ;
l_err number;
l_sign number;
l_cnt2 number;

function dist(p_mg in varchar2, p_summa in number,
  p_tp in number, p_distr in number,
  p_kwtp_mg_id in number --id платежа (дл€ распределени€ пени по уже распределЄнному платежу)
  ) return number is
begin
  l_in_summa:=abs(p_summa);
  l_sign:=sign(p_summa);
  --распределить оплату(пеню) по услугам+орг в периоде
  delete from temp_prep t;
  if p_kwtp_mg_id is null then --если нет идентификатора платежа (либо сумма оплаты, либо пен€, с 0 суммой оплаты)
    if p_distr = 6 then
    --по начислению периода
      select nvl(count(*),0) into l_cnt
                from xitog3_lsk t
                where
                t.lsk=p_rec.lsk
                and t.mg=p_mg
                and t.charges > 0;
    elsif p_distr = 7 then
    --по текущему начислению
      select nvl(count(*),0) into l_cnt
      from (select n.usl, n.org
          from c_charge t, nabor n
          where t.lsk=p_rec.lsk
          and t.lsk=n.lsk
          and t.usl=n.usl
          and t.type=1
        group by n.usl, n.org
        having sum(t.summa) > 0); --только по начислению > 0
    elsif p_distr in (14,15) then
    --по деб сальдо - не провер€ть!
      l_cnt:=1;
    end if;
    --проверить наличие строк дл€ распределени€
    if l_cnt = 0 then
      return 0;
    end if;

  if p_distr = 6 then
  --по начислению периода
    select rec_summ(t.usl, t.org/*redirect_org(p_tp,p_reu,t.usl,t.org,t_redir)*/, t.charges, 0) bulk collect --убрал редирект - тормозит у полыс
          into t_summ
        from xitog3_lsk t
        where t.mg = p_mg
        and t.lsk=p_rec.lsk
        and t.charges > 0;--только по начислению > 0
    if sql%rowcount =0 then
      --нет записей, вернутьс€
      return 0;
    end if;
  elsif p_distr in (7, 16) then
  --по текущему начислению (по тек начисл, без коррект проводки)
    select rec_summ(n.usl, n.org/*redirect_org(p_tp,p_reu,n.usl,n.org,t_redir)*/, sum(t.summa), 0) bulk collect --убрал редирект - тормозит у полыс
          into t_summ
        from c_charge t, nabor n
        where t.lsk=p_rec.lsk
        and t.lsk=n.lsk
        and t.usl=n.usl
        and t.type=1
      group by n.usl, n.org
      having sum(t.summa) > 0; --только по начислению > 0
    if sql%rowcount =0 then
      --нет записей, вернутьс€
      return 0;
    end if;
  elsif p_distr in (14) then
    --по деб сальдо, с учЄтом прин€той оплаты, с корректировкой, распределить не более этого дебетового сальдо
    select rec_summ(d.usl, d.org, sum(d.summa), 0) bulk collect
          into t_summ from
            (select t.usl, t.org, nvl(t.indebet,0)+nvl(t.inkredit,0) as summa
              from xitog3_lsk t, params p --вз€ть вход€щее сальдо
              where t.lsk=p_rec.lsk
              and t.mg=p.period
            union all
            select n.usl, n.org/*redirect_org(p_tp,p_reu,n.usl,n.org,t_redir)*/ as org, t.summa --убрал редирект - тормозит у полыс
              from c_charge t, nabor n  --прибавить текущее начисление
              where t.lsk=p_rec.lsk
              and t.lsk=n.lsk
              and t.usl=n.usl
              and t.type=1
            union all
            select t.usl, t.org, -1*t.summa
              from kwtp_day t  --отн€ть уже прин€тую оплату
              where t.lsk=p_rec.lsk
              and t.priznak=1
             ) d
             group by d.usl, d.org
             having  sum(summa ) > 0;
    if sql%rowcount =0 then
      --нет записей, вернутьс€
      return 0;
    end if;
  elsif p_distr in (15) then
    --по деб сальдо, с учЄтом прин€той оплаты, но без корректировочной проводки
    select rec_summ(d.usl, d.org, sum(d.summa), 0) bulk collect
          into t_summ from
            (select t.usl, t.org, nvl(t.indebet,0)+nvl(t.inkredit,0) as summa
              from xitog3_lsk t, params p --вз€ть вход€щее сальдо
              where t.lsk=p_rec.lsk
              and t.mg=p.period
            union all
            select n.usl, n.org/*redirect_org(p_tp,p_reu,n.usl,n.org,t_redir)*/ as org, t.summa --убрал редирект - тормозит у полыс
              from c_charge t, nabor n  --прибавить текущее начисление
              where t.lsk=p_rec.lsk
              and t.lsk=n.lsk
              and t.usl=n.usl
              and t.type=1
            union all
            select t.usl, t.org, -1*t.summa
              from kwtp_day t  --отн€ть уже прин€тую оплату
              where t.lsk=p_rec.lsk
              and t.priznak=1
             ) d
             group by d.usl, d.org
             having  sum(summa ) > 0;
    if sql%rowcount =0 then
      --нет записей, вернутьс€
      return 0;
    end if;
  end if;
  else
    --подготовить дл€ распределени€ пени по уже выполненному платежу
    select rec_summ(t.usl, t.org, sum(t.summa), 0) bulk collect
      into t_summ from
       kwtp_day t  --уже распределенную оплату
      where t.priznak=1
      and t.kwtp_id=p_kwtp_mg_id
      group by t.usl, t.org
      having nvl(sum(t.summa),0)<>0;
    if sql%rowcount =0 then
      --нет записей, вернутьс€
      return 0;
    end if;
  end if;

--  insert into temp_prep
--    (usl, org, summa, tp_cd)
--  values
--    ('xxx', 0, -1*p_summa, 0); --сумму дл€ распределени€, с обратным знаком
  --обработать
  --c_prep.dist_summa;

    l_err := c_prep.dist_summa_full(p_sum  => l_in_summa,
                             t_summ => t_summ);

   insert into temp_prep
    (usl, org, summa, tp_cd)
   select t.fk_cd, t.fk_id, t.summa, 3 as tp_cd
   from table(t_summ) t
         where t.tp = 1;
  --добавить корректировку, если задано ограничение по сальдо (¬Ќ»ћјЌ»≈! ” “—∆ —¬ќЅќƒј оставить данный параметр ¬џ Ћ до 01.01.2016!!!)
                                                            --(¬ыполн€етс€ проверка распределени€ оплаты!)
  if utils.get_int_param('RESTRICT_BY_SAL') = 1 and p_distr not in (15,16) then
    if p_kwtp_mg_id is null then
      insert into temp_prep  --поставил 20.04.15 в 15:08
        (usl, org, summa, tp_cd)
       with a as (select t.usl, t.org, sum(t.summa) as summa from temp_prep t
                   where t.summa<>0 and t.tp_cd in (3)
                   group by t.usl, t.org),
            b as (select d.usl, d.org, sum(d.summa) as summa from
            (select t.usl, t.org, nvl(t.indebet,0)+nvl(t.inkredit,0) as summa
              from xitog3_lsk t, params p --вз€ть вход€щее сальдо
              where t.lsk=p_rec.lsk
              and t.mg=p.period
            union all
            select n.usl, n.org/*redirect_org(p_tp,p_reu,n.usl,n.org,t_redir)*/ as org, t.summa
              from c_charge t, nabor n  --прибавить текущее начисление
              where t.lsk=p_rec.lsk
              and t.lsk=n.lsk
              and t.usl=n.usl
              and t.type=1
            union all
            select t.usl, t.org, -1*t.summa
              from kwtp_day t  --отн€ть уже прин€тую оплату
              where t.lsk=p_rec.lsk
              and t.priznak=1
             ) d
             group by d.usl, d.org
             having  sum(summa) > 0) --вз€ть только исх.дебетовое сальдо
        select a.usl, a.org, nvl(b.summa,0)-nvl(a.summa,0) as diff, 4 as tp_cd from a
              left join b on a.usl=b.usl and a.org=b.org
              where nvl(b.summa,0)-nvl(a.summa,0) <0; --где распределение породит кредитовое сальдо

--дл€ проверки:
        /*select a.usl, a.org, nvl(a.summa,0)-nvl(b.summa,0) as diff, 4 as tp_cd from
          (select t.usl, t.org, -1*sum(t.summa) as summa from temp_prep t
                   where t.usl<>'xxx' and t.summa<>0 and t.tp_cd in (3)
                   group by t.usl, t.org) a
          left join
            (select d.usl, d.org, sum(d.summa) as summa from
            (select t.usl, t.org, t.summa
              from saldo_usl t, params p --вз€ть вход€щее сальдо
              where t.lsk=p_rec.lsk
              and t.mg=p.period
            union all
            select n.usl, redirect_org(p_tp,p_reu,n.usl,n.org,t_redir) as org, t.summa
              from c_charge t, nabor n  --прибавить текущее начисление
              where t.lsk=p_rec.lsk
              and t.lsk=n.lsk
              and t.usl=n.usl
              and t.type=1
            union all
            select t.usl, t.org, -1*t.summa
              from kwtp_day t  --отн€ть уже прин€тую оплату
              where t.lsk=p_rec.lsk
              and t.priznak=1
             ) d
             group by d.usl, d.org
             having  sum(summa) > 0) b
             on a.usl=b.usl and a.org=b.org
             where nvl(a.summa,0)>nvl(b.summa,0); --где распределение превышает исх дебетовое сальдо
*/
     end if;
   end if;

--перенаправление оплаты и пени
  for c in (
    select
    t.usl, t.org, sum(l_sign * t.summa) as summa --это сделал дл€ распределени€ сн€ти€ пени (≈.». просила)
    from temp_prep t
      where t.tp_cd in (3,4) --—ƒ≈ЋјЋ ѕ–ј¬ќѕ–»≈ћЌ»„≈—“¬ќ!!!30.01.2015
      and t.summa <> 0 and t.usl<>'xxx'
    group by t.usl, t.org
    having sum(l_sign * t.summa) <>0
    ) loop
      --ѕ≈–≈Ќјѕ–ј¬Ћ≈Ќ»≈
      redirect(p_tp => p_tp, p_reu => p_reu, p_usl_src => c.usl,
        p_usl_dst => l_trgt_usl, p_org_src => c.org, p_org_dst => l_trgt_org, t_redir => t_redir);

      insert into kwtp_day
        (fk_distr, kwtp_id, lsk, usl, org, summa, oper, dopl, nkom, nink, dat_ink, priznak, dtek)
      values
        (p_distr, p_rec.id, p_rec.lsk, l_trgt_usl, l_trgt_org, c.summa,
         p_rec.oper, p_mg,
         p_rec.nkom, p_rec.nink, p_rec.dat_ink, p_tp, p_rec.dtek);
  end loop;
--проверка на отрицат.значени€
  if p_summa > 0 and l_sign = 1 then

      select nvl(count(*),0) into l_summa_tmp
      from (
      select t.usl, t.org
        from temp_prep t where t.tp_cd in (3,4)
        and t.usl<>'xxx'
        group by t.usl, t.org
        having sum(t.summa) < -0.05);  --больше -5 копеек
     if l_summa_tmp > 0 then
        Raise_application_error(-20000, ' од ошибки #7');
      end if;

    end if;

  select
    sum(l_sign*t.summa) into l_summa_tmp
    from temp_prep t where t.tp_cd in (3,4)
    and t.summa <> 0 and t.usl<>'xxx';


  --COMMIT
--  commit;
  --COMMIT

  return nvl(l_summa_tmp,0);
end;

begin
--распределение оплаты по задолжности по периодам + орг + услугам
--ќѕ»—јЌ»≈ FK_DISTR
--распределение оплаты:
--0 - резерв C_GEN_PAY
--1 - резерв C_GEN_PAY
--2 - резерв C_GEN_PAY
--3 - резерв C_GEN_PAY
--4 - резерв C_GEN_PAY (корректировки)
--5 - резерв C_GEN_PAY
--11 - резерв C_GEN_PAY


--6 - распределено по мес€цу задолжности
--7 - распределено по текущему начислению
--8 - не распр.на тек.начисление, распр.на тек период всю сумму по вх.сальдо
--9 - не распр.и на вх.сальдо, кинуть на орг "– ÷" - самое плохое распределение!!!

--10 - распределено в ручную из формы распределени€ оплаты
--12 - (корректировки не дл€ c_deb_usl)
--13 - (обратный платЄж!)
--14 - распределить по дебетовому сальдо
--15 - распределить по дебетовому сальдо, без коррект проводки
--16 - распределено по текущему начислению, без коррект проводки

--¬Ќ»ћјЌ»≈!!! —Ќя“»≈ ќѕЋј“џ ƒ≈Ћј“№ ¬ точности по + ќѕЋј“џ (зеркальна€ обратна€ операци€)


/*if sysdate > to_date('20150126','YYYYMMDD') then
  Raise_application_error(-20000, ' од ошибки #5');
end if;*/
/*  select rec_state(t.fk_kart_pr, t.fk_status,
    decode(u.cd, 'PROP', 0, 'PROP_REG', 1),
    nvl(t.dt1, to_date('01011900','DDMMYYYY')),
    nvl(t.dt2, to_date('01012900','DDMMYYYY')),
    p.dat_rog, r.cd) bulk collect into t_state
    from c_states_pr t, u_list u, u_listtp tp, c_kart_pr p, relations r
      where t.fk_tp=u.id and u.fk_listtp=tp.id
       and tp.cd='“ипы статусов проживающих' --необх.использовать типы u_listtp
       and t.fk_kart_pr=p.id and p.lsk=coalesce(l_lsk_main, p_lsk)  --ѕќƒ—“јЌќ¬ ј!!!
       and p.relat_id=r.id(+)*/

select rec_redir(t.reu, t.fk_usl_src, t.fk_usl_dst, t.fk_org_src, t.fk_org_dst, t.tp)
  bulk collect into t_redir from redir_pay t;

--вначале сформируем тек. задолжность и пеню
select p.period into l_mg from params p;

l_summa:=p_rec.summa;
l_summa_p:=p_rec.penya;

--¬нимание! здесь же распределитс€ текущее начисление! (по подготовленному c_deb_usl)

i:=0;
--ѕќѕ–ќЅќ¬ј“№ распределить 500 –ј«!!!
l_summa_old:=l_summa;
l_summap_old:=l_summa_p;
l_flag:=0;
l_flagp:=0;

loop
  if l_flag = 0 then
    if l_summa > 0 then
      --распределить оплату
      if p_rec.dopl>=l_mg then
        --текущий период
        if l_flag=1 then
          l_dist:=14; --по сальдо
        else
          l_dist:=7;
        end if;
        l_summa_tmp:=dist(l_mg, l_summa, 1, l_dist, null);
      else
        --архивный период
        if l_flag=1 then
          l_dist:=14; --по сальдо
        else
          l_dist:=6;
        end if;
        l_summa_tmp:=dist(p_rec.dopl, l_summa, 1, l_dist, null);
      end if;
      l_summa:=l_summa-l_summa_tmp;
    elsif l_summa < 0 then
      --сделал по просьбе ≈.» распределение сн€ти€ пени
      l_dist:=7;
      l_summa_tmp:=dist(p_rec.dopl, l_summa, 1, l_dist, null); --поправил -1 на 1 ред. 19.11.15
      l_summa:=l_summa-l_summa_tmp;
    end if;
  end if;

  if abs(l_summa_old-l_summa)=0 then --распределить, вплоть до копеек!
    --сумма оплаты не распредел€етс€, попробовать распределить
    --по сальдо
    l_flag:=1;
  else
    --сумма распредел€етс€
    l_summa_old:=l_summa;
  end if;

  if l_flagp = 0 then
    if l_summa_p > 0 and l_flag = 0 then
      --распределить пеню - по уже распределЄнной сумме оплаты
      l_dist:=6;
      l_summa_tmp:=dist(p_rec.dopl, l_summa_p, 0, l_dist, p_rec.id);
      l_summa_p:=l_summa_p-l_summa_tmp;
    elsif l_summa_p < 0 then
      --сделал по просьбе ≈.» распределение сн€ти€ пени
      l_dist:=6;
      l_summa_tmp:=dist(p_rec.dopl, l_summa_p, 0, l_dist, null);
      l_summa_p:=l_summa_p-l_summa_tmp;
    end if;
  end if;
  i:=i+1;

  if abs(l_summap_old-l_summa_p)=0 then --распределить, вплоть до копеек!
    --пен€ не распредел€етс€
    l_flagp:=1;
  else
    --сумма распредел€етс€
    l_summap_old:=l_summa_p;
  end if;

  if l_flag =1 and l_flagp =1 then --и оплата и пен€ не распредел€ютс€
    exit;
  end if;

  exit when (l_summa =0 and l_summa_p =0) or i >=500 ;
end loop;

if l_summa <> 0 then
  --если невозможно распред по конкретному периоду, то распределить по текущему начислению (если оно есть вообще), но без корректировочной проводки
  select nvl(count(*),0) into l_cnt2
        from c_charge t, nabor n
        where t.lsk=p_rec.lsk
        and t.lsk=n.lsk
        and t.usl=n.usl
        and t.type=1
        and t.summa > 0;
  if l_cnt<>0 then
    i:=0;
    loop
      l_summa_tmp:=dist(p_rec.dopl, l_summa, 1, 16, null);
      l_summa:=l_summa-l_summa_tmp;
      i:=i+1;
      exit when l_summa =0 or i >=500 ;
    end loop;
  end if;
end if;

if l_summa <> 0 then
  --если пр€м совсем невозможно распред по конкретному периоду, то распределить по дебетовому сальдо, с учЄтом прин€той оплаты, но без корректировочной проводки
  i:=0;
  loop
    l_summa_tmp:=dist(p_rec.dopl, l_summa, 1, 15, null);
    l_summa:=l_summa-l_summa_tmp;
    i:=i+1;
    exit when l_summa =0 or i >=500 ;
  end loop;
end if;


if l_summa <> 0 then --если и по деб сальдо не распр, кинуть на – ÷, тек содерж
  insert into kwtp_day
    (fk_distr, kwtp_id, lsk, usl, org, summa, oper, dopl, nkom, nink, dat_ink, priznak, dtek)
  select
    9 as fk_distr, p_rec.id, p_rec.lsk, '003' as usl, o.id, l_summa,
     p_rec.oper, p_rec.dopl,
     p_rec.nkom, p_rec.nink, p_rec.dat_ink, 1 as priznak, p_rec.dtek
     from t_org o where o.reu=p_reu;
    l_summa:=0;
end if;

--ѕ≈Ќя
if l_summa_p <> 0 then
  --если пр€м совсем невозможно распред по конкретному периоду, то распределить по дебетовому сальдо, с учЄтом прин€той оплаты, но без корректировочной проводки
  i:=0;
  loop
    l_summa_tmp:=dist(p_rec.dopl, l_summa_p, 0, 15, null);
    l_summa_p:=l_summa_p-l_summa_tmp;
    i:=i+1;
    exit when l_summa_p =0 or i >=500 ;
  end loop;
end if;


if l_summa_p > 0 then --если и по деб сальдо не распр, кинуть на – ÷, тек содерж
  insert into kwtp_day
    (fk_distr, kwtp_id, lsk, usl, org, summa, oper, dopl, nkom, nink, dat_ink, priznak, dtek)
  select
    9 as fk_distr, p_rec.id, p_rec.lsk, '003' as usl, o.id, l_summa,
     p_rec.oper, p_rec.dopl,
     p_rec.nkom, p_rec.nink, p_rec.dat_ink, 0 as priznak, p_rec.dtek
     from t_org o where o.reu=p_reu;
elsif l_summa_p < 0 then
    --сделал по просьбе ≈.» распределение сн€ти€ пени
  l_summa_tmp:=dist(p_rec.dopl, l_summa_p, 0, 7, null);
end if;

/*if l_summa_p > 0 then
  --если не возможно распред по конкретному периоду, то распределить по распределЄнному платежу, если он есть
  i:=0;
  loop
    l_summa_tmp:=dist(p_rec.dopl, l_summa_p, 0, 6, p_rec.id);
    l_summa_p:=l_summa_p-l_summa_tmp;
    i:=i+1;
    exit when l_summa_p =0 or i >=500 ;
  end loop;
--  l_summa_tmp:=dist(p_rec.dopl, l_summa_p, 0, 7, -1, 1, null);
end if;*/

--проверка... возможно убрать позже, когда устаканитс€ распределение
select case when nvl(sum(decode(t.priznak, 1, t.summa, 0)),0) - nvl(p_rec.summa,0) <>0  then 1
            when nvl(sum(decode(t.priznak, 0, t.summa, 0)),0) - nvl(p_rec.penya,0) <>0 then 2
            else 0 end,
       case when nvl(sum(decode(t.priznak, 1, t.summa, 0)),0) - nvl(p_rec.summa,0) <>0  then
              nvl(sum(decode(t.priznak, 1, t.summa, 0)),0) - nvl(p_rec.summa,0)
            when nvl(sum(decode(t.priznak, 0, t.summa, 0)),0) - nvl(p_rec.penya,0) <>0 then
              nvl(sum(decode(t.priznak, 0, t.summa, 0)),0) - nvl(p_rec.penya,0)
            else 0 end
       into l_cnt, l_summa_err
  from kwtp_day t where t.kwtp_id=p_rec.id;
if l_cnt = 1 then
  Raise_application_error(-20000, ' од ошибки #1 в kwtp_id='||p_rec.id||' ¬озможно нет начислени€ за период, разница='||l_summa_err);
elsif l_cnt = 2 then
  Raise_application_error(-20000, ' од ошибки #0 в kwtp_id='||p_rec.id||' ¬озможно нет начислени€ за период, разница='||l_summa_err);
end if;

 --выполнить редирект оплаты или пени
 update kwtp_day t set t.org=redirect_org(t.priznak, p_reu, t.usl, t.org, t_redir)
   where t.kwtp_id=p_rec.id;
end;

procedure dist_pay_lsk_force is
begin
--принудительное распределение платежей
for c in (select t.* from c_kwtp_mg t where
 not exists (select * from kwtp_day k where k.kwtp_id=t.id)
 --and t.summa <> 0 --только положительные значени€!
 --and t.lsk='00000191'
 order by t.dopl)
loop
  for c2 in (select k.reu from kart k where k.lsk=c.lsk) loop --бред
    dist_pay_deb_mg_lsk(c2.reu, c);
  end loop;
commit;

end loop;

end;

--обЄртка дл€ функции по редиректу
--¬Ќ»ћјЌ»≈!!!!(только дл€ начислени€!!!! не использовать дл€ редиректа оплаты, так как не выполн€ет редирект услуги)
function redirect_org (p_tp in number, --1-оплата, 0 - пен€
                        p_reu in varchar2, --код –Ё”
                        p_usl_src in varchar2, --исходна€ услуга
                        p_org_src in number,  --исходна€ орг.
                        t_redir in tab_redir --таблица редиректов
                        ) return number is
  l_org number;
  l_dummy usl.usl%type;
begin

  redirect(p_tp => p_tp, p_reu => p_reu, p_usl_src => p_usl_src, p_usl_dst => l_dummy,
           p_org_src => p_org_src, p_org_dst => l_org, t_redir => t_redir);
  return l_org;

end;


--редирект оплаты/пени
procedure redirect (p_tp in number, --1-оплата, 0 - пен€
                        p_reu in varchar2, --код –Ё”
                        p_usl_src in varchar2, --исходна€ услуга
                        p_usl_dst out varchar2,--перенаправленна€ услуга
                        p_org_src in number,  --исходна€ орг.
                        p_org_dst out number, --перенаправленна€ орг.
                        t_redir in tab_redir --таблица редиректов
                        ) is
  l_usl_flag number; --флаг состо€вшегос€ переноса по услуге
  l_org_flag number; --флаг состо€вшегос€ переноса по организации
  l_exist_flag number; --флаг наличи€ типа в массиве
begin

l_usl_flag:=0;
l_org_flag:=0;
p_usl_dst:=p_usl_src;
p_org_dst:=p_org_src;

l_exist_flag:=0;
if t_redir.count > 0 then
  for a in t_redir.first..t_redir.last loop
    if t_redir(a).tp=p_tp then
      l_exist_flag:=1;
      exit;
    end if;
  end loop;
end if;

if l_exist_flag=0 then
  --не найден такой тип в массиве редиректов, ну и нет смысла тогда дальше что то провер€ть
  return;
end if;

for c in (select * from redir_pay t where
                                  nvl(t.reu, p_reu)=p_reu and --либо заполненное –Ё”=вход.–Ё”, либо пусто (редирект дл€ всех –Ё”)
                                  nvl(t.fk_usl_src, p_usl_src)=p_usl_src and --либо заполненное ”—Ћ=вход.”—Ћ, либо пусто (редирект дл€ всех услуг)
                                  nvl(t.fk_org_src, p_org_src)=p_org_src --либо заполненное ќ–√=вход.ќ–√, либо пусто (редирект дл€ всех организаций)
                                  and t.tp=p_tp
                                  order by
                                  case when t.reu=p_reu then 0 else 1 end,
                                  case when t.fk_usl_src=p_usl_src then 0 else 1 end,
                                  case when t.fk_org_src=p_org_src then 0 else 1 end
             ) loop

  if c.fk_usl_dst is not null then
    p_usl_dst:=c.fk_usl_dst;
    l_usl_flag:=1;
  end if;
  if c.fk_org_dst is not null then
    if c.fk_org_dst=-1 then --перенаправить на организацию, обслуживающую фонд
       select o.id into p_org_dst from t_org o
          where o.reu=p_reu;
    else
       p_org_dst:=c.fk_org_dst;
    end if;
    l_org_flag:=1;
  end if;

  if l_usl_flag=1 and l_org_flag=1 then
    exit; --нашли все переносы
  end if;

end loop;

end;

procedure dist_pay_lsk_avnc_force is
begin
--принудительное распределение јвансовых платежей
--удалить распределение авансовых
delete from kwtp_day t where exists (select * from params p where t.dopl>=p.period)
  and exists (select * from c_kwtp_mg m where m.id=t.kwtp_id and (m.summa > 0 or m.penya >0));

--распределить
for c in (select t.* from c_kwtp_mg t where
 not exists (select * from kwtp_day k where k.kwtp_id=t.id)
 and (t.summa > 0 or t.penya >0) --только положительные значени€!
 )
loop
    for c2 in (select k.reu from kart k where k.lsk=c.lsk) loop --бред
      dist_pay_deb_mg_lsk(c2.reu, c);
    end loop;
  commit;
end loop;
end;

end C_DIST_PAY;
/

prompt
prompt Creating package body C_EXP_LIST
prompt ================================
prompt
CREATE OR REPLACE PACKAGE BODY SCOTT.C_EXP_LIST IS

PROCEDURE privs_export is
 type_otchet CONSTANT NUMBER := 54; --тип отчета (архивы)
 cursor c_usl is
  select t.usl, t.lpw from usl t
   where t.lpw is not null;
  rec_usl_ c_usl%rowtype;
  period_ params.period%type;
  sqlstr_ varchar2(4000);
begin
--¬ыполн€ть строго после формировани€ архивов
--обратный парсер дл€ списка льготников
time_ := SYSDATE;

/*begin
 execute immediate 'drop table expprivs';
 exception when others then
 null;
end;
sqlstr_:=' create table expprivs (lsk char(8), id number, adr char(50), fio char(50), doc char(55),
 main number, spk_id number, ';
open c_usl;
loop
  fetch c_usl into rec_usl_;
  exit when c_usl%notfound;
  sqlstr_:=sqlstr_||rec_usl_.lpw||' number (8,2),';
end loop;
close c_usl;
sqlstr_:=sqlstr_||' itog number, var number, mg char(6)) tablespace data';
execute immediate sqlstr_;
*/
--delete from expprivs e where e.mg = (select period from params);

select period into period_ from params;
gen.trunc_part('expprivs', period_);

open c_usl;
loop
  fetch c_usl into rec_usl_;
  exit when c_usl%notfound;

  begin
    execute immediate 'alter table expprivs add '||rec_usl_.lpw||' number(8,2)';  
  exception when others then
    null; --да да null
  end;  

  execute immediate 'insert into expprivs (lsk, id, reu, kul, nd, kw, opl, status, adr, fio, main, spk_id, doc, '||rec_usl_.lpw||', mg)
   select /*+RULE */ a.lsk, c.id, k.reu, k.kul, k.nd, k.kw, k.opl, k.status, s.name||'',''||LTRIM(k.nd,''0'')||''-''||LTRIM(k.kw,''0''), c.fio, a.main, a.spk_id, d.doc, a.summa,
   p.period from
  kart k, nabor b, spul s,
  (select t.lsk, t.usl, t.kart_pr_id, t.spk_id, t.main, t.lg_doc_id, sum(summa) as summa
   from c_charge t where t.type=4 and t.usl=:usl
  group by t.lsk, t.usl, t.kart_pr_id, t.spk_id, t.main, t.lg_doc_id ) a,
  c_kart_pr c, c_lg_docs d, params p
  where k.lsk = b.lsk and b.lsk=a.lsk and k.kul=s.id and b.usl=a.usl
  and a.lg_doc_id=d.id
  and a.kart_pr_id=c.id and a.summa <>0'
  using rec_usl_.usl;
end loop;
close c_usl;

sqlstr_:=' insert into expprivs (lsk, id, reu, kul, nd, kw, opl, status, adr, fio, main, spk_id, doc, ';

open c_usl;
loop
  fetch c_usl into rec_usl_;
  exit when c_usl%notfound;
  sqlstr_:=sqlstr_||trim(rec_usl_.lpw)||', ';
end loop;
close c_usl;
sqlstr_:=sqlstr_||' itog, var, mg)';

sqlstr_:=sqlstr_||' select t.lsk, t.id, t.reu, t.kul, t.nd, t.kw, t.opl, t.status, t.adr, t.fio, t.main, t.spk_id, t.doc,  ';
open c_usl;
loop
  fetch c_usl into rec_usl_;
  exit when c_usl%notfound;
  sqlstr_:=sqlstr_||'sum(t.'||trim(rec_usl_.lpw)||')'||', ';
end loop;
close c_usl;
sqlstr_:=sqlstr_||' sum(';
open c_usl;
loop
  fetch c_usl into rec_usl_;
  exit when c_usl%notfound;
  sqlstr_:=sqlstr_||'nvl(t.'||trim(rec_usl_.lpw)||',0)'||'+ ';
end loop;
close c_usl;
sqlstr_:=sqlstr_||'0) as itog, 1 as var, t.mg  from expprivs t, params p
 where t.mg=p.period
 group by t.lsk, t.id, t.reu, t.kul, t.nd, t.kw, t.opl, t.status, t.adr, t.fio, t.main, t.spk_id, t.doc, t.mg ';
execute immediate sqlstr_;

delete from expprivs t where t.var is null;

--обновл€ем период дл€ отчета
delete from period_reports p
 where p.id in (type_otchet)
    and p.mg in (select s.period from params s);
insert into period_reports
 (id, mg, signed)
 select type_otchet, p.period, 1 from params p;
 logger.log_(time_, 'c_exp_list.privs_export');
commit;
end;

PROCEDURE changes_export is
 type_otchet CONSTANT NUMBER := 53; --тип отчета (архивы)
 cursor c_usl is
  select t.usl, t.kwni as fname from usl t
   where t.kwni is not null;
  rec_usl_ c_usl%rowtype;

  sqlstr_ varchar2(4000);
begin
--¬ыполн€ть строго после формировани€ архивов
time_ := SYSDATE;

--обратный парсер дл€ скидок

--сперва дл€ отчета
delete from expkwniusl e where e.mg = (select period from params);

insert into expkwniusl
  (reu, house_id, kul, adr, summa, usl, opl, mg)
select k.reu, k.house_id, k.kul, s.name||','||LTRIM(k.nd,'0') as adr, sum(t.summa) as summa,
   t.usl, max(c.opl), p.period
   from kart k, c_change t, spul s, params p, c_houses c where
   k.lsk=t.lsk and k.kul=s.id and k.house_id=c.id and t.proc <> 0
   and to_char(t.dtek , 'YYYYMM')=p.period
   group by k.reu, k.house_id, k.kul, s.name||','||LTRIM(k.nd,'0'), t.usl, p.period;

delete from expkwni e where e.mg = (select period from params);

--затем дл€ DBF
open c_usl;
loop
  fetch c_usl into rec_usl_;
  exit when c_usl%notfound;
  
  begin
    execute immediate 'alter table expkwni add '||rec_usl_.fname||' number(8,2)';  
  exception when others then
    null; --да да null
  end;  
  
  execute immediate 'insert into expkwni (reu, house_id, kul, name, nd, '||rec_usl_.fname||', var, mg)
  select k.reu, k.house_id, k.kul, s.name, ltrim(k.nd, ''0'') as nd, sum(t.summa) as summa,
   null as var, p.period
   from kart k, c_change t, spul s, params p where
   k.lsk=t.lsk and k.kul=s.id and t.usl=:usl and t.proc <> 0
   and to_char(t.dtek , ''YYYYMM'')=p.period
   group by k.reu, k.house_id, k.kul, s.name, k.nd, t.usl, p.period'
  using rec_usl_.usl;

end loop;
close c_usl;

sqlstr_:=' insert into expkwni (reu, house_id, kul, name, nd, ';

open c_usl;
loop
  fetch c_usl into rec_usl_;
  exit when c_usl%notfound;
  sqlstr_:=sqlstr_||trim(rec_usl_.fname)||', ';
end loop;
close c_usl;
sqlstr_:=sqlstr_||' itog, var, mg)';

sqlstr_:=sqlstr_||' select reu, house_id, kul, name, nd, ';
open c_usl;
loop
  fetch c_usl into rec_usl_;
  exit when c_usl%notfound;
  sqlstr_:=sqlstr_||'sum(t.'||trim(rec_usl_.fname)||')'||', ';
end loop;
close c_usl;
sqlstr_:=sqlstr_||' sum(';
open c_usl;
loop
  fetch c_usl into rec_usl_;
  exit when c_usl%notfound;
  sqlstr_:=sqlstr_||'nvl(t.'||trim(rec_usl_.fname)||',0)'||'+ ';
end loop;
close c_usl;
sqlstr_:=sqlstr_||'0) as itog, 1 as var, mg from expkwni t, params p
 where t.mg=p.period
 group by reu, house_id, kul, name, nd, mg ';
execute immediate sqlstr_;

sqlstr_:=' insert into expkwni (reu, house_id, kul, name, nd, opl, ';

open c_usl;
loop
  fetch c_usl into rec_usl_;
  exit when c_usl%notfound;
  sqlstr_:=sqlstr_||trim(rec_usl_.fname)||', ';
end loop;
close c_usl;
sqlstr_:=sqlstr_||' itog, var, mg)';

sqlstr_:=sqlstr_||' select e.reu, e.house_id, e.kul, e.name, e.nd, a.opl, ';
open c_usl;
loop
  fetch c_usl into rec_usl_;
  exit when c_usl%notfound;
  sqlstr_:=sqlstr_||'e.'||trim(rec_usl_.fname)||''||', ';
end loop;
close c_usl;
sqlstr_:=sqlstr_||' e.itog, 2 as var, e.mg from expkwni e,
(select k.house_id, sum(k.opl) as opl
 from kart k, spul s where
 k.kul=s.id
 and exists ( select * from c_change t where t.lsk=k.lsk  and t.proc <> 0)
group by k.house_id) a
where e.house_id=a.house_id and e.var = 1';
execute immediate sqlstr_;

delete from expkwni t where t.var is null;
delete from expkwni t where t.var = 1;

--обновл€ем период дл€ отчета
delete from period_reports p
 where p.id in (type_otchet)
    and p.mg in (select s.period from params s);
insert into period_reports
 (id, mg, signed)
 select type_otchet, p.period, 1 from params p;
 logger.log_(time_, 'c_exp_list.changes_export');
commit;
end;

PROCEDURE charges_export is
 cursor c_usl is
  select t.usl, t.kartw as fname from usl t
   where t.kartw is not null and t.usl <>'024';
  rec_usl_ c_usl%rowtype;
  time_ date;
  sqlstr_ varchar2(4000);
  period_ params.period%type;
begin
  time_:=sysdate;
--¬ыполн€ть строго после формировани€ архивов
select period into period_ from params;
gen.trunc_part('expkartw', period_);

open c_usl;
loop
  fetch c_usl into rec_usl_;
  exit when c_usl%notfound;

  begin
    execute immediate 'alter table expkartw add '||rec_usl_.fname||' number(8,2)';  
  exception when others then
    null; --да да null
  end;  
  
  execute immediate 'insert into expkartw (reu, lsk, kpr, adr, '||rec_usl_.fname||', mg, var)
   select /*+RULE */ k.reu, k.lsk, k.kpr, s.name||'',''||LTRIM(k.nd,''0'')||''-''||LTRIM(k.kw,''0''), nvl(a.summa,0)+nvl(d.summa,0) as summa,
   p.period, null as var from arch_kart k, arch_charges a, arch_subsidii d, spul s, params p
   where k.lsk=a.lsk(+) and k.mg=a.mg(+) and a.usl_id(+)=:usl and k.lsk=d.lsk(+) and k.mg=d.mg(+)
   and d.usl_id(+)=:usl and k.kul=s.id and k.mg=p.period'
  using rec_usl_.usl, rec_usl_.usl;

end loop;
close c_usl;

sqlstr_:=' insert into expkartw (reu, lsk, kpr, adr, ';

open c_usl;
loop
  fetch c_usl into rec_usl_;
  exit when c_usl%notfound;
  sqlstr_:=sqlstr_||trim(rec_usl_.fname)||', ';
end loop;
close c_usl;
sqlstr_:=sqlstr_||' itog, mg, var)';

sqlstr_:=sqlstr_||' select reu, lsk, kpr, adr, ';
open c_usl;
loop
  fetch c_usl into rec_usl_;
  exit when c_usl%notfound;
  sqlstr_:=sqlstr_||'sum(t.'||trim(rec_usl_.fname)||')'||', ';
end loop;
close c_usl;
sqlstr_:=sqlstr_||' sum(';
open c_usl;
loop
  fetch c_usl into rec_usl_;
  exit when c_usl%notfound;
  sqlstr_:=sqlstr_||'nvl(t.'||trim(rec_usl_.fname)||',0)'||'+ ';
end loop;
close c_usl;
sqlstr_:=sqlstr_||'0) as itog, mg, 1 as var from expkartw t, params p
 where t.var is null
 and t.mg=p.period
 group by reu, lsk, kpr, adr, mg
 order by reu, lsk';
execute immediate sqlstr_;
commit;
logger.log_(time_, 'c_exp_list.charges_export');
end;
END C_EXP_LIST;
/

prompt
prompt Creating package body C_GEN_PAY
prompt ===============================
prompt
create or replace package body scott.C_GEN_PAY is

PROCEDURE distrib_payment_mg IS
begin
--распределение оплаты по периодам
--подправить newreu
for c in (select * from c_kwtp t where exists
(select * from c_kwtp_mg m where m.c_kwtp_id=t.id and m.lsk in
(select substr(t.comments,1,8) as lsk from log t where to_char(t.timestampm,'DDMMYYYYHH')='0102201009' or
to_char(t.timestampm,'DDMMYYYYHH')='0102201010')))
loop
   logger.log_(null,
          'распредел€ем: ' || c.lsk);
  c_get_pay.get_payment_mg(c.id, c.nkvit,
  c.lsk, c.summa, c.penya, c.oper, c.dopl, c.iscorrect, c.nkom, c.dtek, c.nink);
  commit;
end loop;
end;

PROCEDURE distrib_days(dat1_ in date, dat2_ in date) IS
begin
--распредел€лка по дн€м
 for c in (select distinct dat_ink from c_kwtp_mg t where t.dat_ink between dat1_ and dat2_
  order by t.dat_ink)
 loop
   distrib_days(c.dat_ink, c.dat_ink);
   logger.log_(null,
          'c_gen_pay.distrib_payment ' || to_char(c.dat_ink,'DD-MM-YYYY'));
 end loop;

end;

procedure dist_pay_lsk(rec2_ in c_kwtp_mg%rowtype, itr_ in number) is
  mg_ params.period%type;
  itg_ number;
  kr_ number;
  dt_ number;
  itr2_ number;
  excl_usl_ oper.fk_usl%type;
  chk_summa_ number;
  chk_penya_ number;
  l_reu kart.reu%type;  
  l_flag number;
begin
/*
    TODO: owner="lev" created="10.04.2012"
    text="сделать очистку kwtp_day по концу мес€ца"
*/

--ќѕ»—јЌ»≈ FK_DISTR
--распределение оплаты:
--0 полностью нулевое сальдо, распределить  по тек. начислению;
--1 полностью кредитовое сальдо, распределить  по тек. начислению;
--2	полностью дебетовое сальдо, распределить  по нему;
--3 корректирующа€ ѕ–ќ¬ќƒ ј - смешанное кредит/дебет сальдо
--4 корректировка из t_corrects_payment
--5 экслюзивное распределение оплаты на определенную услугу (Ё+)

--6 - резерв C_DIST_PAY
--7 - резерв C_DIST_PAY
--8 - резерв C_DIST_PAY
--9 - резерв C_DIST_PAY

--10 - распределено в ручную из формы распределени€ оплаты
--11 полностью кредитовое сальдо, Ќќ сумма сн€ти€ отрицательна€ (сн€ть по кредитовому сальдо)
--13 обратный платЄж, выполненный в c_get_pay.reverse_pay

--распределение оплаты по сальдо (верси€ от 10.04.12)
--текущий период
select p.period into mg_ from params p;

--¬Ќ»ћјЌ»≈! не осуществл€етс€ удаление строк из kwtp_day!!!
--(учитывать при возможном перераспределении средств)
--сделано дл€ увеличени€ производительности процедуры

--є итерации рекурсии
itr2_:=itr_;
if itr_ > 1 then
  Raise_application_error(-20000, ' ол-во итераций по платежу с Ћ/C '||rec2_.lsk||' превысило 2!');
end if;

  --найти код –Ё”
  select k.reu into l_reu from kart k where k.lsk=rec2_.lsk;
  
  --предварительно узнать, какое сальдо
  select nvl(sum(summa),0) as itg, nvl(sum(decode(sign(t.summa), -1, t.summa, 0)),0) as kr,
   nvl(sum(decode(sign(t.summa), 1, t.summa, 0)),0) as dt into itg_, kr_, dt_
   from saldo_usl t
   where t.mg = mg_ and t.lsk=rec2_.lsk;

  if abs(kr_) <> 0 and abs(dt_) <> 0 and rec2_.summa < 0 then --если присут. и дебет и кредит сальдо и сумма оплаты < 0
    l_flag:=1;
  elsif abs(kr_) <> 0 and abs(dt_) <> 0 and rec2_.summa > 0 then --если присут. и дебет и кредит сальдо и сумма оплаты > 0
    l_flag:=2;
  else 
    l_flag:=0;
  end if;
   
  --вз€ть только необходимую составл€ющую сальдо
  delete from temp_saldo;
  insert into temp_saldo
  (org, usl, summa)
  select s.org, s.usl, sum(s.summa)
            from saldo_usl s
           where mg = mg_ and s.lsk=rec2_.lsk
   group by s.org, s.usl
   having (l_flag = 1 and sum(s.summa) < 0 or 
          l_flag in (0,2) and sum(s.summa) > 0);

  --еще раз узнать какое сальдо
  select nvl(sum(summa),0) as itg, nvl(sum(decode(sign(t.summa), -1, t.summa, 0)),0) as kr,
   nvl(sum(decode(sign(t.summa), 1, t.summa, 0)),0) as dt into itg_, kr_, dt_
   from temp_saldo t;

  --проверка эксклюзивной услуги по операции
  select o.fk_usl into excl_usl_ from oper o where o.oper=rec2_.oper;

  if excl_usl_ is not null then
    --5 экслюзивное распределение оплаты на определенную услугу (Ё+)
    dist_pay_var(l_reu, excl_usl_, rec2_, 3, 5);
  elsif itg_ = 0 and kr_ =0 and dt_=0 then
    --0 полностью нулевое сальдо, распределить  по тек. начислению;
    dist_pay_var(l_reu, null, rec2_, 0, 0);
  elsif kr_ <> 0 and dt_ <> 0 then
    --3 корректирующа€ ѕ–ќ¬ќƒ ј - смешанное кредит/дебет сальдо
    Raise_application_error(-20000, 'Error #1'); --отменить корректирующую проводку
    dist_pay_var(l_reu, null, rec2_, 2, 3);

    --рекурсивный вызов себ€ же
    dist_pay_lsk(rec2_, itr2_+1);
  elsif kr_ = 0 and dt_ <> 0 then
    --2  полностью дебетовое сальдо, распределить  по нему;
   dist_pay_var(l_reu, null, rec2_, 1, 2);
  elsif kr_ <> 0 and dt_ = 0 and rec2_.summa >= 0 then
    --1 полностью кредитовое сальдо, сумма оплаты > 0 распределить  по тек. начислению (пени надеюсь нет при кредитовом сальдо)
   dist_pay_var(l_reu, null, rec2_, 0, 1);
  elsif kr_ <> 0 and dt_ = 0 and rec2_.summa < 0 then
    --11 полностью кредитовое сальдо, сумма оплаты < 0 распределить кредитовому сальдо (пени надеюсь нет при кредитовом сальдо)
   dist_pay_var(l_reu, null, rec2_, 11, 11);
  end if;
  --проверка распределени€. отключить после вы€влени€ ошибки!
  --ред 04.05.12
  select nvl(sum(decode(t.priznak,1,summa,0)),0),
         nvl(sum(decode(t.priznak,0,summa,0)),0) into chk_summa_, chk_penya_
    from kwtp_day t where t.kwtp_id=rec2_.id;
  if chk_summa_ <> nvl(rec2_.summa,0) then
   -- rollback;  роллбэк в триггере не производитс€!
    Raise_application_error(-20000, 'ќплата не прошла! сумма1='||chk_summa_||', сумма2='||nvl(rec2_.summa,0)||' —ообщите программисту код ошибки C_GEN_PAY строка 127');
  end if;
  if chk_penya_ <> nvl(rec2_.penya,0) then
   -- rollback;  роллбэк в триггере не производитс€!
   Raise_application_error(-20000, 'ѕен€ не прошла! сумма1='||chk_penya_||', сумма2='||nvl(rec2_.penya,0)||' —ообщите программисту код ошибки C_GEN_PAY строка 130');
  end if;
--коммит не ставитс€, так как всЄ в триггере крутитс€...
--commit;
end;

procedure dist_pay_var(p_reu in varchar2, excl_usl_ in oper.fk_usl%type, rec_ in c_kwtp_mg%rowtype, var_ in number, fk_distr_ in number)
  is
  itgchrg_ number;
  summa_ number;
  summa_itg_ number;
  summap_ number;
  summap_itg_ number;
  kr_summa_ number;
  last_id_ kwtp_day.id%type;
  lastp_id_ kwtp_day.id%type;
  org_ nabor.org%type;
  trgt_usl_ usl.usl%type;
  l_sum_test number;
  l_sum_test2 number;
  l_cnt_tst number;
  l_last_org kwtp_day.org%type;
  l_last_usl kwtp_day.usl%type;
  l_org_uk number;
begin
  --"новое" распределение оплаты и пени ред 16.04.12
  --услуга, на которую распр пен€ и оплата, неудачно распределивша€с€
  trgt_usl_:=utils.get_str_param('ZERO_SAL');
  if trgt_usl_ is null then
    Raise_application_error(-20000, 'ѕараметр ZERO_SAL равен пустому значению!');
  end if;
  --варианты распределени€ оплаты/пени
  if var_ = 3 then
  --экслюзивное распределение оплаты на определенную услугу (Ё+)
    begin
    select t.fk_org2 into org_ from nabor n, t_org t
           where n.usl = excl_usl_
             and n.lsk=rec_.lsk
             and n.org=t.id;
    exception
      when no_data_found then
      select t.fk_org2 into org_ from kart k, t_org t
             where k.reu=t.reu
               and k.lsk=rec_.lsk;
    end;
    if rec_.summa <> 0 then
    --сумма оплаты
      insert into kwtp_day
        (fk_distr, kwtp_id, lsk, usl, org, summa, oper, dopl, nkom, nink, dat_ink, priznak, dtek)
      values
        (fk_distr_, rec_.id, rec_.lsk, excl_usl_, org_, rec_.summa, rec_.oper, rec_.dopl,
        rec_.nkom, rec_.nink, rec_.dat_ink, 1, rec_.dtek)
      returning id into last_id_;
    end if;
    --пен€ здесь никуда не перераспредел€етс€
    if rec_.penya <> 0 then
      insert into kwtp_day
        (fk_distr, kwtp_id, lsk, usl, org, summa, oper, dopl, nkom, nink, dat_ink, priznak, dtek)
      values
        (fk_distr_, rec_.id, rec_.lsk, excl_usl_, org_, rec_.penya, rec_.oper, rec_.dopl,
        rec_.nkom, rec_.nink, rec_.dat_ink, 0, rec_.dtek)
      returning id into last_id_;
    end if;
  elsif var_ = 2 then
  --корректирующа€ проводка
  --переносим с кредита на дебет

  --загружаем на обработку массив кредитового сальдо
    delete from temp_prep;
    insert into temp_prep
      (usl, org, summa, tp_cd)
    select s.usl, s.org, s.summa, 0 as tp_cd
      from temp_saldo s;
    --обрабатываем
    c_prep.dist_summa;
    --получаем обработанный массив (корректировки)
    insert into kwtp_day
      (fk_distr, kwtp_id, lsk, usl, org, summa, oper, dopl, nkom, nink, dat_ink, priznak, dtek)
    select
      fk_distr_, rec_.id, rec_.lsk, t.usl, t.org, -1*t.summa, rec_.oper, rec_.dopl,
      rec_.nkom, rec_.nink, rec_.dat_ink, 1 as priznak, rec_.dtek
      from temp_prep t where t.tp_cd in (3,4)
      and t.summa <> 0;

  elsif var_ in (11) then
  --отрицательную сумму по кредитовому сальдо
    if rec_.summa <> 0 then
      l_sum_test:=rec_.summa;
      l_cnt_tst:=0;
      --попытка распределить оплату меньше чем за 10000 циклов
      while l_sum_test <> 0 and l_cnt_tst < 10000
      loop
        dist_pay_prep(rec_, l_sum_test, fk_distr_, l_sum_test2, 1, null);
        l_sum_test:=l_sum_test-l_sum_test2;
        l_cnt_tst:=l_cnt_tst+1;
      end loop;

      --если не распределилось
      if l_sum_test <> 0 then
        --попытка принудительно распределить по дебетовому сальдо
        l_sum_test:=rec_.summa;
        l_cnt_tst:=0;
        --попытка распределить оплату меньше чем за 10000 циклов
        while l_sum_test <> 0 and l_cnt_tst < 10000
        loop
          dist_pay_prep(rec_, l_sum_test, fk_distr_, l_sum_test2, 1, 1);
          l_sum_test:=l_sum_test-l_sum_test2;
          l_cnt_tst:=l_cnt_tst+1;
        end loop;
      end if;

      --получаем обработанный массив (корректировки)
      if l_sum_test <> 0 then
        Raise_application_error(-20000, 'Ѕольшое кол-во циклов распределени€ оплаты в л/c '||rec_.lsk);
      end if;

    end if;

    --тоже по пене (Ќќ еЄ не должно быть, по лс. с кредит.сальдо!!!!)
    --положительна€ или отрицательна€ пен€ может быть,
    --если провод€т корректировку - и + по оплате и пене соответственно
    if rec_.penya <> 0 then
    --если пен€ положительна€-
    --распределить по дебетовому сальдо
    --отрицательную - по кредитовому
      l_sum_test:=rec_.penya;
      l_cnt_tst:=0;
      --попытка распределить оплату меньше чем за 10000 циклов
      while l_sum_test <> 0 and l_cnt_tst < 10000
      loop
        dist_pay_prep(rec_, l_sum_test, fk_distr_, l_sum_test2, 0, null);
        l_sum_test:=l_sum_test-l_sum_test2;
        l_cnt_tst:=l_cnt_tst+1;
      end loop;

      --если не распределилось
      if l_sum_test <> 0 then
        --попытка принудительно распределить по дебетовому сальдо
        l_sum_test:=rec_.penya;
        l_cnt_tst:=0;
        --попытка распределить оплату меньше чем за 10000 циклов
        while l_sum_test <> 0 and l_cnt_tst < 10000
        loop
          if rec_.penya > 0 then
            dist_pay_prep(rec_, l_sum_test, fk_distr_, l_sum_test2, 0, -1);
          else
            dist_pay_prep(rec_, l_sum_test, fk_distr_, l_sum_test2, 0, 1);
          end if;
          l_sum_test:=l_sum_test-l_sum_test2;
          l_cnt_tst:=l_cnt_tst+1;
        end loop;
      end if;

      if l_sum_test <> 0 then
        Raise_application_error(-20000, 'ќшибка распределени€ пени в л/c '||rec_.lsk);
      end if;
    end if;


  elsif var_ in (0,1) then
  if var_ = 0 then
  --по начислению
      delete from temp_charge;

      insert into temp_charge
        (summa, org, usl)
        select
          sum(p.summa) as summa, t.fk_org2, p.usl
          from c_charge p, nabor k, t_org t
         where p.type = 1
           and k.usl = p.usl
           and k.lsk=p.lsk
           and p.lsk=rec_.lsk
           and k.org=t.id
         group by t.fk_org2, p.usl
         having sum(p.summa) <> 0;

      select nvl(sum(summa),0) into itgchrg_ from
         temp_charge;

  elsif var_ = 1 then
  --по дебетовому сальдо
      select nvl(sum(summa),0) into itgchrg_ from
         temp_saldo;

  end if;

  summa_:=0;
  summa_itg_:=0;
  summap_:=0;
  summap_itg_:=0;
  if itgchrg_ <> 0 then
  --есть начисление/сальдо
  for c2 in (select org, usl, summa from temp_charge t where var_=0
        union all
        select org, usl, summa from temp_saldo t where var_=1)
  loop
    summa_:=round(c2.summa/itgchrg_ * rec_.summa,2);
    summa_itg_:=summa_itg_+summa_;
    summap_:=round(c2.summa/itgchrg_ * rec_.penya,2);
    summap_itg_:=summap_itg_+summap_;
    --запомнить последние услугу и орг. с перенаправлением
    redirect(p_tp => 1, p_reu => p_reu, p_usl_src => c2.usl, p_usl_dst => l_last_usl, p_org_src => c2.org, p_org_dst => l_last_org);
    --оплата
    if summa_ <> 0 then
      --перенаправление оплаты
      redirect(p_tp => 1, p_reu => p_reu, p_usl_src => c2.usl, p_usl_dst => trgt_usl_, p_org_src => c2.org, p_org_dst => org_);
      insert into kwtp_day
        (fk_distr, kwtp_id, lsk, usl, org, summa, oper, dopl, nkom, nink, dat_ink, priznak, dtek)
      values
        (fk_distr_, rec_.id, rec_.lsk, trgt_usl_, org_, summa_, rec_.oper, rec_.dopl,
        rec_.nkom, rec_.nink, rec_.dat_ink, 1, rec_.dtek)
      returning id into last_id_;
    end if;

    --пен€
    if rec_.penya <> 0 then
      --перенаправление пени
      redirect(p_tp => 0, p_reu => p_reu, p_usl_src => c2.usl, p_usl_dst => trgt_usl_, p_org_src => c2.org, p_org_dst => org_);
      if summap_ <> 0 then
        insert into kwtp_day
          (fk_distr, kwtp_id, lsk, usl, org, summa, oper, dopl, nkom, nink, dat_ink, priznak, dtek)
        values
          (fk_distr_, rec_.id, rec_.lsk,  trgt_usl_, org_, summap_, rec_.oper, rec_.dopl,
          rec_.nkom, rec_.nink, rec_.dat_ink, 0, rec_.dtek)
        returning id into lastp_id_;
      end if;

    end if;

  end loop;
  if summa_itg_ <> rec_.summa and last_id_ is not null then
     --остаток на последнюю строку распределени€
     c_get_pay.g_flag_upd:=1;
     update kwtp_day t set t.summa=t.summa+(rec_.summa-summa_itg_)
      where t.id=last_id_;
     c_get_pay.g_flag_upd:=0;
     
     summa_itg_:=summa_itg_+(rec_.summa-summa_itg_);
   elsif summa_itg_ <> rec_.summa and last_id_ is null then
     --если программа вообще не заходила в цикл (выше) - бывает при распр. 0.01 руб
      insert into kwtp_day
        (fk_distr, kwtp_id, lsk, usl, org, summa, oper, dopl, nkom, nink, dat_ink, priznak, dtek)
      values
        (fk_distr_, rec_.id, rec_.lsk, l_last_usl, l_last_org, rec_.summa-summa_itg_,
         rec_.oper, rec_.dopl,
         rec_.nkom, rec_.nink, rec_.dat_ink, 1, rec_.dtek);
     summa_itg_:=summa_itg_+(rec_.summa-summa_itg_);
  end if;

  if summap_itg_ <> rec_.penya and lastp_id_ is not null then
   --остаток на последнюю строку распределени€
   c_get_pay.g_flag_upd:=1;
   update kwtp_day t set t.summa=t.summa+(rec_.penya-summap_itg_)
    where t.id=lastp_id_;
      summap_itg_:=summap_itg_+(rec_.penya-summap_itg_);
   c_get_pay.g_flag_upd:=0;
      
   elsif summap_itg_ <> rec_.penya and lastp_id_ is null then
     --если программа вообще не заходила в цикл (выше) - бывает при распр. 0.01 руб
      insert into kwtp_day
        (fk_distr, kwtp_id, lsk, usl, org, summa, oper, dopl, nkom, nink, dat_ink, priznak, dtek)
      values
        (fk_distr_, rec_.id, rec_.lsk, trgt_usl_, org_, rec_.penya-summap_itg_,
         rec_.oper, rec_.dopl,
         rec_.nkom, rec_.nink, rec_.dat_ink, 0, rec_.dtek);
      summap_itg_:=summap_itg_+(rec_.penya-summap_itg_);
  end if;

  else
    --нет начислени€/сальдо, дл€ распределени€, устанавливаем всю оплату на trgt_usl_ услугу, поставщика - ”  в фонде
    if rec_.summa <> 0 then
      insert into kwtp_day
        (fk_distr, kwtp_id, lsk, usl, org, summa, oper, dopl, nkom, nink, dat_ink, priznak, dtek)
      select
        fk_distr_, rec_.id, rec_.lsk, trgt_usl_, t.fk_org2, rec_.summa, rec_.oper, rec_.dopl,
        rec_.nkom, rec_.nink, rec_.dat_ink, 1, rec_.dtek from t_org t, kart k
        where t.reu=k.reu and k.lsk=rec_.lsk;
      summa_itg_:=summa_itg_+rec_.summa;

    end if;

    --пен€
    if rec_.penya <> 0 then
      insert into kwtp_day
        (fk_distr, kwtp_id, lsk, usl, org, summa, oper, dopl, nkom, nink, dat_ink, priznak, dtek)
      select
        fk_distr_, rec_.id, rec_.lsk, trgt_usl_, t.fk_org2, rec_.penya, rec_.oper, rec_.dopl,
        rec_.nkom, rec_.nink, rec_.dat_ink, 0, rec_.dtek from t_org t, kart k
        where t.reu=k.reu and k.lsk=rec_.lsk;
      summap_itg_:=summap_itg_+rec_.penya;

    end if;

  end if;

  --проверка распределени€ оплаты
  if summa_itg_ <> rec_.summa then
    Raise_application_error(-20000, 'ќшибка распределени€ оплаты в л/c '||rec_.lsk);
  end if;


  if summap_itg_ <> rec_.penya then
    Raise_application_error(-20000, 'ќшибка распределени€ пени в л/c '||rec_.lsk);
  end if;

end if;

end;

procedure dist_pay_prep(rec_ in c_kwtp_mg%rowtype, l_summa in number,
  fk_distr_ in number, l_itg out number, l_priznak in kwtp_day.priznak%type,
  l_forсesign in number) is
l_sign number;
l_add_sign number;
begin
--подготовка к распределению
--l_summa - если отрицательна€, то распредел€ть по кредитовому сальдо
--если положительное, то распредел€ть по дебетовому сальдо...

  --принудительно распределить по кредитовому (l_forсesign=-1)
  --или дебетовому (l_forсesign=1) сальдо

  if l_forсesign is not null then
    l_sign:=sign(l_forсesign);
    l_add_sign:=sign(l_forсesign);
  else
    l_sign:=sign(l_summa);
    l_add_sign:=1;
  end if;

  delete from temp_prep;
  insert into temp_prep
    (usl, org, summa, tp_cd)
  select s.usl, s.org, s.summa, 0 as tp_cd
    from temp_saldo s
     where l_sign < 0 and s.summa < 0 or l_sign >= 0 and s.summa > 0
    union all
    select 'XXX' as usl, -1, l_add_sign*-1*l_summa, 0 as tp_cd
    from dual;
  --обрабатываем
  c_prep.dist_summa;

  if l_priznak=1 then
    --оплата
    insert into kwtp_day
      (fk_distr, kwtp_id, lsk, usl, org, summa, oper, dopl, nkom, nink, dat_ink, priznak, dtek)
    select
      fk_distr_, rec_.id, rec_.lsk, t.usl, t.org, l_add_sign*-1*t.summa, rec_.oper, rec_.dopl,
      rec_.nkom, rec_.nink, rec_.dat_ink, l_priznak, rec_.dtek
      from temp_prep t where t.tp_cd in (3,4) and t.usl <> 'XXX';

    select nvl(sum(l_add_sign*-1*t.summa),0) into l_itg
           from temp_prep t
           where t.tp_cd in (3,4) and t.usl <> 'XXX'
           and t.summa <> 0;
  elsif l_priznak=0 then
    --пен€
    insert into kwtp_day
      (fk_distr, kwtp_id, lsk, usl, org, summa, oper, dopl, nkom, nink, dat_ink, priznak, dtek)
    select
      fk_distr_, rec_.id, rec_.lsk, u.fk_usl_pen,
        case when t.usl <> u.fk_usl_pen then o.fk_org2 --есть перенаправление услуги
             when t.usl = u.fk_usl_pen then t.org --нет перенаправлени€ услуг
             end as org,
       l_add_sign*-1*t.summa, rec_.oper, rec_.dopl,
      rec_.nkom, rec_.nink, rec_.dat_ink, l_priznak, rec_.dtek
      from kart k, temp_prep t, usl u, t_org o where t.tp_cd in (3,4) and t.usl <> 'XXX'
      and t.usl=u.usl
      and k.lsk=rec_.lsk
      and k.reu=o.reu;

    select nvl(sum(l_add_sign*-1*t.summa),0) into l_itg
           from temp_prep t
           where t.tp_cd in (3,4) and t.usl <> 'XXX'
           and t.summa <> 0;

  end if;

/*    if rec_.penya <> 0 then
    begin
      select o.fk_org2, s.fk_usl_pen into org_, trgt_usl_ from kart k, t_org o, usl s
          where k.lsk=rec_.lsk and k.reu=o.reu and s.usl=c2.usl
          and not exists --где пен€ перенаправл€етс€ на trgt_usl_
           (select * from usl u where u.fk_usl_pen=c2.usl and u.usl=c2.usl);

--ред. 19.04.12
--      select o.fk_org2 into org_ from kart k, t_org o
--            where k.lsk=rec_.lsk and k.reu=o.reu;
    exception
     when no_data_found then
       --нет перенаправлени€ пени
       org_:=c2.org;
       trgt_usl_:=c2.usl;
    end;*/


end;

procedure dist_pay_var2(excl_usl_ in oper.fk_usl%type, rec_ in c_kwtp_mg%rowtype, var_ in number, fk_distr_ in number)
  is
  itgchrg_ number;
  summa_ number;
  summa_itg_ number;
  summap_ number;
  summap_itg_ number;
  kr_summa_ number;
  last_id_ kwtp_day.id%type;
  lastp_id_ kwtp_day.id%type;
  org_ nabor.org%type;
  trgt_usl_ usl.usl%type;
begin
  --"новое" распределение оплаты и пени ред 16.04.12
  Raise_application_error(-20000, '—“ј–џ… ¬ј–»јЌ“, ƒќ 26.03.13');

  --услуга, на которую распр пен€ и оплата, неудачно распределивша€с€
  trgt_usl_:=utils.get_str_param('ZERO_SAL');
  if trgt_usl_ is null then
    Raise_application_error(-20000, 'ѕараметр ZERO_SAL равен пустому значению!');
  end if;
  --варианты распределени€ оплаты/пени
  if var_ = 3 then
  --экслюзивное распределение оплаты на определенную услугу (Ё+)
    begin
    select t.fk_org2 into org_ from nabor n, t_org t
           where n.usl = excl_usl_
             and n.lsk=rec_.lsk
             and n.org=t.id;
    exception
      when no_data_found then
      select t.fk_org2 into org_ from kart k, t_org t
             where k.reu=t.reu
               and k.lsk=rec_.lsk;
    end;
    if rec_.summa <> 0 then
    --сумма оплаты
      insert into kwtp_day
        (fk_distr, kwtp_id, lsk, usl, org, summa, oper, dopl, nkom, nink, dat_ink, priznak, dtek)
      values
        (fk_distr_, rec_.id, rec_.lsk, excl_usl_, org_, rec_.summa, rec_.oper, rec_.dopl,
        rec_.nkom, rec_.nink, rec_.dat_ink, 1, rec_.dtek)
      returning id into last_id_;
    end if;
    --пен€ здесь никуда не перераспредел€етс€
    if rec_.penya <> 0 then
      insert into kwtp_day
        (fk_distr, kwtp_id, lsk, usl, org, summa, oper, dopl, nkom, nink, dat_ink, priznak, dtek)
      values
        (fk_distr_, rec_.id, rec_.lsk, excl_usl_, org_, rec_.penya, rec_.oper, rec_.dopl,
        rec_.nkom, rec_.nink, rec_.dat_ink, 0, rec_.dtek)
      returning id into last_id_;
    end if;
  elsif var_ = 2 then
  --корректирующа€ проводка
  --переносим с кредита на дебет
  for kr in (select s.org, s.usl, s.summa--кредитовое сальдо
                      from temp_saldo s
              where s.summa < 0) --ред 03.06.12
    /*
    select s.org, s.usl, s.summa
                      from temp_saldo s --кредитовое сальдо
                     where s.summa < 0)*/

  loop
  kr_summa_:=abs(kr.summa);
  while kr_summa_ <> 0
  loop
  for dt in (select t.org,
                 t.usl,
                 sum(t.summa) as summa
            from (select s.org, s.usl, s.summa
                    from temp_saldo s
                  union all
                select t.org, t.usl, -1*t.summa
                  from kwtp_day t-- учЄт корректир проводки (здесь надо учесть иначе перекредитуешь!!!)
                 where t.fk_distr=3 and t.priznak=1 and t.kwtp_id=rec_.id
                 /*and t.dat_ink between init.g_dt_cur_start and init.g_dt_cur_end*/) t
           group by t.org, t.usl
           having sum(t.summa)>0 )
  loop

    if kr_summa_ > dt.summa then
        insert into kwtp_day
          (fk_distr, kwtp_id, lsk, usl, org, summa, oper, dopl, nkom, nink, dat_ink, priznak, dtek)
        values
          (fk_distr_, rec_.id, rec_.lsk, kr.usl, kr.org, -1 * dt.summa, rec_.oper, rec_.dopl,
          rec_.nkom, rec_.nink, rec_.dat_ink, 1, rec_.dtek);

        insert into kwtp_day
          (fk_distr, kwtp_id, lsk, usl, org, summa, oper, dopl, nkom, nink, dat_ink, priznak, dtek)
        values
          (fk_distr_, rec_.id, rec_.lsk, dt.usl, dt.org, dt.summa, rec_.oper, rec_.dopl,
          rec_.nkom, rec_.nink, rec_.dat_ink, 1, rec_.dtek);

        kr_summa_:=kr_summa_-dt.summa;
--        commit;
    elsif kr_summa_ <= dt.summa then
        insert into kwtp_day
          (fk_distr, kwtp_id, lsk, usl, org, summa, oper, dopl, nkom, nink, dat_ink, priznak, dtek)
        values
          (fk_distr_, rec_.id, rec_.lsk, kr.usl, kr.org, -1 * kr_summa_, rec_.oper, rec_.dopl,
          rec_.nkom, rec_.nink, rec_.dat_ink, 1, rec_.dtek);

        insert into kwtp_day
          (fk_distr, kwtp_id, lsk, usl, org, summa, oper, dopl, nkom, nink, dat_ink, priznak, dtek)
        values
          (fk_distr_, rec_.id, rec_.lsk, dt.usl, dt.org, kr_summa_, rec_.oper, rec_.dopl,
          rec_.nkom, rec_.nink, rec_.dat_ink, 1, rec_.dtek);

        kr_summa_:=0;
--        commit;

    end if;
    if kr_summa_ = 0 then
     --выйти из цикла погашени€ кредит.сальдо
     exit;
    end if;


  end loop;

  if kr_summa_ <>0 then
  --кредитова€ сумма не смогла погаситьс€ полностью, выход (результат- всЄ сальдо кредитовое)
   exit;
  end if;


  end loop;


  end loop;


  elsif var_ in (0,1) then
  if var_ = 0 then
  --по начислению
      delete from temp_charge;

      insert into temp_charge
        (summa, org, usl)
        select
          sum(p.summa) as summa, t.fk_org2, p.usl
          from c_charge p, nabor k, t_org t
         where p.type = 1
           and k.usl = p.usl
           and k.lsk=p.lsk
           and p.lsk=rec_.lsk
           and k.org=t.id
         group by t.fk_org2, p.usl
         having sum(p.summa) <> 0;

      select nvl(sum(summa),0) into itgchrg_ from
         temp_charge;

  elsif var_ = 1 then
  --по дебетовому сальдо
      select nvl(sum(summa),0) into itgchrg_ from
         temp_saldo;

  end if;

  summa_:=0;
  summa_itg_:=0;
  summap_:=0;
  summap_itg_:=0;
  if itgchrg_ <> 0 then
  --есть начисление/сальдо
  for c2 in (select org, usl, summa from temp_charge t where var_=0
        union all
        select org, usl, summa from temp_saldo t where var_=1)
  loop
    summa_:=round(c2.summa/itgchrg_ * rec_.summa,2);
    summa_itg_:=summa_itg_+summa_;
    summap_:=round(c2.summa/itgchrg_ * rec_.penya,2);
    summap_itg_:=summap_itg_+summap_;
    --оплата
    if rec_.summa <> 0 then
      insert into kwtp_day
        (fk_distr, kwtp_id, lsk, usl, org, summa, oper, dopl, nkom, nink, dat_ink, priznak, dtek)
      values
        (fk_distr_, rec_.id, rec_.lsk, c2.usl, c2.org, summa_, rec_.oper, rec_.dopl,
        rec_.nkom, rec_.nink, rec_.dat_ink, 1, rec_.dtek)
      returning id into last_id_;

    end if;

    --пен€
    if rec_.penya <> 0 then
    begin
      select o.fk_org2, s.fk_usl_pen into org_, trgt_usl_ from kart k, t_org o, usl s
          where k.lsk=rec_.lsk and k.reu=o.reu and s.usl=c2.usl
          and not exists --где пен€ перенаправл€етс€ на trgt_usl_
           (select * from usl u where u.fk_usl_pen=c2.usl and u.usl=c2.usl);

--ред. 19.04.12
--      select o.fk_org2 into org_ from kart k, t_org o
--            where k.lsk=rec_.lsk and k.reu=o.reu;
    exception
     when no_data_found then
       --нет перенаправлени€ пени
       org_:=c2.org;
       trgt_usl_:=c2.usl;
    end;


      insert into kwtp_day
        (fk_distr, kwtp_id, lsk, usl, org, summa, oper, dopl, nkom, nink, dat_ink, priznak, dtek)
      values
        (fk_distr_, rec_.id, rec_.lsk,  trgt_usl_, org_, summap_, rec_.oper, rec_.dopl,
        rec_.nkom, rec_.nink, rec_.dat_ink, 0, rec_.dtek)
      returning id into lastp_id_;

    end if;

  end loop;
  if summa_itg_ <> rec_.summa then
   --остаток на последнюю строку распределени€
   c_get_pay.g_flag_upd:=1;
   update kwtp_day t set t.summa=t.summa+(rec_.summa-summa_itg_)
    where t.id=last_id_;
   c_get_pay.g_flag_upd:=0;

   summa_itg_:=summa_itg_+(rec_.summa-summa_itg_);
  end if;

  if summap_itg_ <> rec_.penya then
   --остаток на последнюю строку распределени€
   c_get_pay.g_flag_upd:=1;
   update kwtp_day t set t.summa=t.summa+(rec_.penya-summap_itg_)
    where t.id=lastp_id_;
   c_get_pay.g_flag_upd:=0;

    summap_itg_:=summap_itg_+(rec_.penya-summap_itg_);
  end if;

  else
    --нет начислени€/сальдо, дл€ распределени€, устанавливаем всю оплату на trgt_usl_ услугу, поставщика - ”  в фонде
    if rec_.summa <> 0 then
      summa_itg_:=summa_itg_+rec_.summa;
      insert into kwtp_day
        (fk_distr, kwtp_id, lsk, usl, org, summa, oper, dopl, nkom, nink, dat_ink, priznak, dtek)
      select
        fk_distr_, rec_.id, rec_.lsk, trgt_usl_, t.fk_org2, rec_.summa, rec_.oper, rec_.dopl,
        rec_.nkom, rec_.nink, rec_.dat_ink, 1, rec_.dtek from t_org t, kart k
        where t.reu=k.reu and k.lsk=rec_.lsk;

    end if;

    --пен€
    if rec_.penya <> 0 then
      summap_itg_:=summap_itg_+rec_.penya;
      insert into kwtp_day
        (fk_distr, kwtp_id, lsk, usl, org, summa, oper, dopl, nkom, nink, dat_ink, priznak, dtek)
      select
        fk_distr_, rec_.id, rec_.lsk, trgt_usl_, t.fk_org2, rec_.penya, rec_.oper, rec_.dopl,
        rec_.nkom, rec_.nink, rec_.dat_ink, 0, rec_.dtek from t_org t, kart k
        where t.reu=k.reu and k.lsk=rec_.lsk;

    end if;

  end if;

  --проверка распределени€ оплаты
  if summa_itg_ <> rec_.summa then
    Raise_application_error(-20000, 'ќшибка распределени€ оплаты в л/c '||rec_.lsk);
  end if;


  if summap_itg_ <> rec_.penya then
    Raise_application_error(-20000, 'ќшибка распределени€ пени в л/c '||rec_.lsk);
  end if;

end if;

end;


/*procedure dist_pay_add_corr is
begin
--добавл€ем корректировки
--4 корректировка из t_corrects_payment
delete from kwtp_day t where t.nkom='999' and t.kwtp_id is null;
insert into kwtp_day
  (fk_distr, kwtp_id, lsk, summa, oper, dopl, nkom, nink, dat_ink, priznak, usl, org)
 select 4, null, t.lsk, t.summa, '99' as oper, t.dopl, c.nkom, c.nink, t.dat, 1, t.usl, t.org
   from t_corrects_payments t, c_comps c, params p where c.nkom='999' and t.mg=p.period
   and nvl(t.var,0) = 0;
end;
*/


procedure dist_pay_lsk_force is
rec_ c_kwtp_mg%rowtype;

begin
--принудительное распределение платежей
for c in (select t.* into rec_ from c_kwtp_mg t where
 not exists (select * from kwtp_day k where k.kwtp_id=t.id))
loop
dist_pay_lsk(c, 0);
commit;

end loop;

end;


procedure dist_pay_del_corr is
time_ date;

begin
  --удаление корректировок оплаты
  time_:=sysdate;
  delete from kwtp_day t where t.nkom='999' and t.kwtp_id is null
  /*and t.dt between init.g_dt_start and init.g_dt_end*/;

  commit;
  logger.log_(time_,'c_gen_pay.dist_pay_del_corr');
end;


procedure dist_pay_add_corr(var_ in number) is
time_ date;

begin
  time_:=sysdate;
  --добавл€ем корректировки оплаты
  --тип-4 корректировка из t_corrects_payment (либо var_=0,null - до предварительного форм.сальдо, 1- после)
  --тип-11 корректировка котора€ Ќ≈ должна пройти в c_deb_usl
  insert into kwtp_day
    (fk_distr, kwtp_id, lsk, summa, oper, dopl, nkom, nink, dat_ink, priznak, usl, org, dtek)
   select decode(t.var,0,4,1,4, 12, 12, 4) as fk_distr, null, t.lsk, t.summa, '99' as oper,
     t.dopl,
     c.nkom, c.nink, t.dat, 1, t.usl, t.org, t.dat
     from t_corrects_payments t, c_comps c, params p where c.nkom='999' and t.mg=p.period
     and (nvl(t.var,0)=var_ or var_=0 and t.var in (0,12));
  commit;
  logger.log_(time_,'c_gen_pay.dist_pay_add_corr');
end;


--редирект оплаты/пени 
procedure redirect (p_tp in number, --1-оплата, 0 - пен€
                        p_reu in varchar2, --код –Ё”
                        p_usl_src in varchar2, --исходна€ услуга
                        p_usl_dst out varchar2, --исходна€ орг.
                        p_org_src in number, --перенаправленна€ услуга
                        p_org_dst out number --перенаправленна€ орг.
                        ) is
  l_usl_flag number; --флаг состо€вшегос€ переноса по услуге
  l_org_flag number; --флаг состо€вшегос€ переноса по организации
begin
  
l_usl_flag:=0;
l_org_flag:=0;
p_usl_dst:=p_usl_src;
p_org_dst:=p_org_src;

for c in (select * from redir_pay t where 
                                  nvl(t.reu, p_reu)=p_reu and --либо заполненное –Ё”=вход.–Ё”, либо пусто (редирект дл€ всех –Ё”)
                                  nvl(t.fk_usl_src, p_usl_src)=p_usl_src and --либо заполненное ”—Ћ=вход.”—Ћ, либо пусто (редирект дл€ всех услуг)
                                  nvl(t.fk_org_src, p_org_src)=p_org_src --либо заполненное ќ–√=вход.ќ–√, либо пусто (редирект дл€ всех организаций)
                                  and t.tp=p_tp
                                  order by 
                                  case when t.reu=p_reu then 0 else 1 end,
                                  case when t.fk_usl_src=p_usl_src then 0 else 1 end,
                                  case when t.fk_org_src=p_org_src then 0 else 1 end                                    
             ) loop

  if c.fk_usl_dst is not null then
    p_usl_dst:=c.fk_usl_dst;
    l_usl_flag:=1;
  end if;
  if c.fk_org_dst is not null then
    if c.fk_org_dst=-1 then --перенаправить на организацию, обслуживающую фонд
       select o.id into p_org_dst from t_org o
          where o.reu=p_reu;
    else
       p_org_dst:=c.fk_org_dst;
    end if;
    l_org_flag:=1;
  end if;

  if l_usl_flag=1 and l_org_flag=1 then
    exit; --нашли все переносы
  end if;    
  
end loop;             
            
end;

procedure dist_sal_corr is
mg_ params.period%type;
period_ params.period%type;
mgchange_ params.period%type;
kr_summa_ number;
rec_ c_kwtp_mg%rowtype;
changes_id_ number;
user_id_ number;
comment_ c_change_docs.text%type;
cd_tp_ c_change_docs.cd_tp%type;
dat_ date;

begin
  --корректирующа€ проводка
  --¬џѕќЋЌя≈“—я “ќЋ№ ќ если установлен параметр закрывать сальдо - CLOSE_SAL!

  --корректировка сальдо проводками оплаты
  --(переносим с кредита на дебет)
  select p.period1, p.period,
   last_day(to_date(p.period||'01','YYYYMMDD')) into mg_, period_, dat_ from v_params p;

  --ID документа
  select changes_id.nextval into changes_id_ from dual;

  mgchange_:=period_;
  user_id_:=uid;
  comment_:='«акрытие сальдо за период '||period_;
  --удаление предыдущего закрыти€ сальдо за текущий период
  delete from t_corrects_payments t where exists
   (select * from c_change_docs d where d.cd_tp='PAY_SAL' and d.id=t.fk_doc
    and to_char(d.dtek,'YYYYMM')=period_);

  delete from c_change_docs d where d.cd_tp='PAY_SAL' and
   to_char(d.dtek,'YYYYMM')=period_;



  insert into c_change_docs (id, mgchange, dtek, ts, user_id, text, cd_tp)
  values (changes_id_, mgchange_, trunc(dat_), sysdate, user_id_, comment_, 'PAY_SAL');


  for c in (select distinct t.lsk --л.с. со "смешанным" исход€щим сальдо
           from saldo_usl t
           where t.mg = mg_ and
             nvl(t.summa,0) < 0-- and t.lsk='01003333'
            and exists
           (select * from saldo_usl s where s.lsk=t.lsk and t.mg = mg_ and
             s.mg=t.mg and s.summa > 0)
          )
  loop
  for kr in (select s.org, s.usl, s.summa
                      from saldo_usl s --кредитовое исход€щее сальдо
                     where s.summa < 0 and s.mg = mg_
                     and s.lsk=c.lsk)
  loop
  kr_summa_:=abs(kr.summa);
  while kr_summa_ <> 0
  loop
  for dt in (select t.org, t.usl, sum(t.summa) as summa
              from (select s.org, s.usl, s.summa
                      from saldo_usl s where s.mg = mg_
                     and s.lsk=c.lsk
                     union all
                    select s.org, s.usl, -1*s.summa
                      from t_corrects_payments s where s.mg = period_
                     and s.lsk=c.lsk and s.fk_doc=changes_id_
                      ) t
             group by t.org, t.usl
             having sum(t.summa) > 0)
  loop

    if kr_summa_ > dt.summa then
      insert into t_corrects_payments
        (lsk, usl, org, summa, user_id, dat, mg, dopl, fk_doc, var)
       values (
         c.lsk, kr.usl, kr.org, -1 * dt.summa, user_id_, dat_, period_, period_, changes_id_, 1);

      insert into t_corrects_payments
        (lsk, usl, org, summa, user_id, dat, mg, dopl, fk_doc, var)
       values (
         c.lsk, dt.usl, dt.org, dt.summa, user_id_, dat_, period_, period_, changes_id_, 1);

--      commit;

      kr_summa_:=kr_summa_-dt.summa;
    elsif kr.summa <= dt.summa then
      insert into t_corrects_payments
        (lsk, usl, org, summa, user_id, dat, mg, dopl, fk_doc, var)
       values (
         c.lsk, kr.usl, kr.org, -1 * kr_summa_, user_id_, dat_, period_, period_, changes_id_, 1);

      insert into t_corrects_payments
        (lsk, usl, org, summa, user_id, dat, mg, dopl, fk_doc, var)
       values (
         c.lsk, dt.usl, dt.org, kr_summa_, user_id_, dat_, period_, period_, changes_id_, 1);

--      commit;
      kr_summa_:=0;

    end if;
     if kr_summa_ = 0 then
      exit;
     end if;

  end loop;


  if kr_summa_ <>0 then
  --кредитова€ сумма не смогла погаситьс€ полностью, выход (результат- всЄ сальдо кредитовое)
   exit;
  end if;


  end loop;


  end loop;

  end loop;

  commit;
end;

end C_GEN_PAY;
/

prompt
prompt Creating package body C_GET_PAY
prompt ===============================
prompt
create or replace package body scott.C_GET_PAY is

function get_payment_bank_date
  return date
is
  dtek_ date;
begin
--возвращает дату пакета, прин€того от банка
  select max(dtek) into dtek_ from load_bank t where t.nkom=init.get_nkom;
  return dtek_;
end;

function check_payment_bank_date
  return number
is
  cnt_ number;
begin
--провер€ет, принималс€ ли уже пакет банка за данную дату
--возвращает кол-во записей
  select count(*) into cnt_ from c_kwtp c
    where exists (select * from load_bank t where t.nkom=c.nkom and c.dat_ink=init.get_date
      and t.nkom=init.get_nkom);
  return cnt_;
end;

function check_payment_bank_nink(nink_ in c_kwtp.nink%type)
  return number
is
  cnt_ number;
begin
--провер€ет, принималс€ ли уже пакет банка c данным номером
--возвращает кол-во записей
  select count(*) into cnt_ from c_kwtp c
      where c.nkom=init.get_nkom and c.nink=nink_;
  return cnt_;
end;


function get_payment_bank_summa
  return number
is
  summa_ number;
begin
--возвращает сумму платежей пакета, прин€того от банка
  select sum(summa) into summa_ from load_bank t where t.nkom=init.get_nkom
    and t.code='01';
  return summa_;
end;

function get_payment_bank_summp
  return number
is
  summap_ number;
begin
--возвращает сумму пени пакета, прин€того от банка
  select sum(summa) into summap_ from load_bank t where t.nkom=init.get_nkom
    and t.code='02';
  return summap_;
end;

procedure cur_payment_bank (id_ in number, prep_refcursor in out rep_refcursor) is
begin
--выводит список не прошедших проверку платежей банка
if id_ =1 then
   open prep_refcursor for select t.* from c_comps t where
     t.nkom=init.get_nkom and t.fk_oper is null;
elsif id_ =2 then
   open prep_refcursor for select t.* from load_bank t where
     t.nkom=init.get_nkom and
     not exists (select * from kart k where k.lsk=t.lsk);

elsif id_=3 then
    open prep_refcursor for select t.* from load_bank t where
  t.nkom=init.get_nkom and t.code not in ('01','02') ;

/* --ред.05.03.12
elsif id_=4 then
   open prep_refcursor for select t.* from load_bank t, params p
    where t.nkom=init.get_nkom and to_char(t.dtek,'YYYYMM')<>p.period;
  */
elsif id_=5 then
   open prep_refcursor for select t.* from load_bank t where
  t.nkom=init.get_nkom and not exists --лЄгкий бред
  (select * from c_chargepay c, params p where c.period=p.period
   and c.mg=t.dopl);
end if;

end;

function recv_payment_bank(nink_ in c_kwtp.nink%type)
 return number
is
  oper_ oper.oper%type;
  cnt_ number;
  distrib_pay_ number;
begin
--оплата из внешних источников (банк, почта)
  select fk_oper into oper_
    from c_comps c where c.nkom=init.get_nkom;
  if oper_ is null then
  --не найден экслюзивный код операции поставщика оплаты в справочнике c_comps
    return 1;
    raise_application_error(-20001,
    'Ќе найден экслюзивный код операции поставщика оплаты в справочнике c_comps');
  end if;

--распредел€ть ли оплату по периодам (кисел)
  select nvl(p.distrib_pay,0) into distrib_pay_
    from params p;

 select nvl(count(*),0) into cnt_ from load_bank t where
  t.nkom=init.get_nkom and
  not exists (select * from kart k where k.lsk=t.lsk);
 if cnt_ <> 0 then
   --‘айл платежей содержит лицевые счета не соответствующие лицевым счетам базы!
     return 2;
 end if;

 select nvl(count(*),0) into cnt_ from load_bank t where
  t.nkom=init.get_nkom and t.code not in ('01','02') ;
 if cnt_ <> 0 then
    return 3;
  -- '‘айл платежей содержит недопустимый код операции!');
 end if;


 select nvl(count(*),0) into cnt_ from load_bank t where
  t.nkom=init.get_nkom and not exists --лЄгкий бред
  (select * from c_chargepay c, params p where c.period=p.period
   and c.mg=t.dopl);
 if cnt_ <> 0 then
    return 5;
  -- '‘айл платежей содержит недопустимый период оплаты !');
 end if;

  --ред 05.03.12 сн€т контроль на дату платежа, - главное дата инкассации

if nvl(nink_,0) <> 0 then
  --чистим платежи, если принудительно указан номер инкассации
  delete from c_kwtp_mg c where c.nkom=init.get_nkom and c.nink=nink_;
  delete from c_kwtp c where c.nkom=init.get_nkom and c.nink=nink_;
  --сommit - иначе deadlock в c_valid! ред 02.12.12
  commit;
end if;

for c in (select * from load_bank t where t.nkom=init.get_nkom)
loop

  --не допустить прин€тие платежей за период больше чем текуща€ дата инкассации банковского реестра ред.02.09.14
  if c.dtek > init.get_date then
     -- '‘айл платежей содержит недопустимую дату оплаты!');
     return 4;
  end if;
  if c.code = '01' then
    if distrib_pay_ = 0 then
      --платЄж не распредел€ть по периодам
--      get_payment(dtek_ => , lsk_ => , summa_ => , penya_ => , oper_ => , dopl_ => , iscorrect_ => , nkvit1_ => , iscommit_ => , num_doc_ => , dat_doc_ => );
      get_payment(c.dtek, c.lsk, c.summa, null, oper_, c.dopl, 1, null, 0, null, null);
    elsif distrib_pay_ = 2 then
      --платЄж распредел€ть по периодам, как единый платеж
      get_payment(c.dtek, c.lsk, c.summa, null, oper_, c.dopl, 4, null, 0, null, null);
    else
      --платЄж распредел€ть по периодам
      get_payment(c.dtek, c.lsk, c.summa, null, oper_, null, 0, null, 0, null, null);
    end if;
  elsif c.code = '02' then
    if distrib_pay_ = 0 then
      --пеню не распредел€ть по периодам
      get_payment(c.dtek, c.lsk, null, c.summa, oper_, c.dopl, 1, null, 0, null, null);
    elsif distrib_pay_ = 2 then
      --распределение пени, в едином платеже не производитс€
      null;
    else
      --пеню распредел€ть по периодам
      get_payment(c.dtek, c.lsk, null, c.summa, oper_, null, 0, null, 0, null, null);
    end if;
  end if;
end loop;
--чистим файл с прин€тым пакетом
delete from load_bank t where t.nkom=init.get_nkom;
--выполнение инкассации, текущим компьютером, текущей датой
make_inkass;
commit;
--всЄ выполнено успешно
return 0;
end;

procedure get_payment(dtek_ in c_kwtp.dtek%type, lsk_ in c_kwtp.lsk%type, summa_ in c_kwtp.summa%type,
  penya_ in c_kwtp.penya%type, oper_ in c_kwtp.oper%type, dopl_ in c_kwtp.dopl%type, iscorrect_ number,
   nkvit1_ in c_kwtp.nkvit%type, iscommit_ in number,
   num_doc_ in c_kwtp.num_doc%type, dat_doc_ in c_kwtp.dat_doc%type) is
  nkvit_ number;
  id_ number;
  dtplat_ c_kwtp.dtek%type;
begin
--прием оплаты
if lsk_ is null then
  Raise_application_error(-20000, 'ѕолучен пустой лицевой счет!');
end if;

if dtek_ is null then
  --если платеж с пустой датой - установить текущую
  --от банков могут приходить платежи с мес€цем <> текущему
  dtplat_:=init.get_date();
  else
  dtplat_:=dtek_;
end if;

if nvl(iscorrect_,0) = 3 then --наличка
  nkvit_:=nkvit1_;
else
  select nkvit into nkvit_ from c_comps t
        where t.nkom=init.get_nkom();
end if;

if nvl(iscorrect_,0) in (0, 1,2,3,4) then 
  select c_kwtp_id.nextval into id_ from dual;
end if;

if nvl(iscorrect_,0) = 1 then --корректировка оплаты
  insert into c_kwtp
    (lsk, summa, penya, oper, dopl, nink, nkom, dtek, nkvit, ts, id, iscorrect,
    num_doc, dat_doc)
  values
    (lpad(lsk_,8,'0'), summa_, penya_, oper_, dopl_,
     0, init.get_nkom(), dtplat_, nkvit_, sysdate,
     id_, iscorrect_, num_doc_, dat_doc_);
 elsif nvl(iscorrect_,0) = 2 then --распределение оплаты
  insert into c_kwtp
    (lsk, summa, penya, oper, dopl, nink, nkom, dtek, nkvit, ts, id, iscorrect,
    num_doc, dat_doc)
  values
    (lpad(lsk_,8,'0'), summa_, penya_, oper_, dopl_,
     0, init.get_nkom(), dtplat_, nkvit_, sysdate,
     id_, iscorrect_, num_doc_, dat_doc_);
 elsif nvl(iscorrect_,0) = 3 then --наличка
  insert into c_kwtp
    (lsk, summa, penya, oper, dopl, nink, nkom, dtek, nkvit, ts, id, iscorrect,
    num_doc, dat_doc)
  values
    (lpad(lsk_,8,'0'), summa_, penya_, oper_, dopl_,
     0, init.get_nkom(), dtplat_, nkvit_, sysdate,
     id_, iscorrect_, num_doc_, dat_doc_);
 elsif nvl(iscorrect_,0) in (5) then --комплексный платЄж - не делаетс€ здесь строчка!
  null;
 elsif nvl(iscorrect_,0) in (4) then --единой суммой
  --здесь пен€ не выдел€етс€ (только в c_kwtp_mg)
  insert into c_kwtp
    (lsk, summa, oper, dopl, nink, nkom, dtek, nkvit, ts, id, iscorrect,
    num_doc, dat_doc)
  values
    (lpad(lsk_,8,'0'), summa_, oper_, dopl_,
     0, init.get_nkom(), dtplat_, nkvit_, sysdate,
     id_, iscorrect_, num_doc_, dat_doc_);
else -- обычна€ оплата (0)
  insert into c_kwtp
    (lsk, summa, penya, oper, dopl, nink, nkom, dtek, nkvit, ts, id, iscorrect,
    num_doc, dat_doc)
  values
    (lpad(lsk_,8,'0'), summa_, penya_, oper_, (select period from params),
     0, init.get_nkom(), dtplat_, nkvit_, sysdate,
     id_, iscorrect_, num_doc_, dat_doc_);
 end if;
 --распредел€ем оплату по периодам
 get_payment_mg(id_, nkvit_, lsk_, summa_, penya_, oper_, dopl_, nvl(iscorrect_,0), init.get_nkom(), dtplat_, 0);

 update c_comps c set c.nkvit = nkvit_+1
        where c.nkom = init.get_nkom();
 if nvl(iscommit_,0)=1 then
   commit;
 end if;
end;

procedure get_payment_mg(id_ in c_kwtp.id%type, nkvit_ in c_kwtp.nkvit%type,
  lsk_ in c_kwtp.lsk%type, summa_ in c_kwtp.summa%type,
  penya_ in c_kwtp.penya%type, oper_ in c_kwtp.oper%type,
  dopl_ in c_kwtp.dopl%type, iscorrect_ in number, nkom_ in c_kwtp.nkom%type,
  dtek_ in c_kwtp.dtek%type, nink_ in c_kwtp.nink%type) is

t_lsk tab_lsk;
summa_pay_ number;
summa_pn_ number;
saldo_ number;
l_proc_summa number;
l_summa number;
l_penya number;
l_kwtp_id number;

--курсор распределени€ по c_penya (общий вариант)
  cursor c is
    select t.lsk, t.mg1 as mg,
      nvl(t.summa,0) as summa, nvl(t.penya,0) as penya
      from c_penya t
      where t.lsk = lpad(lsk_,8,'0')
     order by t.mg1;
  rec_ c%rowtype;

--курсор распределени€ по c_penya, по основному и дополнительному лиц счетам 
  cursor c2 is
    select t.lsk, t.mg1 as mg,
      nvl(t.summa,0) as summa, nvl(t.penya,0) as penya
      from c_penya t, temp_lsk s
      where t.lsk=s.lsk 
     order by t.mg1, t.lsk;
  rec_all_lsk c2%rowtype;

--курсор распределени€ по c_chargepay (особое распределение)
  cursor r is
    select *
      from (select c.lsk, c.mg, sum(decode(type, 1, -1 * summa, summa)) as summa
               from c_chargepay c, params p
              where c.period = p.period and
                c.lsk = lpad(lsk_,8,'0')
                and c.type in (0, 1)
                and c.mg <= dopl_
              group by c.lsk, c.mg --сначала старые периоды платим (начина€ с самых новых к старым)
              order by c.mg desc, c.lsk);
  rec_r_ r%rowtype;

begin
 --ввод оплаты, пени

if nvl(iscorrect_,0) in (0, 2, 4) then
  --выполн€етс€ только в случае платежа, необходимого дл€ распределени€ платежей по периодам
  --начисление без коммита - зачем нужно, если оно посчитано...ред 16.04.12
  --cnt_:=c_charges.gen_charges(lsk_, lsk_, null, 0, 0);
  --движение без коммита и пен€ на текущую дату, чтобы правильно посчитать периоды задолжн
  --ред 16.04.12
  --c_cpenya.gen_charge_pay(lsk_, 0); --убрал, считаетс€ в gen_penya 28.12.2015
  c_cpenya.gen_penya(lpad(lsk_,8,'0'), 0, 0);
elsif nvl(iscorrect_,0) = 5 then
  --комплексный платЄж (основной и дополнительный (капрем) долги 
  --рассчитать долг и пеню по каждому л.с.
  --t_lsk-коллекци€, - работает медленно в выражении table(t_lsk), пришлось отказатьс€ 
  delete from temp_lsk;
  t_lsk:=p_houses.get_other_lsk(lpad(lsk_,8,'0'));   
  if t_lsk.count > 0 then
    for i in t_lsk.first..t_lsk.last loop
      insert into temp_lsk (lsk) --t_lsk-коллекци€, - работает медленно в выражении table(t_lsk), пришлось ввести temp_lsk (бред конечно)
       values(t_lsk(i).lsk);
      c_cpenya.gen_penya(t_lsk(i).lsk, 0, 0);
    end loop;
  end if;
  
end if;


summa_pay_:=nvl(summa_,0);
summa_pn_:=nvl(penya_,0);

saldo_:=0;

if nvl(iscorrect_,0) = 0 then --обычный платЄж  --распределение со старых периодов (нового л.с.) к новым
open c;
loop
  fetch c into rec_;
  exit when c%notfound or summa_pay_ = 0;
  if rec_.summa+saldo_ <= 0 then --если переплата, перенести на след. период.
    saldo_:=rec_.summa+saldo_;
  elsif summa_pay_ <= rec_.summa+saldo_ then
    insert into c_kwtp_mg
      (lsk, summa, penya, oper, dopl, nink, nkom, dtek, nkvit, ts, c_kwtp_id)
      values
        (rec_.lsk, summa_pay_, summa_pn_, oper_, rec_.mg, nink_, nkom_, dtek_, nkvit_, sysdate,
          id_);
   summa_pay_:=0;
   summa_pn_:=0; --пен€ принимаетс€ первым периодом
  else
    insert into c_kwtp_mg
      (lsk, summa, penya, oper, dopl, nink, nkom, dtek, nkvit, ts, c_kwtp_id)
      values
        (rec_.lsk, rec_.summa+saldo_, summa_pn_, oper_, rec_.mg, nink_, nkom_, dtek_, nkvit_, sysdate,
          id_);
   summa_pay_:=summa_pay_-(rec_.summa+saldo_);
   saldo_:=0;
   summa_pn_:=0; --пен€ принимаетс€ первым периодом
  end if;

end loop;
close c;

--если оплата не обработалась, ставим еЄ на текущий период (Ќового Ћ»÷≈¬ќ√ќ —„≈“ј!!!)
if summa_pay_ <>0 or summa_pn_ <>0 then
    insert into c_kwtp_mg
      (lsk, summa, penya, oper, dopl, nink, nkom, dtek, nkvit, ts, c_kwtp_id)
      select k.lsk, summa_pay_, summa_pn_, oper_, p.period, nink_,
          nkom_, dtek_, nkvit_, sysdate, id_
        from kart k, params p where
                k.c_lsk_id = (select max(c_lsk_id) from kart t where
                 t.lsk=lpad(lsk_,8,'0')) and rownum = 1;
end if;

elsif nvl(iscorrect_,0) = 4 then
--≈диный платЄж  --распределение со старых периодов (нового л.с.) к новым
--и распределение на оплату и пеню
--ред 29.08.13
open c;
loop
  fetch c into rec_;
  exit when c%notfound or summa_pay_ = 0;
  if rec_.summa+rec_.penya+saldo_ <= 0 then --если переплата, перенести на след. период.
    saldo_:=rec_.summa+rec_.penya+saldo_;
  elsif summa_pay_ <= rec_.summa+rec_.penya+saldo_ then
    l_proc_summa:=rec_.summa/(rec_.summa+rec_.penya);
    l_summa:= round(l_proc_summa * summa_pay_,2);
    l_penya:= summa_pay_ - l_summa;

    insert into c_kwtp_mg
      (lsk, summa, penya, oper, dopl, nink, nkom, dtek, nkvit, ts, c_kwtp_id)
      values
        (rec_.lsk, l_summa, l_penya, oper_, rec_.mg, nink_, nkom_, dtek_, nkvit_, sysdate,
          id_);
   summa_pay_:=0;
  else
    l_proc_summa:=rec_.summa/(rec_.summa+rec_.penya);
    --здесь перенос с прошлых периодов распредел€ем пропорционально долгу и пени
    l_summa:= rec_.summa+round(saldo_*l_proc_summa,2);
    l_penya:= rec_.penya+(saldo_-round(saldo_*l_proc_summa,2));
    insert into c_kwtp_mg
      (lsk, summa, penya, oper, dopl, nink, nkom, dtek, nkvit, ts, c_kwtp_id)
      values
        (rec_.lsk, l_summa, l_penya, oper_, rec_.mg, nink_, nkom_, dtek_, nkvit_, sysdate,
          id_);
   summa_pay_:=summa_pay_-(l_summa+l_penya);
   saldo_:=0;
  end if;

end loop;
close c;

--если оплата не обработалась, ставим еЄ на текущий период
if summa_pay_ <>0 or summa_pn_ <>0 then
    insert into c_kwtp_mg
      (lsk, summa, penya, oper, dopl, nink, nkom, dtek, nkvit, ts, c_kwtp_id)
      select k.lsk, summa_pay_, summa_pn_, oper_, p.period, nink_,
          nkom_, dtek_, nkvit_, sysdate, id_
        from kart k, params p where
                k.lsk=lpad(lsk_,8,'0') and rownum = 1;

end if;


elsif nvl(iscorrect_,0) = 5 then
-- омплексный платЄж  --распределение со старых периодов к новым по основному и дополнительному лс
--и распределение на оплату и пеню
--ред 01.01.2016

/*  insert into c_kwtp
    (lsk, summa, oper, dopl, nink, nkom, dtek, nkvit, ts, id, iscorrect,
    num_doc, dat_doc)
  values
    (lpad(lsk_,8,'0'), summa_, oper_, dopl_,
     0, init.get_nkom(), dtplat_, nkvit_, sysdate,
     id_, iscorrect_, num_doc_, dat_doc_); */

delete from temp_kwtp_mg;
open c2;
loop
  fetch c2 into rec_;
  exit when c2%notfound or summa_pay_ = 0;
  if rec_.summa+rec_.penya+saldo_ <= 0 then --если переплата, перенести на след. период.
    saldo_:=rec_.summa+rec_.penya+saldo_;
  elsif summa_pay_ <= rec_.summa+rec_.penya+saldo_ then
    l_proc_summa:=rec_.summa/(rec_.summa+rec_.penya);
    l_summa:= round(l_proc_summa * summa_pay_,2);
    l_penya:= summa_pay_ - l_summa;

    insert into temp_kwtp_mg
      (lsk, summa, penya, oper, dopl, nink, nkom, dtek, nkvit, ts)
      values
        (rec_.lsk, l_summa, l_penya, oper_, rec_.mg, nink_, nkom_, dtek_, nkvit_, sysdate/*,
          id_*/);
   summa_pay_:=0;
  else
    l_proc_summa:=rec_.summa/(rec_.summa+rec_.penya);
    --здесь перенос с прошлых периодов распредел€ем пропорционально долгу и пени
    l_summa:= rec_.summa+round(saldo_*l_proc_summa,2);
    l_penya:= rec_.penya+(saldo_-round(saldo_*l_proc_summa,2));
    insert into temp_kwtp_mg
      (lsk, summa, penya, oper, dopl, nink, nkom, dtek, nkvit, ts)
      values
        (rec_.lsk, l_summa, l_penya, oper_, rec_.mg, nink_, nkom_, dtek_, nkvit_, sysdate);
   summa_pay_:=summa_pay_-(l_summa+l_penya);
   saldo_:=0;
  end if;

end loop;
close c2;

--если оплата не обработалась, ставим еЄ на текущий период в пропорции от начислени€
if summa_pay_ <>0 then
    for c in (select t.lsk, t.summa/ (sum(t.summa) over (partition by 0)) as proc
          from (select a.lsk, sum(a.summa) as summa from c_charge a, temp_lsk s
          where a.lsk=s.lsk and a.type=1
          group by a.lsk) t
          ) loop
          
      insert into temp_kwtp_mg
        (lsk, summa, penya, oper, dopl, nink, nkom, dtek, nkvit, ts)
        select k.lsk, round(summa_pay_ * c.proc,2), null, oper_, p.period, nink_,
            nkom_, dtek_, nkvit_, sysdate
          from kart k, params p where
                  k.lsk=c.lsk;
                  
       summa_pay_:=summa_pay_-round(summa_pay_ * c.proc,2);
    end loop;
end if;

--если остаток осталс€, то кинуть на любой л.с.
if nvl(summa_pay_,0) <>0 then
   update temp_kwtp_mg t set t.summa=nvl(t.summa,0)+summa_pay_
     where rowid=
       (select max(rowid) from temp_kwtp_mg k where k.summa>=summa_pay_);
end if;


--а теперь добавл€ем заголовок платежа, и детали
for c in (select distinct t.lsk from temp_kwtp_mg t)
  loop
    select c_kwtp_id.nextval into l_kwtp_id from dual;
    insert into c_kwtp
        (id, lsk, summa, penya, oper, dopl, nink, nkom, dtek, nkvit, ts, iscorrect)
      select l_kwtp_id, lsk, sum(summa) as summa, sum(penya) as penya, oper_, dopl_, 0, init.get_nkom(), dtek_, nkvit_, sysdate,
         iscorrect_
         from temp_kwtp_mg t
         where t.lsk=c.lsk
         group by t.lsk;
    insert into c_kwtp_mg
        (lsk, summa, penya, oper, dopl, nink, nkom, dtek, nkvit, ts, c_kwtp_id)
    select t.lsk, t.summa, t.penya, t.oper, t.dopl, t.nink, t.nkom, t.dtek, t.nkvit, t.ts, l_kwtp_id
          from temp_kwtp_mg t where t.lsk=c.lsk;
  
  end loop;


elsif nvl(iscorrect_,0) = 2 then --распределение со старых периодов к новым
--смысл? так и не пон€л... переговорить с кис и удалить ветку (ред 16.04.12) - бывает иногда нужно!!!
open r;
loop
  fetch r into rec_r_;
  exit when r%notfound or summa_pay_ = 0;
  if rec_r_.summa+saldo_ <= 0 then --если переплата, перенести на след. период.
    saldo_:=rec_r_.summa+saldo_;
  elsif summa_pay_ <= rec_r_.summa+saldo_ then
    insert into c_kwtp_mg
      (lsk, summa, penya, oper, dopl, nink, nkom, dtek, nkvit, ts, c_kwtp_id)
      values
        (rec_r_.lsk, summa_pay_, summa_pn_, oper_, rec_r_.mg, nink_, nkom_, dtek_, nkvit_, sysdate,
          id_);
   summa_pay_:=0;
   summa_pn_:=0; --пен€ принимаетс€ первым периодом
  else
    insert into c_kwtp_mg
      (lsk, summa, penya, oper, dopl, nink, nkom, dtek, nkvit, ts, c_kwtp_id)
      values
        (rec_r_.lsk, rec_r_.summa+saldo_, summa_pn_, oper_, rec_r_.mg, nink_, nkom_, dtek_, nkvit_, sysdate,
          id_);
   summa_pay_:=summa_pay_-(rec_r_.summa+saldo_);
   saldo_:=0;
   summa_pn_:=0; --пен€ принимаетс€ первым периодом
  end if;

end loop;
close r;

--если оплата не обработалась, ставим еЄ на текущий период (Ќового Ћ»÷≈¬ќ√ќ —„≈“ј!!!)
if summa_pay_ <>0 or summa_pn_ <>0 then
    insert into c_kwtp_mg
      (lsk, summa, penya, oper, dopl, nink, nkom, dtek, nkvit, ts, c_kwtp_id)
      select k.lsk, summa_pay_, summa_pn_, oper_, p.period, nink_,
          nkom_, dtek_, nkvit_, sysdate, id_
        from kart k, params p where
                k.c_lsk_id = (select max(c_lsk_id) from kart t where
                 t.lsk=lpad(lsk_,8,'0')) and rownum = 1;
end if;

else --корректировка оплаты
  insert into c_kwtp_mg
    (lsk, summa, penya, oper, dopl, nink, nkom, dtek, nkvit, ts, c_kwtp_id)
    values
      (lpad(lsk_,8,'0'), summa_pay_, summa_pn_, oper_, dopl_, nink_, nkom_,
        dtek_, nkvit_, sysdate,
        id_);
        
        
        
end if;

end;

function get_tails
  return number is
 summa_ number;
begin
 -- остаток в кассе по текущему компьютеру
 select nvl(sum(nvl(summa,0)+nvl(penya,0)),0) into summa_
        from c_kwtp t
        where t.nkom=init.get_nkom() and nvl(nink,0) = 0
          /*and t.dtek between init.g_dt_cur_start and init.g_dt_cur_end*/; --надо чтобы была видна вс€ оплата
 return summa_;
end;

function dst_money_cur_month(summa_ number)
   return number
 is
maxmg_ c_kwtp_temp_dolg.mg%type;
begin
--распределение излишне оплаченной суммы (чтобы не давать сдачу)
begin
select trim(max(t.mg)) into maxmg_ from c_kwtp_temp_dolg t;
exception when others then
  Raise; -- не пон€л... в –€бинке вылетает
  Raise_application_error(-20000, maxmg_);
end;
if maxmg_ is not null then
  --распредел€ем на последний мес€ц оплаты
  update c_kwtp_temp_dolg t set t.summa=nvl(t.summa,0)+summa_, t.itog=nvl(t.itog,0)+summa_
    where t.mg=maxmg_;

  update c_kwtp_temp t set t.summa=nvl(t.summa,0)+summa_, t.itog=nvl(t.itog,0)+summa_
    where exists (select * from oper o where o.oper=t.oper and nvl(o.iscounter,0) =0);
  return 0;
else
  return 1;
end if;

end;

function get_money_nal(lsk_ in kart.lsk%type)
  return c_kwtp.id%type is
 nkvit_ number;
 cnt_ number;
 id_ c_kwtp.id%type;
 c_kwtp_summa_ number;
 c_kwtp_mg_summa_ number;
 summa_mg_ number;
begin
  --ввод оплаты, наличкой


  select nvl(count(*),0) into cnt_ from (
  select count(*) as cnt, t.oper from c_kwtp_temp t
  group by t.oper
  ) where cnt > 1;
  if cnt_ > 1 then
    Raise_application_error(-20001,
     '¬нимание! ƒублируетс€ код операции, отмена!');
  end if;

  --номер квитанции
  select nkvit into nkvit_ from c_comps t
        where t.nkom=init.get_nkom();
  update c_comps c set c.nkvit = nkvit_+1
        where c.nkom = init.get_nkom();
  select c_kwtp_id.nextval into id_
    from dual;


  insert into c_kwtp
    (lsk, summa, penya, oper, dopl, nink, nkom, dtek, nkvit, dat_ink, ts, id, iscorrect)
  select lpad(lsk_,8,'0'), sum(t.summa), sum(t.penya), null, null, 0, init.get_nkom(), init.get_date(),
     nkvit_, null, sysdate, id_, 3
    from c_kwtp_temp t where nvl(t.summa,0) <> 0 or nvl(t.penya,0) <> 0;

  select nvl(sum(t.summa),0)+nvl(sum(t.penya),0) into c_kwtp_summa_
    from c_kwtp_temp t where nvl(t.summa,0) <> 0 or nvl(t.penya,0) <> 0;

  summa_mg_:=0;
  c_kwtp_mg_summa_:=0;
  for c in (select t.*, nvl(o.iscounter,0) as iscounter, trim(u.counter) as counter
     from c_kwtp_temp t , oper o, usl u where t.oper=o.oper and o.fk_usl_chk=u.usl(+))
  loop
    if c.iscounter = 0 then
      --например 01 - опер, квартплата
      insert into c_kwtp_mg
      (lsk, summa, penya, oper, dopl, nink, nkom, dtek, nkvit, dat_ink, ts, c_kwtp_id)
      select lpad(lsk_,8,'0'), t.summa, t.penya, c.oper, t.mg, 0, init.get_nkom(), init.get_date(),
       nkvit_, null, sysdate, id_
       from c_kwtp_temp_dolg t where (nvl(t.summa,0) <> 0 or nvl(t.penya,0) <> 0);

      if SQL%ROWCOUNT = 0 then
        rollback;
        logger.log_(null, 'C_GET_PAY.GET_MONEY_NAL, ќшибка при вводе оплаты! ѕовторить ввод!');
        Raise_application_error(-20000, 'ќшибка при вводе оплаты! ѕовторить ввод!'||c_kwtp_summa_||' '||c_kwtp_mg_summa_);
      end if;
      select nvl(sum(t.summa),0)+nvl(sum(t.penya),0) into summa_mg_
        from c_kwtp_temp_dolg t where nvl(t.summa,0) <> 0 or nvl(t.penya,0) <> 0;
    elsif c.iscounter <> 0  and c.counter is not null then
      --расход
      --последние показани€ по х.воде-г.воде (обраб в триггере)
      execute immediate 'update kart k set k.'||c.counter||'=:cnt_ where k.lsk=lpad(:lsk_,8,''0'')'
      using c.cnt_sch, lsk_;
      insert into c_kwtp_mg
      (lsk, summa, penya, oper, dopl, cnt_sch, cnt_sch0, nink, nkom, dtek, nkvit, dat_ink, ts, c_kwtp_id)
      select lpad(lsk_,8,'0'), t.summa, t.penya, c.oper, p.period, t.cnt_sch, c.cnt_sch0, 0, init.get_nkom(), init.get_date(),
       nkvit_, null, sysdate, id_
       from c_kwtp_temp t, params p where t.oper=c.oper and (nvl(t.summa,0) <> 0 or nvl(t.penya,0) <> 0);
      if SQL%ROWCOUNT = 0 then
        rollback;
        logger.log_(null, 'C_GET_PAY.GET_MONEY_NAL, ќшибка при вводе оплаты! ѕовторить ввод!');
        Raise_application_error(-20000, 'ќшибка при вводе оплаты! ѕовторить ввод!'||c_kwtp_summa_||' '||c_kwtp_mg_summa_);
      end if;

      select nvl(sum(t.summa),0)+nvl(sum(t.penya),0) into summa_mg_
        from c_kwtp_temp t where t.oper=c.oper and (nvl(t.summa,0) <> 0 or nvl(t.penya,0) <> 0);
    elsif c.iscounter = 2 then
      --например каб.тел
      insert into c_kwtp_mg
      (lsk, summa, penya, oper, dopl, cnt_sch, cnt_sch0, nink, nkom, dtek, nkvit, dat_ink, ts, c_kwtp_id)
      select lpad(lsk_,8,'0'), t.summa, t.penya, c.oper, p.period, t.cnt_sch, c.cnt_sch0, 0, init.get_nkom(), init.get_date(),
       nkvit_, null, sysdate, id_
       from c_kwtp_temp t, params p where t.oper=c.oper and (nvl(t.summa,0) <> 0 or nvl(t.penya,0) <> 0);
      if SQL%ROWCOUNT = 0 then
        rollback;
        logger.log_(null, 'C_GET_PAY.GET_MONEY_NAL, ќшибка при вводе оплаты! ѕовторить ввод!');
        Raise_application_error(-20000, 'ќшибка при вводе оплаты! ѕовторить ввод!'||c_kwtp_summa_||' '||c_kwtp_mg_summa_);
      end if;

      select nvl(sum(t.summa),0)+nvl(sum(t.penya),0) into summa_mg_
        from c_kwtp_temp t where t.oper=c.oper and (nvl(t.summa,0) <> 0 or nvl(t.penya,0) <> 0);
    else
      Raise_application_error(-20000, 'Ќе корректно настроен справочник операций!');
    end if;
    c_kwtp_mg_summa_:=c_kwtp_mg_summa_+summa_mg_;
  end loop;
  if nvl(c_kwtp_summa_,0) <> nvl(c_kwtp_mg_summa_,0) then
    rollback;
    logger.log_(null, 'C_GET_PAY.GET_MONEY_NAL, ќшибка при вводе оплаты! ѕовторить ввод!');
    Raise_application_error(-20000, 'ќшибка при вводе оплаты! ѕовторить ввод!'||c_kwtp_summa_||' '||c_kwtp_mg_summa_);
--  else
--    commit;
  end if;
  --начислить, чтобы объемы осели в начислении
  --cnt2_:=c_charges.gen_charges(lpad(lsk_,8,'0'), lpad(lsk_,8,'0'), null, 0, 0);

  return id_;
end;

procedure make_inkass is
  nink_ number;
begin
 --инкассаци€
 select nvl(nink,0) into nink_ from c_comps t
        where t.nkom=init.get_nkom();

 update kwtp_day t set t.nink = nink_, t.dat_ink = init.get_date()
        where exists (select * from c_kwtp_mg c
          where c.nkom = init.get_nkom() and nvl(c.nink,0) = 0
        and t.kwtp_id=c.id
        /*and c.dtek between init.g_dt_cur_start and init.g_dt_cur_end*/);

 update c_kwtp c set c.nink = nink_, c.dat_ink = init.get_date()
        where c.nkom = init.get_nkom() and nvl(c.nink,0) = 0
        /*and c.dtek between init.g_dt_cur_start and init.g_dt_cur_end*/;

 update c_kwtp_mg c set c.nink = nink_, c.dat_ink = init.get_date()
        where c.nkom = init.get_nkom() and nvl(c.nink,0) = 0
        /*and c.dtek between init.g_dt_cur_start and init.g_dt_cur_end*/;


 update c_comps c set c.nink = nink_+1
        where c.nkom = init.get_nkom();
--Ѕез коммита (он - на стороне клиента)
-- commit;
end;

procedure init_c_kwtp_temp_dolg (lsk_ in kart.lsk%type) is
  lsk_new_ c_kwtp.lsk%type;
begin
  lsk_new_:=lpad(lsk_,8,'0');
  --текущее движение по л.с.
  c_cpenya.gen_charge_pay(lsk_new_, 0);
  --пен€ об€зательно!
  c_cpenya.gen_penya(lsk_new_, 0, 0);

  delete from c_kwtp_temp_dolg;
  insert into c_kwtp_temp_dolg
  (mg, charge, payment, /*dolg,*/ summa, penya, sal, itog)
  select a.mg,
         nvl(b.summa,0) as charge,
         nvl(c.summa,0) as payment,
         /*nvl(d.summa,0) as dolg,*/
         case when nvl(d.summa,0) > 0 then nvl(d.summa,0)
         else 0
         end as summa,
         nvl(d.penya,0) as penya,
         nvl(e.summa,0) as sal,
         case when nvl(d.summa,0) > 0 then nvl(d.summa,0)
         else 0
         end+nvl(d.penya,0)
    from scott.long_table a, params p,
         (select mg, sum(summa) as summa
            from scott.c_chargepay
           where period = (select period from scott.params)
             and lsk = lsk_new_
             and type = 0
           group by mg) b,
         (select mg, sum(summa) as summa
            from scott.c_chargepay
           where period = (select period from scott.params)
             and lsk = lsk_new_
             and type = 1
           group by mg) c,
           (select * from c_penya where lsk = lsk_new_) d,
           (select sum(summa) as summa from c_penya where lsk = lsk_new_) e--совокупный долг
   where a.mg = b.mg(+)
     and a.mg = c.mg(+)
     and a.mg = d.mg1(+)
     and ((nvl(b.summa,0) = 0 and p.period=a.mg) or
         nvl(b.summa,0) <> 0 or
         nvl(d.summa,0) <> 0 or
         nvl(c.summa,0) <> 0);

end;

procedure remove_pay(id_ in c_kwtp.id%type) is
begin
--удаление неправильных оплат из ввода списком
  delete from c_kwtp_mg t where t.c_kwtp_id=id_;
  delete from c_kwtp t where t.id=id_;
--  без коммита
--  commit;
end;

procedure remove_inkass(nkom_ in c_kwtp.nkom%type, nink_ in c_kwtp.nink%type) is
begin
--удаление неправильных инкассаций...
--кассовый аппарат - в пролЄте?))
  delete from c_kwtp_mg t where t.nkom=nkom_ and nvl(t.nink,0)=nvl(nink_,0);
  delete from c_kwtp t where t.nkom=nkom_ and nvl(t.nink,0)=nvl(nink_,0);
  commit;
end;

function reverse_pay(p_kwtp_id in c_kwtp.id%type) return number is
l_id number;
l_id2 number;
l_dt date;
--текущий є комп.
l_nkom c_kwtp.nkom%type;
l_nkvit c_kwtp.nkvit%type;
begin
--обратный платЄж (провести зеркально сумму, в тек.периоде,
--в точности как была, только с обратным знаком)
  l_dt:=init.get_date;
  l_nkom:=init.get_nkom;
  select scott.c_kwtp_id.nextval into l_id from dual;
  select nkvit into l_nkvit from c_comps t
    where t.nkom=l_nkom;
  update c_comps c set c.nkvit = l_nkvit+1
        where c.nkom = init.get_nkom();

  insert into c_kwtp
    (lsk, summa, penya, oper, dopl, nink,
     nkom, dtek, nkvit, id,
     iscorrect, num_doc, dat_doc)
  select t.lsk, -1*nvl(t.summa,0) as summa, -1*nvl(t.penya,0) as penya,
     t.oper, t.dopl, 0 as nink,
     l_nkom as nkom, l_dt as dtek, l_nkvit, l_id,
     t.iscorrect, t.num_doc, t.dat_doc
  from a_kwtp t
  where t.id=p_kwtp_id;
  if SQL%ROWCOUNT = 0 then
    --не успешно
    rollback;
    return 1;
  end if;

for c in (select t.lsk, -1*nvl(summa,0) as summa, -1*nvl(penya,0) as penya,
    t.oper, t.dopl, null as nink,
    l_nkom as nkom, l_dt as dtek, l_nkvit as nkvit,
    t.cnt_sch, t.cnt_sch0, t.id
  from a_kwtp_mg t
  where t.c_kwtp_id=p_kwtp_id)
loop
  insert into c_kwtp_mg
    (lsk, summa, penya, oper, dopl,
    nkom, dtek, nkvit, c_kwtp_id,
    cnt_sch, cnt_sch0, is_dist, nink)
  values
    (c.lsk, c.summa, c.penya, c.oper, c.dopl,
    c.nkom, c.dtek, c.nkvit, l_id,
    c.cnt_sch, c.cnt_sch0, 1, --is_dist=1 - оплата уже распределена (чтоб повторно не распредел€лась в триггере)
    0
    )
   returning id into l_id2;
  if SQL%ROWCOUNT = 0 then
    --не успешно
    rollback;
    return 2;
  end if;

  insert into kwtp_day
    (summa, lsk, oper, dopl, nkom, nink,
    dat_ink, priznak, usl, org, fk_distr, sum_distr, kwtp_id, dtek)
  select -1*nvl(t.summa,0) as summa,
    t.lsk, t.oper, t.dopl, l_nkom as nkom, 0 as nink,
    null as dat_ink, t.priznak, t.usl, t.org, 13 as fk_distr, --12 тип (обратный платЄж)
    t.sum_distr,
    l_id2 as kwtp_id,
    init.get_date
    from a_kwtp_day t
    where t.kwtp_id=c.id;
  if SQL%ROWCOUNT = 0 then
    --не успешно
    rollback;
    return 3;
  end if;
end loop;

commit;
--успешно
return 0;

end;

end C_GET_PAY;
/

prompt
prompt Creating package body C_KART
prompt ============================
prompt
create or replace package body scott.C_KART is

/*procedure set_part_kpr_all(p_kart_pr in c_kart_pr.id%type) is

begin
--пересчитать всех в л.с. где проживает данный p_kart_pr
for c in (select distinct k.lsk, k.fk_tp from kart k, c_kart_pr t where t.id = p_kart_pr and t.lsk=k.lsk)
loop
  set_part_kpr(c.lsk, c.fk_tp);
end loop;
end;

procedure set_part_kpr_all_lsk is

begin
--пересчитать все не закрытые л.с.
for c in (select t.lsk, t.fk_tp from kart t where psch not in (8,9)
  )
loop
  set_part_kpr(c.lsk, c.fk_tp);
  commit;
end loop;
end;

procedure set_part_kpr_house(p_house_id in c_houses.id%type) is

begin
--пересчитать все не закрытые л.с. в доме
for c in (select t.lsk, t.fk_tp from kart t where psch not in (8,9)
  and t.house_id=p_house_id
  )
loop
  set_part_kpr(c.lsk, c.fk_tp);
--  commit;
end loop;
end;

*/

procedure set_part_kpr_vvod(p_vvod in c_vvod.id%type) is

begin
--пересчитать все не закрытые л.с. во вводе
for c in (select t.lsk, n.usl, u.cd as tp from kart t, nabor n, u_list u where t.psch not in (8,9)
  and t.lsk=n.lsk and n.fk_vvod=p_vvod and t.fk_tp=u.id
  )
loop
  set_part_kpr(c.lsk, c.usl, 0, c.tp);
--убрал коммит - исполн€етс€ в триггере
--  commit;
end loop;
end;

/*procedure set_part_kpr(p_lsk in kart.lsk%type, --лицевой
                       p_tp in u_list.cd%type --тип лицевого, дл€ расчета капремонта в доп.счетах (дл€ подстановки проживающих из основного
                       ) is
begin
--обертка, по всем услугам
  set_part_kpr(p_lsk, null, null, p_tp);
end;*/

--заполнить подготовительной информацией c_charge_prep
procedure set_part_kpr(p_lsk in kart.lsk%type, p_usl in usl.usl%type,
                       p_set_utl_kpr in number,
                       p_tp in u_list.cd%type --тип лицевого, дл€ расчета капремонта в доп.счетах (дл€ подстановки проживающих из основного
                       ) is
  l_dt_start date;
  l_dt_end date;
  l_dt date;
  l_hw_days number; --кол-во дней установленного счетчика ’.¬. в мес€це
  l_gw_days number; --кол-во дней установленного счетчика √.¬. в мес€це

  l_max_days number; --макс кол-во дней в мес€це
  l_part_days number; --дол€ одного дн€ в мес€це
  l_mg params.period%type;
  l_prop c_states_pr.fk_status%type;
  l_prop_reg c_states_pr.fk_status%type;
  --внимание! 5000-критична€ величина, представл€ет собой макс кол-во дней * макс кол-во проживающих
  TYPE l_rec_prop_type IS RECORD (id number, dt date, prop number, prop_reg number, rel_cd relations.cd%type, dat_rog date);
  TYPE l_arr_prop_type IS VARRAY(5000) OF l_rec_prop_type;
  l_arr_prop l_arr_prop_type;

  --еще один массив ID проживающих
  TYPE l_rec_prop2_type IS RECORD (id number, status number,
    dat_prop date, dat_ub date, dat_rog date, rel_cd relations.cd%type);
  TYPE l_arr_prop2_type IS VARRAY(200) OF l_rec_prop2_type;
  l_arr_prop2 l_arr_prop2_type;


  TYPE l_rec_type IS RECORD (usl varchar2(3), sch number, chrg_round number, exist_kpr number);
  TYPE l_arr_type IS VARRAY(100) OF l_rec_type;
  l_arr l_arr_type;
  
  l_kpr_wrz number;     --дни подсчитанные по вр.зарег, по нормативу
  l_kpr_wro number;     --дни подсчитанные по вр.отсут., по нормативу
  l_kpr number;
  l_kpr2 number; --дни подсчитанные дл€ всех статусов проживающих (нужно дл€ ќƒЌ)

  --округление до є знаков
  l_round number;    

  --флаги счетчиков
  l_psch number;
  l_sch_el kart.sch_el%type;
  --норматив по услуге
  l_norm number;

  l_temp_days number;
  --временные переменные
  l_tmp1 number;
  l_tmp2 number;

  --переменна€ дл€ хранени€ ненужной информации))
  l_dummy number;
  --максимальное кол-во проживающих, в течении мес€ца (дл€ соцнормы)
  l_max_kpr number;
  --параметр - считать детально c_charge_prep-1, или считать прописку-выписку по 15 числу
  l_det params.is_det_chrg%type;
  --параметр подсчета кол-во прожив (0-дл€ кис, 1 - дл€ “—∆, ѕолыс.)
  l_var_cnt_kpr number;
  --дата середины мес€ца
  l_hf_dt date;
  l_is_1room_sn number;
  --CD отношение между прожив.
  l_rel_cd relations.cd%type;
  --дата рождени€ проживающего
  l_dat_rog date;
  l_dat_rog_tmp date;
  --признаки, дл€ идентификации проживающего, дл€ капремонта
  l_above70_owner number;
  l_above70 number;
  l_under70 number;
  --основной лиц.счет (дл€ расчета капремонта в доп.счетах)
  l_lsk_main kart.lsk%type;
  t_state tab_state;
  
cursor cur1 is
  select u.usl_norm, u.counter, u.usl, u.usl_type2, u.fk_calc_tp,
          case when u.cd in ('х.вода', 'г.вода', 'х.в. дл€ гвс') then n.norm
               else null
               end as norm,
          u.cd,
          case when u.cd in ('х.вода') then k.mhw
               when u.cd in ('г.вода', 'х.в. дл€ гвс') then k.mgw
               when u.cd = 'эл.энерг.2' then k.mel
               when u.cd = 'отоп.гкал.' and k.opl <> 0 and d.dist_tp in (1) then nvl(n.vol,0) --есть ќƒѕ” по отоплению гкал, начислить по распределению
               when u.cd = 'отоп.гкал.' and k.opl <> 0 and d.dist_tp in (4,5) then k.opl*nvl(n.norm,0) --есть ќƒѕ” по отоплению гкал, начислить по нормативу                 
               when u.cd in ('г.вода.ќƒЌ', 'х.вода.ќƒЌ', 'х.в. гвс как ќƒЌ', 'эл.эн.ќƒЌ') then nvl(n.vol_add,0)
                    else null
                    end
                    as sch_vol,
          nvl(n.vol,0) as vol, -- распределение (в тех усл, где есть, например отопл.г.кал)
          nvl(n.vol_add,0) as vol_add, -- распределение (в тех усл, где есть, например х.в.ќƒЌ)
          d.kub, decode(u.cd, 'г.вода', k.kran1, 'г.вода.ќƒЌ', k.kran1, null) as kran1,
          case when u.cd = 'х.вода' then 1
               when u.cd = 'г.вода' then 1
               when u.cd = 'х.в. дл€ гвс' then 1
               when u.cd = 'эл.энерг.2' then 2
               when u.cd = 'отоп.гкал.' then 0  --засунуть в справочник можно
               when u.cd in ('г.вода.ќƒЌ', 'х.вода.ќƒЌ', 'х.в. гвс как ќƒЌ', 'эл.эн.ќƒЌ') then 4  --засунуть в справочник можно
               when u.cd in ('кап.') then 5  --капремонт! (с >=70 лет прожив.!)
                    else 3 --остальные (тек.содерж, отопление м2)
                    end as norm_tp,
                    k.opl,
                    f.norma_1, f.norma_2, f.norma_3,
                    k.komn
          from kart k, nabor n, usl u, c_vvod d, load_memof f
          where k.lsk=p_lsk
          and n.usl=u.usl
          and n.lsk=k.lsk
          and n.fk_vvod=d.id(+)
          and u.usl_norm=0
          and k.psch not in (8,9)
--          and u.is_iter=1 -делать по всем услугам, ред.13.05.14
          and (p_usl is null or u.usl = p_usl)
          order by u.usl; --order by нужен дл€ корректного заполнени€/чтени€ массива

--предварительна€ запись в temp данных о статусах
procedure load_temp is
begin

l_is_1room_sn:=utils.get_int_param('IS_1ROOM_SN');

--временна€ таблица
--##delete from tmp_state;
  --считать детально мес€ц
  --загружаем статусы по проживающим в этом л.с.

  select rec_state(t.fk_kart_pr, t.fk_status,
    decode(u.cd, 'PROP', 0, 'PROP_REG', 1),
    nvl(t.dt1, to_date('01011900','DDMMYYYY')),
    nvl(t.dt2, to_date('01012900','DDMMYYYY')),
    p.dat_rog, r.cd) bulk collect into t_state
    from c_states_pr t, u_list u, u_listtp tp, c_kart_pr p, relations r
      where t.fk_tp=u.id and u.fk_listtp=tp.id
       and tp.cd='“ипы статусов проживающих' --необх.использовать типы u_listtp
       and t.fk_kart_pr=p.id and p.lsk=coalesce(l_lsk_main, p_lsk)  --ѕќƒ—“јЌќ¬ ј!!!
       and p.relat_id=r.id(+)
  union all
  --загружаем статусы счетчиков в этом л.с.
  select rec_state(t.id, t.fk_status, 2, nvl(t.dt1, to_date('01011900','DDMMYYYY')),
    nvl(t.dt2, to_date('01012900','DDMMYYYY')), null, null)
    from c_states_sch t
      where t.lsk=p_lsk;

/*--##  insert into tmp_state
    (fk_kart_pr, fk_status, tp, dt1, dt2, dat_rog, rel_cd)
  select t.fk_kart_pr, t.fk_status,
    decode(u.cd, 'PROP', 0, 'PROP_REG', 1) as tp,
    nvl(t.dt1, to_date('01011900','DDMMYYYY')) as dt1,
    nvl(t.dt2, to_date('01012900','DDMMYYYY')) as dt2,
    p.dat_rog, r.cd
    from c_states_pr t, u_list u, u_listtp tp, c_kart_pr p, relations r
      where t.fk_tp=u.id and u.fk_listtp=tp.id
       and tp.cd='“ипы статусов проживающих' --необх.использовать типы u_listtp
       and t.fk_kart_pr=p.id and p.lsk=coalesce(l_lsk_main, p_lsk)  --ѕќƒ—“јЌќ¬ ј!!!
       and p.relat_id=r.id(+);

  --загружаем статусы счетчиков в этом л.с.
  insert into tmp_state
    (fk_kart_pr, fk_status, tp, dt1, dt2)
  select t.id, t.fk_status, 2, nvl(t.dt1, to_date('01011900','DDMMYYYY')) as dt1,
    nvl(t.dt2, to_date('01012900','DDMMYYYY')) as dt2
    from c_states_sch t
      where t.lsk=p_lsk;
*/
select t.sch_el into l_sch_el from kart t
  where t.lsk=p_lsk;

--загрузить кол-во дней наличи€ счетчиков по воде
--по эл.эн - кол-во соответствует кол-ву дней в мес€це
select
  sum(c_kart.get_is_sch(u.fk_calc_tp, t.fk_status, null)) as cnt,
  sum(c_kart.get_is_sch(u2.fk_calc_tp, t.fk_status, null)) as cnt2
  into l_hw_days, l_gw_days
  from c_states_sch t, v_cur_days d, usl u, usl u2
    where t.lsk=p_lsk
    and d.dat between nvl(t.dt1, to_date('01011900','DDMMYYYY')) and
                      nvl(t.dt2, to_date('01012900','DDMMYYYY'))
    and u.cd in ('х.вода')
    and u2.cd in ('г.вода'/*, 'х.в. дл€ гвс'*/); --здесь не надо 'х.в. дл€ гвс'

end;

--получить статусы проживающего из массива
procedure get_prop(p_fk_kart_pr in number, p_dt in date,
                   p_prop out number, p_prop_reg out number, 
                   p_rel_cd out relations.cd%type,
                   p_dat_rog out date) is
begin
  for element in 1..l_arr_prop.count --нельз€ переписать... так как будет требоватьс€ получение параметров
  loop
     if l_arr_prop(element).id=p_fk_kart_pr and  --таких как l_arr_prop(element).prop;
        l_arr_prop(element).dt=p_dt then
       p_prop:=l_arr_prop(element).prop;
       p_prop_reg:=l_arr_prop(element).prop_reg;
       p_rel_cd:=l_arr_prop(element).rel_cd;
       p_dat_rog:=l_arr_prop(element).dat_rog;
       --выйти, как нашли
       exit;
     end if;
  end loop;
end;

procedure init_arr_usl is
  l_nrm_kpr number;     --кол-во проживающих, дл€ установлени€ соц.нормы
  l_rel_cd relations.cd%type; --отношение между прожив. (в этой проц. - не нужны)
begin
  --подсчитать кол-во людей, дл€ определени€ нормативов по отдельным услугам
  --перебираем услуги
  --инициализаци€ пустого массива записей
  l_nrm_kpr:=0;
    --перебираем дни мес€ца
    l_dt:=l_dt_start;
    l_nrm_kpr:=0;
    --суть - найти наибольшее кол-во проживающих в дн€х мес€ца (по услуге)
    --дл€ определени€ норматива
    while l_dt <= l_dt_end
    loop
      l_kpr:=0;
      if l_arr_prop2.count > 0 then
      for i in l_arr_prop2.FIRST..l_arr_prop2.LAST
      loop
        --получить статусы проживающего из массива
        get_prop(l_arr_prop2(i).id, l_dt, l_prop, l_prop_reg, l_rel_cd, l_dat_rog);
        --считать кол-во проживающих по услуге с данными статусами
        --(процедура в других модул€х считает дни, здесь же - кол-во прож
        --принудительно тип - 2 (дл€ подсчЄта кол-во прож. дл€ опеределени€ соцнормы)
        get_days(2, l_kpr, l_dummy, l_dummy, l_dummy, l_prop, l_prop_reg, l_var_cnt_kpr);
      end loop;
      end if;
      if l_kpr > l_nrm_kpr then
        l_nrm_kpr:=l_kpr;
      end if;
      l_dt:=l_dt+1;
    end loop;

--    l_arr_usl.extend;
    l_max_kpr:=ceil(l_nrm_kpr); --округлить в большую сторону

  --сохранить инфу в таблице, чтобы использовать в начислении (пакет c_charge)
  for c2 in cur1
  loop
    insert into c_charge_prep
     (lsk, usl, kpr, tp)
     values
     (p_lsk, c2.usl, l_max_kpr, 2);
  end loop;


  --инициализировать массив дл€ работы со счетчиком
  select usl, 0 as sch, nvl(u.chrg_round,3),--округление по умолчанию то 3 знаков
    0 as exist_kpr
    bulk collect into l_arr
    from usl u where (p_usl is null or u.usl=p_usl); --внимание! критический код! (возможно нельз€ ограничивать одной услугой) ред.17.02.2015
end;

--получить статус из array
function get_status(t_state in tab_state, p_dt in date, p_tp in number, p_prop in number) return number is
begin
  if t_state.count > 0 then       
    if p_tp=2 then
      --поиск по счетчикам
        --если указана конкретна€ дата
        for j in t_state.first..t_state.last loop
          if t_state(j).tp=p_tp 
            and p_dt between t_state(j).dt1 and t_state(j).dt2 then
            return t_state(j).fk_status;
          end if;
        end loop;    
    else
      --поиск по проживающим
      for j in t_state.first..t_state.last loop
        if t_state(j).tp=p_tp and t_state(j).fk_kart_pr=p_prop
          and p_dt between t_state(j).dt1 and t_state(j).dt2 then
          return t_state(j).fk_status;
        end if;
      end loop;    
    end if;
  end if;    
  return null;
end;

--инициализаци€ массива со статусами проживающих
procedure init_array is
j number;
--локальные переменные, чтобы отделить от глобальных
l_prop2 number;
l_prop_reg2 number;
l_dt_tmp date;
begin
  
  --инициализаци€ пустого массива записей
  l_arr_prop:=l_arr_prop_type();

  --инициализировать массив-2 дл€ работы с проживающими
  select t.id, t.status, t.dat_prop, t.dat_ub, t.dat_rog, r.cd as relat_cd
    bulk collect into l_arr_prop2
  from c_kart_pr t, relations r where t.lsk=coalesce(l_lsk_main, p_lsk)  --ѕќƒ—“јЌќ¬ ј!!!
   and t.relat_id=r.id(+);

  --перебираем проживающих
  j:=1;
--  for c in (select t.id, t.status, t.dat_prop, t.dat_ub from c_kart_pr t where t.lsk=p_lsk)
  if l_arr_prop2.count > 0 then
  for i in l_arr_prop2.FIRST..l_arr_prop2.LAST
  loop
    l_dt_tmp:=l_dt_start;
    --перебираем дни мес€ца
    while l_dt_tmp <= l_dt_end
    loop
      --статусы в текущем периоде
      --статус посто€нной регистрации
      --begin
      if l_det <> 0 then
        --считаем детально мес€ц
        --t_state in tab_state, p_dt in date, p_tp in number, p_prop in number
        l_prop2:=get_status(t_state => t_state, p_dt => l_dt_tmp, p_tp => 0, p_prop => l_arr_prop2(i).id);
        /*select t.fk_status into l_prop2
          from tmp_state t
           where t.tp=0 and t.fk_kart_pr=l_arr_prop2(i).id
            and l_dt_tmp between t.dt1 and t.dt2;*/
      else
        --берем даты статусов прописки-выписки на 15 число
        l_prop2:=get_status(t_state => t_state, p_dt => l_hf_dt, p_tp => 0, p_prop => l_arr_prop2(i).id);
        /*select t.fk_status into l_prop2
          from tmp_state t
           where t.tp=0 and t.fk_kart_pr=l_arr_prop2(i).id
            and l_hf_dt between t.dt1 and t.dt2;*/
      end if;
      --exception when NO_DATA_FOUND then
        if l_prop2 is null then
          l_prop2:=4; --если нет записей, значит был выписан
        end if;
      --end;
      --статус временного отсут - регистрации
      --begin
      if l_det <> 0 then
        --считаем детально мес€ц
        l_prop_reg2:=get_status(t_state => t_state, p_dt => l_dt_tmp, p_tp => 1, p_prop => l_arr_prop2(i).id);
        /*select t.fk_status into l_prop_reg2
          from tmp_state t
           where t.tp=1 and t.fk_kart_pr=l_arr_prop2(i).id
            and l_dt_tmp between t.dt1 and t.dt2;*/
      else
        --берем даты статусов прописки-выписки на 15 число
        l_prop_reg2:=get_status(t_state => t_state, p_dt => l_hf_dt, p_tp => 1, p_prop => l_arr_prop2(i).id);
        /*select t.fk_status into l_prop_reg2
          from tmp_state t
           where t.tp=1 and t.fk_kart_pr=l_arr_prop2(i).id
            and l_hf_dt between t.dt1 and t.dt2;*/
      end if;
      --exception when NO_DATA_FOUND then
      --  l_prop_reg2:=null;
      --end;
      --заполнить массив значени€ми
      l_arr_prop.extend;
      l_arr_prop(j).id:=l_arr_prop2(i).id;
      l_arr_prop(j).dt:=l_dt_tmp;
      l_arr_prop(j).prop:=l_prop2;
      l_arr_prop(j).prop_reg:=l_prop_reg2;
      l_arr_prop(j).dat_rog:=l_arr_prop2(i).dat_rog;
      l_arr_prop(j).rel_cd:=l_arr_prop2(i).rel_cd;
      
      j:=j+1;
      l_dt_tmp:=l_dt_tmp+1;
    end loop;
  end loop;
  end if;
end;


begin
--if admin.get_state_base = 0 or init.g_admin_acc <> 0 then
--если база открыта и простой пользователь или админский доступ
--то разрешить пересчЄт...
--сделано дл€ ускорени€ работы приложени€

--удалить предыдущие данные
delete from c_charge_prep t where t.lsk=p_lsk
 and t.tp in (0,1,2,3,5,6,7,8,9)
 and (p_usl is null or t.usl=p_usl);

--почистить временную таблицу
delete from temp_c_charge_prep t;

--первый день мес€ца
select to_date(p.period||'01','YYYYMMDD'),
  p.period, nvl(p.is_det_chrg,0), to_date(p.period||'15','YYYYMMDD')
   into l_dt_start, l_mg, l_det, l_hf_dt
   from params p; --параметр подсчета пользующихс€ соцнормой

--установить подстановку основного лиц.счета вместо дополнительного лиц.счета 
--чтобы использовать c_kart_pr и c_states_pr из основного счета
l_lsk_main:=null;
if p_tp='LSK_TP_ADDIT' then
  begin
    select t.lsk into l_lsk_main from kart k, kart t, u_list u
                          where k.lsk=p_lsk and k.k_lsk_id=t.k_lsk_id
                          and t.psch not in (8,9) and t.fk_tp=u.id
                          and u.cd='LSK_TP_MAIN';
    exception when no_data_found then
      --нет основного счета, попробовать посчитать по текущему
      l_lsk_main:=p_lsk;
    when others then
      raise;                      
  end;                        
end if;


--параметр подсчета кол-во прожив (0-дл€ кис, 1 - дл€ “—∆, ѕолыс.)
l_var_cnt_kpr:=nvl(utils.get_int_param('VAR_CNT_KPR'),0);

--последний день мес€ца
l_dt_end:=last_day(l_dt_start);
--кол-во дней в мес€це
l_max_days:=to_number(to_char(l_dt_end,'DD'));
--дол€ одного дн€ в мес€це
l_part_days:=1/l_max_days;

--предварительна€ запись в temp данных о статусах проживающих
load_temp;
--инициализаци€ массива со статусами проживающих
init_array;
--инициализаци€ массива с кол-во прожив по услуге
init_arr_usl;

  --перебираем дни мес€ца
  l_dt:=l_dt_start;
  while l_dt <= l_dt_end
  loop
--    j:=1;
    --перебираем услуги
    for c2 in cur1
    loop

      --узнать про счетчик
      --begin
      --либо €вно счетчик стоит, либо тип услуги 4 - (ќƒЌ)
        if c2.counter is not null or c2.norm_tp=4 then
          if l_det <> 0 then
            --считаем детально мес€ц
            l_psch:=get_status(t_state => t_state, p_dt => l_dt, p_tp => 2, p_prop => null);
            /*select nvl(max(t.fk_status),0) into l_psch
              from tmp_state t
               where t.tp=2 and l_dt between t.dt1 and t.dt2;*/
          else
            --берем, состо€ние счетчика на конец мес€ца
            l_psch:=get_status(t_state => t_state, p_dt => l_dt_end, p_tp => 2, p_prop => null);
            /*select nvl(max(t.fk_status),0) into l_psch
              from tmp_state t
               where t.tp=2 and l_dt_end between t.dt1 and t.dt2;*/
--               Raise_application_error(-20000, to_char(l_dt_end,'YYYYMMDD')||'-'||l_psch);
          end if;
        else
         --услуги без счетчиков
         l_psch:=0;
        end if;
        --не найден счетчик, попробовать вз€ть на последнюю дату, или присвоить 0 (хм...)
        if l_psch is null then
            l_psch:=nvl(get_status(t_state => t_state, p_dt => l_dt_end, p_tp => 2, p_prop => null),0);
        end if;
      --exception when NO_DATA_FOUND then
        /*select nvl(max(t.fk_status),0) into l_psch
          from tmp_state t
           where t.tp=2;*/
      --end;

      --—читаем кол-во проживающих, объемы дл€ текущего периода, по услуге
      l_kpr:=0;
      l_kpr_wrz:=0;
      l_kpr_wro:=0;
      --l_kpr2 - считает всех, ¬.ѕ.¬.«.¬.ќ.ѕ.ѕ.  –ќћ≈ ¬.ќ. - дл€ расчЄта в нормативе (не путать с l_max_kpr!)
      l_kpr2:=0;
      l_dummy:=0;

      l_dat_rog:=null;
      l_above70_owner:=0;
      l_above70:=0;
      l_under70:=0;
      if l_arr_prop2.count > 0 then
        for i in l_arr_prop2.FIRST..l_arr_prop2.LAST
        loop
          --получить статусы проживающего из массива
          get_prop(l_arr_prop2(i).id, l_dt, l_prop, l_prop_reg, l_rel_cd, l_dat_rog_tmp);
          if l_prop =1 and months_between(l_dt, coalesce(l_dat_rog_tmp, sysdate))/12 >= 70 and l_rel_cd in (' вартиросъемщик', '—обственник') then
            --посто€нно проживающий >=70 лет, да еще и квартиросъемщик (собственник)
            l_above70_owner:=1;      
          elsif l_prop =1 and months_between(l_dt, coalesce(l_dat_rog_tmp, sysdate))/12 >= 70 and (l_rel_cd is null or l_rel_cd not in (' вартиросъемщик', '—обственник')) then
            --посто€нно проживающий >=70 лет, Ќќ Ќ≈ квартиросъемщик (Ќ≈ собственник)
            l_above70:=1;      
          elsif l_prop in (1,3) and months_between(l_dt, coalesce(l_dat_rog_tmp, sysdate))/12 < 70 then
            --посто€нно, временно зарег <70 лет
            l_under70:=1;
          end if;
            
--          end if;
          --считать кол-во проживающих по услуге с данными статусами
	          --(процедура в других модул€х считает дни, здесь же - кол-во прож
          get_days(p_usl_type2 =>c2.usl_type2 ,
                   p_days => l_kpr, --кол-во прож. дл€ определени€ расценки
                   p_days_wrz => l_kpr_wrz,
                   p_days_wro => l_kpr_wro,
                   p_days_kpr2 => l_kpr2, --кол-во прож. дл€ определени€ соцнормы по услуге
                   p_prop => l_prop,
                   p_prop_reg => l_prop_reg,
                   p_var_cnt_kpr => l_var_cnt_kpr);
        end loop;
      end if;


      --определить соц норму по кол-ву проживающих
      --(только дл€ определени€ сумм по норме и свыше соцнормы)
      l_norm:=null;
      if c2.norm_tp=1 then
        --услуги, по которым задан норматив в курсоре
        l_norm:=c2.norm;
      elsif c2.norm_tp=2 then --дл€ эл.эн.
        --заменил в условии l_max_kpr на l_kpr ред. 20.05.14
        if l_kpr = 1 THEN
          l_norm := 130;
        ELSIF l_kpr IN (2, 3) THEN
          l_norm := 100;
        ELSIF l_kpr = 4 THEN
          l_norm := 87.5;
        ELSIF l_kpr = 5 THEN
          l_norm := 80;
        ELSIF l_kpr >= 6 THEN
          l_norm := 75;
        END IF;
      elsif c2.norm_tp=3 then --дл€ тек.содерж., отопление м2
        IF l_kpr = 1 THEN
          l_norm := c2.norma_1;
        ELSIF l_kpr IN (2) THEN
          l_norm := c2.norma_2;
        ELSIF l_kpr >= 3 THEN
          l_norm := c2.norma_3;
        ELSE
          --кол-во прожив = 0 (бывает при временно зарег)
          l_norm := c2.norma_1;
        END IF;
      end if;

      --записать кол-во дней наличи€ счетчика
      l_temp_days:= null;
      if c2.cd in ('х.вода') then
        l_temp_days:=l_hw_days;
      elsif c2.cd in ('г.вода', 'х.в. дл€ гвс') then
        l_temp_days:=l_gw_days;
      elsif c2.cd='отоп.гкал.' then
        l_temp_days:=l_max_days;
      else
        --дл€ прочих услуг, берЄм макс кол-во дней
        l_temp_days:=l_max_days;
      end if;

      --записать долю одного дн€
      if get_is_sch(c2.fk_calc_tp, l_psch, l_sch_el) = 1 then
        --счетчик, установить это в массиве наличи€ счетчиков по услугам
        --(в том числе счетчик по ќƒЌ)
        for i in l_arr.FIRST..l_arr.LAST
        loop
          if l_arr(i).usl=c2.usl then
            l_arr(i).sch:=1;
          end if;
        end loop;

        --изменил дл€ ѕолыс - норматив
--        l_tmp1:=l_norm * l_max_kpr * l_part_days;
       if c2.cd <> 'г.вода.ќƒЌ' or c2.cd='г.вода.ќƒЌ' and
         (nvl(c2.kran1, 0) = 0 or
          nvl(c2.kran1, 0) = 1
          and l_dt between utils.get_date_param('MONTH_HEAT1') --обраб.отопит.период
                       and utils.get_date_param('MONTH_HEAT2'))
          then

          l_tmp1:=l_norm * l_kpr2 * l_part_days;
          l_tmp2:=c2.sch_vol * 1/l_temp_days;

          insert into temp_c_charge_prep
           (usl, vol, vol_nrm, vol_sv_nrm, kpr, kprz, kpro, kpr2, sch, dt1, tp, opl)
          values
           (c2.usl,
           c2.sch_vol * 1/l_temp_days, --дол€ одного дн€
           case when l_tmp1 > l_tmp2 then
              l_tmp2
              else
               l_tmp1 end, --по соц.норме
           case when l_tmp1 > l_tmp2 then
              null
              else
               l_tmp2 - l_tmp1 end, --свыше соц.нормы
           l_kpr * l_part_days,
           l_kpr_wrz * l_part_days,
           l_kpr_wro * l_part_days,
           l_kpr2 * l_part_days,
           1, l_dt, 0,
             case when nvl(c2.sch_vol * 1/l_temp_days,0)<>0 then c2.opl * 1/l_max_days
               else null end --площадь в доле одного дн€
           );
       end if;
      elsif get_is_sch(c2.fk_calc_tp, l_psch, l_sch_el) is null and c2.sch_vol <> 0 then
        --нет счетчика, расход распредел€етс€ по услуге в nabor.vol (отоп.гкал) или 
        insert into temp_c_charge_prep
         (usl, vol, kpr, kprz, kpro, kpr2, sch, dt1, tp, opl)
        values
         (c2.usl,
         c2.sch_vol * 1/l_temp_days, --дол€ одного дн€
         l_kpr * l_part_days,
         l_kpr_wrz * l_part_days,
         l_kpr_wro * l_part_days,
         l_kpr2 * l_part_days,
         0, l_dt, 0,
           case when nvl(c2.sch_vol * 1/l_temp_days,0)<>0 then c2.opl * 1/l_max_days
             else null end --площадь в доле одного дн€
         );
      else
        --норматив
        if c2.norm_tp=3 then
          --–асчет норматива/свыше (дл€ услуги например отопление, тек.содерж. м2)
-- изменил дл€ полыс. 19.05.14
--          l_tmp1:=l_norm * l_max_kpr * l_part_days;
          if l_is_1room_sn=1 and c2.komn =1 and l_kpr2 > 0 then 
            --в 1-комн квартире при наличии проживающих, всЄ идЄт в соцнорму (если разрешено параметром l_is_1room_sn=1)
            l_tmp1:=c2.opl * 1/l_temp_days;
            l_tmp2:=c2.opl * 1/l_temp_days;
          else
            l_tmp1:=l_norm * l_kpr2 * l_part_days;
            l_tmp2:=c2.opl * 1/l_temp_days;
          end if;

          insert into temp_c_charge_prep
           (usl, vol, vol_nrm, vol_sv_nrm, kpr, kprz, kpro, kpr2, sch, dt1, tp, opl)
          values
           (c2.usl,
           l_tmp2, --дол€ одного дн€
           case when l_tmp1 > l_tmp2 then
              l_tmp2
              else
               l_tmp1 end, --по соц.норме
           case when l_tmp1 > l_tmp2 then
              null
              else
               l_tmp2 - l_tmp1 end, --свыше соц.нормы
           l_kpr * l_part_days,
           l_kpr_wrz * l_part_days,
           l_kpr_wro * l_part_days,
           l_kpr2 * l_part_days,
           0, l_dt, 0,
           case when nvl(l_tmp2,0)<>0 then c2.opl * 1/l_max_days
             else null end --площадь в доле одного дн€
           );
        elsif c2.norm_tp=4 then
          --расчет нормативной доли по ќƒЌ
           if c2.cd <> 'г.вода.ќƒЌ' or c2.cd='г.вода.ќƒЌ' and
             (nvl(c2.kran1, 0) = 0 or
              nvl(c2.kran1, 0) = 1
              and l_dt between utils.get_date_param('MONTH_HEAT1') --обраб.отопит.период
                           and utils.get_date_param('MONTH_HEAT2'))
               then
                l_tmp1:=c2.sch_vol * l_part_days;
                insert into temp_c_charge_prep
                 (usl, vol, vol_nrm, vol_sv_nrm, kpr, kprz, kpro, kpr2, sch, dt1, tp, opl)
                values
                 (c2.usl,
                 l_tmp1, --дол€ одного дн€
                 l_tmp1, --только по соцнорме
                 null,
                 l_kpr * l_part_days,
                 l_kpr_wrz * l_part_days,
                 l_kpr_wro * l_part_days,
                 l_kpr2 * l_part_days,
                 0, l_dt, 0,
                 case when nvl(l_tmp1,0)<>0 then c2.opl * 1/l_max_days
                   else null end --площадь в доле одного дн€
                 );
            end if;
        elsif c2.norm_tp=5 then --капремонт
          
          insert into temp_c_charge_prep
           (usl, vol, vol_nrm, vol_sv_nrm, kpr, kprz, kpro, kpr2, sch, dt1, tp, opl)
          values
           (c2.usl,
           case when l_above70_owner=1 and l_above70 = 0 and l_under70=0 then 0 -- льгота одиноким собственникам > 70 лет 
                when l_above70_owner=1 and l_above70 = 1 and l_under70=0 then 0 -- льгота собственникам > 70 лет с прожив > 70лет
                else c2.opl * 1/l_temp_days end, --площадь в доле одного дн€
           null, null,
           l_kpr * l_part_days,
           l_kpr_wrz * l_part_days,
           l_kpr_wro * l_part_days,
           l_kpr2 * l_part_days,
           0, l_dt, 0,
           null);

          --добавить инфу по льготе
          insert into temp_c_charge_prep
           (usl, vol, dt1, tp, fk_spk)
          select 
           c2.usl,
           case when l_above70_owner=1 and l_under70=0 then c2.opl * 1/l_temp_days
                else null end as vol, --площадь в доле одного дн€
               l_dt as dt1, 8 as tp, t.id as fk_spk
           from spk t where 
           case when l_above70_owner=1 and l_above70 = 0 and l_under70=0 then 'PENS_SINGLE_70'
                when l_above70_owner=1 and l_above70 = 1 and l_under70=0 then 'PENS_70_WITH_70'
                else null end =t.cd;
        elsif c2.norm_tp in (1,2) then
          --норматив указан (на человека) и Ќ≈ надо считать свыше соц нормы
          if c2.kub <> 0.001  or c2.kub is null then
           --≈сли был указан объем по вводу, не равный нулевому (убрать этот позор наф - 0.001)
           if c2.cd <> 'г.вода' or c2.cd='г.вода' and
             (nvl(c2.kran1, 0) = 0 or
              nvl(c2.kran1, 0) = 1
              and l_dt between utils.get_date_param('MONTH_HEAT1') --обраб.отопит.период
                           and utils.get_date_param('MONTH_HEAT2'))
               then
           --если период - отопительный (только дл€ гор€чей воды)
             if nvl(l_kpr2,0) <> 0 then
             --если есть проживающие в этой дате
               insert into temp_c_charge_prep
                 (usl, vol, vol_nrm, kpr, kprz, kpro, kpr2, sch, dt1, tp, opl)
                values
                 (c2.usl,
                 l_norm * l_kpr2 * l_part_days,
                 l_norm * l_kpr2 * l_part_days,
                 l_kpr * l_part_days,
                 l_kpr_wrz * l_part_days,
                 l_kpr_wro * l_part_days,
                 l_kpr2 * l_part_days,
                 0, l_dt, 0,
                 case when nvl(l_norm * l_kpr2 * l_part_days,0)<>0 then c2.opl * 1/l_max_days
                  else null end --площадь в доле одного дн€
                 );
              end if;
           end if;
          end if;
        end if;
      end if;
    end loop;
    l_dt:=l_dt+1;
  end loop;

   --добавить строчку о наличии счетчика по услуге в данном периоде
  for i in l_arr.FIRST..l_arr.LAST
  loop
    if l_arr(i).sch=1 then
      insert into c_charge_prep
       (lsk, usl, sch, tp)
      values
       (p_lsk, l_arr(i).usl, 1, 7);
    end if;
  end loop;

--группировать до ключевых позиций
--без учЄта корректировок ќƒЌ
--в TEMP
--где есть проживающие
for i in l_arr.FIRST..l_arr.LAST
loop
  l_round:=l_arr(i).chrg_round;

  insert into temp_c_charge_prep
   (usl, vol, vol_nrm, vol_sv_nrm, kpr, kprz, kpro, kpr2, sch, tp)
  select usl, round(sum(vol), l_round),
   nvl(round(sum(vol_nrm), l_round),0)
   + --округление
   (nvl(round(sum(vol), l_round),0)-nvl(round(sum(vol_nrm), l_round),0)-nvl(round(sum(vol_sv_nrm), l_round),0))
   ,
   round(sum(vol_sv_nrm) ,l_round),
   round(sum(kpr),4),
   round(sum(kprz),4),
   round(sum(kpro),4),
   round(sum(kpr2),4),
   sch, 5 as tp
   from temp_c_charge_prep t
   where t.tp in (0) --Ќ≈ включа€ корректировки ќƒЌ (4)
   and nvl(t.kpr,0)<>0
   and t.usl = l_arr(i).usl
   group by t.usl, t.sch;

  --где нет проживающих и есть объем
  insert into temp_c_charge_prep
   (usl, vol, vol_nrm, vol_sv_nrm, kpr, kprz, kpro, kpr2, sch, tp)
  select usl, round(sum(vol),l_round),
   nvl(round(sum(vol_nrm),l_round),0)
   + --округление
   (nvl(round(sum(vol),l_round),0)-nvl(round(sum(vol_nrm),l_round),0)-nvl(round(sum(vol_sv_nrm),l_round),0))
   ,
   round(sum(vol_sv_nrm) ,l_round),
   round(sum(kpr),4),
   round(sum(kprz),4),
   round(sum(kpro),4),
   round(sum(kpr2),4),
   sch, 5 as tp
   from temp_c_charge_prep t
   where t.tp in (0) --Ќ≈ включа€ корректировки ќƒЌ (4)
   and nvl(t.kpr,0)=0 and nvl(t.vol,0)<>0
   and t.usl = l_arr(i).usl
   group by t.usl, t.sch;

end loop;

--переписать в общую таблицу
insert into c_charge_prep
 (lsk, usl, vol, vol_nrm, vol_sv_nrm, kpr, kprz, kpro, kpr2, sch, tp)
select p_lsk, usl, vol, vol_nrm, vol_sv_nrm, kpr, kprz, kpro, kpr2, sch, tp
 from temp_c_charge_prep t
 where t.tp = 5;


--с учЄтом корректировок ќƒЌ
--сперва в TEMP

--где есть проживающие
for i in l_arr.FIRST..l_arr.LAST
loop
  l_round:=l_arr(i).chrg_round;
  
  insert into temp_c_charge_prep
   (usl, vol, vol_nrm, vol_sv_nrm, kpr, kprz, kpro, kpr2, sch, tp)
  select usl, round(sum(vol), l_round),
   nvl(round(sum(vol_nrm), l_round),0)
   + --округление
   (nvl(round(sum(vol), l_round),0)-nvl(round(sum(vol_nrm), l_round),0)-nvl(round(sum(vol_sv_nrm), l_round),0))
   ,
   round(sum(vol_sv_nrm) ,l_round),
   round(sum(kpr),4),
   round(sum(kprz),4),
   round(sum(kpro),4),
   round(sum(kpr2),4),
   sch, 1 as tp
   from (select p_lsk as lsk, usl, vol, vol_nrm, vol_sv_nrm, kpr, kprz, kpro, kpr2, sch, tp from
      temp_c_charge_prep r where r.tp=0
      union all
      select lsk, usl, vol, vol_nrm, vol_sv_nrm, kpr, kprz, kpro, kpr2, sch, tp from
      c_charge_prep r where r.tp=4 and r.lsk=p_lsk
      ) t
   where t.lsk=p_lsk and t.tp in (0,4) --включа€ корректировки ќƒЌ (4)
   and (nvl(t.kpr,0)<>0 or t.tp=4) --либо кто-то проживает, либо корректировка
   and t.usl = l_arr(i).usl
   group by t.lsk, t.usl, t.sch;

  --флаг наличи€ проживающих (чтобы добавить корректировки ќƒЌ либо туда либо туда)
  if SQL%NOTFOUND then
    l_arr(i).exist_kpr:=0;
  else
    l_arr(i).exist_kpr:=1;
  end if;
end loop;


--где нет проживающих и есть объем
for i in l_arr.FIRST..l_arr.LAST
loop
  l_round:=l_arr(i).chrg_round;
  insert into temp_c_charge_prep
   (usl, vol, vol_nrm, vol_sv_nrm, kpr, kprz, kpro, kpr2, sch, tp)
  select usl, round(sum(vol), l_round) as vol,
   nvl(round(sum(vol_nrm), l_round),0)
   + --округление
   (nvl(round(sum(vol), l_round),0)-nvl(round(sum(vol_nrm), l_round),0)-nvl(round(sum(vol_sv_nrm), l_round),0)) as vol_nrm,
   round(sum(vol_sv_nrm) , l_round) as vol_sv_nrm,
   round(sum(kpr),4) as kpr,
   round(sum(kprz),4) as kprz,
   round(sum(kpro),4) as kpro,
   round(sum(kpr2),4) as kpr2,
   sch, 1 as tp
   from (select p_lsk as lsk, usl, vol, vol_nrm, vol_sv_nrm, kpr, kprz, kpro, kpr2, sch, tp from
      temp_c_charge_prep r where r.tp=0
      union all
      select lsk, usl, vol, vol_nrm, vol_sv_nrm, kpr, kprz, kpro, kpr2, sch, tp from
      c_charge_prep r where r.tp=4 and r.lsk=p_lsk
      ) t
   where (t.tp in (0,4) and l_arr(i).exist_kpr=0 or
        t.tp in (0) and l_arr(i).exist_kpr=1)  --включа€ или не включа€ корректировки ќƒЌ (4)
   and nvl(t.kpr,0)=0 and nvl(t.vol,0)<>0
   and t.usl = l_arr(i).usl
   group by t.lsk, t.usl, t.sch;
end loop;

--переписать в общую таблицу
insert into c_charge_prep
 (lsk, usl, vol, vol_nrm, vol_sv_nrm, kpr, kprz, kpro, kpr2, sch, tp)
select p_lsk, usl, vol, vol_nrm, vol_sv_nrm, kpr, kprz, kpro, kpr2, sch, tp
 from temp_c_charge_prep t
 where t.tp = 1;


--итог объема, итог проживающих, по счетчику, нормативу
--группированный по наличию- отсутствию счетчика
--без учета корр.ќƒЌ
insert into c_charge_prep
 (lsk, usl, vol, vol_nrm, vol_sv_nrm, kpr, kprz, kpro, kpr2, sch, tp)
 select p_lsk, usl, sum(vol) as vol, sum(vol_nrm) as vol_nrm,
        sum(vol_sv_nrm) as vol_sv_nrm, sum(kpr) as kpr,
        sum(kprz) as kprz, sum(kpro) as kpro, sum(kpr2) as kpr2, sch, 6 as tp
  from temp_c_charge_prep t where t.tp=5
  and (p_usl is null or t.usl = p_usl)
  group by usl, sch;

--с учЄтом корр.ќƒЌ
insert into c_charge_prep
 (lsk, usl, vol, vol_nrm, vol_sv_nrm, kpr, kprz, kpro, kpr2, sch, tp)
 select p_lsk, usl, sum(vol) as vol, sum(vol_nrm) as vol_nrm,
        sum(vol_sv_nrm) as vol_sv_nrm, sum(kpr) as kpr,
        sum(kprz) as kprz, sum(kpro) as kpro, sum(kpr2) as kpr2, sch, 3 as tp
  from temp_c_charge_prep t where t.tp=1
  and (p_usl is null or t.usl = p_usl)
  group by usl, sch;

--сгруппировать инфу по льготам, до крупных периодов
/*delete kmp1;
insert into kmp1
select * from temp_c_charge_prep t;*/

insert into c_charge_prep
 (lsk, usl, fk_spk, vol, tp, dt1, dt2)

with r as
 (select t.dt1, t.vol, t.usl, t.fk_spk
    from temp_c_charge_prep t
   where t.fk_spk is not null
     and (p_usl is null or t.usl = p_usl)
     and t.tp = 8)
     
select p_lsk as lsk, d.usl, d.fk_spk, round(sum(d.vol),2) as vol, 9 as tp, d.dt1, d.dt2
  from (
  select c.fk_spk, c.usl, c.dt1, c.dt2, r.vol
           from (select b.fk_spk, b.usl, grp1 as dt1,
                         case
                           when grp2 is null then
                            lead(grp2, 1) over (order by usl, dt1)
                           else
                            grp2
                         end as dt2
                    from (select fk_spk, usl, dt1,
                                  case
                                    when fk_spk = lag(fk_spk, 1) over(order by usl, dt1) and usl = lag(usl, 1) over(order by usl, dt1)
                                      then
                                     null
                                    else
                                     dt1
                                  end as grp1,
                                  case
                                    when fk_spk = lead(fk_spk, 1) over(order by usl, dt1) and usl = lead(usl, 1) over(order by usl, dt1) 
                                      then
                                     null
                                    else
                                     dt1
                                  end as grp2
                             from r) b
                   where b.grp1 is not null
                      or b.grp2 is not null) c
           join r
             on r.usl=c.usl and r.dt1 between c.dt1 and c.dt2
          where c.dt1 is not null
            and c.dt2 is not null
            ) d
 group by d.fk_spk, d.usl, d.dt1, d.dt2;

/* if sql%rowcount = 0 then 
   Raise_application_error(-20000, 'TEST1');
 end if;*/

--«ƒ≈—№ ћќ∆Ќќ ¬–≈ћ≈ЌЌќ ¬ Ћё„»“№ ƒ≈“јЋ»«ј÷»ё!
/*insert into c_charge_prep
 (lsk, usl, vol, vol_nrm, vol_sv_nrm, kpr, kprz, kpro, kpr2, sch, tp, dt1, dt2, fk_spk)
 select p_lsk, usl, vol, vol_nrm, vol_sv_nrm, kpr, kprz, kpro, kpr2, sch,
   t.tp as tp, t.dt1, t.dt2, t.fk_spk
  from temp_c_charge_prep t where t.tp in (0,8); --например начисление и льготы
*/

--вызвать дополнительные функции расчЄта кол-во проживающих
if nvl(p_set_utl_kpr,0) = 1 then
  utils.set_kpr(p_lsk);
end if;

end;

procedure get_days(
   p_usl_type2 in usl.usl_type2%type,
   p_days in out number,
   p_days_wrz in out number,
   p_days_wro in out number,
   p_days_kpr2 in out number,
   p_prop in c_states_pr.fk_status%type,
   p_prop_reg in c_states_pr.fk_status%type,
   p_var_cnt_kpr in number) is
begin
--услуга подолева€ (х.в.,г.в.)
if p_var_cnt_kpr = 0 then
  --¬ј–»јЌ“  ис.
  if p_prop in (4) and p_prop_reg is null then
    --выписан без доп.статусов
    null;
  elsif p_prop in (4) and p_prop_reg in (2) then
    --выписан и временно отсут. (ошибка, не бывает такого)
    null;
  elsif (p_prop in (4) or p_prop is null) and p_prop_reg in (3,6) then
    --выписан или пустой основной статус и временно зарег.
    if p_usl_type2 =1 then
      --услуга жилищна€ (тек.сод.)
      p_days_wrz:=p_days_wrz+1;
      --дл€ расчЄта объема дл€ нормативного начислени€
      p_days_kpr2:=p_days_kpr2+1;
    elsif p_usl_type2 in (0) then
      --услуга коммунальна€ (х.в.)
      p_days_wrz:=p_days_wrz+1;
      --дл€ расчЄта объема дл€ нормативного начислени€
      p_days_kpr2:=p_days_kpr2+1;
    elsif p_usl_type2 in (2) then
      --дл€ расчЄта макс кол-во прожив
      --услуга коммунальна€ (х.в.)
    --ред. 20.08.2014
    null;
--      p_days:=p_days+1;
    end if;
  elsif p_prop in (1,5) and p_prop_reg is null then
    --прописан или статус=дл€_начислени€ без доп.статусов
    if p_usl_type2 =1 then
      --услуга жилищна€ (тек.сод.)
      p_days:=p_days+1;
      --дл€ расчЄта объема дл€ нормативного начислени€
      p_days_kpr2:=p_days_kpr2+1;
    elsif p_usl_type2 in (0) then
      --услуга коммунальна€ (х.в.)
      p_days:=p_days+1;
      --дл€ расчЄта объема дл€ нормативного начислени€
      p_days_kpr2:=p_days_kpr2+1;
    elsif p_usl_type2 in (2) then
      --дл€ расчЄта макс кол-во прожив
      p_days:=p_days+1;
    end if;
  elsif p_prop in (1,5) and p_prop_reg in (2) then
    --прописан или статус=дл€_начислени€ и временно отсут.
    if p_usl_type2 =1 then
      --услуга жилищна€ (тек.сод.)
      p_days:=p_days+1;
      p_days_wro:=p_days_wro+1;
    elsif p_usl_type2 in (0) then
      --услуга коммунальна€ (х.в.)
      p_days:=p_days+1;
      p_days_wro:=p_days_wro+1;
    elsif p_usl_type2 in (2) then
      --дл€ расчЄта макс кол-во прожив
      p_days:=p_days+1;
    end if;
  elsif p_prop in (1,5) and p_prop_reg in (3,6) then
    --прописан или статус=дл€_начислени€ и временно зарег. (ошибка, не бывает такого)
    if p_usl_type2 =1 then
      --услуга жилищна€ (тек.сод.)
      p_days:=p_days+1;
      --дл€ расчЄта объема дл€ нормативного начислени€
      p_days_kpr2:=p_days_kpr2+1;
    elsif p_usl_type2 in (0) then
      --услуга коммунальна€ (х.в.)
      p_days:=p_days+1;
      --дл€ расчЄта объема дл€ нормативного начислени€
      p_days_kpr2:=p_days_kpr2+1;
    elsif p_usl_type2 in (2) then
      --дл€ расчЄта макс кол-во прожив
    --ред. 20.08.2014
    null;
--      p_days:=p_days+1;
    end if;
  end if;
elsif p_var_cnt_kpr = 1 then
--#######################################################################
--¬ариант ѕолыс.
  if p_prop in (4) and p_prop_reg is null then
    --выписан без доп.статусов
    null;
  elsif p_prop in (4) and p_prop_reg in (2) then
    --выписан и временно отсут. (ошибка, не бывает такого)
    null;
  elsif (p_prop in (4) or p_prop is null) and p_prop_reg in (3,6) then
    --выписан или пустой основной статус и временно зарег.
    if p_usl_type2 =1 then
      --услуга жилищна€ (отопление)
      p_days_wrz:=p_days_wrz+1;
      --дл€ расчЄта объема дл€ нормативного начислени€
      --p_days_kpr2:=p_days_kpr2+1;
      --p_days:=p_days+1;
    elsif p_usl_type2 in (0) then
      --услуга коммунальна€ (х.в.)
      p_days_wrz:=p_days_wrz+1;
      --дл€ расчЄта объема дл€ нормативного начислени€
      p_days_kpr2:=p_days_kpr2+1;
      p_days:=p_days+1;
    elsif p_usl_type2 in (2) then
      --дл€ расчЄта макс кол-во прожив
      --услуга коммунальна€ (х.в.)
      p_days:=p_days+1;
    end if;
  elsif p_prop in (1,5) and p_prop_reg is null then
    --прописан или статус=дл€_начислени€ без доп.статусов
    if p_usl_type2 =1 then
      --услуга жилищна€ (тек.сод.)
      p_days:=p_days+1;
      --дл€ расчЄта объема дл€ нормативного начислени€
      p_days_kpr2:=p_days_kpr2+1;
    elsif p_usl_type2 in (0) then
      --услуга коммунальна€ (х.в.)
      p_days:=p_days+1;
      --дл€ расчЄта объема дл€ нормативного начислени€
      p_days_kpr2:=p_days_kpr2+1;
    elsif p_usl_type2 in (2) then
      --дл€ расчЄта макс кол-во прожив
      p_days:=p_days+1;
    end if;
  elsif p_prop in (1,5) and p_prop_reg in (2) then
    --прописан или статус=дл€_начислени€ и временно отсут.
    if p_usl_type2 =1 then
      --услуга жилищна€ (тек.сод.)
      p_days:=p_days+1;
      p_days_wro:=p_days_wro+1;
      --дл€ расчЄта объема дл€ нормативного начислени€
      p_days_kpr2:=p_days_kpr2+1;
    elsif p_usl_type2 in (0) then
      --услуга коммунальна€ (х.в.)
      p_days:=p_days+1;
      p_days_wro:=p_days_wro+1;
      --дл€ расчЄта объема дл€ нормативного начислени€
      --p_days_kpr2:=p_days_kpr2+1; ---ƒќЅј¬»Ћ
    elsif p_usl_type2 in (2) then
      --дл€ расчЄта макс кол-во прожив
      p_days:=p_days+1;
    end if;
  elsif p_prop in (1,5) and p_prop_reg in (3,6) then
    --прописан или статус=дл€_начислени€ и временно зарег. (ошибка, не бывает такого)
    if p_usl_type2 =1 then
      --услуга жилищна€ (тек.сод.)
      p_days:=p_days+1;
      --дл€ расчЄта объема дл€ нормативного начислени€
      p_days_kpr2:=p_days_kpr2+1;
    elsif p_usl_type2 in (0) then
      --услуга коммунальна€ (х.в.)
      p_days:=p_days+1;
      --дл€ расчЄта объема дл€ нормативного начислени€
      p_days_kpr2:=p_days_kpr2+1;
    elsif p_usl_type2 in (2) then
      --дл€ расчЄта макс кол-во прожив
      p_days:=p_days+1;
    end if;
  end if;
elsif p_var_cnt_kpr = 2 then
--#######################################################################
--¬ариант “—∆
  if p_prop in (4) and p_prop_reg is null then
    --выписан без доп.статусов
    null;
  elsif p_prop in (4) and p_prop_reg in (2) then
    --выписан и временно отсут. (ошибка, не бывает такого)
    null;
  elsif (p_prop in (4) or p_prop is null) and p_prop_reg in (3,6) then
    --выписан или пустой основной статус и временно зарег.
    if p_usl_type2 =1 then
      --услуга жилищна€ (отопление)
      p_days_wrz:=p_days_wrz+1;
      --дл€ расчЄта объема дл€ нормативного начислени€
--      p_days_kpr2:=p_days_kpr2+1;
      p_days:=p_days+1;
    elsif p_usl_type2 in (0) then
      --услуга коммунальна€ (х.в.)
      p_days_wrz:=p_days_wrz+1;
      --дл€ расчЄта объема дл€ нормативного начислени€
      p_days_kpr2:=p_days_kpr2+1;
      p_days:=p_days+1;
    elsif p_usl_type2 in (2) then
      --дл€ расчЄта макс кол-во прожив
      --услуга коммунальна€ (х.в.)
      p_days:=p_days+1;
    end if;
  elsif p_prop in (1,5) and p_prop_reg is null then
    --прописан или статус=дл€_начислени€ без доп.статусов
    if p_usl_type2 =1 then
      --услуга жилищна€ (тек.сод.)
      p_days:=p_days+1;
      --дл€ расчЄта объема дл€ нормативного начислени€
      p_days_kpr2:=p_days_kpr2+1;
    elsif p_usl_type2 in (0) then
      --услуга коммунальна€ (х.в.)
      p_days:=p_days+1;
      --дл€ расчЄта объема дл€ нормативного начислени€
      p_days_kpr2:=p_days_kpr2+1;
    elsif p_usl_type2 in (2) then
      --дл€ расчЄта макс кол-во прожив
      p_days:=p_days+1;
    end if;
  elsif p_prop in (1,5) and p_prop_reg in (2) then
    --прописан или статус=дл€_начислени€ и временно отсут.
    if p_usl_type2 =1 then
      --услуга жилищна€ (тек.сод.)
      p_days:=p_days+1;
      p_days_wro:=p_days_wro+1;
    elsif p_usl_type2 in (0) then
      --услуга коммунальна€ (х.в.)
      p_days:=p_days+1;
      p_days_wro:=p_days_wro+1;
    elsif p_usl_type2 in (2) then
      --дл€ расчЄта макс кол-во прожив
      p_days:=p_days+1;
    end if;
  elsif p_prop in (1,5) and p_prop_reg in (3,6) then
    --прописан или статус=дл€_начислени€ и временно зарег. (ошибка, не бывает такого)
    if p_usl_type2 =1 then
      --услуга жилищна€ (тек.сод.)
      p_days:=p_days+1;
      --дл€ расчЄта объема дл€ нормативного начислени€
      p_days_kpr2:=p_days_kpr2+1;
    elsif p_usl_type2 in (0) then
      --услуга коммунальна€ (х.в.)
      p_days:=p_days+1;
      --дл€ расчЄта объема дл€ нормативного начислени€
      p_days_kpr2:=p_days_kpr2+1;
    elsif p_usl_type2 in (2) then
      --дл€ расчЄта макс кол-во прожив
      p_days:=p_days+1;
    end if;
  end if;

end if;
end;

function get_is_sch (p_fk_calc in usl.fk_calc_tp%type,
  p_psch in kart.psch%type, p_sch_el in kart.sch_el%type) return number is
l_ret number;
begin
--функци€ определ€юща€ наличие счетчика по услуге
l_ret:=null;

if p_fk_calc in (3, 17, 20, 38) then --(в т.ч.ќƒЌ услуга)
  --х.вода
  if p_psch in (1,2) then
    l_ret:=1;
  else
    l_ret:=0;
  end if;
elsif p_fk_calc in (4, 18, 21, 38, 40) then --(в т.ч.ќƒЌ услуга)
  --г.вода
  if p_psch in (1,3) then
    l_ret:=1;
  else
    l_ret:=0;
  end if;
elsif p_fk_calc in (31, 23) then --здесь возможны другие fk_calc (проверить!) --(в т.ч.ќƒЌ услуга)
  --эл.энерг
    l_ret:=p_sch_el;
end if;

return l_ret;
end;

function get_is_chrg(p_sptarn in usl.sptarn%type,
    p_koeff in nabor.koeff%type, p_norm in nabor.norm%type) return number is
begin
  --функци€ определени€ наличи€ услуги по пол€м
  --справочников nabor и usl
  case
     when p_sptarn = 0 and nvl(p_koeff, 0) <> 0 then
      return 1;
     when p_sptarn = 1 and nvl(p_norm, 0) <> 0 then
      return 1;
     when p_sptarn = 2 and nvl(p_koeff, 0) <> 0 and nvl(p_norm, 0) <> 0 then
      return 1;
     when p_sptarn = 3 and nvl(p_koeff, 0) <> 0 and nvl(p_norm, 0) <> 0 then
      return 1;
     else
      return 0;
   end case;
end;


/*procedure set_part_kpr_old(l_lsk in kart.lsk%type) is
  l_dt_start date;
  l_dt_end date;
  l_dt date;
  l_dat_prop c_kart_pr.dat_prop%type;
  l_dat_ub c_kart_pr.dat_prop%type;
  l_max_days number; --макс кол-во дней в мес€це
  l_part_days number; --дол€ одного дн€ в мес€це
  l_psch kart.psch%type;
  l_sch_el kart.sch_el%type;
  l_days number;     --дни подсчитанные по человеку, по нормативу
  l_days_sch number;     --дни подсчитанные по человеку, по счетчику
  l_days_wrz number;     --дни подсчитанные по вр.зарег, по нормативу
  l_days_wrz_sch number;     --дни подсчитанные по вр.зарег, по счетчику
  l_days_wro number;     --дни подсчитанные по вр.отсут., по нормативу
  l_days_wro_sch number;     --дни подсчитанные по вр.отсут., по счетчику

  l_kf_usl number; --итоговый коэфф по услуге, по нормативу, по всем проживающим
  l_kf_usl_sch number; --итоговый коэфф по услуге, по счетчикам, по всем проживающим

  l_kf_usl_wrz number; --итоговый коэфф по услуге, по нормативу, по врем.зарег
  l_kf_usl_wrz_sch number; --итоговый коэфф по услуге, по счетчикам, по врем.зарег

  l_kf_usl_wro number; --итоговый коэфф по услуге, по нормативу, по врем.отсут
  l_kf_usl_wro_sch number; --итоговый коэфф по услуге, по счетчикам, по врем.отсут

  l_nrm_kpr number;     --кол-во проживающих, дл€ установлени€ соц.нормы
  l_nrm_kpr2 number;     --кол-во проживающих, дл€ определени€ расценки (считаетс€ по-другому)
  l_prop c_states_pr.fk_status%type;
  l_prop_reg c_states_pr.fk_status%type;
  l_fullmonth params.is_fullmonth%type;
  l_mg params.period%type;
  l_var_nrm number;
  type l_smpl_type is record(
    nrm_kpr number,
    kf_kpr number,
    kf_kpr_sch number,
    kf_kpr_wrz number,
    kf_kpr_wrz_sch number,
    kf_kpr_wro number,
    kf_kpr_wro_sch number);

  l_smpl_rec l_smpl_type;

  TYPE l_rec_type IS RECORD (id number, dt date, prop number, prop_reg number);
  --внимание! 5000-критична€ величина, представл€ет собой макс кол-во дней * макс кол-во проживающих
  TYPE l_arr_prop_type IS VARRAY(5000) OF l_rec_type ;
  l_arr_prop l_arr_prop_type;
  i number;
  l_smpl_usl usl.usl%type;

begin
--подсчет долей времени присутстви€ проживающего
--в течении мес€ца по услугам

if admin.get_state_base = 0 or init.g_admin_acc <> 0 then
--если база открыта и простой пользователь или админский доступ
--то разрешить пересчЄт...
--сделано дл€ ускорени€ работы приложени€

  --инициализаци€ пустого массива записей
  l_arr_prop:=l_arr_prop_type();

--первый день мес€ца
select p.is_fullmonth, to_date(p.period||'01','YYYYMMDD'),
  p.period, nvl(s.parn1,0) into l_fullmonth, l_dt_start, l_mg, l_var_nrm
   from params p, spr_params s
   where s.cd='VAR_NRM_CNT'; --параметр подсчета пользующихс€ соцнормой
--последний день мес€ца
l_dt_end:=last_day(l_dt_start);
--кол-во дней в мес€це
l_max_days:=to_number(to_char(l_dt_end,'DD'));
--дол€ одного дн€ в мес€це
l_part_days:=1/l_max_days;

--begin
select t.sch_el into l_sch_el from kart t
  where t.lsk=l_lsk;
--exception when others then
-- Raise_application_error(-20000, l_lsk);
--end;

--временна€ таблица
delete from tmp_state;
--загружаем статусы по проживающим в этом л.с.
insert into tmp_state
  (fk_kart_pr, fk_status, tp, dt1, dt2)
select t.fk_kart_pr, t.fk_status,
  decode(u.cd, 'PROP', 0, 'PROP_REG', 1) as tp,
  nvl(t.dt1, to_date('01011900','DDMMYYYY')) as dt1,
  nvl(t.dt2, to_date('01012900','DDMMYYYY')) as dt2
  from c_states_pr t, u_list u, u_listtp tp
    where t.fk_tp=u.id and u.fk_listtp=tp.id
     and tp.cd='“ипы статусов проживающих' --необх.использовать типы u_listtp
     and exists                                --так как u_list.cd не уникальны
     (select * from c_kart_pr k where k.id=t.fk_kart_pr
       and k.lsk=l_lsk);
--загружаем статусы счетчиков в этом л.с.
insert into tmp_state
  (fk_kart_pr, fk_status, tp, dt1, dt2)
select t.id, t.fk_status, 2, nvl(t.dt1, to_date('01011900','DDMMYYYY')) as dt1,
  nvl(t.dt2, to_date('01012900','DDMMYYYY')) as dt2
  from c_states_sch t
    where t.lsk=l_lsk;

  i:=1;
  --перебираем проживающих
  for c2 in (select t.id, t.status, t.dat_prop, t.dat_ub from c_kart_pr t where t.lsk=l_lsk)
  loop
    l_dt:=l_dt_start;
    --перебираем дни мес€ца
    while l_dt <= l_dt_end
    loop
      --статусы в текущем периоде
      --статус посто€нной регистрации
      begin
      select t.fk_status into l_prop
        from tmp_state t
         where t.tp=0 and t.fk_kart_pr=c2.id
          and l_dt between t.dt1 and t.dt2;
      exception when NO_DATA_FOUND then
        l_prop:=null;
      end;
      --статус временного отсут - регистрации
      begin
        select t.fk_status into l_prop_reg
          from tmp_state t
           where t.tp=1 and t.fk_kart_pr=c2.id
            and l_dt between t.dt1 and t.dt2;
      exception when NO_DATA_FOUND then
        l_prop_reg:=null;
      end;
      --заполнить массив значени€ми
      l_arr_prop.extend;
      l_arr_prop(i).id:=c2.id;
      l_arr_prop(i).dt:=l_dt;
      l_arr_prop(i).prop:=l_prop;
      l_arr_prop(i).prop_reg:=l_prop_reg;
      i:=i+1;
      l_dt:=l_dt+1;
    end loop;
  end loop;


--перебираем услуги
for c in (select n.rowid as rw, u.usl_norm, u.counter, u.usl, u.usl_type2, u.fk_calc_tp
    from nabor n, usl u
    where
    n.usl=u.usl
    and n.lsk=l_lsk
    )
loop
  l_kf_usl:=0;
  l_kf_usl_sch:=0;

  l_kf_usl_wrz:=0;
  l_kf_usl_wrz_sch:=0;
  l_kf_usl_wro:=0;
  l_kf_usl_wro_sch:=0;

  l_nrm_kpr:=0;
  l_nrm_kpr2:=0;
  --перебираем проживающих
  for c2 in (select t.id, t.status, t.dat_prop, t.dat_ub from c_kart_pr t where t.lsk=l_lsk)
  loop
  l_days:=0;
  l_days_sch:=0;
  l_days_wrz:=0;
  l_days_wrz_sch:=0;
  l_days_wro:=0;
  l_days_wro_sch:=0;
  l_days_wro:=0;

  l_dt:=l_dt_start;

  --выбрать ту услугу, из которой потом будут вз€ты kf_kpr и прочие коэфф.
  if c.counter is null then
    l_smpl_usl:=c.usl;
  end if;

    --перебираем дни мес€ца
    while l_dt <= l_dt_end
    loop

    --вытащить статусы из массива --можно переписать на Nested tables и здесь использовать MEMBER OF
    for element in 1..l_arr_prop.count --нельз€ переписать... так как будет требоватьс€ получение параметров
    loop
       if l_arr_prop(element).id=c2.id and  --таких как l_arr_prop(element).prop;
          l_arr_prop(element).dt=l_dt then
         l_prop:=l_arr_prop(element).prop;
         l_prop_reg:=l_arr_prop(element).prop_reg;
       end if;
    end loop;

      --счетчик
      begin
        --здесь брать тоже max() - иначе ошибка, когда мен€ют дату статуса счетчиков сразу в двух периодах
        --ред.13.05.13
        if c.counter is not null then
          select nvl(max(t.fk_status),0) into l_psch
            from tmp_state t
             where t.tp=2 and l_dt between t.dt1 and t.dt2;
        else
         --услуги без счетчиков
         l_psch:=0;
        end if;
      exception when NO_DATA_FOUND then
--        Raise_application_error(-20000, '¬нимание! ¬ л/с: '||l_lsk||' отсутствует признак счетчика!');
          --вз€ть по MAX статусу, если периоды настроены не верно.
          --иначе - будет эксепшн в самом приложении!!!
          --если вообще нет статусов счетчиков - вз€ть как нормативный
        select nvl(max(t.fk_status),0) into l_psch
          from tmp_state t
           where t.tp=2;
      end;

      if get_is_sch(c.fk_calc_tp, l_psch, l_sch_el) =1 then
        --прибавить день по счетчикам
        get_days(c.usl_type2, l_days_sch, l_days_wrz_sch, l_days_wro_sch, l_prop, l_prop_reg);
      else
        --прибавить день по нормативу
        get_days(c.usl_type2, l_days, l_days_wrz, l_days_wro,  l_prop, l_prop_reg);
      end if;

      i:=i+1;
      l_dt:=l_dt+1;
    end loop;
    --коэфф по услуге, по нормативу (сумма всех коэфф по люд€м)
    l_kf_usl:=l_kf_usl+l_days/l_max_days;

    --коэфф по услуге, по нормативу (сумма всех коэфф по люд€м), по вр.зарег, вр.отсут
    l_kf_usl_wrz:=l_kf_usl_wrz+l_days_wrz/l_max_days;
    l_kf_usl_wro:=l_kf_usl_wro+l_days_wro/l_max_days;

    --коэфф по услуге, по счетчику (сумма всех коэфф по люд€м)
    if l_days+l_days_sch=l_max_days and l_days <> 0 and l_days_sch <> 0 then
    --если необходимо округлить (в случае кол-ва дней по сч и по норме = макс дней мес.)
      l_kf_usl_sch:=l_kf_usl_sch+(1-round(l_days/l_max_days,4)); --здесь округл до 4
    else
      l_kf_usl_sch:=l_kf_usl_sch+round(l_days_sch/l_max_days,4); --здесь округл до 4
    end if;

    --коэфф по услуге, по счетчику (сумма всех коэфф по люд€м) по вр.зарег, вр.отсут
    if l_days_wrz+l_days_wrz_sch=l_max_days and l_days_wrz <> 0 and l_days_wrz_sch <> 0 then
    --если необходимо округлить (в случае кол-ва дней по сч и по норме = макс дней мес.)
      l_kf_usl_wrz_sch:=l_kf_usl_wrz_sch+(1-round(l_days_wrz/l_max_days,4)); --здесь округл до 4
    else
      l_kf_usl_wrz_sch:=l_kf_usl_wrz_sch+round(l_days_wrz_sch/l_max_days,4); --здесь округл до 4
    end if;

    --коэфф по услуге, по счетчику (сумма всех коэфф по люд€м) по вр.зарег, вр.отсут
    if l_days_wro+l_days_wro_sch=l_max_days and l_days_wro <> 0 and l_days_wro_sch <> 0 then
    --если необходимо округлить (в случае кол-ва дней по сч и по норме = макс дней мес.)
      l_kf_usl_wro_sch:=l_kf_usl_wro_sch+(1-round(l_days_wro/l_max_days,4)); --здесь округл до 4
    else
      l_kf_usl_wro_sch:=l_kf_usl_wro_sch+round(l_days_wro_sch/l_max_days,4); --здесь округл до 4
    end if;

    --кол-во прожив. дл€ соц.нормы, дл€ расценки
    if l_var_nrm=0 and (l_days <> 0 or l_days_sch <> 0) then
      --“—∆, полыс
      l_nrm_kpr:=l_nrm_kpr+1;
      l_nrm_kpr2:=l_nrm_kpr2+1;
    elsif l_var_nrm=1 then
      -- ис.
      if c2.status = 4 and --если выписан до 15 включительно то не считать

       nvl(c2.dat_ub, to_date('19000101', 'YYYYMMDD')) <= --если нет даты выписки, то как будто бы выписан давно (в 1900 году)))
       to_date((l_mg || '15'), 'YYYYMMDD') then
       null;
      elsif c2.status IN (1, 5) AND --если прописан после 15 невключительно то не считать
       nvl(c2.dat_prop, to_date('19000101', 'YYYYMMDD')) > --если нет даты прописки, то как будто бы прописан давно (в 1900 году)))
       to_date((l_mg || '15'), 'YYYYMMDD') then
       null;
      elsif c.usl_type2 = 0 and c2.status IN (3) then --временно зарег
       --дл€ коммунальной услуги
       l_nrm_kpr:=l_nrm_kpr+1;
       --l_nrm_kpr2:=l_nrm_kpr2+1;
      elsif c.usl_type2 = 0 and c2.status IN (6) then --временно прожив
       --дл€ коммунальной услуги
       null;
      elsif c.usl_type2 = 0 and c2.status IN (2) then --временно отсут
       --дл€ коммунальной услуги
       l_nrm_kpr2:=l_nrm_kpr2+1;--дл€ расценки - считаем...
      elsif c.usl_type2 = 1 and c2.status IN (6) then --временно прожив
       --дл€ жилищной услуги
       null;
      elsif c.usl_type2 = 1 and c2.status IN (3) then --временно зарег
       --дл€ жилищной услуги
       null;
       --l_nrm_kpr2:=l_nrm_kpr2+1;--дл€ расценки - считаем...
      elsif c.usl_type2 = 1 and c2.status IN (2) then --временно отсут
       --дл€ жилищной услуги
       l_nrm_kpr:=l_nrm_kpr+1;
       l_nrm_kpr2:=l_nrm_kpr2+1;
      else
       --дл€ прочего
       l_nrm_kpr:=l_nrm_kpr+1;
       l_nrm_kpr2:=l_nrm_kpr2+1;
      end if;
     end if;

  end loop;

    --проставить по основным услугам, убрать у услуги свыше соц нормы
    update nabor n set n.nrm_kpr=decode(c.usl_norm,1,null,l_nrm_kpr),
                       n.nrm_kpr2=decode(c.usl_norm,1,null,l_nrm_kpr2),
                       n.kf_kpr=decode(c.usl_norm,1,null,round(l_kf_usl,4)),
                       n.kf_kpr_sch=decode(c.usl_norm,1,null,round(l_kf_usl_sch,4)),
                       n.kf_kpr_wrz=decode(c.usl_norm,1,null,round(l_kf_usl_wrz,4)),
                       n.kf_kpr_wrz_sch=decode(c.usl_norm,1,null,round(l_kf_usl_wrz_sch,4)),
                       n.kf_kpr_wro=decode(c.usl_norm,1,null,round(l_kf_usl_wro,4)),
                       n.kf_kpr_wro_sch=decode(c.usl_norm,1,null,round(l_kf_usl_wro_sch,4))
        where n.rowid=c.rw;
end loop;

end if;
end;*/



 /*   case when t.fk_status in (1,3,5,6\*статусы прописки - ѕ.ѕ. ¬.«.*\)
              and t.dt1 > l_hf_dt --больше середины мес€ца - 15 числа
           then l_dt_end+1 --прибавить тупо 1 день к последнему дню мес€ца
         when t.fk_status in (1,3,5,6\*статусы прописки - ѕ.ѕ. ¬.«.*\)
              and t.dt1 <= l_hf_dt --меньше середины мес€ца - 15 числа
           then l_dt_start --вз€ть начало мес€ца
         when t.fk_status in (1,3,5,6\*статусы прописки - ¬.«.*\) and t.dt1 is null
           then to_date('01011900','DDMMYYYY') --вз€ть, как будто давно прописан

         when t.fk_status in (2,4\*статусы выписки - ¬џЅ, ¬.ќ.*\)
              and t.dt1 <= l_hf_dt --меньше середины мес€ца - 15 числа
           then l_dt_start --вз€ть начало мес€ца
         when t.fk_status in (2,4\*статусы выписки - ¬џЅ, ¬.ќ.*\)
              and t.dt1 > l_hf_dt --больше середины мес€ца - 15 числа
           then l_dt_end+1 --прибавить тупо 1 день к последнему дню мес€ца
         when t.fk_status in (2,4\*статусы выписки - ¬џЅ, ¬.ќ.*\) and t.dt1 is null
           then to_date('01011900','DDMMYYYY') --вз€ть, как будто давно выписан
         end
     as dt1,

    case when t.fk_status in (1,3,5,6\*статусы прописки - ѕ.ѕ. ¬.«.*\)
              and t.dt2 > l_hf_dt --больше середины мес€ца - 15 числа
           then l_dt_end+1 --прибавить тупо 1 день к последнему дню мес€ца
         when t.fk_status in (1,3,5,6\*статусы прописки - ѕ.ѕ. ¬.«.*\)
              and t.dt2 <= l_hf_dt --меньше середины мес€ца - 15 числа
           then l_dt_start --вз€ть начало мес€ца
         when t.fk_status in (1,3,5,6\*статусы прописки - ¬.«.*\) and t.dt1 is null
           then to_date('01011900','DDMMYYYY') --вз€ть, как будто давно прописан

         when t.fk_status in (2,4\*статусы выписки - ¬џЅ, ¬.ќ.*\)
              and t.dt2 <= l_hf_dt --меньше середины мес€ца - 15 числа
           then l_dt_start --вз€ть начало мес€ца
         when t.fk_status in (2,4\*статусы выписки - ¬џЅ, ¬.ќ.*\)
              and t.dt2 > l_hf_dt --больше середины мес€ца - 15 числа
           then l_dt_end+1 --прибавить тупо 1 день к последнему дню мес€ца
         when t.fk_status in (2,4\*статусы выписки - ¬џЅ, ¬.ќ.*\) and t.dt1 is null
           then to_date('01011900','DDMMYYYY') --вз€ть, как будто давно выписан
         end
     as dt2
*/

end C_KART;
/

prompt
prompt Creating package body C_LOAD_PRIVS
prompt ==================================
prompt
CREATE OR REPLACE PACKAGE BODY SCOTT.c_load_privs IS
--ѕакет посвещен загрузке и обработке реестров льготников

--очистить подготовительные справочники
procedure clear_spr is
begin
  delete from prep_street;
  delete from prep_house;
end clear_spr;

--очистить подготовительные таблицы
procedure clear_tabs is
begin
  delete from load_privs;
  delete from prep_file;
end clear_tabs;

--добавить строку с наименованием файла, обновить залитые строки
procedure add_file(p_name in prep_file.name%type) is
 l_id number;
begin
  insert into prep_file(name)
   values(p_name)
   returning id into l_id;
  update load_privs t set t.fk_file=l_id where t.fk_file is null;
end;

--подоговить таблицу соответствий улиц
procedure prep_street is
begin
  insert into prep_street
    (ext_nylic)
  select distinct t.nylic from load_privs t
   where not exists 
    (select * from prep_street r where t.nylic=r.ext_nylic);
end prep_street;

--подоговить таблицу соответствий домов 
procedure prep_house is
begin
--загрузить только новые дома
insert into prep_house
  (ext_ndom, ext_nkorp, ext_nylic)
select distinct t.ndom, t.nkorp, t.nylic
   from prep_street r join
   load_privs t on r.ext_nylic=t.nylic
   where not exists (select * from prep_house p where p.ext_nylic=r.ext_nylic
                     and p.ext_ndom=t.ndom and nvl(p.ext_nkorp,'XXXXX')=nvl(t.nkorp,'XXXXX'))
   and r.kul is not null;

--попытатьс€ проставить в домах без буквы корректный номер дома
--в домах с буквой - пользователь сам проставит
update prep_house t
 set t.nd=(select max(k.nd) from kart k, prep_street s
    where k.kul=s.kul and s.ext_nylic=t.ext_nylic and k.nd=lpad(t.ext_ndom,6,'0')
    and k.psch not in (8,9))
 where t.nd is null
       and t.ext_nkorp is null
 and exists
 (select k.* from kart k, prep_street s
    where k.kul=s.kul and s.ext_nylic=t.ext_nylic and k.nd=lpad(t.ext_ndom,6,'0')
    and k.psch not in (8,9));

end;

--подготовка таблицы к выгрузке
procedure prep_output(p_mg in params.period%type, p_file in number, p_cnt out number) is
 l_mg params.period%type;
 l_cnt number;
begin
/*  select '201509' into l_mg from params p;*/
  l_mg:=p_mg;
  delete from load_privs t where t.tp=1 and t.fk_file=p_file;
  --подсчитать кол-во записей - источников
  select nvl(count(*),0) into l_cnt from load_privs t where nvl(t.tp,0)=0 and t.fk_file=p_file;
  
  insert into load_privs
    (fk_src, org1, datn, posel, nasp, nylic, ndom, nkorp, nkw, nkomn, lchet, famil,
     imja, otch, drog, id_pku, pku, gku1, lchet1, ed_izm1, fakt1, sum_f1, prz1,
     gku2, lchet2, ed_izm2, fakt2, sum_f2, norm2, fakt21, sum_f21, o_pl2, prz2,
     gku3, lchet3, ed_izm3, fakt3, sum_f3, norm3, pr3_1, pr3_2, pr3_3, o_pl3,
     prz3, gku4, lchet4, ed_izm4, fakt4, sum_f4, norm4, prz4, gku5, lchet5,
     ed_izm5, fakt5, sum_f5, norm5, fakt51, sum_f51, o_pl5, prz5, gku6, lchet6,
     ed_izm6, fakt6, sum_f6, norm6, prz6, gku7, lchet7, ed_izm7, fakt7, sum_f7,
     norm7, fakt71, sum_f71, o_pl7, prz7, gku8, lchet8, ed_izm8, fakt8, sum_f8,
     norm8, prz8, gku9, lchet9, ed_izm9, fakt9, sum_f9, norm9, fakt91, tf_n,
     tf_sv, o_pl9, prz9, gku10, lchet10, ed_izm10, fakt10, sum_f10, prz10, tp, fk_file)
  select m.id, m.org1, m.datn, m.posel, m.nasp, m.nylic, m.ndom, m.nkorp, m.nkw, m.nkomn, 
      s.lsk as lchet, m.famil, m.imja, m.otch, m.drog, m.id_pku, m.pku,
       /*'Ёлектроэнерги€' as gku1,
       s.lsk as lchet1,
       'квт.' as edizm1,*/
       m.gku1, m.lchet1, m.ed_izm1,
       e5.test_opl as fakt1,
       e5.summa_itg as sum_f1,
       case when nvl(e5.test_opl,0)<>0 then 1 else null end as prz1,

       /*'Ёлектроэнерги€ на ќƒЌ' as gku2,
       s.lsk as lchet2,
       'квт.' as ed_izm2,*/
       m.gku2, m.lchet2, m.ed_izm2,
       nvl(e6.test_opl,0) as fakt2,
       e6.summa_itg as sum_f2,
       e6.nrm as norm2,
       case when nvl(s.opl,0)<>0 then
                 e6.test_opl/s.opl
                 else 0 end as fakt21,
       case when nvl(s.opl,0)<>0 then
                 e6.summa_itg/s.opl
                 else null end as sum_f21,
       s.opl as o_pl2,
       case when nvl(e6.test_opl,0)<>0 then 1 else null end as prz2,

       m.gku3,
       m.lchet3,
       m.ed_izm3,
       0 as fakt3,
       null as sum_f3,
       null as norm3,
       null as pr3_1,
       null as pr3_2,
       null as pr3_3,
       null as o_pl3,
       null as prz3,

/*       '’¬—' as gku4,
       s.lsk as lchet4,
       'м3' as edizm4,*/
       m.gku4, m.lchet4, m.ed_izm4,

       nvl(e7.test_opl,0) as fakt4,
       e7.summa_itg as sum_f4,
       e7.norm as norm4,
       case when nvl(e7.test_opl,0)<>0 then 1 else null end as prz4,

/*       '’олодна€ вода, ќƒЌ' as gku5,
       s.lsk as lchet5,
       'м3' as ed_izm5,*/
       m.gku5,m.lchet5, m.ed_izm5,
       
       nvl(e8.test_opl,0) as fakt5,
       e8.summa_itg as sum_f5,
       e8.nrm as norm5,
       case when nvl(s.opl,0)<>0 then
                 e8.test_opl/s.opl
                 else 0 end as fakt51,
       case when nvl(s.opl,0)<>0 then
                 e8.summa_itg/s.opl
                 else null end as sum_f51,
       s.opl as o_pl5,
       case when nvl(e8.test_opl,0)<>0 then 1 else null end as prz5,
       
/*       '√ор€ча€ вода' as gku6,
       s.lsk as lchet6,
       'м3' as edizm6,*/
       m.gku6, m.lchet6, m.ed_izm6,
       
       nvl(e9.test_opl,0) as fakt6,
       e9.summa_itg as sum_f6,
       e9.norm as norm6,
       case when nvl(e9.test_opl,0)<>0 then 1 else null end as prz6,

/*       '√ор€ча€ вода, ќƒЌ' as gku7,
       s.lsk as lchet7,
       'м3' as edizm7,*/
       m.gku7, m.lchet7, m.ed_izm7,
       
       nvl(e10.test_opl,0) as fakt7,
       e10.summa_itg as sum_f7,
       e10.nrm as norm7,
       case when nvl(s.opl,0)<>0 then
                 e10.test_opl/s.opl
                 else 0 end as fakt71,
       case when nvl(s.opl,0)<>0 then
                 e10.summa_itg/s.opl
                 else null end as sum_f71,
       s.opl as o_pl7,
       case when nvl(e10.test_opl,0)<>0 then 1 else null end as prz7,
       
/*       ' анализаци€' as gku8,
       s.lsk as lchet8,
       'м3' as edizm8,*/
       m.gku8, m.lchet8, m.ed_izm8,
       
       nvl(e11.test_opl,0) as fakt8,
       e11.summa_itg as sum_f8,
       e11.norm as norm8,
       case when nvl(e11.test_opl,0)<>0 then 1 else null end as prz8,
       
/*       'ќтопление' as gku9,
       s.lsk as lchet9,
       'м2' as edizm9,*/
       m.gku9, m.lchet9, m.ed_izm9,
       
       nvl(e12.test_opl,0) as fakt9,
       e12.summa_itg as sum_f9,
       e12.norm as norm9,
       case when nvl(s.opl,0)<>0 then
                 e12.test_opl/s.opl
                 else 0 end as fakt91,
       c12.tf1 as tf_n,
       c12.tf2 as tf_sv,
       s.opl as o_pl9,
       case when nvl(e12.test_opl,0)<>0 then 1 else null end as prz9,
                           
/*       '√аз в баллонах' as gku10,
       null as lchet10,
       null as edizm10,*/
       m.gku10, m.lchet10, m.ed_izm10,
       
       0 as fakt10,
       null as sum_f10,
       null as prz10,
       1 as tp,
       p_file as fk_file
      from 
      v_load_privs m left join 
      (select s.* from arch_kart s, s_reu_trest e where s.mg=l_mg
       /*and e.reu='01'
       and s.lsk='00000001'*/
       and s.reu=e.reu
       and s.psch not in (8,9) --только открытые
       and s.status not in (7)--убрал нежилые
       ) s on s.lsk=m.lsk
           left join t_org c on s.reu=c.reu
           left join t_org_tp tp on tp.cd='√ород'
           left join t_org c2 on c2.fk_orgtp=tp.id
           left join spul l on s.kul=l.id
           left join 
      (select s.lsk, 
       sum(s.summa) as summa_itg
         from a_charge s, usl u 
          where s.mg=l_mg and s.usl=u.usl and
         u.cd in ('т/сод', 'т/сод/св.нор', 'лифт', 'лифт/св.нор', 'дерат.', 'дерат/св.нор', 'мус.площ.', 'мус.площ./св.нор',
         'выв.мус.', 'выв.мус./св.нор')
         and s.type=1 --текущее содержание, вместе с под-услугами
       group by s.lsk) e2 on s.lsk = e2.lsk
           left join 
      (select s.lsk,
       sum(s.summa) as summa_itg
         from a_charge s, usl u where s.mg=l_mg and s.usl=u.usl and
        u.cd in ('кап.', 'кап/св.нор') and s.type=1 --капремонт
       group by s.lsk) e3 on s.lsk = e3.lsk
           left join 
      (select s.lsk,
       sum(s.summa) as summa_itg
         from a_charge s, usl u where s.mg=l_mg and s.usl=u.usl and
        u.cd in ('найм') and s.type=1 --найм
       group by s.lsk) e4 on s.lsk = e4.lsk
           left join 
      (select s.lsk,
       sum(s.test_opl) as test_opl,
       sum(s.summa) as summa_itg
         from a_charge s, usl u where s.mg=l_mg and s.usl=u.usl and
        u.cd in ('эл.энерг.2','эл.эн.2/св.нор') and s.type=1 --эл.энерг
       group by s.lsk) e5 on s.lsk = e5.lsk
           left join 
      (select s.lsk,
       sum(s.test_opl) as test_opl,
       sum(s.summa) as summa_itg,
       max(d.nrm) as nrm
         from a_charge s
         join a_nabor n on s.lsk=n.lsk and s.mg=n.mg and 
         s.mg=l_mg
         join a_vvod d on n.fk_vvod=d.id and n.usl=d.usl
         and n.mg=d.mg
         join usl u2 on n.usl=u2.usl and u2.cd in ('эл.энерг.2', 'эл.эн.ќƒЌ', 'эл.эн.ћќѕ2') --јƒ
         join usl u on s.usl=u.usl and u.cd in ('эл.эн.ќƒЌ', 'эл.эн.ћќѕ2') and s.type=1 --эл.энерг
       group by s.lsk) e6 on s.lsk = e6.lsk
           left join 
      (select s.lsk,
       sum(s.test_opl) as test_opl,
       sum(s.summa) as summa_itg,
       max(n.norm) as norm
         from a_charge s, a_nabor n, usl u where 
         s.mg=l_mg and s.usl=u.usl and s.lsk=n.lsk and s.mg=n.mg
         and s.usl=n.usl and
         u.cd in ('х.вода', 'х.вода/св.нор') and s.type=1
       group by s.lsk) e7 on s.lsk = e7.lsk
           left join 
      (select s.lsk,
       sum(s.test_opl) as test_opl,
       sum(s.summa) as summa_itg,
       max(d.nrm) as nrm
         from a_charge s
         join a_nabor n on s.lsk=n.lsk and s.mg=n.mg and 
         s.mg=l_mg
         join a_vvod d on n.fk_vvod=d.id and n.usl=d.usl
         and n.mg=d.mg
         join usl u2 on n.usl=u2.usl and u2.cd in ('х.вода')
         join usl u on s.usl=u.usl and u.cd in ('х.вода.ќƒЌ') and s.type=1
       group by s.lsk) e8 on s.lsk = e8.lsk
           left join 
      (select s.lsk,
       sum(s.test_opl) as test_opl,
       sum(s.summa) as summa_itg,
       max(n.norm) as norm
         from a_charge s, a_nabor n, usl u where 
         s.mg=l_mg and s.usl=u.usl and s.lsk=n.lsk and s.mg=n.mg
         and s.usl=n.usl and
         u.cd in ('г.вода', 'г.вода/св.нор') and s.type=1
       group by s.lsk) e9 on s.lsk = e9.lsk
           left join 
      (select s.lsk,
       sum(s.test_opl) as test_opl,
       sum(s.summa) as summa_itg,
       max(d.nrm) as nrm
         from a_charge s
         join a_nabor n on s.lsk=n.lsk and s.mg=n.mg and 
         s.mg=l_mg
         join a_vvod d on n.fk_vvod=d.id and n.usl=d.usl
         and n.mg=d.mg
         join usl u2 on n.usl=u2.usl and u2.cd in ('г.вода')
         join usl u on s.usl=u.usl and u.cd in ('г.вода.ќƒЌ') and s.type=1 --эл.энерг
       group by s.lsk) e10 on s.lsk = e10.lsk
           left join 
      (select s.lsk,
       sum(s.test_opl) as test_opl,
       sum(s.summa) as summa_itg,
       max(n.norm) as norm
         from a_charge s, a_nabor n, usl u where 
         s.mg=l_mg and s.usl=u.usl and s.lsk=n.lsk and s.mg=n.mg
         and s.usl=n.usl and
         u.cd in ('канализ', 'канализ/св.нор') and s.type=1
       group by s.lsk) e11 on s.lsk = e11.lsk
           left join 
      (select s.lsk,
       sum(s.test_opl) as test_opl,
       sum(s.summa) as summa_itg,
       max(n.norm) as norm
         from a_charge s, a_nabor n, usl u where 
         s.mg=l_mg and s.usl=u.usl and s.lsk=n.lsk and s.mg=n.mg 
         and s.usl=n.usl and
         u.cd in ('отоп', 'отоп/св.нор', 'отоп.гкал.') and s.type=1 --возьмутс€ услуги у кого какие, провер€ть!
       group by s.lsk) e12 on s.lsk = e12.lsk

       left join
       (select n.lsk, round(sum(case when u.usl_norm = 0 then 
          case when n.koeff is not null and u.sptarn in (0,2,3) then n.koeff else 1 end * r.summa else 0 end),2) as tf1,
               round(sum(case when u.usl_norm = 1 then 
          case when n.koeff is not null and u.sptarn in (0,2,3) then n.koeff else 1 end * r.summa else 0 end),2) as tf2
         from 
           a_nabor n join usl u on n.usl=u.usl 
           join a_prices r on n.usl=r.usl and n.mg=r.mg
        where n.mg=l_mg 
        and u.cd in ('т/сод', 'т/сод/св.нор', 'лифт', 'лифт/св.нор', 'дерат.', 'дерат/св.нор', 'мус.площ.', 'мус.площ./св.нор',
               'выв.мус.', 'выв.мус./св.нор')
        group by n.lsk       
         ) c1
         on s.lsk=c1.lsk
       left join
       (select n.lsk, round(sum(case when u.usl_norm = 0 then 
          case when n.koeff is not null and u.sptarn in (0,2,3) then n.koeff else 1 end * r.summa else 0 end),2) as tf1,
               round(sum(case when u.usl_norm = 1 then 
          case when n.koeff is not null and u.sptarn in (0,2,3) then n.koeff else 1 end * r.summa else 0 end),2) as tf2
         from 
           a_nabor n join usl u on n.usl=u.usl 
           join a_prices r on n.usl=r.usl and n.mg=r.mg
        where n.mg=l_mg 
        and u.cd in ('кап.', 'кап/св.нор')
        group by n.lsk       
         ) c2
         on s.lsk=c2.lsk
         
         
       left join
       (select n.lsk, round(sum(case when u.usl_norm = 0 then 
          case when n.koeff is not null and u.sptarn in (0,2,3) then n.koeff else 1 end * r.summa else 0 end),2) as tf1,
               round(sum(case when u.usl_norm = 1 then 
          case when n.koeff is not null and u.sptarn in (0,2,3) then n.koeff else 1 end * r.summa else 0 end),2) as tf2
         from 
           a_nabor n join usl u on n.usl=u.usl 
           join a_prices r on n.usl=r.usl and n.mg=r.mg
        where n.mg=l_mg 
        and u.cd in ('найм')
        group by n.lsk       
         ) c4
         on s.lsk=c4.lsk
       left join
       (select n.lsk, round(sum(case when u.usl_norm = 0 then 
          case when n.koeff is not null and u.sptarn in (0,2,3) then n.koeff else 1 end * r.summa else 0 end),2) as tf1,
               round(sum(case when u.usl_norm = 1 then 
          case when n.koeff is not null and u.sptarn in (0,2,3) then n.koeff else 1 end * r.summa else 0 end),2) as tf2
         from 
           a_nabor n join usl u on n.usl=u.usl 
           join a_prices r on n.usl=r.usl and n.mg=r.mg
        where n.mg=l_mg 
        and u.cd in ('эл.энерг.2','эл.эн.2/св.нор')
        group by n.lsk       
         ) c5
         on s.lsk=c5.lsk
         
       left join
       (select n.lsk, round(sum(case when u.usl_norm = 0 then 
          case when n.koeff is not null and u.sptarn in (0,2,3) then n.koeff else 1 end * r.summa else 0 end),2) as tf1,
               round(sum(case when u.usl_norm = 1 then 
          case when n.koeff is not null and u.sptarn in (0,2,3) then n.koeff else 1 end * r.summa else 0 end),2) as tf2
         from 
           a_nabor n join usl u on n.usl=u.usl 
           join a_prices r on n.usl=r.usl and n.mg=r.mg
        where n.mg=l_mg 
        and u.cd in ('эл.эн.ќƒЌ')
        group by n.lsk       
         ) c6
         on s.lsk=c6.lsk
         
       left join
       (select n.lsk, round(sum(case when u.usl_norm = 0 then 
          case when n.koeff is not null and u.sptarn in (0,2,3) then n.koeff else 1 end * r.summa else 0 end),2) as tf1,
               round(sum(case when u.usl_norm = 1 then 
          case when n.koeff is not null and u.sptarn in (0,2,3) then n.koeff else 1 end * r.summa else 0 end),2) as tf2
         from 
           a_nabor n join usl u on n.usl=u.usl 
           join a_prices r on n.usl=r.usl and n.mg=r.mg
        where n.mg=l_mg 
        and u.cd in ('х.вода', 'х.вода/св.нор')
        group by n.lsk       
         ) c7
         on s.lsk=c7.lsk       
         
       left join
       (select n.lsk, round(sum(case when u.usl_norm = 0 then 
          case when n.koeff is not null and u.sptarn in (0,2,3) then n.koeff else 1 end * r.summa else 0 end),2) as tf1,
               round(sum(case when u.usl_norm = 1 then 
          case when n.koeff is not null and u.sptarn in (0,2,3) then n.koeff else 1 end * r.summa else 0 end),2) as tf2
         from 
           a_nabor n join usl u on n.usl=u.usl 
           join a_prices r on n.usl=r.usl and n.mg=r.mg
        where n.mg=l_mg 
        and u.cd in ('х.вода.ќƒЌ')
        group by n.lsk       
         ) c8
         on s.lsk=c8.lsk       

       left join
       (select n.lsk, round(sum(case when u.usl_norm = 0 then 
          case when n.koeff is not null and u.sptarn in (0,2,3) then n.koeff else 1 end * r.summa else 0 end),2) as tf1,
               round(sum(case when u.usl_norm = 1 then 
          case when n.koeff is not null and u.sptarn in (0,2,3) then n.koeff else 1 end * r.summa else 0 end),2) as tf2
         from 
           a_nabor n join usl u on n.usl=u.usl 
           join a_prices r on n.usl=r.usl and n.mg=r.mg
        where n.mg=l_mg 
        and u.cd in ('г.вода', 'г.вода/св.нор')
        group by n.lsk       
         ) c9
         on s.lsk=c9.lsk       

       left join
       (select n.lsk, round(sum(case when u.usl_norm = 0 then 
          case when n.koeff is not null and u.sptarn in (0,2,3) then n.koeff else 1 end * r.summa else 0 end),2) as tf1,
               round(sum(case when u.usl_norm = 1 then 
          case when n.koeff is not null and u.sptarn in (0,2,3) then n.koeff else 1 end * r.summa else 0 end),2) as tf2
         from 
           a_nabor n join usl u on n.usl=u.usl 
           join a_prices r on n.usl=r.usl and n.mg=r.mg
        where n.mg=l_mg 
        and u.cd in ('г.вода.ќƒЌ')
        group by n.lsk       
         ) c10
         on s.lsk=c10.lsk       

       left join
       (select n.lsk, round(sum(case when u.usl_norm = 0 then 
          case when n.koeff is not null and u.sptarn in (0,2,3) then n.koeff else 1 end * r.summa else 0 end),2) as tf1,
               round(sum(case when u.usl_norm = 1 then 
          case when n.koeff is not null and u.sptarn in (0,2,3) then n.koeff else 1 end * r.summa else 0 end),2) as tf2
         from 
           a_nabor n join usl u on n.usl=u.usl 
           join a_prices r on n.usl=r.usl and n.mg=r.mg
        where n.mg=l_mg 
        and u.cd in ('канализ', 'канализ/св.нор')
        group by n.lsk       
         ) c11
         on s.lsk=c11.lsk       

       left join
       (select n.lsk, round(sum(case when u.usl_norm = 0 then 
          case when n.koeff is not null and u.sptarn in (0,2,3) then n.koeff else 1 end * r.summa else 0 end),2) as tf1,
               round(sum(case when u.usl_norm = 1 then 
          case when n.koeff is not null and u.sptarn in (0,2,3) then n.koeff else 1 end * r.summa else 0 end),2) as tf2
         from 
           a_nabor n join usl u on n.usl=u.usl 
           join a_prices r on n.usl=r.usl and n.mg=r.mg
        where n.mg=l_mg 
        and u.cd in ('отоп', 'отоп/св.нор')
        group by n.lsk       
         ) c12
         on s.lsk=c12.lsk    
      where m.fk_file=p_file

      order by l.name, s.nd, s.kw;

  --подсчитать кол-во записей - после выгрузки
  select l_cnt-nvl(count(*),0) into l_cnt
    from load_privs t where nvl(t.tp,0)=1 and t.fk_file=p_file;
  if l_cnt > 0 then  
    --кол-во записей в выгрузке меньше чем в источнике!
    p_cnt:=1;
  elsif l_cnt < 0 then  
    --кол-во записей в выгрузке больше чем в источнике!
    p_cnt:=2;
  else
    --кол-во записей совпало
    p_cnt:=0;
  end if;
    

end;


--рефкурсор дл€ выгрузки
procedure rep(p_file in number, prep_refcursor in out rep_refcursor) is
begin
  open prep_refcursor for
    select org1, datn, posel, nasp, nylic, ndom, nkorp, nkw, nkomn, lchet,
           famil, imja, otch, drog, id_pku, pku, gku1, lchet1, ed_izm1,
           fakt1, sum_f1, prz1, gku2, lchet2, ed_izm2, fakt2, sum_f2, norm2,
           fakt21, sum_f21, o_pl2, prz2, gku3, lchet3, ed_izm3, fakt3,
           sum_f3, norm3, pr3_1, pr3_2, pr3_3, o_pl3, prz3, gku4, lchet4,
           ed_izm4, fakt4, sum_f4, norm4, prz4, gku5, lchet5, ed_izm5, fakt5,
           sum_f5, norm5, fakt51, sum_f51, o_pl5, prz5, gku6, lchet6,
           ed_izm6, fakt6, sum_f6, norm6, prz6, gku7, lchet7, ed_izm7, fakt7,
           sum_f7, norm7, fakt71, sum_f71, o_pl7, prz7, gku8, lchet8,
           ed_izm8, fakt8, sum_f8, norm8, prz8, gku9, lchet9, ed_izm9, fakt9,
           sum_f9, norm9, fakt91, tf_n, tf_sv, o_pl9, prz9, gku10, lchet10,
           ed_izm10, fakt10, sum_f10, prz10
      from load_privs t
     where t.fk_file = p_file and t.tp=1;

end;
END c_load_privs;
/

prompt
prompt Creating package body C_OBJ_PAR
prompt ===============================
prompt
create or replace package body scott.c_obj_par is

 function get_num_param(p_k_lsk_id in k_lsk.id%type, p_lsk in kart.lsk%type,
   p_cd in u_list.cd%type) return t_objxpar.n1%type is
 begin
  return c_obj_par.get_num_param(p_k_lsk_id => p_k_lsk_id,
                                     p_lsk => p_lsk,
                                     p_cd => p_cd,
                                     p_cdtp => 'ѕараметры лиц.счета');
 end;

 function get_num_param(p_k_lsk_id in k_lsk.id%type, p_lsk in kart.lsk%type,
   p_cd in u_list.cd%type,
   p_cdtp in u_listtp.cd%type) return t_objxpar.n1%type is
 l_val_tp u_list.val_tp%type;
 l_result t_objxpar.n1%type;
 l_id_tp u_listtp.id%type;
 begin
   --возращает значение параметра Number либо по k_lsk.id либо по kart.lsk
   select t.id into l_id_tp from u_listtp t where t.cd=p_cdtp;
   begin
   if p_k_lsk_id is not null then
     select max(x.n1), s.val_tp into l_result, l_val_tp
            from t_objxpar x, u_list s where upper(s.cd)=upper(p_cd)
            and x.fk_k_lsk=p_k_lsk_id and s.fk_listtp=l_id_tp
            and x.fk_list=s.id
            group by s.val_tp;
   elsif p_lsk is not null then
     select max(x.n1), s.val_tp into l_result, l_val_tp
            from t_objxpar x, u_list s where upper(s.cd)=upper(p_cd)
            and x.fk_lsk=p_lsk and s.fk_listtp=l_id_tp
            and x.fk_list=s.id
            group by s.val_tp;
   else
     Raise_application_error(-20000, '—топ! ќдин из двух об€зательных параметров p_lsk или p_k_lsk_id - не используетс€!');
   end if;

   if l_val_tp <> 'NM' then
      raise_application_error(-20001,
                              'ѕараметр - '||p_cd||' не €вл€етс€ NUMBER типом!');
   end if;
    exception
    when NO_DATA_FOUND then
      return null;
--      raise_application_error(-20001,
--                              'ѕараметр - '||p_cd||' не зарегистрирован!');
   end;
   return l_result;
 end;

 function get_str_param(p_k_lsk_id in k_lsk.id%type, p_lsk in kart.lsk%type,
   p_cd in u_list.cd%type) return t_objxpar.s1%type is
 begin
   return c_obj_par.get_str_param(p_k_lsk_id => p_k_lsk_id,
                                 p_lsk => p_lsk,
                                 p_cd => p_cd,
                                 p_cdtp => 'ѕараметры лиц.счета');
 end;

 function get_str_param(p_k_lsk_id in k_lsk.id%type, p_lsk in kart.lsk%type,
   p_cd in u_list.cd%type,
   p_cdtp in u_listtp.cd%type) return t_objxpar.s1%type is
 l_val_tp u_list.val_tp%type;
 l_result t_objxpar.s1%type;
 l_id_tp u_listtp.id%type;
 begin
   --возращает значение параметра Number либо по k_lsk.id либо по kart.lsk
   select t.id into l_id_tp from u_listtp t where t.cd=p_cdtp;
   begin
   if p_k_lsk_id is not null then
     select max(x.s1), s.val_tp into l_result, l_val_tp
            from t_objxpar x, u_list s where upper(s.cd)=upper(p_cd)
            and x.fk_k_lsk=p_k_lsk_id and s.fk_listtp=l_id_tp
            and x.fk_list=s.id
            group by s.val_tp;
   elsif p_lsk is not null then
     select max(x.s1), s.val_tp into l_result, l_val_tp
            from t_objxpar x, u_list s where upper(s.cd)=upper(p_cd)
            and x.fk_lsk=p_lsk and s.fk_listtp=l_id_tp
            and x.fk_list=s.id
            group by s.val_tp;
   else
     Raise_application_error(-20000, '—топ! ќдин из двух об€зательных параметров p_lsk или p_k_lsk_id - не используетс€!');
   end if;

   if l_val_tp <> 'ST' then
      raise_application_error(-20001,
                              'ѕараметр - '||p_cd||' не €вл€етс€ VARCHAR2 типом!');
   end if;
    exception
    when NO_DATA_FOUND then
      return null;
--      raise_application_error(-20001,
--                              'ѕараметр - '||p_cd||' не зарегистрирован!');
   end;
   return l_result;
 end;

 function set_num_param(p_k_lsk_id in k_lsk.id%type, p_lsk in kart.lsk%type,
   p_cd in varchar2, p_val in t_objxpar.n1%type) return t_objxpar.id%type is
 l_val_tp u_list.val_tp%type;
 l_id_tp u_listtp.id%type;
 l_id_list u_list.id%type;
 l_t_objxpar_id t_objxpar.id%type;
 l_cnt number;
 begin
   --вернуть id параметра
   return c_obj_par.set_num_param(p_k_lsk_id => p_k_lsk_id,
                                     p_lsk => p_lsk,
                                     p_cd => p_cd,
                                     p_val => p_val,
                                     p_cdtp => 'ѕараметры лиц.счета');

 end;

 function set_num_param(p_k_lsk_id in k_lsk.id%type, p_lsk in kart.lsk%type,
   p_cd in varchar2, p_val in t_objxpar.n1%type, p_cdtp in u_listtp.cd%type) return t_objxpar.id%type is
 l_val_tp u_list.val_tp%type;
 l_id_tp u_listtp.id%type;
 l_id_list u_list.id%type;
 l_t_objxpar_id t_objxpar.id%type;
 l_cnt number;
 begin
   --задает (создает в случае отсутстви€) значение параметра Number либо по k_lsk.id либо по kart.lsk
   if p_k_lsk_id is not null and p_lsk is not null then
     Raise_application_error(-20000, 'ѕопытка использовать LSK и K_LSK_ID одовременно при установке параметра!');
   end if;
   begin
   select t.id into l_id_tp from u_listtp t where t.cd=p_cdtp;
     select s.id, s.val_tp into l_id_list, l_val_tp
            from u_list s where upper(s.cd)=upper(p_cd)
              and s.fk_listtp=l_id_tp;
   if l_val_tp <> 'NM' then
      raise_application_error(-20001,
                              'ѕараметр - '||p_cd||' не €вл€етс€ NUMBER типом!');
   end if;
    exception
    when NO_DATA_FOUND then
      raise_application_error(-20001,
                              'ѕараметр - '||p_cd||' не зарегистрирован!');
   end;

   if p_k_lsk_id is not null then

     update t_objxpar x set x.n1=p_val, x.ts=sysdate
       where x.fk_list=l_id_list
       and x.fk_k_lsk=p_k_lsk_id
       and exists (--только те л/c, в которых инф. мен€етс€
             select *
                    from t_objxpar x2 where
                    x2.fk_k_lsk=x.fk_k_lsk
                    and x2.fk_list=x.fk_list
                    and x2.n1 <> p_val);

     if SQL%NOTFOUND then
       --возможно не найден параметр - создать
       select nvl(count(*),0) into l_cnt from
         t_objxpar x where x.fk_k_lsk=p_k_lsk_id
          and x.fk_list=l_id_list;
       if l_cnt = 0 then
         insert into t_objxpar
           (fk_lsk, fk_k_lsk, fk_list, n1)
           values (p_lsk, p_k_lsk_id, l_id_list, p_val)
           returning id into l_t_objxpar_id;
       end if;
     end if;

   elsif p_lsk is not null then
     update t_objxpar x set x.n1=p_val, x.ts=sysdate
       where x.fk_list=l_id_list
       and x.fk_lsk=p_lsk
       and exists (--только те л/c, в которых инф. мен€етс€
             select *
                    from t_objxpar x2 where
                    x2.fk_lsk=x.fk_lsk
                    and x2.fk_list=x.fk_list
                    and x2.n1 <> p_val);
     if SQL%NOTFOUND then
       --возможно не найден параметр - создать
       select nvl(count(*),0) into l_cnt from
         t_objxpar x where x.fk_lsk=p_lsk
          and x.fk_list=l_id_list;
       if l_cnt = 0 then
         insert into t_objxpar
           (fk_lsk, fk_k_lsk, fk_list, n1)
           values (p_lsk, p_k_lsk_id, l_id_list, p_val)
           returning id into l_t_objxpar_id;
       end if;
     end if;

   else
     Raise_application_error(-20000, '—топ! ќдин из двух об€зательных параметров p_lsk или p_k_lsk_id - не используетс€!');
   end if;

   --коммит не делаетс€
   --commit;
   --вернуть id параметра
   return l_t_objxpar_id;
 end;


 function set_str_param(p_k_lsk_id in k_lsk.id%type, p_lsk in kart.lsk%type,
   p_cd in varchar2, p_val in t_objxpar.s1%type) return t_objxpar.id%type is
begin
  return c_obj_par.set_str_param(p_k_lsk_id => p_k_lsk_id,
                                     p_lsk => p_lsk,
                                     p_cd => p_cd,
                                     p_val => p_val,
                                     p_cdtp =>'ѕараметры лиц.счета');
end;



 function set_str_param(p_k_lsk_id in k_lsk.id%type, p_lsk in kart.lsk%type,
   p_cd in varchar2, p_val in t_objxpar.s1%type, p_cdtp in u_listtp.cd%type)
   return t_objxpar.id%type is
 l_val_tp u_list.val_tp%type;
 l_id_tp u_listtp.id%type;
 l_id_list u_list.id%type;
 l_t_objxpar_id t_objxpar.id%type;
 l_cnt number;
 begin
   --задает (создает в случае отсутстви€) значение параметра Varchar2 либо по k_lsk.id либо по kart.lsk
   if p_k_lsk_id is not null and p_lsk is not null then
     Raise_application_error(-20000, 'ѕопытка использовать LSK и K_LSK_ID ондовременно при установке параметра!');
   end if;
   begin
   select t.id into l_id_tp from u_listtp t where t.cd=p_cdtp;
     select s.id, s.val_tp into l_id_list, l_val_tp
            from u_list s where upper(s.cd)=upper(p_cd)
              and s.fk_listtp=l_id_tp;
   if l_val_tp <> 'ST' then
      raise_application_error(-20001,
                              'ѕараметр - '||p_cd||' не €вл€етс€ VARCHAR2 типом!');
   end if;
    exception
    when NO_DATA_FOUND then
      raise_application_error(-20001,
                              'ѕараметр - '||p_cd||' не зарегистрирован!');
   end;
   if p_k_lsk_id is not null then
     update t_objxpar x set x.s1=p_val, x.ts=sysdate
       where x.fk_list=l_id_list
       and x.fk_k_lsk=p_k_lsk_id
       and exists (--только те л/c, в которых инф. мен€етс€
             select *
                    from t_objxpar x2 where
                    x2.fk_k_lsk=x.fk_k_lsk
                    and x2.fk_list=x.fk_list
                    and x2.s1 <> p_val);
     if SQL%NOTFOUND then
       --возможно не найден параметр - создать
       select nvl(count(*),0) into l_cnt from
         t_objxpar x where x.fk_k_lsk=p_k_lsk_id
          and x.fk_list=l_id_list;
       if l_cnt = 0 then
         insert into t_objxpar
           (fk_lsk, fk_k_lsk, fk_list, s1)
           values (p_lsk, p_k_lsk_id, l_id_list, p_val)
           returning id into l_t_objxpar_id;
       end if;
     end if;

   elsif p_lsk is not null then
     update t_objxpar x set x.s1=p_val, x.ts=sysdate
       where x.fk_list=l_id_list
       and x.fk_lsk=p_lsk
       and exists (--только те л/c, в которых инф. мен€етс€
             select *
                    from t_objxpar x2 where
                    x2.fk_lsk=x.fk_lsk
                    and x2.fk_list=x.fk_list
                    and x2.s1 <> p_val);
     if SQL%NOTFOUND then
       --возможно не найден параметр - создать
       select nvl(count(*),0) into l_cnt from
         t_objxpar x where x.fk_lsk=p_lsk
          and x.fk_list=l_id_list;
       if l_cnt = 0 then
         insert into t_objxpar
           (fk_lsk, fk_k_lsk, fk_list, s1)
           values (p_lsk, p_k_lsk_id, l_id_list, p_val)
           returning id into l_t_objxpar_id;
       end if;
     end if;
   else
     Raise_application_error(-20000, '—топ! ќдин из двух об€зательных параметров p_lsk или p_k_lsk_id - не используетс€!');
   end if;

   --коммит не делаетс€
   --commit;
   --вернуть id параметра
   return l_t_objxpar_id;
 end;

function set_date_param(p_k_lsk_id in k_lsk.id%type, p_lsk in kart.lsk%type,
   p_cd in varchar2, p_val in t_objxpar.d1%type, p_dflt in number)
   return t_objxpar.id%type is
begin
  return c_obj_par.set_date_param(p_k_lsk_id => p_k_lsk_id,
                                      p_lsk => p_lsk,
                                      p_cd => p_cd,
                                      p_val => p_val,
                                      p_dflt => p_dflt,
                                      p_cdtp => 'ѕараметры лиц.счета');

end;

function set_date_param(p_k_lsk_id in k_lsk.id%type, p_lsk in kart.lsk%type,
   p_cd in varchar2, p_val in t_objxpar.d1%type, p_dflt in number,
   p_cdtp in u_listtp.cd%type) return t_objxpar.id%type is
 l_val_tp u_list.val_tp%type;
 l_id_tp u_listtp.id%type;
 l_id_list u_list.id%type;
 l_t_objxpar_id t_objxpar.id%type;
 l_cnt number;
 l_val t_objxpar.d1%type;
 begin
   --задает (создает в случае отсутстви€) значение параметра Date либо по k_lsk.id либо по kart.lsk
   if p_dflt=1 then
     --в случае отсутстви€ параметра и при наличии флага установить по умлочанию
     if p_val is null then
       l_val:=sysdate;
     end if;
   else
     l_val:=p_val;
   end if;
   if p_k_lsk_id is not null and p_lsk is not null then
     Raise_application_error(-20000, 'ѕопытка использовать LSK и K_LSK_ID ондовременно при установке параметра!');
   end if;
   begin
   select t.id into l_id_tp from u_listtp t where t.cd=p_cdtp;
     select s.id, s.val_tp into l_id_list, l_val_tp
            from u_list s where upper(s.cd)=upper(p_cd)
              and s.fk_listtp=l_id_tp;
   if l_val_tp <> 'DT' then
      raise_application_error(-20001,
                              'ѕараметр - '||p_cd||' не €вл€етс€ DATE типом!');
   end if;
    exception
    when NO_DATA_FOUND then
      raise_application_error(-20001,
                              'ѕараметр - '||p_cd||' не зарегистрирован!');
   end;
   if p_k_lsk_id is not null then
     update t_objxpar x set x.d1=l_val, x.ts=sysdate
       where x.fk_list=l_id_list
       and x.fk_k_lsk=p_k_lsk_id
       and exists (--только те л/c, в которых инф. мен€етс€
             select *
                    from t_objxpar x2 where
                    x2.fk_k_lsk=x.fk_k_lsk
                    and x2.fk_list=x.fk_list
                    and x2.d1 <> l_val);
     if SQL%NOTFOUND then
       --возможно не найден параметр - создать
       select nvl(count(*),0) into l_cnt from
         t_objxpar x where x.fk_k_lsk=p_k_lsk_id
          and x.fk_list=l_id_list;
       if l_cnt = 0 then
         insert into t_objxpar
           (fk_lsk, fk_k_lsk, fk_list, d1)
           values (p_lsk, p_k_lsk_id, l_id_list, l_val)
           returning id into l_t_objxpar_id;
       end if;
     end if;

   elsif p_lsk is not null then
     update t_objxpar x set x.d1=l_val, x.ts=sysdate
       where x.fk_list=l_id_list
       and x.fk_lsk=p_lsk
       and exists (--только те л/c, в которых инф. мен€етс€
             select *
                    from t_objxpar x2 where
                    x2.fk_lsk=x.fk_lsk
                    and x2.fk_list=x.fk_list
                    and x2.d1 <> l_val);
     if SQL%NOTFOUND then
       --возможно не найден параметр - создать
       select nvl(count(*),0) into l_cnt from
         t_objxpar x where x.fk_lsk=p_lsk
          and x.fk_list=l_id_list;
       if l_cnt = 0 then
         insert into t_objxpar
           (fk_lsk, fk_k_lsk, fk_list, d1)
           values (p_lsk, p_k_lsk_id, l_id_list, l_val)
           returning id into l_t_objxpar_id;
       end if;
     end if;
   else
     Raise_application_error(-20000, '—топ! ќдин из двух об€зательных параметров p_lsk или p_k_lsk_id - не используетс€!');
   end if;

   --коммит не делаетс€
   --commit;
   --вернуть id параметра
   return l_t_objxpar_id;
 end;

 function set_md5_param(p_k_lsk_id in k_lsk.id%type, p_lsk in kart.lsk%type,
   p_cd in varchar2, p_val in varchar2) return t_objxpar.id%type is
 l_val_tp u_list.val_tp%type;
 l_id_tp u_listtp.id%type;
 l_id_list u_list.id%type;
 l_t_objxpar_id t_objxpar.id%type;
 l_md5 RAW(50);
 begin
   --задает (создает в случае отсутстви€) значение параметра RAW, зашифрованное MD5 либо по k_lsk.id либо по kart.lsk
   --чтение параметра - не предусмотрено
   if p_k_lsk_id is not null and p_lsk is not null then
     Raise_application_error(-20000, 'ѕопытка использовать LSK и K_LSK_ID ондовременно при установке параметра!');
   end if;
   begin
   select t.id into l_id_tp from u_listtp t where t.cd='ѕараметры лиц.счета';
     select s.id, s.val_tp into l_id_list, l_val_tp
            from u_list s where upper(s.cd)=upper(p_cd)
              and s.fk_listtp=l_id_tp;
   if l_val_tp <> 'RW' then
      raise_application_error(-20001,
                              'ѕараметр - '||p_cd||' не €вл€етс€ RAW типом!');
   end if;
    exception
    when NO_DATA_FOUND then
      raise_application_error(-20001,
                              'ѕараметр - '||p_cd||' не зарегистрирован!');
   end;
   l_md5:=utl_raw.cast_to_raw(dbms_obfuscation_toolkit.md5
                          (input_string => p_val));

   if p_k_lsk_id is not null then
     update t_objxpar x set x.pass=l_md5, x.ts=sysdate
       where x.fk_list=l_id_list
       and x.fk_k_lsk=p_k_lsk_id;
   elsif p_lsk is not null then
     update t_objxpar x set x.pass=l_md5, x.ts=sysdate
       where x.fk_list=l_id_list
       and x.fk_lsk=p_lsk;
   end if;

   if SQL%NOTFOUND then
     --не найден параметр - создать
     insert into t_objxpar
       (fk_lsk, fk_k_lsk, fk_list, pass)
       values (p_lsk, p_k_lsk_id, l_id_list, l_md5)
       returning id into l_t_objxpar_id;
   end if;

   --коммит не делаетс€
   --commit;
   --вернуть id параметра
   return l_t_objxpar_id;
 end;


 function ins_num_param(p_k_lsk_id in k_lsk.id%type, p_lsk in kart.lsk%type,
   p_cd in varchar2, p_val in t_objxpar.n1%type,
   p_usl in usl.usl%type,
   p_tp in t_objxpar.tp%type) return t_objxpar.id%type is
 l_val_tp u_list.val_tp%type;
 l_id_tp u_listtp.id%type;
 l_id_list u_list.id%type;
 l_t_objxpar_id t_objxpar.id%type;
 l_user number;
 l_mg params.period%type;
 begin
   --задает (создает в случае отсутстви€) значение параметра Number либо по k_lsk.id либо по kart.lsk
   --получить ID пользовател€
   l_user:=init.get_user;

   --текущий период
   select p.period into l_mg from
     params p;

   if p_k_lsk_id is not null and p_lsk is not null then
     Raise_application_error(-20000, 'ѕопытка использовать LSK и K_LSK_ID одовременно при установке параметра!');
   end if;
   begin
   select t.id into l_id_tp from u_listtp t where t.cd='ѕараметры лиц.счета';
     select s.id, s.val_tp into l_id_list, l_val_tp
            from u_list s where upper(s.cd)=upper(p_cd)
              and s.fk_listtp=l_id_tp;
   if l_val_tp <> 'NM' then
      raise_application_error(-20001,
                              'ѕараметр - '||p_cd||' не €вл€етс€ NUMBER типом!');
   end if;
    exception
    when NO_DATA_FOUND then
      raise_application_error(-20001,
                              'ѕараметр - '||p_cd||' не зарегистрирован!');
   end;

   if p_k_lsk_id is not null then
     --создать строку
     insert into t_objxpar
       (fk_lsk, fk_k_lsk, fk_list, n1, fk_user, fk_usl, tp, ts, mg)
       values (p_lsk, p_k_lsk_id, l_id_list, p_val, l_user, p_usl, p_tp, sysdate, l_mg)
       returning id into l_t_objxpar_id;
   elsif p_lsk is not null then
     insert into t_objxpar
       (fk_lsk, fk_k_lsk, fk_list, n1, fk_user, fk_usl, tp, ts, mg)
       values (p_lsk, p_k_lsk_id, l_id_list, p_val, l_user, p_usl, p_tp, sysdate, l_mg)
       returning id into l_t_objxpar_id;
   end if;

   --коммит не делаетс€
   --commit;
   --вернуть id параметра
   return l_t_objxpar_id;
 end;

end c_obj_par;
/

prompt
prompt Creating package body C_PREP
prompt ============================
prompt
create or replace package body scott.C_PREP is

procedure dist_summa is
l_summa number;
l_summa2 number;
l_summa_r number;
l_summa_kr number;
l_summa_kr_tst number;
l_summa_itg_dt number;
l_proc number;
l_flag_r number;
--l_id number;
--l_id2 number;
l_id3 number;
l_id4 number;
l_round number;
begin
--ѕроцедура - сложить все отрицательные значени€
--с положительными (пропорционально)
--формирование исход€щей таблицы корректировок
--а так же исход€щей таблицы значений закрыти€ сумм
--Ќа вход - отправить значени€ в TEMP_PREP!
delete from temp_prep t where t.tp_cd not in (0);
--формируем сразу исх.значени€
/*insert into temp_prep
   (usl, org, summa, tp_cd)
 select usl, org, summa, 1 from
 temp_prep;*/

select nvl(sum(case when t.summa>0 then 0 else t.summa end),0),
 nvl(sum(case when t.summa<0 then 0 else t.summa end),0)
  into l_summa, l_summa2
   from temp_prep t where t.tp_cd=0;
if l_summa = 0 or l_summa2 = 0 then
  --распредел€ть нечего или не куда
  --просто переписываем исх данные
  insert into temp_prep
     (usl, org, summa, tp_cd )
  select usl, org, summa, 1 as tp_cd from temp_prep t
    where t.tp_cd = 0;
 return;
end if;


select case when sum(t.summa)/abs(l_summa) > 1 then 1
            else sum(t.summa)/abs(l_summa)
            end into l_proc --% отношени€ кр/деб
   from temp_prep t where t.tp_cd=0
   and t.summa > 0;

--l_id:=null;
--l_id2:=null;
l_id3:=null;
l_id4:=null;

for c_kr in (select round(t.summa * l_proc,7) as summa, t.org, t.usl
   from temp_prep t where t.tp_cd=0
   and round(t.summa * l_proc,7) < 0
   order by t.usl, t.org)
loop
  l_summa_kr:=c_kr.summa;
  l_summa_kr_tst:=0;
  select nvl(sum(t.summa),0) into l_summa_itg_dt
     from temp_prep t where t.tp_cd=0
     and t.summa > 0;

  if l_summa_itg_dt > 0 then
    for c_deb in (select
      t.summa as dddd,
      case when
                           round(abs(l_summa_kr)*t.summa/l_summa_itg_dt,7) >= t.summa then t.summa
                           else round(abs(l_summa_kr)*t.summa/l_summa_itg_dt,7) end as summa,
                           t.usl, t.org
                  from temp_prep t where t.tp_cd=0
                  and t.summa > 0
                  order by t.usl, t.org)
    loop
      if c_deb.summa > 0 then
          insert into temp_prep
             (usl, org, summa, tp_cd)
          values --снимаем с кредита
             (c_kr.usl, c_kr.org, c_deb.summa, 2);
--          return id into l_id;
          insert into temp_prep
             (usl, org, summa, tp_cd)
          values --ставим на дебет
             (c_deb.usl, c_deb.org, -1*c_deb.summa, 2);
--          return id into l_id2;
/*          if abs(c_deb.summa) > 0.01 then
              --запомнить id дл€ округлени€
                l_id3:=l_id;
                l_id4:=l_id2;
          end if;  */
          l_summa_kr_tst:=l_summa_kr_tst-c_deb.summa;
 --         l_summa_r:=l_summa_r-c_deb.summa;
          if l_summa_kr_tst <= l_summa_kr then
           --выход из цикла, когда сумма распределилась
           exit;
          end if;
      end if;
    end loop;
  end if;

end loop;


  --корректировки округленные
  insert into temp_prep
     (usl, org, summa, tp_cd)
  select usl, org, round(sum(summa),2), 3 as tp_cd from temp_prep t
    where t.tp_cd = 2
   group by usl, org, mg;


  -- исх. суммы
  insert into temp_prep
     (usl, org, summa, tp_cd)
  select usl, org, sum(summa), 1 as tp_cd from
  (select usl, org, summa from temp_prep t
    where t.tp_cd = 0
  union all
  select usl, org, summa from temp_prep t
    where t.tp_cd = 3
    )
    group by usl, org
  having sum(summa)<>0;


  --округление
  select a.summa-b.summa into l_summa_r from
 (select nvl(sum(t.summa),0) as summa
   from temp_prep t
   where t.tp_cd = 0) a,
 (select nvl(sum(t.summa),0) as summa
   from temp_prep t
   where t.tp_cd = 1) b;

--COMMIT;

  --попытатьс€ округлить по отриц.значению
  l_flag_r:=0;
  if l_summa_r <>0 then
    l_flag_r:=1;
    for c in (select t.usl, t.org, abs(t.summa) as summa from temp_prep t
          where t.tp_cd = 1 and t.summa < 0
--                and exists (select * from temp_prep p where p.tp_cd=3 and p.usl=t.usl and p.org=t.org and p.summa<>0) --и чтоб была корректировка!
          )
    loop
      if abs(l_summa_r) > c.summa then
        insert into temp_prep
           (usl, org, summa, tp_cd)
           values
           (c.usl,c.org, sign(l_summa_r)*c.summa, 4);
      l_summa_r:=l_summa_r-sign(l_summa_r)*c.summa;
      else
        insert into temp_prep
           (usl, org, summa, tp_cd)
           values
           (c.usl,c.org, l_summa_r, 4);
        l_summa_r:=0;
        exit;
      end if;
    end loop;

  --не нашли отрицательные, попытатьс€ округлить по положит.значению
    if l_summa_r <>0 then
    for c in (select t.usl, t.org, abs(t.summa) as summa from temp_prep t
          where t.tp_cd = 1 and t.summa > 0
--                and exists (select * from temp_prep p where p.tp_cd=3 and p.usl=t.usl and p.org=t.org and p.summa<>0) --и чтоб была корректировка!
                )
    loop
      if abs(l_summa_r) > c.summa then
        insert into temp_prep
           (usl, org, summa, tp_cd)
           values
           (c.usl,c.org, sign(l_summa_r)*c.summa, 4);
      l_summa_r:=l_summa_r - (sign(l_summa_r)*c.summa);
      else
        insert into temp_prep
           (usl, org, summa, tp_cd)
           values
           (c.usl,c.org, l_summa_r, 4);
        l_summa_r:=0;
        exit;
      end if;
    end loop;
    end if;


    if l_summa_r >0 then
    --если нет записей после округлени€
    --(бывает когда значени€ близки к 0.01)
    --и сумма > 0
      insert into temp_prep
         (usl, org, summa, tp_cd)
      select t.usl, t.org, l_summa_r as summa,4 from temp_prep t
            where t.rowid=(select max(rowid) from temp_prep r where
              r.summa > 0 and r.tp_cd=0);
    elsif l_summa_r <0 then
    --если нет записей после округлени€
    --(бывает когда значени€ близки к 0.01)
    --и сумма < 0
      insert into temp_prep
         (usl, org, summa, tp_cd)
      select t.usl, t.org, l_summa_r as summa,4 from temp_prep t
            where rowid=(select max(rowid) from temp_prep r where
              r.summa < 0 and r.tp_cd=0);
    end if;


  end if;

  if l_flag_r =1 then
    -- еще раз, исх. суммы, если было округление
    delete from temp_prep t where t.tp_cd=1;
    insert into temp_prep
       (usl, org, summa, tp_cd)
    select usl, org, sum(summa), 1 from
    (select usl, org, summa from temp_prep t
      where t.tp_cd = 0
    union all
    select usl, org, summa from temp_prep t
      where t.tp_cd = 3
    union all
    select usl, org, summa from temp_prep t
      where t.tp_cd = 4
      )
      group by usl, org
    having sum(summa)<>0;
  end if;
end;

--ѕроцедура - сложить все отрицательные значени€
--с положительными (пропорционально)
--специализированна дл€ распределени€ сальдо по мес€цам задолжности!!!
procedure dist_summa2 is
l_summa number;
l_summa2 number;
l_summa_r number;
l_summa_kr number;
l_summa_kr_tst number;
l_summa_itg_dt number;
l_proc number;
l_flag_r number;
--l_id number;
--l_id2 number;
l_id3 number;
l_id4 number;
l_round number;
begin
--формирование исход€щей таблицы корректировок
--а так же исход€щей таблицы значений закрыти€ сумм
--Ќа вход - отправить значени€ в TEMP_PREP!
delete from temp_prep t where t.tp_cd not in (0);
--формируем сразу исх.значени€
/*insert into temp_prep
   (usl, org, summa, tp_cd)
 select usl, org, summa, 1 from
 temp_prep;*/

select nvl(sum(case when t.summa>0 then 0 else t.summa end),0),
 nvl(sum(case when t.summa<0 then 0 else t.summa end),0)
  into l_summa, l_summa2
   from temp_prep t where t.tp_cd=0;
if l_summa = 0 or l_summa2 = 0 then
  --распредел€ть нечего или не куда
  --просто переписываем исх данные
  insert into temp_prep
     (usl, org, summa, tp_cd, mg)
  select usl, org, summa, 1 as tp_cd, mg from temp_prep t
    where t.tp_cd = 0;
 return;
end if;


select case when sum(t.summa)/abs(l_summa) > 1 then 1
            else sum(t.summa)/abs(l_summa)
            end into l_proc --% отношени€ кр/деб
   from temp_prep t where t.tp_cd=0
   and t.summa > 0;

--l_id:=null;
--l_id2:=null;
l_id3:=null;
l_id4:=null;

for c_kr in (select round(t.summa * l_proc,7) as summa, t.org, t.usl
   from temp_prep t where t.tp_cd=0
   and round(t.summa * l_proc,7) < 0
   order by t.usl, t.org)
loop
  l_summa_kr:=c_kr.summa;
  l_summa_kr_tst:=0;
  select nvl(sum(t.summa),0) into l_summa_itg_dt
     from temp_prep t where t.tp_cd=0
     and t.summa > 0;

  if l_summa_itg_dt > 0 then
    for c_deb in (select
      t.summa as dddd,
      case when
                           round(abs(l_summa_kr)*t.summa/l_summa_itg_dt,7) >= t.summa then t.summa
                           else round(abs(l_summa_kr)*t.summa/l_summa_itg_dt,7) end as summa,
                           t.usl, t.org, t.mg
                  from temp_prep t where t.tp_cd=0
                  and t.summa > 0
                  order by t.usl, t.org)
    loop
      if c_deb.summa > 0 then
          insert into temp_prep
             (usl, org, summa, tp_cd)
          values --снимаем с кредита
             (c_kr.usl, c_kr.org, c_deb.summa, 2);
          insert into temp_prep
             (usl, org, summa, tp_cd, mg)
          values --ставим на дебет
             (c_kr.usl, c_kr.org, -1*c_deb.summa, 2, c_deb.mg);
/*          if abs(c_deb.summa) > 0.01 then
              --запомнить id дл€ округлени€
                l_id3:=l_id;
                l_id4:=l_id2;
          end if;  */
          l_summa_kr_tst:=l_summa_kr_tst-c_deb.summa;
 --         l_summa_r:=l_summa_r-c_deb.summa;
          if l_summa_kr_tst <= l_summa_kr then
           --выход из цикла, когда сумма распределилась
           exit;
          end if;
      end if;
    end loop;
  end if;

end loop;


  --корректировки округленные
  insert into temp_prep
     (usl, org, summa, tp_cd, mg)
  select usl, org, round(sum(summa),2), 3 as tp_cd, t.mg from temp_prep t
    where t.tp_cd = 2
   group by usl, org, mg;


  -- исх. суммы
  insert into temp_prep
     (usl, org, summa, tp_cd, mg)
  select usl, org, sum(summa), 1 as tp_cd, mg from
  (select usl, org, summa, mg from temp_prep t
    where t.tp_cd = 0
  union all
  select usl, org, summa, mg from temp_prep t
    where t.tp_cd = 3
    )
    group by usl, org, mg
  having sum(summa)<>0;


  --округление
  select a.summa-b.summa into l_summa_r from
 (select nvl(sum(t.summa),0) as summa
   from temp_prep t
   where t.tp_cd = 0) a,
 (select nvl(sum(t.summa),0) as summa
   from temp_prep t
   where t.tp_cd = 1) b;

--COMMIT;

  --попытатьс€ округлить по отриц.значению
  l_flag_r:=0;
  if l_summa_r <>0 then
    l_flag_r:=1;
    for c in (select t.usl, t.org, t.mg, abs(t.summa) as summa from temp_prep t
          where t.tp_cd = 1 and t.summa < 0)
    loop
      if abs(l_summa_r) > c.summa then
        insert into temp_prep
           (usl, org, summa, tp_cd, mg)
           values
           (c.usl,c.org, sign(l_summa_r)*c.summa, 4, c.mg);
      l_summa_r:=l_summa_r-sign(l_summa_r)*c.summa;
      else
        insert into temp_prep
           (usl, org, summa, tp_cd, mg)
           values
           (c.usl,c.org, l_summa_r, 4, c.mg);
        l_summa_r:=0;
        exit;
      end if;
    end loop;

  --не нашли отрицательные, попытатьс€ округлить по положит.значению
    if l_summa_r <>0 then
    for c in (select t.usl, t.org, abs(t.summa) as summa, t.mg from temp_prep t
          where t.tp_cd = 1 and t.summa > 0)
    loop
      if abs(l_summa_r) > c.summa then
        insert into temp_prep
           (usl, org, summa, tp_cd, mg)
           values
           (c.usl,c.org, sign(l_summa_r)*c.summa, 4, c.mg);
      l_summa_r:=l_summa_r - (sign(l_summa_r)*c.summa);
      else
        insert into temp_prep
           (usl, org, summa, tp_cd, mg)
           values
           (c.usl,c.org, l_summa_r, 4, c.mg);
        l_summa_r:=0;
        exit;
      end if;
    end loop;
    end if;


    if l_summa_r >0 then
    --если нет записей после округлени€
    --(бывает когда значени€ близки к 0.01)
    --и сумма > 0
      insert into temp_prep
         (usl, org, summa, tp_cd, mg)
      select t.usl, t.org, l_summa_r as summa,4, t.mg from temp_prep t
            where t.rowid=(select max(r.rowid) from temp_prep r where
              r.summa > 0 and r.tp_cd=0);
    elsif l_summa_r <0 then
    --если нет записей после округлени€
    --(бывает когда значени€ близки к 0.01)
    --и сумма < 0
      insert into temp_prep
         (usl, org, summa, tp_cd, mg)
      select t.usl, t.org, l_summa_r as summa,4, t.mg from temp_prep t
            where t.rowid=(select max(r.rowid) from temp_prep r where
              r.summa < 0 and r.tp_cd=0);
    end if;


  end if;

  if l_flag_r =1 then
    -- еще раз, исх. суммы, если было округление
    delete from temp_prep t where t.tp_cd=1;
    insert into temp_prep
       (usl, org, summa, tp_cd, mg)
    select usl, org, sum(summa), 1, mg from
    (select usl, org, summa, mg from temp_prep t
      where t.tp_cd = 0
    union all
    select usl, org, summa, mg from temp_prep t
      where t.tp_cd = 3
    union all
    select usl, org, summa,mg from temp_prep t
      where t.tp_cd = 4
      )
      group by usl, org, mg
    having sum(summa)<>0;
  end if;
end;

--распределить сумму полностью (любой знак), пропорционально, по другим значени€м
function dist_summa_full(p_sum in number, t_summ in out tab_summ) return number is
 l_sum number;
 l_max_sum number;
 l_max_sum_id number;
 l_id number;
 l_sum_itg number;
 l_lst_fk_cd varchar2(3);
 l_lst_fk_id number;
 r_summ rec_summ;
 l_sign number;
begin
--на вход - массив значений >0  в temp_prep, параметр p_num

l_sum:=abs(nvl(p_sum,0));
if p_sum<0 then 
  l_sign:=-1;
else
  l_sign:=1;
end if;   

l_sum_itg:=0;
l_max_sum:=0;
for c in (select t.fk_cd, t.fk_id, t.summa, sum(t.summa) over (partition by 0) as summ_itg,
      round(l_sum*t.summa/sum(t.summa) over (partition by 0),2) as summ_out
      from table(t_summ) t where t.tp=0)
loop
  if c.summ_out <> 0 then

    t_summ.extend;
    r_summ:=rec_summ(fk_cd => c.fk_cd, fk_id => c.fk_id, summa => l_sign*c.summ_out, tp => 1);
    t_summ(t_summ.last):=r_summ;
    l_id:=t_summ.last;
    
    --найти макс сумму, чтобы округлить на неЄ
    if c.summ_out >= l_max_sum then
      l_max_sum:=c.summ_out;
      l_max_sum_id:=l_id;
    end if;
    l_sum_itg:=l_sum_itg+c.summ_out;
  end if;
  l_lst_fk_cd:=c.fk_cd;
  l_lst_fk_id:=c.fk_id;
end loop;

if l_sum between 0.01 and 0.06 and l_id is null and l_lst_fk_cd is not null then
  --вход€щ€€ сумма така€ маленька€, чтобы распределить, то попытатьс€ еЄ добавить с последней услугой+орг
    t_summ.extend;
    r_summ:=rec_summ(fk_cd => l_lst_fk_cd, fk_id => l_lst_fk_id, summa => l_sign*p_sum, tp => 1);
    t_summ(t_summ.last):=r_summ;

elsif l_sum not between 0.01 and 0.06 and l_id is null then
  --Ќет записей дл€ распределени€ суммы!
  Raise_application_error(-20000, 'ќшибка c_prep #1');
--  return 1;
elsif abs(p_sum-l_sum_itg) > 0.07 then
  --—лишком большое округление;
  Raise_application_error(-20000, 'ќшибка c_prep #3');
--  return 3;
elsif abs(p_sum-l_sum_itg) <= 0.07 and l_max_sum_id is not null then
  --округлить
  t_summ(l_max_sum_id).summa:=t_summ(l_max_sum_id).summa + (p_sum-l_sum_itg);
else --бывает при p_sum=0.01
  --Ќет записей дл€ распределени€ суммы!
  Raise_application_error(-20000, 'ќшибка c_prep #4');
--  return 1;
end if;

--проверить
select nvl(p_sum,0)-nvl(sum(t.summa),0) into l_sum_itg from 
 table(t_summ) t where t.tp=1;
if l_sum_itg <>0 then
  --—умма распределена не корректно!
  Raise_application_error(-20000, 'ќшибка c_prep #5');
--  return 2;
end if;

return 0;

end;

end C_PREP;
/

prompt
prompt Creating package body C_VALID
prompt =============================
prompt
create or replace package body scott.C_VALID is

procedure set_valid_lsk(p_lsk in kart.lsk%type, p_valid in number, p_tp in varchar2) is
l_cnt number;
l_klsk number;
begin
 --по л/с
 --начисление ('gen_chrg')
 --движение ('gen_chrgpay')
--  if p_tp not in ('gen_chrg', 'gen_chrgpay', 'gen_part_kpr'--, 'gen_vvod'
  if p_tp not in ('gen_chrgpay') then
    Raise_application_error(-20000, 'Ќедопустимый параметр '||p_tp);
  end if;

  --если была вызвана установка пересчЄта ввода и
  --запрещен пересчЄт
/*  if p_tp in ('gen_vvod')
     and p_valid = 1
     and nvl(c_charges.dsbl_vld_gen_vvod,0) = 1 then
    return;
  els*/

--  if p_tp in ('gen_chrg') and p_valid = 1 then
    --если была вызвана ”—“јЌќ¬ ј (p_valid=1)(!) пересчЄта начислени€, вызвать еще пересчет
    --движени€
--    l_cnt:=c_obj_par.set_num_param(null, p_lsk, 'gen_chrg', p_valid);
--    l_cnt:=c_obj_par.set_num_param(null, p_lsk, 'gen_chrgpay', p_valid);

    --установить пересчЄт ввода
/*    if nvl(c_charges.dsbl_vld_gen_vvod,0) <> 1 then
      if p_vvod is null then
           --вызов из прочих мест
          for c in (select distinct d.fk_k_lsk from nabor n, c_vvod d where n.lsk=p_lsk
              and n.fk_vvod=d.id)
            loop
              set_valid_klsk(c.fk_k_lsk, p_valid, 'gen_obj', 'ѕараметры объекта');
            end loop;
      elsif nvl(p_vvod,0) <> -1 then
           --вызов из nabor
           --получить k_lsk_id
           select t.fk_k_lsk into l_klsk from c_vvod t
             where t.id=p_vvod;
           set_valid_klsk(l_klsk, p_valid, 'gen_obj', 'ѕараметры объекта');
      end if;
    end if;*/
--  else
    --сн€тие перерасчета и прочее вызываетс€ отдельно!!!
    l_cnt:=c_obj_par.set_num_param(null, p_lsk, p_tp, p_valid);
--  end if;
 --коммит нельз€ - выполн€етс€ в триггерах
end;

function get_valid_lsk(p_lsk in kart.lsk%type, p_tp in varchar2) return number is
begin

 --начисление ('gen_chrg')
 --движение ('gen_chrgpay')
--  if p_tp not in ('gen_chrg', 'gen_chrgpay', 'gen_part_kpr') then
  if p_tp not in ('gen_chrgpay') then
    Raise_application_error(-20000, 'Ќе допустимый параметр '||p_tp);
  end if;
  return c_obj_par.get_num_param(null, p_lsk, p_tp);
end;


/*procedure set_valid_as_vvod(p_vvod in c_vvod.id%type, p_valid in number, p_tp in varchar2) is
l_klsk number;
begin
 --вызов например из nabor
 if nvl(c_charges.dsbl_vld_gen_vvod,0) = 0 then
   select d.fk_k_lsk into l_klsk from c_vvod d where d.id=p_vvod;
   set_valid_klsk (l_klsk, p_valid, p_tp, 'ѕараметры объекта');
 end if;
end;

procedure set_valid_as_house(p_lsk in kart.lsk%type, p_valid in number, p_tp in varchar2) is
l_klsk number;
begin
 --вызов например из nabor
 if nvl(c_charges.dsbl_vld_gen_vvod,0) = 0 then
   select h.k_lsk_id into l_klsk
     from kart t, c_houses h
     where t.lsk=p_lsk and t.house_id=h.id
     and rownum=1;
   set_valid_klsk (l_klsk, p_valid, p_tp, 'ѕараметры объекта');
 end if;
end;
*/

/*procedure set_valid_klsk(p_klsk in k_lsk.id%type, p_valid in number, p_tp in varchar2,
  p_cdtp in varchar2) is
l_cnt number;
begin
 --по k_lsk_id
 --пересчет объекта ('gen_obj')
  if p_tp not in ('gen_obj') then
    Raise_application_error(-20000, 'Ќедопустимый параметр '||p_tp);
  end if;
  l_cnt:=c_obj_par.set_num_param(p_klsk, null, p_tp, p_valid, p_cdtp);
 --коммит нельз€ - выполн€етс€ в триггерах
end;

function get_valid_klsk(p_klsk in k_lsk.id%type, p_tp in varchar2,
  p_cdtp in varchar2) return number is
begin
 --по k_lsk_id
 --пересчет объекта ('gen_obj')
  if p_tp not in ('gen_obj') then
    Raise_application_error(-20000, 'Ќедопустимый параметр '||p_tp);
  end if;
  return c_obj_par.get_num_param(p_klsk, null, p_tp, p_cdtp);
end;
*/

/*procedure set_valid_states_pr(p_kart_pr in c_states_pr.id%type, p_valid in number, p_tp in varchar2) is
l_cnt number;
begin
 --по статусу прописки
 --начисление ('gen_chrg')
 --движение ('gen_chrgpay')
 --кол-во прожив ('gen_part_kpr')
for c in (select k.lsk from c_kart_pr k where
    k.id=p_kart_pr)
loop

  set_valid_lsk(c.lsk, p_valid, p_tp);

end loop;

 --коммит нельз€ - выполн€етс€ в триггерах
end;*/

/*procedure set_valid_for_vvod(p_vvod in c_vvod.id%type, p_lsk in kart.lsk%type,
   p_valid in number, p_tp in varchar2) is
begin
--установить статус пересчЄта по вводу, к которому принадлежит лицевой счет
if p_lsk is not null then
  for c in (select d.fk_k_lsk from nabor n, c_vvod d where
              n.fk_vvod=d.id
              and n.lsk=p_lsk)
  loop
    set_valid_klsk(c.fk_k_lsk, p_valid, p_tp, 'ѕараметры объекта');
  end loop;
elsif p_vvod is not null then
  for c in (select d.fk_k_lsk from c_vvod d where
              d.id=p_vvod)
  loop
    set_valid_klsk(c.fk_k_lsk, p_valid, p_tp, 'ѕараметры объекта');
  end loop;
end if;

end; */

/*procedure set_valid_vvod(p_vvod in c_vvod.id%type, p_valid in number, p_tp in varchar2) is
l_cnt number;
begin
--установить статус пересчета по л/с, относ€щимс€ ко вводу

for c in (select n.lsk from nabor n where n.fk_vvod=p_vvod
  and not exists (--только по тем л/c, где нужен перерасчет
           select *
                  from t_objxpar x, u_list s, u_listtp tp where --ред. 21.10.13 (не протестировано)
                  s.fk_listtp=tp.id and tp.cd='ѕараметры лиц.счета'
                  and x.fk_list=s.id and s.cd=p_tp
                  and x.fk_lsk=n.lsk
                  and s.cd = p_tp
                  and x.n1=p_valid)
         )
loop

  set_valid_lsk(c.lsk, p_valid, p_tp);

end loop;

end;

procedure set_valid_house(p_house in c_houses.id%type, p_valid in number, p_tp in varchar2) is
l_cnt number;
begin
--установить статус пересчета по л/с, относ€щимс€ к дому

for c in (select k.lsk from kart k where k.house_id=p_house
         and not exists (--только по тем л/c, где нужен перерасчет
           select *
                  from t_objxpar x, u_list s, u_listtp tp where  --ред. 21.10.13 (не протестировано)
                  s.fk_listtp=tp.id and tp.cd='ѕараметры лиц.счета'
                  and x.fk_list=s.id and s.cd=p_tp
                  and x.fk_lsk=k.lsk
                  and s.cd = p_tp
                  and x.n1=p_valid)
         )
loop

  set_valid_lsk(c.lsk, p_valid, p_tp);

end loop;

end;*/

/*procedure set_valid_all_nc(p_valid in number, p_tp in varchar2) is
l_cnt number;
begin
--установить статус пересчета по л/с, по всем не закрытым л.с.
--(например после перехода, только дл€ начислени€)
if p_tp = 'gen_chrgpay' then
  --запрещено потому что использование функции может привести к Ќ≈ пересчету движени€ по закрытым л/c
  Raise_application_error(-20000, '«апрещено использовать C_VALID.set_valid_all_nc c "gen_chrgpay"');
end if;

for c in (select k.lsk from kart k where k.psch not in (8,9)
       and not exists (--только по тем л/c, где нужен перерасчет
         select *
                from t_objxpar x, u_list s, u_listtp tp where  --ред. 21.10.13 (не протестировано)
                s.fk_listtp=tp.id and tp.cd='ѕараметры лиц.счета'
                and x.fk_list=s.id and s.cd=p_tp
                and x.fk_lsk=k.lsk
                and x.n1=p_valid)
          )
loop

  set_valid_lsk(c.lsk, p_valid, p_tp);
end loop;

end; */

procedure set_valid_all(p_valid in number, p_tp in varchar2) is
l_cnt number;
begin
--установить статус пересчета по л/с, по ¬—≈ћ л.с.
--(например после перехода, дл€ движени€)

for c in (select k.lsk from kart k
    where not exists (--только по тем л/c, где нужен перерасчет
         select *
                from t_objxpar x, u_list s, u_listtp tp where  --ред. 21.10.13 (не протестировано)
                s.fk_listtp=tp.id and tp.cd='ѕараметры лиц.счета'
                and x.fk_list=s.id and s.cd=p_tp
                and x.fk_lsk=k.lsk
--                and s.cd in ('gen_chrg', 'gen_chrgpay', 'gen_part_kpr')
                and s.cd in ('gen_chrgpay')
                and x.n1=p_valid)
         )
loop

  set_valid_lsk(c.lsk, p_valid, p_tp);

end loop;

end;

end C_VALID;
/

prompt
prompt Creating package body DBASE_PKG
prompt ===============================
prompt
create or replace package body scott.dbase_pkg
as
--пакет дл€ загрузки DBF в ORACLE

-- Might have to change on your platform!!!
-- Controls the byte order of binary integers read in
-- from the dbase file
BIG_ENDIAN      constant boolean default TRUE;

type dbf_header is RECORD
(
    version    varchar2(25), -- dBASE version number
    year       int,          -- 1 byte int year, add to 1900
    month      int,          -- 1 byte month
    day        int,             -- 1 byte day
    no_records int,             -- number of records in file,
                             -- 4 byte int
    hdr_len    int,             -- length of header, 2 byte int
    rec_len    int,             -- number of bytes in record,
                             -- 2 byte int
    no_fields  int           -- number of fields
);


type field_descriptor is RECORD
(
    name     varchar2(11),
    type     char(1),
    length   int,   -- 1 byte length
    decimals int    -- 1 byte scale
);

type field_descriptor_array
is table of
field_descriptor index by binary_integer;


type rowArray
is table of
varchar2(4000) index by binary_integer;


g_cursor binary_integer default dbms_sql.open_cursor;




-- Function to convert a binary unsigned integer
-- into a PLSQL number

function to_int( p_data in varchar2 ) return number
is
    l_number number default 0;
    l_bytes  number default length(p_data);
begin
    if (big_endian)
    then
        for i in 1 .. l_bytes loop
            l_number := l_number +
                              ascii(substr(p_data,i,1)) *
                                           power(2,8*(i-1));
        end loop;
    else
        for i in 1 .. l_bytes loop
            l_number := l_number +
                         ascii(substr(p_data,l_bytes-i+1,1)) *
                         power(2,8*(i-1));
        end loop;
    end if;

    return l_number;
end;


function mytrim(p_str in varchar2) return varchar2 is
i number;
j number;
v_res varchar2(100);
begin
  for i in 1 .. 11 loop
    if ascii(substr(p_str,i,1)) = 0 then
     j:= i;
     exit;
    end if;
  end loop;
  v_res := substr(p_str,1,j-1);
  return v_res;
end mytrim;


-- Routine to parse the DBASE header record, can get
-- all of the details of the contents of a dbase file from
-- this header

procedure get_header
(p_bfile        in bfile,
 p_bfile_offset in out NUMBER,
 p_hdr          in out dbf_header,
 p_flds         in out field_descriptor_array )
is
    l_data            varchar2(100);
    l_hdr_size        number default 32;
    l_field_desc_size number default 32;
    l_flds            field_descriptor_array;
begin
    p_flds := l_flds;

    l_data := utl_raw.cast_to_varchar2(
                       dbms_lob.substr( p_bfile,
                                        l_hdr_size,
                                        p_bfile_offset ) );
    p_bfile_offset := p_bfile_offset + l_hdr_size;

    p_hdr.version    := ascii( substr( l_data, 1, 1 ) );
    p_hdr.year       := 1900 + ascii( substr( l_data, 2, 1 ) );
    p_hdr.month      := ascii( substr( l_data, 3, 1 ) );
    p_hdr.day        := ascii( substr( l_data, 4, 1 ) );
    p_hdr.no_records := to_int( substr( l_data,  5, 4 ) );
--    p_hdr.hdr_len    := to_int( substr( l_data,  9, 2 ) );
    p_hdr.hdr_len    := to_int( substr( l_data,  9, 2 ) );
    p_hdr.rec_len    := to_int( substr( l_data, 11, 2 ) );
    p_hdr.no_fields  := trunc( (p_hdr.hdr_len - l_hdr_size)/
                                           l_field_desc_size );


    for i in 1 .. p_hdr.no_fields
    loop
        l_data := utl_raw.cast_to_varchar2(
                         dbms_lob.substr( p_bfile,
                                          l_field_desc_size,
                                          p_bfile_offset ));
        p_bfile_offset := p_bfile_offset + l_field_desc_size;

/*
        p_flds(i).name := rtrim(substr(l_data,1,11),chr(0));
        p_flds(i).type := substr( l_data, 12, 1 );
        p_flds(i).length  := ascii( substr( l_data, 17, 1 ) );
        p_flds(i).decimals := ascii(substr(l_data,18,1) );
*/
        p_flds(i).name := mytrim(substr(l_data,1,11));
        p_flds(i).type := substr( l_data, 12, 1 );
        p_flds(i).length  := ascii( substr( l_data, 17, 1 ) );
        p_flds(i).decimals := ascii(substr(l_data,18,1) );
    end loop;

    p_bfile_offset := p_bfile_offset +
                          mod( p_hdr.hdr_len - l_hdr_size,
                               l_field_desc_size );
end;



function build_insert
( p_tname in varchar2,
  p_cnames in varchar2,
  p_flds in field_descriptor_array ) return varchar2
is
    l_insert_statement long;
begin
    l_insert_statement := 'insert into ' || p_tname || '(';
    if ( p_cnames is NOT NULL )
    then
        l_insert_statement := l_insert_statement ||
                              p_cnames || ') values (';
    else
        for i in 1 .. p_flds.count
        loop
            if ( i <> 1 )
            then
               l_insert_statement := l_insert_statement||',';
            end if;
            l_insert_statement := l_insert_statement ||
                            '"'||  p_flds(i).name || '"';
        end loop;
        l_insert_statement := l_insert_statement ||
                                           ') values (';
    end if;
    for i in 1 .. p_flds.count
    loop
        if ( i <> 1 )
        then
           l_insert_statement := l_insert_statement || ',';
        end if;
        if ( p_flds(i).type = 'D' )
        then

            l_insert_statement := l_insert_statement ||
                     'to_date(:bv' || i || ',''yyyymmdd'' )';
        else
            l_insert_statement := l_insert_statement ||
                                                ':bv' || i;
        end if;
    end loop;
    l_insert_statement := l_insert_statement || ')';

    return l_insert_statement;
end;


function get_row
( p_bfile in bfile,
  p_bfile_offset in out number,
  p_hdr in dbf_header,
  p_flds in field_descriptor_array ) return rowArray
is
    l_data     varchar2(4000);
    l_row   rowArray;
    l_n     number default 2;
begin
    l_data := utl_raw.cast_to_varchar2(
                   dbms_lob.substr( p_bfile,
                                    p_hdr.rec_len,
                                    p_bfile_offset ) );
    p_bfile_offset := p_bfile_offset + p_hdr.rec_len;

    l_row(0) := substr( l_data, 1, 1 );

    for i in 1 .. p_hdr.no_fields loop
        l_row(i) := rtrim(ltrim(substr( l_data,
                                        l_n,
                                        p_flds(i).length ) ));
        if ( p_flds(i).type = 'F' and l_row(i) = '.' )
        then
            l_row(i) := NULL;
        end if;
        l_n := l_n + p_flds(i).length;
    end loop;
    return l_row;
end get_row;


procedure show( p_hdr    in dbf_header,
                p_flds   in field_descriptor_array,
                p_tname  in varchar2,
                p_cnames in varchar2,
                p_bfile  in bfile )
is
    l_sep varchar2(1) default ',';

    procedure p(p_str in varchar2)
    is
        l_str long default p_str;
    begin
        while( l_str is not null )
        loop
            dbms_output.put_line( substr(l_str,1,250) );
            l_str := substr( l_str, 251 );
        end loop;
    end;
begin
    p( 'Sizeof DBASE File: ' || dbms_lob.getlength(p_bfile) );

    p( 'DBASE Header Information: ' );
    p( chr(9)||'Version = ' || p_hdr.version );
    p( chr(9)||'Year    = ' || p_hdr.year   );
    p( chr(9)||'Month   = ' || p_hdr.month   );
    p( chr(9)||'Day     = ' || p_hdr.day   );
    p( chr(9)||'#Recs   = ' || p_hdr.no_records);
    p( chr(9)||'Hdr Len = ' || p_hdr.hdr_len  );
    p( chr(9)||'Rec Len = ' || p_hdr.rec_len  );
    p( chr(9)||'#Fields = ' || p_hdr.no_fields );

    p( chr(10)||'Data Fields:' );
    for i in 1 .. p_hdr.no_fields
    loop
        p( 'Field(' || i || ') '
             || 'Name = "' || p_flds(i).name || '", '
             || 'Type = ' || p_flds(i).Type || ', '
             || 'Len  = ' || p_flds(i).length || ', '
             || 'Scale= ' || p_flds(i).decimals );
    end loop;

    p( chr(10) || 'Insert We would use:' );
    p( build_insert( p_tname, p_cnames, p_flds ) );

    p( chr(10) || 'Table that could be created to hold data:');
    p( 'create table ' || p_tname );
    p( '(' );

    for i in 1 .. p_hdr.no_fields
    loop
        if ( i = p_hdr.no_fields ) then l_sep := ')'; end if;
        dbms_output.put
        ( chr(9) || '"' || p_flds(i).name || '"   ');

        if ( p_flds(i).type = 'D' ) then
            p( 'date' || l_sep );
        elsif ( p_flds(i).type = 'F' ) then
            p( 'float' || l_sep );
        elsif ( p_flds(i).type = 'N' ) then
            if ( p_flds(i).decimals > 0 )
            then
                p( 'number('||p_flds(i).length||','||
                              p_flds(i).decimals || ')' ||
                              l_sep );
            else
                p( 'number('||p_flds(i).length||')'||l_sep );
            end if;
        else
            p( 'varchar2(' || p_flds(i).length || ')'||l_sep);
        end if;
    end loop;
    p( '/' );
end;

function parse_row_txt(txt_ in varchar2, at_ in number)
 return varchar2
is
  i number;
  i2 number;
begin
  --парсинг строки
  --начало строки
  if at_ - 1 = 0 then
    --ищем с начала файла
    i:=1;
    else
      if instr(txt_,'|', 1, at_-1) = 0 then
      --не найден лидирующий символ (некорректный запрос)
        return null;
      end if;
    i:= instr(txt_,'|', 1, at_-1)+1;
  end if;

  --конец строки
  i2:= instr(txt_,'|', 1, at_);
  if i2 = 0 then
    i2:=length(txt_)+1;
  end if;
  return substr(txt_, i, i2-i);
end;


--загрузка таблицы долгов от ќрганизации fk_org
procedure load_e(p_org in t_org.id%type) is
l_adr varchar2(4000);
begin
--из таблицы load_tmp_bulk
--regexp_instr('1,1,67,2,3,7,2,4,8', '(,|^)67(,|$){1,}')
--расшифровываетс€: 
--найти цифру (67)
--один раз {1}
delete from load_tmp_e;

for c in (
         with a as (select rownum as rn, replace(regexp_substr(t.s1, '[^|].+?(\||$)', 1, 1),'|','') as lsk_ext,
         replace(regexp_substr(t.s1, '[^|].+?(\||$)', 1, 2),'|','') as fio,
         replace(regexp_substr(t.s1, '[^|].+?(\||$)', 1, 3),'|','') as adr,
         replace(regexp_substr(t.s1, '[^|].+?(\||$)', 1, 4),'|','') as usl_cd,
         replace(regexp_substr(t.s1, '[^|].+?(\||$)', 1, 5),'|','') as usl_name,
         replace(regexp_substr(t.s1, '[^|].+?(\||$)', 1, 6),'|','') as period,
         to_number(replace(regexp_substr(t.s1, '[^|][[:digit:]]{0,}(\||$)', 1, 7),'|','')) as mel,
         replace(regexp_substr(t.s1, '[^|][[:digit:]]{0,}(\||$)', 1, 8),'|','')/100 as sal 
 from load_tmp_bulk t) 
  select a.rn, a.lsk_ext, a.fio, a.adr, a.usl_cd, a.usl_name, 
    substr(a.period,3,4)||substr(a.period,1,2) as period, a.mel, a.sal from a
 )
loop
  begin
    insert into load_tmp_e
      (lsk_ext, fio, adr, usl_cd, usl_name, period, mel, sal, fk_org)
      values
      (c.lsk_ext, c.fio, c.adr, c.usl_cd, c.usl_name, c.period, c.mel, c.sal, p_org);
    exception when value_error then
              Raise_application_error(-20000, 'ќшибка значени€ в строке файла:'||c.rn||' '||SQLCODE||' -ERRmsg- '||SQLERRM);
              when others then
              Raise;
  end;
end loop;
commit;
end;

--получить кол-во лицевых счетов, дл€ загрузки в kart
function get_cnt_to_load(p_org in t_org.id%type) return number is
l_cnt number;
begin
select count(*) into l_cnt from load_tmp_e t
 where not exists (select * from kart k, t_org o 
   where k.lsk_ext=t.lsk_ext and t.fk_org=o.id 
         and o.reu=k.reu);
 
return l_cnt;
end;

--выполнить загрузку лицевых счетов в kart
procedure ins_to_kart(p_org in t_org.id%type) is
 l_lsk_smpl kart.lsk%type;
 l_lsk_new kart.lsk%type;
 a number;
 l_reu t_org.reu%type;
begin

select t.reu into l_reu 
  from t_org t where t.id=p_org;
--загрузить лиц.счета
select k.lsk into l_lsk_smpl from kart k 
  where k.reu=l_reu and rownum=1;
for c in (select t.* from load_tmp_e t
   where not exists (select * from kart k where k.lsk_ext=t.lsk_ext))
loop
  l_lsk_new:=utils.get_new_lsk_by_reu(p_reu => l_reu);  
  a:=utils.CREATE_LSK(l_lsk_smpl, l_lsk_new, c.lsk_ext, c.fio);
end loop;   

--загрузить суммы задолжности



commit;
end;
  
procedure load_file_txt_bulk(p_dir in varchar2,
                      p_file in varchar2)
is
  buffer varchar2(4000);
  l_fname varchar2(100);
  i number;
  pos number;
  ft  utl_file.file_type;
begin
--загрузка текстового файла, без разбора формата
  i:=1;
  while instr(p_file, '\',  1, i) <> 0
  loop
   pos:=instr(p_file, '\', 1, i);
   i:=i+1;
  end loop;
  l_fname:=substr(p_file,pos+1, length(p_file)-pos);
  ft:=utl_file.fopen(p_dir, l_fname, 'r');
  execute immediate 'truncate table load_tmp_bulk';
  
  loop
    begin 
      utl_file.get_line(ft, buffer, 4000);
    exception
       when NO_DATA_FOUND then
         --конец файла
         exit;
       when OTHERS then
         Raise;  
    end;
    insert into load_tmp_bulk(s1)
      values (buffer);
  end loop;
  utl_file.fCLOSE(ft);
  commit;

end;                      

procedure load_file_txt(p_dir in varchar2,
                      p_file in varchar2)
is
  l_bfile      bfile;
  ft  utl_file.file_type;
  buffer varchar2(4000);
  cnt_ number;
  summa_ number;
  fname_ varchar2(100);
  i number;
  pos number;
begin
  --получение текстового файла оплаты из банка
  select nvl(count(*),0) into cnt_ from c_comps c, t_org o
    where c.nkom=init.get_nkom and c.fk_org=o.id
    and o.cd in ('—бербанк', 'ѕочта', '∆ ’-1');
  if cnt_ = 0 then
    raise_application_error( -20001,
     'є  омпьютера не соответствует данному типу файлов');
  end if;
  --выдел€ем им€ файла из полного пути
  i:=1;
  pos:=1;
  while instr(p_file, '\',  1, i) <> 0
  loop
   pos:=instr(p_file, '\', 1, i);
   i:=i+1;
  end loop;
  fname_:=substr(p_file,pos+1, length(p_file)-pos);
  --
  delete from load_bank t where t.nkom=init.get_nkom;
  ft:=utl_file.fopen(p_dir, fname_, 'r');
  summa_:=0;
  --проверить, установлен ли параметр
  cnt_:=utils.get_int_param('REJECT_PERIOD_BANK');

  cnt_:=0;

begin
  loop
    utl_file.get_line(ft, buffer, 2000);
    if parse_row_txt(buffer, 1) <> '=' then
    cnt_:=cnt_+1;
    summa_:=summa_+nvl(to_number(parse_row_txt(buffer, 4)/100),0);
    begin
    insert into load_bank(nkom, dtek, lsk, lsk2, code, summa, dopl, dn, nkvit)
      values (init.get_nkom, trunc(to_date(parse_row_txt(buffer, 1),'DDMMYYYY')),
              parse_row_txt(buffer, 2),
              parse_row_txt(buffer, 2),
              lpad(parse_row_txt(buffer, 3),2,'0'),
              to_number(parse_row_txt(buffer, 4)/100),
              case when utils.get_int_param('REJECT_PERIOD_BANK') = 0
                  and instr(parse_row_txt(buffer, 5),'.') > 0 then
                   substr(parse_row_txt(buffer, 5),4,4)||substr(parse_row_txt(buffer, 5),1,2)
                when utils.get_int_param('REJECT_PERIOD_BANK') = 0
                  and instr(parse_row_txt(buffer, 5),'.') = 0 then
                   substr(parse_row_txt(buffer, 5),3,4)||substr(parse_row_txt(buffer, 5),1,2)
                when utils.get_int_param('REJECT_PERIOD_BANK') = 1 then
                   init.get_period
                end
              ,
              parse_row_txt(buffer, 6),
              parse_row_txt(buffer, 7)
                );
     exception
       when others then
          raise_application_error( -20001,
           'ќЎ»Ѕ ј ¬ —“–ќ ≈ є '||cnt_||' ѕ–»Ќ»ћј≈ћќ√ќ ‘ј…Ћј');
     end;
     else
     --найден итог по файлу
       if parse_row_txt(buffer, 2) <> cnt_  then
          raise_application_error( -20001,
           'кол-во строк не корректное, найдено ' || cnt_ || ', в файле указано '||parse_row_txt(buffer, 2));
       end if;
       if to_number(parse_row_txt(buffer, 3))/100 <> summa_  then
          raise_application_error( -20001,
           'сумма не корректна€, найдено ' || summa_ || ', в файле указано '||parse_row_txt(buffer, 3)/100);
       end if;
       --выход, больше не ищем строк, если нашли итог
       exit;
     end if;
  end loop;
exception
  when no_data_found then
    null;
end;
  utl_file.fCLOSE(ft);
  commit;
end;

procedure load_file_dbf(p_dir in varchar2,
                      p_file in varchar2)
is
  p_show boolean;
  cnt_ number;
  i number;
  pos number;
  fname_ varchar2(100);
begin
  --получение dbf файла оплаты из ѕочты
  select nvl(count(*),0) into cnt_ from c_comps c, t_org o
    where c.nkom=init.get_nkom and c.fk_org=o.id
    and o.cd in ('ѕочта');
  if cnt_ = 0 then
    raise_application_error( -20001,
     'є  омпьютера не соответствует данному типу файлов');
  end if;

  --выдел€ем им€ файла из полного пути
  i:=1;
  pos:=1;
  while instr(p_file, '\',  1, i) <> 0
  loop
   pos:=instr(p_file, '\', 1, i);
   i:=i+1;
  end loop;
  fname_:=substr(p_file,pos+1, length(p_file)-pos);

  delete from load_tmp_post;
  p_show:=sys.diutil.int_to_bool(0);
  load_Table(p_dir, fname_, 'load_tmp_post', null, p_show);

  delete from load_bank t where t.nkom=init.get_nkom;
  insert into load_bank
   (dtek, lsk, lsk2, code, summa, dopl, dn, nkvit, nkom)
  select t.getd, lpad(trim(t.lc),8,'0'), trim(t.lc), decode(t.typep, 1, '01', '02'),
   t.summa,
   case when  utils.get_int_param('REJECT_PERIOD_BANK') = 0 then
        t.year||lpad(trim(t.month),2,'0')
      else
        init.get_period
      end
   , null, null, init.get_nkom
    from load_tmp_post t;
    commit;
end;

procedure load_file_dbf2(p_dir in varchar2,
                      p_file in varchar2)
is
  p_show boolean;
  cnt_ number;
  i number;
  pos number;
  fname_ varchar2(100);
begin
  --получение dbf файла оплаты из —бербанка
  select nvl(count(*),0) into cnt_ from c_comps c, t_org o
    where c.nkom=init.get_nkom and c.fk_org=o.id
    and o.cd in ('—бербанк');
  if cnt_ = 0 then
    raise_application_error( -20001,
     'є  омпьютера не соответствует данному типу файлов');
  end if;

  --выдел€ем им€ файла из полного пути
  i:=1;
  pos:=1;
  while instr(p_file, '\',  1, i) <> 0
  loop
   pos:=instr(p_file, '\', 1, i);
   i:=i+1;
  end loop;
  fname_:=substr(p_file,pos+1, length(p_file)-pos);

  delete from load_tmp_post2;
  p_show:=sys.diutil.int_to_bool(0);
  load_Table(p_dir, fname_, 'load_tmp_post2', null, p_show);

  delete from load_bank t where t.nkom=init.get_nkom;
  insert into load_bank
   (dtek, lsk, lsk2, code, summa, dopl, dn, nkvit, nkom)
  select t.dtek, lpad(trim(t.lsk),8,'0'), trim(t.lsk), '01',
   t.ska,
   case when  utils.get_int_param('REJECT_PERIOD_BANK') = 0 then
        substr(t.dopl,3,4)||substr(t.dopl,1,2)
      else
        init.get_period
      end,
   null, null, init.get_nkom
    from load_tmp_post2 t where nvl(t.ska,0) <> 0
   union all
  select t.dtek, lpad(trim(t.lsk),8,'0'), trim(t.lsk), '02',
   t.pn,
   case when  utils.get_int_param('REJECT_PERIOD_BANK') = 0 then
        substr(t.dopl,3,4)||substr(t.dopl,1,2)
      else
        init.get_period
      end,
   null, null, init.get_nkom
    from load_tmp_post2 t where nvl(t.pn,0) <> 0 ;
    commit;
end;

procedure load_other_file_dbf(p_dir in varchar2,
                      p_file in varchar2)
is
  p_show boolean;
  cnt_ number;
  i number;
  pos number;
  fname_ varchar2(100);
  tname_ varchar2(100);
begin
  --загрузка прочих dbf-ок
  --выдел€ем им€ файла из полного пути
  i:=1;
  pos:=1;
  while instr(p_file, '\',  1, i) <> 0
  loop
   pos:=instr(p_file, '\', 1, i);
   i:=i+1;
  end loop;
  fname_:=substr(p_file,pos+1, length(p_file)-pos);
  tname_:=substr(p_file,pos+1, length(p_file)-pos-4); --4- кол-во символов расширени€

  p_show:=sys.diutil.int_to_bool(0);
  execute immediate 'delete from '||tname_;
  load_Table(p_dir, fname_, tname_, null, p_show);

  commit;
end;


--обертка
procedure load_db(p_dir in varchar2,
                      isdel_ in number,
                      fname_ in varchar2,
                      tname_ in varchar2
                      ) is
begin
  --вызвать новую процедуру
  load_db(p_dir => p_dir, isdel_ => isdel_, fname_ => fname_, tname_ => tname_, p_is_comm => 1);

end;                      

--загрузка dbf                      
procedure load_db(p_dir in varchar2,
                      isdel_ in number,
                      fname_ in varchar2,
                      tname_ in varchar2,
                      p_is_comm in number --0-без коммита, 1-коммит
                      )
is
  p_show boolean;
  cnt_ number;
  i number;
  pos number;

begin
  p_show:=sys.diutil.int_to_bool(0);

  if nvl(isdel_,0) = 1 then --удаление записей из таблицы перед загрузкой
    execute immediate 'delete from '||tname_;
  elsif nvl(isdel_,0) = 2 then --truncate записей из таблицы перед загрузкой
    execute immediate 'truncate table '||tname_;
  end if;

  load_Table(p_dir, fname_, tname_, null, p_show);
  if nvl(p_is_comm,0) =1 then
    commit;
  end if;
end;

procedure load_Table( p_dir in varchar2, --директори€ Oracle, в которой искать файл
                      p_file in varchar2, --им€ файла, с расширением
                      p_tname in varchar2, --в какую таблицу грузить
                      p_cnames in varchar2 default NULL,
                      p_show in boolean default false --1-просто показать запрос в OUTPUT, 0 - загрузить
                       )
is
    l_bfile      bfile;
    l_offset  number default 1;
    l_hdr     dbf_header;
    l_flds    field_descriptor_array;
    l_row      rowArray;
    ii number;
begin
    l_bfile := bfilename( p_dir, p_file );
    dbms_lob.fileopen( l_bfile );

    get_header( l_bfile, l_offset, l_hdr, l_flds );

    if ( p_show )
    then
        show( l_hdr, l_flds, p_tname, p_cnames, l_bfile );
    else
        dbms_sql.parse( g_cursor,
                        build_insert(p_tname,p_cnames,l_flds),
                        dbms_sql.native );

        for i in 1 .. l_hdr.no_records loop
            ii:=i;
            l_row := get_row( l_bfile,
                              l_offset,
                              l_hdr,
                              l_flds );

            if ( l_row(0) <> '*' ) -- deleted record
            then
                for i in 1..l_hdr.no_fields loop
                    dbms_sql.bind_variable( g_cursor,
                                            ':bv'||i,
                                            convert(l_row(i),'CL8MSWIN1251','RU8PC866'),
                                            4000 );
                end loop;
                if ( dbms_sql.execute( g_cursor ) <> 1 )
                then
                    raise_application_error( -20001,
                                 'Insert failed ' || sqlerrm );
                end if;
            end if;
        end loop;
    end if;

    dbms_lob.fileclose( l_bfile );
exception
    when others then
        if ( dbms_lob.isopen( l_bfile ) > 0 ) then
            dbms_lob.fileclose( l_bfile );
        end if;
        if sqlcode in (-1722, -1438) then
          raise_application_error( -20001,
              '“аблица '||p_file||', в строке є' || ii ||',- ошибка');
        end if;
        RAISE;
end;

end;
/

prompt
prompt Creating package body EXT_PKG
prompt =============================
prompt
CREATE OR REPLACE PACKAGE BODY SCOTT.ext_pkg

IS
--ѕакет обмена с внешним сервером личного кабинета
--вызов из JOB:
--  begin
--
--   scott.ext_pkg.imp_vol_all;
--    scott.ext_pkg.exp_base(1, null, null);
--  end;
--дл€ того чтобы новый л.с. по€вилс€ в базе, необходимо
--чтобы отработали процедуры
--imp_vol_all
--exp_base(1, null, null)
--и оп€ть imp_vol_all (чтобы уже загрузить показани€ счетчиков



procedure exp_base(var_ in number, p_mg1 in params.period%type, p_mg2 in params.period%type)
is
 org_ t_org.id%type;
 cd_org_ t_org.cd%type;
 l_list u_list.id%type;
 l_cd_listtp u_listtp.cd%type;
 l_mg params.period%type;
 l_mg2 params.period%type;
 l_p_mg1 params.period%type;
 l_p_mg2 params.period%type;
 a number;
 l_cnt_new_lsk number;
-- type empcurtyp is ref cursor;
-- cur1 empcurtyp;

begin
begin

execute immediate'ALTER SESSION SET TIME_ZONE = ''+7:0''';

--≈∆≈дневный/ежеминутный экспорт базы,
--Ћ/—, показаний счетчиков
--на удаленную систему APEX
init.set_user;

if utils.get_int_param('HAVE_LK') = 0 then
 --≈сли отсутствует функци€ личного кабинета - выход
  logger.log_(null, 'Apex_new: - Ћичный кабинет не установлен,- обмен запрещен!');
  return;
end if;


select o.id, o.cd into org_, cd_org_
 from scott.t_org o, scott.t_org_tp tp
where tp.id=o.fk_orgtp and tp.cd='– ÷';

if ext_pkg.is_lst(cd_org_) = 1 and 
   c_charges.trg_proc_next_month = 0 then
  --или последние 2 дн€ мес€ца » не идЄт переход мес€ца!!!-  обмен запрещен!
  logger.log_(null, 'Apex_new: - база закрыта или последний день мес€ца,- обмен запрещен!');
  return;
end if;

--текущий период
select p.period into l_mg from scott.params p;

l_cd_listtp:='ѕараметры лиц.счета';

--тип параметра "пароль"
select u.id into l_list from scott.u_list u, scott.u_listtp tp
    where u.fk_listtp=tp.id
    and u.cd='pass'
    and tp.cd=l_cd_listtp;

--расчет долгов, пени по л/c
--выполн€ть - вначале (после приЄмки счетчиков), так как нетранзакционно (коммит внутри)
--и счетчики должны быть учтены
--####
if to_char(trunc(sysdate),'YYYYMM') <> l_mg then
  a:=scott.init.set_date(last_day(to_date(l_mg||'01','YYYYMMDD'))); --последн€€ дата текущего периода...
else
  a:=scott.init.set_date(trunc(sysdate)); --текуща€ дата...
end if;


--получаем кол-во л.с. необходимых дл€ обновлени€ (новых)
execute immediate 'select nvl(count(*),0)
   from scott.kart k where
     exists
    (select * from scott.t_objxpar x where x.fk_k_lsk=k.k_lsk_id --только там, где установлен параметр login-pass
     and x.fk_list=:l_list)
    and not exists
    (select * from t_obj@Apex t, t_org@Apex o, t_org@Apex o2 where t.lsk=k.lsk
      and t.fk_org=o2.id and o2.parent_id=o.id
      and o.cd=:cd_org_)'
      into l_cnt_new_lsk using l_list, cd_org_ ;

if p_mg1 is not null then
  --если заданы принудительно периоды загрузки архива
   l_p_mg1:=p_mg1;
   l_p_mg2:=p_mg2;
elsif l_cnt_new_lsk <> 0 then
  --если не заданы принудительно периоды загрузки архива,
  --но найдены новые л.с. (получившие пароль), по которым нужно загрузить архив
  execute immediate
    'select min(t.mg), max(t.mg) from t_mg@Apex t, t_org@Apex o, scott.params p
       where t.mg<>p.period and t.fk_org=o.id
       and o.cd=:cd_org_'
    into l_p_mg1, l_p_mg2 using cd_org_;
end if;

logger.log_(null, 'Apex_new: подготовка начислени€, задолжности по л/с-начало');
for c in (select k.lsk
 from scott.kart k, scott.t_org o where k.reu=o.reu and
   exists
  (select * from scott.t_objxpar x where x.fk_k_lsk=k.k_lsk_id --только там, где установлен параметр login-pass
   and x.fk_list=l_list))
loop --всЄ c коммитом, так как нет опасности потер€ть целостность информации по счетчикам!
  a:=scott.c_charges.gen_charges(c.lsk, c.lsk, null, null, 1, 0);
  scott.c_cpenya.gen_charge_pay(c.lsk, 1);
  scott.c_cpenya.gen_penya(c.lsk, 0, 1);

end loop;
logger.log_(null, 'Apex_new: подготовка начислени€, задолжности по л/с-окончание');
--####

if var_ = 1 then
  --экспорт улиц
  --только ежедневный обмен
  logger.log_(null, 'Apex_new: экспорт справочника улиц-начало');
  execute immediate 'delete from imp_street@apex t
   where t.cd_org=:cd_org_'
   using cd_org_;

  execute immediate 'insert into imp_street@apex
    (kul, cd_org, name)
  select
    t.id, :cd_org_, t.name
    from scott.spul t'
   using cd_org_;
  logger.log_(null, 'Apex_new: экспорт справочника улиц-окончание, отправлено строк: '||to_char(SQL%ROWCOUNT));


  --экспорт справочника услуг
  logger.log_(null, 'Apex_new: экспорт справочника услуг-начало');

  execute immediate 'delete from imp_usl@apex';
  execute immediate 'insert into imp_usl@apex
    (uslm, usl, kartw, kwni, lpw, ed_izm, nm, nm1, usl_p, sptarn, usl_type, usl_plr, usl_norm, typ_usl, usl_order, usl_type2, usl_subs, nm2, nm3, cd, npp, fk_calc_tp, uslg, counter, have_vvod, n_progs, fk_usl_pen, can_vv, is_iter, max_vol, fk_usl_chld)
  select uslm, usl, kartw, kwni, lpw, ed_izm, nm, nm1, usl_p, sptarn, usl_type, usl_plr, usl_norm, typ_usl, usl_order, usl_type2, usl_subs, nm2, nm3, cd, npp, fk_calc_tp, uslg, counter, have_vvod, n_progs, fk_usl_pen, can_vv, is_iter, max_vol, fk_usl_chld
   from scott.usl';

  logger.log_(null, 'Apex_new: экспорт справочника услуг-окончание, отправлено строк: '||to_char(SQL%ROWCOUNT));

  --экспорт справочника организаций
  logger.log_(null, 'Apex_new: экспорт справочника организаций-начало');

  execute immediate 'delete from imp_t_org@apex';
  execute immediate 'insert into imp_t_org@apex
    (id, cd, fk_orgtp, name, npp, v, parent_id, reu, trest, uch, adr,
     inn, manager, buh, raschet_schet, k_schet, kod_okonh, kod_ogrn,
     bik, phone, kpp, bank, id_exp, adr_recip, authorized_dir, authorized_buh,
     auth_dir_doc, auth_buh_doc, okpo, ver_cd, full_name, phone2, parent_id2, fk_org2, bank_cd, email)
  select id, cd, fk_orgtp, name, npp, v, parent_id, reu, trest, uch, adr,
  inn, manager, buh, raschet_schet, k_schet, kod_okonh, kod_ogrn, bik, phone,
  kpp, bank, id_exp, adr_recip, authorized_dir, authorized_buh, auth_dir_doc,
  auth_buh_doc, okpo, ver_cd, full_name, phone2, parent_id2, fk_org2, bank_cd, email
  from scott.t_org';

  logger.log_(null, 'Apex_new: экспорт справочника организаций-окончание, отправлено строк: '||to_char(SQL%ROWCOUNT));

  --экспорт типов организаций
  --только ежедневный обмен
  logger.log_(null, 'Apex_new: экспорт справочника типов организаций');
  execute immediate 'delete from imp_t_org_tp@apex t';

  execute immediate 'insert into imp_t_org_tp@apex
    (id, cd, name, npp, v, parent_id, type, menu_id, name_0, name_1, comm)
  select id, cd, name, npp, v, parent_id, type, menu_id, name_0, name_1, comm
    from scott.t_org_tp t';
  logger.log_(null, 'Apex_new: экспорт справочника типов организаций-окончание, отправлено строк: '||to_char(SQL%ROWCOUNT));

  --экспорт справочника компьютеров
  logger.log_(null, 'Apex_new: экспорт справочника компьютеров-начало');

  execute immediate 'delete from imp_c_comps@apex';
  execute immediate 'insert into imp_c_comps@apex
  (nkom, nink, nkvit, cd, fk_oper, fk_org)
  select nkom, nink, nkvit, cd, fk_oper, fk_org
    from scott.c_comps';
   logger.log_(null, 'Apex_new: экспорт справочника компьютеров-окончание, отправлено строк: '||to_char(SQL%ROWCOUNT));


  --только ежедневный обмен
  logger.log_(null, 'Apex_new: экспорт параметров LSK, K_LSK-начало');

    delete from scott.exp_kartxpar;
    insert into scott.exp_kartxpar
    (cd_org, fk_k_lsk, cd_list, s1, d1, n1, c1, pass)
    select cd_org_, k.fk_k_lsk, u.cd, k.s1, k.d1, k.n1, k.c1, k.pass
     from scott.t_objxpar k, scott.u_list u, scott.u_listtp tp where
     k.fk_list=u.id and u.fk_listtp=tp.id
     and tp.cd=l_cd_listtp
     and exists
    (select * from scott.t_objxpar x where x.fk_k_lsk=k.fk_k_lsk
     and x.fk_list=l_list); --только там, где установлен параметр login-pass

  execute immediate 'delete from imp_kartxpar@apex t
   where t.cd_org=:cd_org_'
   using cd_org_;
  execute immediate 'insert into imp_kartxpar@apex
    (cd_org, fk_k_lsk, cd_list, s1, d1, n1, c1, pass)
    select :cd_org_, fk_k_lsk, cd_list, s1, d1, n1, c1, pass
    from scott.exp_kartxpar t'
    using cd_org_;

  logger.log_(null, 'Apex_new: экспорт параметров LSK, K_LSK-окончание, отправлено строк: '||to_char(SQL%ROWCOUNT));

  logger.log_(null, 'Apex_new: экспорт наличи€ услуг-начало');
  delete from scott.exp_nabor;
  insert into scott.exp_nabor
   (lsk, cd_usl)
  select n.lsk, u.usl  from scott.kart k, scott.nabor n, scott.usl u
    where
    k.lsk = n.lsk and case
             when u.sptarn = 0 and nvl(n.koeff, 0) <> 0 then
              1 --определ€ем наличие услуги в л.с.
             when u.sptarn = 1 and nvl(n.norm, 0) <> 0 then
              1
             when u.sptarn = 2 and nvl(n.koeff, 0) <> 0 and nvl(n.norm, 0) <> 0 then
              1
             when u.sptarn = 3 and nvl(n.koeff, 0) <> 0 and nvl(n.norm, 0) <> 0 then
              1
             else
              0
           end = 1
    and n.usl=u.usl
    and case
    when u.cd = 'х.вода' and k.psch in (1,2) then 1
    when u.cd = 'г.вода' and k.psch in (1,3) then 1
    when u.cd = 'эл.энерг.' and k.psch not in (8,9) then 1
    when u.cd = 'эл.энерг.2' and k.psch not in (8,9) then 1
    else 0
    end =1
    and exists
    (select * from scott.t_objxpar x where x.fk_k_lsk=k.k_lsk_id
     and x.fk_list=l_list);

  execute immediate 'delete from imp_nabor@apex t
   where t.cd_org=:cd_org_'
   using cd_org_;

  execute immediate 'insert into imp_nabor@apex t
   (lsk, cd_org, cd_usl)
   select n.lsk, :cd_org_, n.cd_usl from scott.exp_nabor n'
   using cd_org_;
  logger.log_(null, 'Apex_new: экспорт наличи€ услуг-окончание, отправлено строк: '||to_char(SQL%ROWCOUNT));

   --текущие долги, с пенЄй на текущую дату
  --здесь должен быть где то расчЄт пени на текущий день...
  execute immediate 'delete from imp_debit@apex t';

  execute immediate 'insert into imp_debit@apex t
   (lsk, db, pn, chrg, pay, paypn, mg)
   select m.lsk, t.summa as db, t.penya as pn, c.summa as chrg,
     c2.summa as pay, c2.summap as pay_pen, m.mg
      from (
      select k.lsk, t.mg from scott.kart k, scott.long_table t
        where exists
        (select * from scott.t_objxpar x where x.fk_k_lsk=k.k_lsk_id
          and x.fk_list='||l_list||') --только там, где установлен параметр login-pass
      ) m,
      scott.c_penya t,
      scott.c_chargepay c, scott.c_chargepay c2
      where
      m.mg=c.mg(+) and m.lsk=c.lsk(+) and c.type(+)=0 and c.period(+)='''||l_mg||'''
      and m.mg=c2.mg(+) and m.lsk=c2.lsk(+) and c2.type(+)=1 and c2.period(+)='''||l_mg||'''
      and m.mg=t.mg1(+) and m.lsk=t.lsk(+)';
  logger.log_(null, 'Apex_new: загрузка движени€ по л/c-начало');

  --сперва чистим временные таблицы
  execute immediate 'delete from imp_a_charge@apex t';
  execute immediate 'delete from imp_a_change@apex t';
  execute immediate 'delete from imp_a_kwtp@apex t';
  --сперва текущее
  --начисление
  execute immediate 'insert into imp_a_charge@apex t
    (lsk, usl, summa, kart_pr_id, spk_id, type, test_opl, test_cena, test_tarkoef,
      test_spk_koef, main, mg, lg_doc_id, npp, sch)
    select t.lsk, t.usl, t.summa, t.kart_pr_id, t.spk_id, t.type, t.test_opl,
        t.test_cena, t.test_tarkoef,
        t.test_spk_koef, t.main, p.period as mg, t.lg_doc_id, t.npp, t.sch
        from scott.c_charge t, scott.params p
      where exists
        (select * from scott.t_objxpar x, scott.kart k where x.fk_k_lsk=k.k_lsk_id
          and k.lsk=t.lsk
          and x.fk_list=:l_list) --только там, где установлен параметр login-pass'
  using l_list;

  logger.log_(null, 'Apex_new: загрузка движени€ по л/c-1');

  --изменени€
  execute immediate 'insert into imp_a_change@apex t
    (lsk, usl, summa, proc, mgchange, nkom, org, type, dtek,
      ts, user_id, mg, doc_id, cnt_days, show_bill, id)
    select t.lsk, t.usl, t.summa, t.proc, t.mgchange, t.nkom, t.org, t.type, t.dtek,
      t.ts, t.user_id, p.period as mg, t.doc_id, t.cnt_days, t.show_bill, t.id
        from scott.c_change t, scott.params p
      where exists
        (select * from scott.t_objxpar x, scott.kart k where x.fk_k_lsk=k.k_lsk_id
          and k.lsk=t.lsk
          and x.fk_list=:l_list) --только там, где установлен параметр login-pass'
  using l_list;
  logger.log_(null, 'Apex_new: загрузка движени€ по л/c-2');
  --оплата
  execute immediate 'insert into imp_a_kwtp@apex t
    (lsk, summa, penya, oper, dopl, nink, nkom, dtek,
      nkvit, dat_ink, ts, id, mg, iscorrect, num_doc, dat_doc)
    select t.lsk, t.summa, t.penya, t.oper, t.dopl, t.nink, t.nkom, t.dtek,
      t.nkvit, t.dat_ink, t.ts, t.id, p.period as mg, t.iscorrect, t.num_doc, t.dat_doc
        from scott.c_kwtp t, scott.params p
      where exists
        (select * from scott.t_objxpar x, scott.kart k where x.fk_k_lsk=k.k_lsk_id
          and k.lsk=t.lsk
          and x.fk_list=:l_list) --только там, где установлен параметр login-pass'
  using l_list;
  logger.log_(null, 'Apex_new: загрузка движени€ по л/c-3');

  --затем архивное (если задано такое)
  l_mg2:=l_p_mg1;
  while l_mg2 <= l_p_mg2 and l_p_mg1 is not null --если задано архивное
  loop
    --начисление
      execute immediate 'insert into imp_a_charge@apex t
        (lsk, usl, summa, kart_pr_id, spk_id, type, test_opl, test_cena, test_tarkoef,
          test_spk_koef, main, mg, lg_doc_id, npp, sch)
        select t.lsk, t.usl, t.summa, t.kart_pr_id, t.spk_id, t.type, t.test_opl,
            t.test_cena, t.test_tarkoef,
            t.test_spk_koef, t.main, :p_mg as mg, t.lg_doc_id, t.npp, t.sch
            from scott.a_charge t
          where t.mg=:p_mg and exists
            (select * from scott.t_objxpar x, scott.kart k where x.fk_k_lsk=k.k_lsk_id
              and k.lsk=t.lsk
              and x.fk_list=:l_list) --только там, где установлен параметр login-pass'
    using l_mg2, l_mg2, l_list;
    --изменени€
    execute immediate 'insert into imp_a_change@apex t
      (lsk, usl, summa, proc, mgchange, nkom, org, type, dtek,
        ts, user_id, mg, doc_id, cnt_days, show_bill, id)
      select t.lsk, t.usl, t.summa, t.proc, t.mgchange, t.nkom, t.org, t.type, t.dtek,
        t.ts, t.user_id, :p_mg as mg, t.doc_id, t.cnt_days, t.show_bill, t.id
          from scott.a_change t
        where t.mg=:p_mg and exists
          (select * from scott.t_objxpar x, scott.kart k where x.fk_k_lsk=k.k_lsk_id
            and k.lsk=t.lsk
            and x.fk_list=:l_list) --только там, где установлен параметр login-pass'
     using l_mg2, l_mg2, l_list;
  --оплата
  execute immediate 'insert into imp_a_kwtp@apex t
    (lsk, summa, penya, oper, dopl, nink, nkom, dtek,
      nkvit, dat_ink, ts, id, mg, iscorrect, num_doc, dat_doc)
    select t.lsk, t.summa, t.penya, t.oper, t.dopl, t.nink, t.nkom, t.dtek,
      t.nkvit, t.dat_ink, t.ts, t.id, :p_mg as mg, t.iscorrect, t.num_doc, t.dat_doc
        from scott.a_kwtp t
      where t.mg=:p_mg and exists
        (select * from scott.t_objxpar x, scott.kart k where x.fk_k_lsk=k.k_lsk_id
          and k.lsk=t.lsk
          and x.fk_list=:l_list) --только там, где установлен параметр login-pass'
     using l_mg2, l_mg2, l_list;
  logger.log_(null, 'Apex_new: загрузка движени€ за период: '||l_mg2||' ќтправлено строк по оплате:'||to_char(SQL%ROWCOUNT));
  l_mg2:=to_char(add_months(to_date(l_mg2||'01','YYYYMMDD'), 1), 'YYYYMM');
  end loop;
  logger.log_(null, 'Apex_new: загрузка движени€ по л/c-окончание');
end if;

  --выполнение импорта на стороне Ћ 
  --#################################
  --#################################
  logger.log_(null, 'Apex_new: выполнение импорта на стороне Ћ -начало');
  --загрузить архивную информацию, если это необходимо
  if l_p_mg1 is not null then
    execute immediate 'begin imp_frm_base.imp_all@apex(:var_, :cd_org_, :l_p_mg1, :l_p_mg2); end;'
    using var_, cd_org_, l_p_mg1, l_p_mg2;
  end if;
  --и в любом случае загрузить текущую информацию
  execute immediate 'begin imp_frm_base.imp_all@apex(:var_, :cd_org_, null, null); end;'
  using var_, cd_org_;

  logger.log_(null, 'Apex_new: выполнение импорта на стороне Ћ -окончание');
  --#################################
  --#################################
logger.log_(null, 'Apex_new: ## - ќ ќЌ„јЌ»≈ ќЅћ≈Ќј');

execute immediate 'begin c_logger.cr_event@apex(:cd_org_,:cd_event, 0, :event_body); end;'
using cd_org_, '—инхронизаци€ с базой',
'ќ ќЌ„јЌ»≈ ќЅћ≈Ќј';

 exception when others then
  execute immediate 'begin c_logger.cr_event@apex(:cd_org_,:cd_event, 1, :event_body); end;'
  using cd_org_, '—инхронизаци€ с базой',
  'ќшибка при получении информации из Ћ : ERRcode - '||SQLCODE||' -ERRmsg- '||SQLERRM;
  logger.raiseError('ext_pkg.exp_base');
--  Raise;
end;
commit;
--закрыть DBLINK, чтобы не было ошибки ORA-02049: timeout: distributed transaction waiting for lock 
dbms_session.close_database_link('apex');
end;

procedure imp_vol_all is
 cd_org_ t_org.cd%type;
 l_cnt number;
begin
begin
--получение расхода по всем услугам/счетчикам из личного кабинета

execute immediate'ALTER SESSION SET TIME_ZONE = ''+7:0''';
select o.cd into cd_org_
 from scott.t_org o, scott.t_org_tp tp
where tp.id=o.fk_orgtp and tp.cd='– ÷';

logger.log_(null, 'Apex_new: ## - Ќј„јЋќ ќЅћ≈Ќј');

execute immediate 'begin c_logger.cr_event@apex(:cd_org_,:cd_event, 0, :event_body); end;'
using cd_org_, '—инхронизаци€ с базой', 'Ќј„јЋќ ќЅћ≈Ќј';

init.set_user;

if ext_pkg.is_lst(cd_org_) = 1 and c_charges.trg_proc_next_month = 0 then
  --или последние 2 дн€ мес€ца » не идЄт переход мес€ца!!!-  обмен запрещен!
  logger.log_(null, 'Apex_new: - база закрыта или последний день мес€ца,- обмен запрещен!');
  return;
end if;

logger.log_(null, 'Apex_new: импорт расхода по счетчикам-начало');

--подготовка к выгрузке объемов на стороне Ћ 
execute immediate 'begin exp_to_base.exp_sch_vol@apex(:cd_org_); end;'
using cd_org_;

--загрузка расходов в промежуточную таблицу
delete from scott.imp_sch_vol t;

select nvl(count(*),0) into l_cnt from
  scott.imp_sch_vol;

if l_cnt <> 0 then
  logger.log_(null, 'Apex_new: ¬Ќ»ћјЌ»≈! scott.imp_sch_vol не почищен - ќЅћ≈Ќ ѕ–≈ –јў≈Ќ!');
  return;
end if;

execute immediate 'insert into scott.imp_sch_vol t
 (lsk, cd_usl, vol)
 select t.lsk, t.cd_usl, t.vol from exp_sch_vol@apex t
  where t.cd_org=:cd_org_'
 using cd_org_;


--выбираютс€ только те услуги по которым заполнено поле COUNTER

for c in (select nvl(count(*),0) as cnt from scott.imp_sch_vol t) loop
    if c.cnt > 0 then 
      --есть объемы
      for c in (select u.usl from scott.usl u where trim(u.counter) is not null
         )
      loop
       --обновление расходов в kart
       imp_vol_usl(c.usl);
      end loop;
    else
      logger.log_(null, 'Apex_new: объемов счетчиков из Ћ -Ќ≈“');
    end if;      
  end loop;

--установка флага прин€ти€ объемов счетчиков
--выполн€етс€ позже в exp_base!!! (иначе пустые значени€ в Ћ !)
--execute immediate 'begin exp_to_base.acpt_sch_vol@apex(:cd_org_); end;'
--using cd_org_;

 --тут же отправл€ем новые показани€ в Ћ , делаем коммит
 exp_vol_all;
exception when others then
  execute immediate 'begin c_logger.cr_event@apex(:cd_org_,:cd_event, 1, :event_body); end;'
  using cd_org_, '—инхронизаци€ с базой',
  'ќшибка при получении информации из Ћ : в строке: ERRcode - '||SQLCODE||' -ERRmsg- '||SQLERRM;
--  Raise;
  rollback;  --добавил 12.11.2015
  logger.raiseError('ext_pkg.imp_vol_all');
end;
 --коммит
commit;

--«десь это нельз€ ставить, так как выполн€етс€ не€вный коммит, и чиститс€ темпова€ таблица
--закрыть DBLINK, чтобы не было ошибки ORA-02049: timeout: distributed transaction waiting for lock 
--dbms_session.close_database_link('apex');

logger.log_(null, 'Apex_new: импорт расхода по счетчикам-окончание');
end;

procedure exp_vol_all is
 l_list u_list.id%type;
 l_cd_listtp u_listtp.cd%type;
 cd_org_ t_org.cd%type;
begin
begin
--экспорт л/с, показаний счетчиков (ежедневный и так же и ежеминутный обмен)
--пришлось выгружать в промежуточную таблицу, после чего
--уже отправл€ть на удаленный сервер
--(на пр€мую не получилось из за искажени€ кодировки при использовании
--конструкции case when ....

l_cd_listtp:='ѕараметры лиц.счета';
select o.cd into cd_org_
 from scott.t_org o, scott.t_org_tp tp
where tp.id=o.fk_orgtp and tp.cd='– ÷';

if ext_pkg.is_lst(cd_org_) = 1 and c_charges.trg_proc_next_month = 0 then
  --или последние 2 дн€ мес€ца » не идЄт переход мес€ца!!!-  обмен запрещен!
  logger.log_(null, 'Apex_new: - база закрыта или последний день мес€ца,- обмен запрещен!');
  return;
end if;

--тип параметра "пароль"
select u.id into l_list from scott.u_list u, scott.u_listtp tp
    where u.fk_listtp=tp.id
    and u.cd='pass'
    and tp.cd=l_cd_listtp;

logger.log_(null, 'Apex_new: экспорт домов-начало');
--экспорт домов
delete from scott.exp_c_houses;
insert into scott.exp_c_houses
  (id, reu, kul, nd, k_lsk_id, cd_org)
select k.id, k.reu, k.kul, k.nd, k.k_lsk_id, o.cd as cd_org
 from scott.c_houses k, scott.t_org o where k.reu=o.reu;

execute immediate 'delete from imp_c_houses@apex t';

execute immediate 'insert into imp_c_houses@apex t
(id, reu, kul, nd, k_lsk_id, cd_org)
select k.id, k.reu, k.kul, k.nd, k.k_lsk_id, k.cd_org
 from scott.exp_c_houses k';
logger.log_(null, 'Apex_new: экспорт домов-окончание');


logger.log_(null, 'Apex_new: экспорт л/с, показаний счетчиков-начало');

delete from scott.exp_kart;
insert into scott.exp_kart t
(k_lsk_id, lsk, cd_org, kul, nd, kw, phw, mhw, pgw, mgw, pel, mel, psch, cd_lsk_tp)
select k.k_lsk_id, k.lsk, o.cd, k.kul,
 k.nd, k.kw,
 k.phw, k.mhw, k.pgw, k.mgw, k.pel, k.mel, k.psch, tp.cd as cd_lsk_tp
 from scott.kart k, scott.t_org o, scott.v_lsk_tp tp where k.reu=o.reu and k.fk_tp=tp.id
   and exists
  (select * from scott.t_objxpar x where x.fk_k_lsk=k.k_lsk_id --только там, где установлен параметр login-pass
   and x.fk_list=l_list);

execute immediate 'delete from imp_kart@apex t';

execute immediate 'insert into imp_kart@apex t
(k_lsk_id, lsk, cd_org, kul, nd, kw, phw, mhw, pgw, mgw, pel, mel, psch, cd_lsk_tp)
select k.k_lsk_id, k.lsk, k.cd_org, k.kul,
 k.nd, k.kw,
 k.phw, k.mhw, k.pgw, k.mgw, k.pel, k.mel, k.psch, k.cd_lsk_tp
 from scott.exp_kart k';

logger.log_(null, 'Apex_new: экспорт л/с, показаний счетчиков-окончание, отправлено строк: '||to_char(SQL%ROWCOUNT));

logger.log_(null, 'Apex_new: выполнение импорта счетчиков на стороне Ћ -начало');
execute immediate 'begin imp_frm_base.imp_sch_cnt@apex(:cd_org_); end;'
using cd_org_;
logger.log_(null, 'Apex_new: выполнение импорта счетчиков на стороне Ћ -окончание');

  --сделать отметку, с проверкой наличи€ записей в imp_sch_vol
  for c in (select nvl(count(*),0) as cnt from scott.imp_sch_vol t) loop
    if c.cnt > 0 then 
      logger.log_(null, 'Apex_new: отметка о завершении приема счетчиков на стороне Ћ -начало');
      execute immediate 'begin exp_to_base.acpt_sch_vol@apex(:cd_org_); end;'
      using cd_org_;
      logger.log_(null, 'Apex_new: отметка о завершении приема счетчиков на стороне Ћ -окончание');
    else
      logger.log_(null, 'Apex_new: отметка о завершении приема счетчиков Ќ≈ ¬џѕќЋЌ»Ћј—№, так как нет объемов счетчиков из Ћ ');
    end if;      
  end loop;

exception when others then
  execute immediate 'begin c_logger.cr_event@apex(:cd_org_,:cd_event, 1, :event_body); end;'
  using cd_org_, '—инхронизаци€ с базой',
  'ќшибка при экспорте информации в Ћ : в строке: ERRcode - '||SQLCODE||' -ERRmsg- '||SQLERRM;
--  Raise;
  logger.raiseError('ext_pkg.exp_vol_all');
end;
end;

procedure imp_vol_usl(cd_usl_ in usl.cd%type) is
 fld_ usl.counter%type;
 l_usl_name usl.nm%type;
begin
--получение расхода по услуге/счетчику из Ћ 
if utils.get_int_param('HAVE_LK') = 0 then
 --≈сли отсутствует функци€ личного кабинета - выход
  logger.log_(null, 'Apex_new: - Ћичный кабинет не установлен,- обмен запрещен!');
  return;
end if;


select
   u.counter, trim(u.nm) into fld_, l_usl_name
  from scott.usl u where u.usl=cd_usl_;

--проверка на повторный ввод расхода по л/c
logger.log_(null, 'Apex_new: - проверка на повторный ввод расхода по л/c');
for c in (select distinct s.lsk as lsk from scott.imp_sch_vol s,
  scott.t_objxpar t, scott.u_list u, scott.params p
  where t.ts between to_date(p.period||'01','YYYYMMDD') and
  last_day(to_date(p.period||'01','YYYYMMDD'))
  and t.fk_list=u.id
  and u.cd='ins_vol_sch'
  and t.fk_usl=cd_usl_
  and s.cd_usl=cd_usl_
  and s.lsk=t.fk_lsk
)
loop
  logger.log_(null, 'Apex_new: - ѕ–≈ƒ”ѕ–≈∆ƒ≈Ќ»≈, по л/c:'||c.lsk||', услуге:'||cd_usl_||':'||trim(l_usl_name)||' в текущем периоде уже был введен расход!');
end loop;

execute immediate 'update scott.kart x
 set x.'||fld_||' = nvl(x.'||fld_||',0) +
  (select nvl(t.vol,0) from scott.imp_sch_vol t
    where t.lsk=x.lsk
    and t.cd_usl=:cd_usl_
    )
  where exists
  (select * from scott.imp_sch_vol t
    where t.lsk=x.lsk
    and t.cd_usl=:cd_usl_
    )'
using cd_usl_,cd_usl_;

for c in (select s.lsk, s.cd_usl, s.vol from scott.imp_sch_vol s where s.cd_usl=cd_usl_)
loop
  logger.log_(null, 'Apex_new: по л/c:'||c.lsk||', услуге:'||cd_usl_||':'||trim(l_usl_name)||' получен объем:'||c.vol);
end loop;

end;

function is_lst(p_cd_org in varchar2) return number is
 l_ret number;
begin
--исполн€етс€ функци€ на стороне Apex, возвращаетс€ значение
execute immediate 'begin 
                    :l_ret:=proc.is_lst_day@apex(:cd_org_, -1);
                   end;'
using out l_ret, in p_cd_org;
return l_ret;
end; 

procedure fill_table is
cnt_ number;
dat_ date;
a number;
begin
--тестова€ процедура проверки dblink на mysql
--закомментировал, иначе не компилируетс€
/*
while true
loop
  delete from "test2"@mysql;

  a:=0;
  for c in (select t.id, t.fio as name from c_kart_pr t)
  loop

  insert into "test2"@mysql ("id", "Name")
   values (c.id, c.name);

  a:=a+1;
  if a = 100 then
    select max(t."id")+1 into cnt_ from "par"@mysql t;
    dat_:=sysdate;
    insert into "par"@mysql ("id", "d1")
     values (cnt_, dat_);
  a:=0;
  end if;

  end loop;
  commit;

end loop;
*/
null;
end fill_table;

END ext_pkg;
/

prompt
prompt Creating package body EXT_PKG_NEW
prompt =================================
prompt
CREATE OR REPLACE PACKAGE BODY SCOTT.ext_pkg_new

IS
--ѕакет обмена с внешним сервером личного кабинета
--вызов из JOB:
--  begin
--
--   scott.ext_pkg_new.imp_vol_all;
--    scott.ext_pkg_new.exp_base(1, null, null);
--  end;
--дл€ того чтобы новый л.с. по€вилс€ в базе, необходимо
--чтобы отработали процедуры
--imp_vol_all
--exp_base(1, null, null)
--и оп€ть imp_vol_all (чтобы уже загрузить показани€ счетчиков



procedure exp_base(var_ in number, p_mg1 in params.period%type, p_mg2 in params.period%type)
is
 org_ t_org.id%type;
 cd_org_ t_org.cd%type;
-- l_list u_list.id%type;
 l_cd_listtp u_listtp.cd%type;
 l_mg params.period%type;
 l_mg2 params.period%type;
 l_p_mg1 params.period%type;
 l_p_mg2 params.period%type;
 a number;
 l_cnt_new_lsk number;
-- type empcurtyp is ref cursor;
-- cur1 empcurtyp;

begin
begin

execute immediate'ALTER SESSION SET TIME_ZONE = ''+7:0''';

--≈∆≈дневный/ежеминутный экспорт базы,
--Ћ/—, показаний счетчиков
--на удаленную систему APEX
init.set_user;

if utils.get_int_param('HAVE_LK') = 0 then
 --≈сли отсутствует функци€ личного кабинета - выход
  logger.log_(null, 'Apex_new: - Ћичный кабинет не установлен,- обмен запрещен!');
  return;
end if;


select o.id, o.cd into org_, cd_org_
 from scott.t_org o, scott.t_org_tp tp
where tp.id=o.fk_orgtp and tp.cd='– ÷';

if ext_pkg_new.is_lst(cd_org_) = 1 and
   c_charges.trg_proc_next_month = 0 then
  --или последние 2 дн€ мес€ца » не идЄт переход мес€ца!!!-  обмен запрещен!
  logger.log_(null, 'Apex_new: - база закрыта или последний день мес€ца,- обмен запрещен!');
  return;
end if;

--текущий период
select p.period into l_mg from scott.params p;

l_cd_listtp:='ѕараметры лиц.счета';

--тип параметра "пароль"
/*select u.id into l_list from scott.u_list u, scott.u_listtp tp
    where u.fk_listtp=tp.id
    and u.cd='pass'
    and tp.cd=l_cd_listtp;*/

--расчет долгов, пени по л/c
--выполн€ть - вначале (после приЄмки счетчиков), так как нетранзакционно (коммит внутри)
--и счетчики должны быть учтены
--####
if to_char(trunc(sysdate),'YYYYMM') <> l_mg then
  a:=scott.init.set_date(last_day(to_date(l_mg||'01','YYYYMMDD'))); --последн€€ дата текущего периода...
else
  a:=scott.init.set_date(trunc(sysdate)); --текуща€ дата...
end if;


--получаем кол-во л.с. необходимых дл€ обновлени€ (новых)
execute immediate 'select nvl(count(*),0)
   from scott.kart k where
/*     exists
    (select * from scott.t_objxpar x where x.fk_k_lsk=k.k_lsk_id --только там, где установлен параметр login-pass  --”Ѕ–јЋ Ё“ќ –ед. 12.12.2014
     and x.fk_list=:l_list)
    and */not exists
    (select * from t_obj@Apex_new t, t_org@Apex_new o, t_org@Apex_new o2 where t.lsk=k.lsk
      and t.fk_org=o2.id and o2.parent_id=o.id
      and o.cd=:cd_org_)'
      into l_cnt_new_lsk using cd_org_ ;

if p_mg1 is not null then
  --если заданы принудительно периоды загрузки архива
   l_p_mg1:=p_mg1;
   l_p_mg2:=p_mg2;
elsif l_cnt_new_lsk <> 0 and 1=2 then  --пока отключил такую возможность, так как всегда грузитс€ вс€ база! ред. 20.12.14
  --если не заданы принудительно периоды загрузки архива,
  --но найдены новые л.с. (получившие пароль), по которым нужно загрузить архив
  execute immediate
    'select min(t.mg), max(t.mg) from t_mg@Apex_new t, t_org@Apex_new o, scott.params p
       where t.mg<>p.period and t.fk_org=o.id
       and o.cd=:cd_org_'
    into l_p_mg1, l_p_mg2 using cd_org_;
end if;

logger.log_(null, 'Apex_new: подготовка начислени€, задолжности по л/с-начало');
logger.log_(null, 'Apex_new: ќ“„ Ћё„≈Ќј ѕќƒ√ќ“ќ¬ ј Ќј„»—Ћ≈Ќ»я!!!!!!!!!!!');

for c in (select k.lsk
 from scott.kart k, scott.t_org o where k.reu=o.reu
/*   exists
  (select * from scott.t_objxpar x where x.fk_k_lsk=k.k_lsk_id --только там, где установлен параметр login-pass --”Ѕ–јЋ Ё“ќ –ед. 12.12.2014
   and x.fk_list=l_list) */
   )
loop --всЄ c коммитом, так как нет опасности потер€ть целостность информации по счетчикам!
/*  a:=scott.c_charges.gen_charges(c.lsk, c.lsk, null, null, 1, 0);
  scott.c_cpenya.gen_charge_pay(c.lsk, 1);
  scott.c_cpenya.gen_penya(c.lsk, 0, 1);
*/
null;
end loop;
logger.log_(null, 'Apex_new: подготовка начислени€, задолжности по л/с-окончание');
--####

if var_ = 1 then
  --экспорт улиц
  --только ежедневный обмен
  logger.log_(null, 'Apex_new: экспорт справочника улиц-начало');
  execute immediate 'delete from imp_street@Apex_new t
   where t.cd_org=:cd_org_'
   using cd_org_;

  execute immediate 'insert into imp_street@Apex_new
    (kul, cd_org, name)
  select
    t.id, :cd_org_, t.name
    from scott.spul t'
   using cd_org_;
  logger.log_(null, 'Apex_new: экспорт справочника улиц-окончание, отправлено строк: '||to_char(SQL%ROWCOUNT));


  --экспорт справочника услуг
  logger.log_(null, 'Apex_new: экспорт справочника услуг-начало');

  execute immediate 'delete from imp_usl@Apex_new';
  execute immediate 'insert into imp_usl@Apex_new
    (uslm, usl, kartw, kwni, lpw, ed_izm, nm, nm1, usl_p, sptarn, usl_type, usl_plr, usl_norm, typ_usl, usl_order, usl_type2, usl_subs, nm2, nm3, cd, npp, fk_calc_tp, uslg, counter, have_vvod, n_progs, fk_usl_pen, can_vv, is_iter, max_vol, fk_usl_chld)
  select uslm, usl, kartw, kwni, lpw, ed_izm, nm, nm1, usl_p, sptarn, usl_type, usl_plr, usl_norm, typ_usl, usl_order, usl_type2, usl_subs, nm2, nm3, cd, npp, fk_calc_tp, uslg, counter, have_vvod, n_progs, fk_usl_pen, can_vv, is_iter, max_vol, fk_usl_chld
   from scott.usl';

  logger.log_(null, 'Apex_new: экспорт справочника услуг-окончание, отправлено строк: '||to_char(SQL%ROWCOUNT));

  --экспорт справочника организаций
  logger.log_(null, 'Apex_new: экспорт справочника организаций-начало');

  execute immediate 'delete from imp_t_org@Apex_new';
  execute immediate 'insert into imp_t_org@Apex_new
    (id, cd, fk_orgtp, name, npp, v, parent_id, reu, trest, uch, adr,
     inn, manager, buh, raschet_schet, k_schet, kod_okonh, kod_ogrn,
     bik, phone, kpp, bank, id_exp, adr_recip, authorized_dir, authorized_buh,
     auth_dir_doc, auth_buh_doc, okpo, ver_cd, full_name, phone2, parent_id2, fk_org2, bank_cd, email)
  select id, cd, fk_orgtp, name, npp, v, parent_id, reu, trest, uch, adr,
  inn, manager, buh, raschet_schet, k_schet, kod_okonh, kod_ogrn, bik, phone,
  kpp, bank, id_exp, adr_recip, authorized_dir, authorized_buh, auth_dir_doc,
  auth_buh_doc, okpo, ver_cd, full_name, phone2, parent_id2, fk_org2, bank_cd, email
  from scott.t_org';

  logger.log_(null, 'Apex_new: экспорт справочника организаций-окончание, отправлено строк: '||to_char(SQL%ROWCOUNT));

  --экспорт типов организаций
  --только ежедневный обмен
  logger.log_(null, 'Apex_new: экспорт справочника типов организаций');
  execute immediate 'delete from imp_t_org_tp@Apex_new t';

  execute immediate 'insert into imp_t_org_tp@Apex_new
    (id, cd, name, npp, v, parent_id, type, menu_id, name_0, name_1, comm)
  select id, cd, name, npp, v, parent_id, type, menu_id, name_0, name_1, comm
    from scott.t_org_tp t';
  logger.log_(null, 'Apex_new: экспорт справочника типов организаций-окончание, отправлено строк: '||to_char(SQL%ROWCOUNT));

  --экспорт справочника компьютеров
  logger.log_(null, 'Apex_new: экспорт справочника компьютеров-начало');

  execute immediate 'delete from imp_c_comps@Apex_new';
  execute immediate 'insert into imp_c_comps@Apex_new
  (nkom, nink, nkvit, cd, fk_oper, fk_org)
  select nkom, nink, nkvit, cd, fk_oper, fk_org
    from scott.c_comps';
   logger.log_(null, 'Apex_new: экспорт справочника компьютеров-окончание, отправлено строк: '||to_char(SQL%ROWCOUNT));


  --только ежедневный обмен
  logger.log_(null, 'Apex_new: экспорт параметров LSK, K_LSK-начало');

    delete from scott.exp_kartxpar;
    insert into scott.exp_kartxpar
    (cd_org, fk_k_lsk, cd_list, s1, d1, n1, c1, pass)
    select cd_org_, k.fk_k_lsk, u.cd, k.s1, k.d1, k.n1, k.c1, k.pass
     from scott.t_objxpar k, scott.u_list u, scott.u_listtp tp where
     k.fk_list=u.id and u.fk_listtp=tp.id
     and tp.cd=l_cd_listtp
/*     and exists
    (select * from scott.t_objxpar x where x.fk_k_lsk=k.fk_k_lsk --только там, где установлен параметр login-pass  --”Ѕ–јЋ Ё“ќ –ед. 12.12.2014
     and x.fk_list=l_list)*/
     ;

  execute immediate 'delete from imp_kartxpar@Apex_new t
   where t.cd_org=:cd_org_'
   using cd_org_;
  execute immediate 'insert into imp_kartxpar@Apex_new
    (cd_org, fk_k_lsk, cd_list, s1, d1, n1, c1, pass)
    select :cd_org_, fk_k_lsk, cd_list, s1, d1, n1, c1, pass
    from scott.exp_kartxpar t'
    using cd_org_;

  logger.log_(null, 'Apex_new: экспорт параметров LSK, K_LSK-окончание, отправлено строк: '||to_char(SQL%ROWCOUNT));

  logger.log_(null, 'Apex_new: экспорт наличи€ услуг-начало');
  delete from scott.exp_nabor;
  insert into scott.exp_nabor
   (lsk, cd_usl)
  select n.lsk, u.usl  from scott.kart k, scott.nabor n, scott.usl u
    where
    k.lsk = n.lsk and case
             when u.sptarn = 0 and nvl(n.koeff, 0) <> 0 then
              1 --определ€ем наличие услуги в л.с.
             when u.sptarn = 1 and nvl(n.norm, 0) <> 0 then
              1
             when u.sptarn = 2 and nvl(n.koeff, 0) <> 0 and nvl(n.norm, 0) <> 0 then
              1
             when u.sptarn = 3 and nvl(n.koeff, 0) <> 0 and nvl(n.norm, 0) <> 0 then
              1
             else
              0
           end = 1
    and n.usl=u.usl
    and case
    when u.cd = 'х.вода' and k.psch in (1,2) then 1
    when u.cd = 'г.вода' and k.psch in (1,3) then 1
    when u.cd = 'эл.энерг.' and k.psch not in (8,9) then 1
    when u.cd = 'эл.энерг.2' and k.psch not in (8,9) then 1
    else 0
    end =1
/*    and exists
    (select * from scott.t_objxpar x where x.fk_k_lsk=k.k_lsk_id
     and x.fk_list=l_list)*/ --”Ѕ–јЋ Ё“ќ –ед. 12.12.2014
     ;

  execute immediate 'delete from imp_nabor@Apex_new t
   where t.cd_org=:cd_org_'
   using cd_org_;

  execute immediate 'insert into imp_nabor@Apex_new t
   (lsk, cd_org, cd_usl)
   select n.lsk, :cd_org_, n.cd_usl from scott.exp_nabor n'
   using cd_org_;
  logger.log_(null, 'Apex_new: экспорт наличи€ услуг-окончание, отправлено строк: '||to_char(SQL%ROWCOUNT));

  logger.log_(null, 'Apex_new: загрузка текущих долгов по л/c-начало');
   --текущие долги, с пенЄй на текущую дату
  --здесь должен быть где то расчЄт пени на текущий день...
  execute immediate 'delete from imp_debit@Apex_new t';

  execute immediate 'insert into imp_debit@Apex_new t
   (lsk, db, pn, chrg, pay, paypn, mg)
   select m.lsk, t.summa as db, t.penya as pn, c.summa as chrg,
     c2.summa as pay, c2.summap as pay_pen, m.mg
      from (
      select k.lsk, t.mg from scott.kart k, scott.long_table t
/*        where exists
        (select * from scott.t_objxpar x where x.fk_k_lsk=k.k_lsk_id
          and x.fk_list=)*/  --только там, где установлен параметр login-pass --”Ѕ–јЋ Ё“ќ –ед. 12.12.2014
      ) m,
      scott.c_penya t,
      scott.c_chargepay c, scott.c_chargepay c2
      where
      m.mg=c.mg(+) and m.lsk=c.lsk(+) and c.type(+)=0 and c.period(+)='''||l_mg||'''
      and m.mg=c2.mg(+) and m.lsk=c2.lsk(+) and c2.type(+)=1 and c2.period(+)='''||l_mg||'''
      and m.mg=t.mg1(+) and m.lsk=t.lsk(+)';
  logger.log_(null, 'Apex_new: загрузка текущих долгов по л/c-окончание');

  logger.log_(null, 'Apex_new: загрузка движени€ по л/c-начало');

  --сперва чистим временные таблицы
  execute immediate 'delete from imp_a_charge@Apex_new t';
  execute immediate 'delete from imp_a_change@Apex_new t';
  execute immediate 'delete from imp_a_kwtp@Apex_new t';
  execute immediate 'delete from imp_xitog3_lsk@Apex_new t';
  --сперва текущее
  --начисление
  execute immediate 'insert into imp_a_charge@Apex_new t
    (lsk, usl, summa, kart_pr_id, spk_id, type, test_opl, test_cena, test_tarkoef,
      test_spk_koef, main, mg, lg_doc_id, npp, sch)
    select t.lsk, t.usl, t.summa, t.kart_pr_id, t.spk_id, t.type, t.test_opl,
        t.test_cena, t.test_tarkoef,
        t.test_spk_koef, t.main, p.period as mg, t.lg_doc_id, t.npp, t.sch
        from scott.c_charge t, scott.params p';
/*      where exists
        (select * from scott.t_objxpar x, scott.kart k where x.fk_k_lsk=k.k_lsk_id
          and k.lsk=t.lsk
          and x.fk_list=:l_list)*/ --только там, где установлен параметр login-pass  --”Ѕ–јЋ Ё“ќ –ед. 12.12.2014'
--  using l_list;

  logger.log_(null, 'Apex_new: загрузка движени€ по л/c-1');

  --изменени€
  execute immediate 'insert into imp_a_change@Apex_new t
    (lsk, usl, summa, proc, mgchange, nkom, org, type, dtek,
      ts, user_id, mg, doc_id, cnt_days, show_bill, id)
    select t.lsk, t.usl, t.summa, t.proc, t.mgchange, t.nkom, t.org, t.type, t.dtek,
      t.ts, t.user_id, p.period as mg, t.doc_id, t.cnt_days, t.show_bill, t.id
        from scott.c_change t, scott.params p';
/*      where exists
        (select * from scott.t_objxpar x, scott.kart k where x.fk_k_lsk=k.k_lsk_id
          and k.lsk=t.lsk
          and x.fk_list=:l_list)*/ --только там, где установлен параметр login-pass --”Ѕ–јЋ Ё“ќ –ед. 12.12.2014'
--  using l_list;
  logger.log_(null, 'Apex_new: загрузка движени€ по л/c-2');
  --оплата
  execute immediate 'insert into imp_a_kwtp@Apex_new t
    (lsk, summa, penya, oper, dopl, nink, nkom, dtek,
      nkvit, dat_ink, ts, id, mg, iscorrect, num_doc, dat_doc)
    select t.lsk, t.summa, t.penya, t.oper, t.dopl, t.nink, t.nkom, t.dtek,
      t.nkvit, t.dat_ink, t.ts, t.id, p.period as mg, t.iscorrect, t.num_doc, t.dat_doc
        from scott.c_kwtp t, scott.params p';
--  using l_list;
  logger.log_(null, 'Apex_new: загрузка движени€ по л/c-3');


/*  logger.log_(null, 'Apex_new: загрузка оборотки xitog3 по л/c-начало');
  execute immediate 'insert into imp_xitog3_lsk@Apex_new
    (lsk, org, uslm, usl, status, indebet, inkredit, charges, changes, subsid,
    payment, pn, outdebet, outkredit, mg, privs, privs_city, ch_full, changes2, pcharges)
    select lsk, t.org, t.uslm, t.usl, t.status, t.indebet, t.inkredit, t.charges, t.changes, t.subsid, t.
      payment, t.pn, t.outdebet, t.outkredit, t.mg, t.privs, t.privs_city, t.ch_full, t.changes2, t.pcharges
    from scott.xitog3_lsk t, scott.params p where t.mg=p.period';
  logger.log_(null, 'Apex_new: загрузка оборотки xitog3 по л/c-окончание, передано строк='||sql%rowcount);
*/
  --затем архивное (если задано такое)
  l_mg2:=l_p_mg1;
  while l_mg2 <= l_p_mg2 and l_p_mg1 is not null --если задано архивное
  loop
    --начисление
      execute immediate 'insert into imp_a_charge@Apex_new t
        (lsk, usl, summa, kart_pr_id, spk_id, type, test_opl, test_cena, test_tarkoef,
          test_spk_koef, main, mg, lg_doc_id, npp, sch)
        select t.lsk, t.usl, t.summa, t.kart_pr_id, t.spk_id, t.type, t.test_opl,
            t.test_cena, t.test_tarkoef,
            t.test_spk_koef, t.main, :p_mg as mg, t.lg_doc_id, t.npp, t.sch
            from scott.a_charge t
            where t.mg=:p_mg'
    using l_mg2, l_mg2;
    --изменени€
    execute immediate 'insert into imp_a_change@Apex_new t
      (lsk, usl, summa, proc, mgchange, nkom, org, type, dtek,
        ts, user_id, mg, doc_id, cnt_days, show_bill, id)
      select t.lsk, t.usl, t.summa, t.proc, t.mgchange, t.nkom, t.org, t.type, t.dtek,
        t.ts, t.user_id, :p_mg as mg, t.doc_id, t.cnt_days, t.show_bill, t.id
          from scott.a_change t
        where t.mg=:p_mg'
     using l_mg2, l_mg2;
  --оплата
  execute immediate 'insert into imp_a_kwtp@Apex_new t
    (lsk, summa, penya, oper, dopl, nink, nkom, dtek,
      nkvit, dat_ink, ts, id, mg, iscorrect, num_doc, dat_doc)
    select t.lsk, t.summa, t.penya, t.oper, t.dopl, t.nink, t.nkom, t.dtek,
      t.nkvit, t.dat_ink, t.ts, t.id, :p_mg as mg, t.iscorrect, t.num_doc, t.dat_doc
        from scott.a_kwtp t
      where t.mg=:p_mg'
     using l_mg2, l_mg2;
  logger.log_(null, 'Apex_new: загрузка движени€ за период: '||l_mg2||' ќтправлено строк по оплате:'||to_char(SQL%ROWCOUNT));

  logger.log_(null, 'Apex_new: загрузка оборотки xitog3 по л/c-начало');
  execute immediate 'insert into imp_xitog3_lsk@Apex_new
    (lsk, org, uslm, usl, status, indebet, inkredit, charges, changes, subsid,
    payment, pn, outdebet, outkredit, mg, privs, privs_city, ch_full, changes2, pcharges)
    select lsk, t.org, t.uslm, t.usl, t.status, t.indebet, t.inkredit, t.charges, t.changes, t.subsid, t.
      payment, t.pn, t.outdebet, t.outkredit, t.mg, t.privs, t.privs_city, t.ch_full, t.changes2, t.pcharges
    from scott.xitog3_lsk t where t.mg=:p_mg'
    using l_mg2;
  logger.log_(null, 'Apex_new: загрузка оборотки xitog3 по л/c-окончание, ќтправлено строк='||sql%rowcount);

  l_mg2:=to_char(add_months(to_date(l_mg2||'01','YYYYMMDD'), 1), 'YYYYMM');
  end loop;
  logger.log_(null, 'Apex_new: загрузка движени€ по л/c-окончание');
end if;

  --выполнение импорта на стороне Ћ 
  --#################################
  --#################################
  logger.log_(null, 'Apex_new: выполнение импорта на стороне Ћ -начало');
  --загрузить архивную информацию, если это необходимо
  if l_p_mg1 is not null then
    execute immediate 'begin imp_frm_base.imp_all@Apex_new(:var_, :cd_org_, :l_p_mg1, :l_p_mg2); end;'
    using var_, cd_org_, l_p_mg1, l_p_mg2;
  end if;
  --и в любом случае загрузить текущую информацию
  execute immediate 'begin imp_frm_base.imp_all@Apex_new(:var_, :cd_org_, null, null); end;'
  using var_, cd_org_;

  logger.log_(null, 'Apex_new: выполнение импорта на стороне Ћ -окончание');
  --#################################
  --#################################
logger.log_(null, 'Apex_new: ## - ќ ќЌ„јЌ»≈ ќЅћ≈Ќј');

execute immediate 'begin c_logger.cr_event@Apex_new(:cd_org_,:cd_event, 0, :event_body); end;'
using cd_org_, '—инхронизаци€ с базой',
'ќ ќЌ„јЌ»≈ ќЅћ≈Ќј';

 exception when others then
  execute immediate 'begin c_logger.cr_event@Apex_new(:cd_org_,:cd_event, 1, :event_body); end;'
  using cd_org_, '—инхронизаци€ с базой',
  'ќшибка при получении информации из Ћ : ERRcode - '||SQLCODE||' -ERRmsg- '||SQLERRM;
  logger.raiseError('ext_pkg_new.exp_base');
--  Raise;
end;
commit;
--закрыть DBLINK, чтобы не было ошибки ORA-02049: timeout: distributed transaction waiting for lock

begin
 dbms_session.close_database_link('apex');
exception when others then 
   null; --ƒа! null!
end;

end;

procedure imp_vol_all is
 cd_org_ t_org.cd%type;
 l_cnt number;
begin
  Raise_application_error(-20000, 'пока закрыто!');

begin
--получение расхода по всем услугам/счетчикам из личного кабинета
execute immediate'ALTER SESSION SET TIME_ZONE = ''+7:0''';
select o.cd into cd_org_
 from scott.t_org o, scott.t_org_tp tp
where tp.id=o.fk_orgtp and tp.cd='– ÷';

logger.log_(null, 'Apex_new: ## - Ќј„јЋќ ќЅћ≈Ќј');

execute immediate 'begin c_logger.cr_event@Apex_new(:cd_org_,:cd_event, 0, :event_body); end;'
using cd_org_, '—инхронизаци€ с базой', 'Ќј„јЋќ ќЅћ≈Ќј';

init.set_user;

if ext_pkg_new.is_lst(cd_org_) = 1 and c_charges.trg_proc_next_month = 0 then
  --или последние 2 дн€ мес€ца » не идЄт переход мес€ца!!!-  обмен запрещен!
  logger.log_(null, 'Apex_new: - база закрыта или последний день мес€ца,- обмен запрещен!');
  return;
end if;

logger.log_(null, 'Apex_new: импорт расхода по счетчикам-начало');

--подготовка к выгрузке объемов на стороне Ћ 
execute immediate 'begin exp_to_base.exp_sch_vol@Apex_new(:cd_org_); end;'
using cd_org_;

--загрузка расходов в промежуточную таблицу
delete from scott.imp_sch_vol t;

select nvl(count(*),0) into l_cnt from
  scott.imp_sch_vol;

if l_cnt <> 0 then
  logger.log_(null, 'Apex_new: ¬Ќ»ћјЌ»≈! scott.imp_sch_vol не почищен - ќЅћ≈Ќ ѕ–≈ –јў≈Ќ!');
  return;
end if;

execute immediate 'insert into scott.imp_sch_vol t
 (lsk, cd_usl, vol)
 select t.lsk, t.cd_usl, t.vol from exp_sch_vol@Apex_new t
  where t.cd_org=:cd_org_'
 using cd_org_;


--выбираютс€ только те услуги по которым заполнено поле COUNTER
for c in (select u.usl from scott.usl u where trim(u.counter) is not null
   )
loop
 --обновление расходов в kart
 imp_vol_usl(c.usl);

end loop;

--установка флага прин€ти€ объемов счетчиков
--выполн€етс€ позже в exp_base!!! (иначе пустые значени€ в Ћ !)
--execute immediate 'begin exp_to_base.acpt_sch_vol@Apex_new(:cd_org_); end;'
--using cd_org_;

 --тут же отправл€ем новые показани€ в Ћ , делаем коммит
 exp_vol_all;
exception when others then
  execute immediate 'begin c_logger.cr_event@Apex_new(:cd_org_,:cd_event, 1, :event_body); end;'
  using cd_org_, '—инхронизаци€ с базой',
  'ќшибка при получении информации из Ћ : в строке: ERRcode - '||SQLCODE||' -ERRmsg- '||SQLERRM;
--  Raise;
  logger.raiseError('ext_pkg_new.imp_vol_all');
end;
 --коммит
commit;

--«десь это нельз€ ставить, так как выполн€етс€ не€вный коммит, и чиститс€ темпова€ таблица
--закрыть DBLINK, чтобы не было ошибки ORA-02049: timeout: distributed transaction waiting for lock
--dbms_session.close_database_link('apex');

logger.log_(null, 'Apex_new: импорт расхода по счетчикам-окончание');
end;

procedure exp_vol_all is
-- l_list u_list.id%type;
 l_cd_listtp u_listtp.cd%type;
 cd_org_ t_org.cd%type;
begin
begin
--экспорт л/с, показаний счетчиков (ежедневный и так же и ежеминутный обмен)
--пришлось выгружать в промежуточную таблицу, после чего
--уже отправл€ть на удаленный сервер
--(на пр€мую не получилось из за искажени€ кодировки при использовании
--конструкции case when ....

l_cd_listtp:='ѕараметры лиц.счета';
select o.cd into cd_org_
 from scott.t_org o, scott.t_org_tp tp
where tp.id=o.fk_orgtp and tp.cd='– ÷';

if ext_pkg_new.is_lst(cd_org_) = 1 and c_charges.trg_proc_next_month = 0 then
  --или последние 2 дн€ мес€ца » не идЄт переход мес€ца!!!-  обмен запрещен!
  logger.log_(null, 'Apex_new: - база закрыта или последний день мес€ца,- обмен запрещен!');
  return;
end if;

--тип параметра "пароль"
/*select u.id into l_list from scott.u_list u, scott.u_listtp tp  --”Ѕ–јЋ Ё“ќ –ед. 12.12.2014'
    where u.fk_listtp=tp.id
    and u.cd='pass'
    and tp.cd=l_cd_listtp;*/

logger.log_(null, 'Apex_new: экспорт домов-начало');
--экспорт домов
delete from scott.exp_c_houses;
insert into scott.exp_c_houses
  (id, reu, kul, nd, k_lsk_id, cd_org, psch)
select k.id, k.reu, k.kul, k.nd, k.k_lsk_id, o.cd as cd_org, k.psch
 from scott.c_houses k, scott.t_org o where k.reu=o.reu;

execute immediate 'delete from imp_c_houses@Apex_new t';

execute immediate 'insert into imp_c_houses@Apex_new t
(id, reu, kul, nd, k_lsk_id, cd_org, psch)
select k.id, k.reu, k.kul, k.nd, k.k_lsk_id, k.cd_org, k.psch
 from scott.exp_c_houses k';
logger.log_(null, 'Apex_new: экспорт домов-окончание');


logger.log_(null, 'Apex_new: экспорт л/с-начало');

delete from scott.exp_kart;
insert into scott.exp_kart t
(k_lsk_id, lsk, cd_org, kul, nd, kw, phw, mhw, pgw, mgw, pel, mel, psch, house_id)
select k.k_lsk_id, k.lsk, o.cd, k.kul,
 k.nd, k.kw,
 k.phw, k.mhw, k.pgw, k.mgw, k.pel, k.mel, k.psch, k.house_id
 from scott.kart k, scott.t_org o where k.reu=o.reu;/* and
   exists
  (select * from scott.t_objxpar x where x.fk_k_lsk=k.k_lsk_id --только там, где установлен параметр login-pass --”Ѕ–јЋ Ё“ќ –ед. 12.12.2014'
   and x.fk_list=l_list);*/

execute immediate 'delete from imp_kart@Apex_new t';

execute immediate 'insert into imp_kart@Apex_new t
(k_lsk_id, lsk, cd_org, kul, nd, kw, phw, mhw, pgw, mgw, pel, mel, psch, house_id)
select k.k_lsk_id, k.lsk, k.cd_org, k.kul,
 k.nd, k.kw,
 k.phw, k.mhw, k.pgw, k.mgw, k.pel, k.mel, k.psch, k.house_id
 from scott.exp_kart k';

logger.log_(null, 'Apex_new: экспорт л/с, отправлено строк: '||to_char(SQL%ROWCOUNT));

logger.log_(null, 'Apex_new: выполнение импорта счетчиков на стороне Ћ -начало');
execute immediate 'begin imp_frm_base.imp_sch_cnt@Apex_new(:cd_org_); end;'
using cd_org_;
logger.log_(null, 'Apex_new: выполнение импорта счетчиков на стороне Ћ -окончание');

logger.log_(null, 'Apex_new: отметка о завершении приема счетчиков на стороне Ћ -начало');
execute immediate 'begin exp_to_base.acpt_sch_vol@Apex_new(:cd_org_); end;'
using cd_org_;
logger.log_(null, 'Apex_new: отметка о завершении приема счетчиков на стороне Ћ -окончание');

exception when others then
  execute immediate 'begin c_logger.cr_event@Apex_new(:cd_org_,:cd_event, 1, :event_body); end;'
  using cd_org_, '—инхронизаци€ с базой',
  'ќшибка при экспорте информации в Ћ : в строке: ERRcode - '||SQLCODE||' -ERRmsg- '||SQLERRM;
--  Raise;
  logger.raiseError('ext_pkg_new.exp_vol_all');
end;
end;

procedure imp_vol_usl(cd_usl_ in usl.cd%type) is
 fld_ usl.counter%type;
 l_usl_name usl.nm%type;
begin
--получение расхода по услуге/счетчику из Ћ 
if utils.get_int_param('HAVE_LK') = 0 then
 --≈сли отсутствует функци€ личного кабинета - выход
  logger.log_(null, 'Apex_new: - Ћичный кабинет не установлен,- обмен запрещен!');
  return;
end if;


select
   u.counter, trim(u.nm) into fld_, l_usl_name
  from scott.usl u where u.usl=cd_usl_;

--проверка на повторный ввод расхода по л/c
logger.log_(null, 'Apex_new: - проверка на повторный ввод расхода по л/c');
for c in (select distinct s.lsk as lsk from scott.imp_sch_vol s,
  scott.t_objxpar t, scott.u_list u, scott.params p
  where t.ts between to_date(p.period||'01','YYYYMMDD') and
  last_day(to_date(p.period||'01','YYYYMMDD'))
  and t.fk_list=u.id
  and u.cd='ins_vol_sch'
  and t.fk_usl=cd_usl_
  and s.cd_usl=cd_usl_
  and s.lsk=t.fk_lsk
)
loop
  logger.log_(null, 'Apex_new: - ѕ–≈ƒ”ѕ–≈∆ƒ≈Ќ»≈, по л/c:'||c.lsk||', услуге:'||cd_usl_||':'||trim(l_usl_name)||' в текущем периоде уже был введен расход!');
end loop;

execute immediate 'update scott.kart x
 set x.'||fld_||' = nvl(x.'||fld_||',0) +
  (select nvl(t.vol,0) from scott.imp_sch_vol t
    where t.lsk=x.lsk
    and t.cd_usl=:cd_usl_
    )
  where exists
  (select * from scott.imp_sch_vol t
    where t.lsk=x.lsk
    and t.cd_usl=:cd_usl_
    )'
using cd_usl_,cd_usl_;



end;

function is_lst(p_cd_org in varchar2) return number is
 l_ret number;
begin
--исполн€етс€ функци€ на стороне Apex, возвращаетс€ значение
execute immediate 'begin
                    :l_ret:=proc.is_lst_day@Apex_new(:cd_org_, -1);
                   end;'
using out l_ret, in p_cd_org;
return l_ret;
end;

procedure fill_table is
cnt_ number;
dat_ date;
a number;
begin
--тестова€ процедура проверки dblink на mysql
--закомментировал, иначе не компилируетс€
/*
while true
loop
  delete from "test2"@mysql;

  a:=0;
  for c in (select t.id, t.fio as name from c_kart_pr t)
  loop

  insert into "test2"@mysql ("id", "Name")
   values (c.id, c.name);

  a:=a+1;
  if a = 100 then
    select max(t."id")+1 into cnt_ from "par"@mysql t;
    dat_:=sysdate;
    insert into "par"@mysql ("id", "d1")
     values (cnt_, dat_);
  a:=0;
  end if;

  end loop;
  commit;

end loop;
*/
null;
end fill_table;

END ext_pkg_new;
/

prompt
prompt Creating package body GEN
prompt =========================
prompt
create or replace package body scott.gen is
  procedure gen_check (err_ out number, err_str_ out varchar2,
    var_ in number) is
  cnt_ number;
  l_cd_org t_org.cd%type;
  l_str varchar2(1000);
  cursor cur_params is
    select * from params;
  l_mg1 params.period%type;
  rec_params cur_params%rowtype;
  begin
  --нет ошибок
  err_:=0;

  select o.cd into l_cd_org
   from scott.t_org o, scott.t_org_tp tp
   where tp.id=o.fk_orgtp and tp.cd='– ÷';
  
  
  open cur_params;
  fetch cur_params
    into rec_params;
  close cur_params;
  
  
  l_mg1:=utils.add_months_pr(rec_params.period, 1);

  --проверка до и во врем€ формировани€
  if var_ = 1 then --проверка всех ошибок до формировани€
    if rec_params.period <> init.get_period then
       err_str_:='—топ, заданна€ дата не соответствующа€ текущему периоду!';
       err_:=6;
       return;
    end if;

   select nvl(count(*),0) into cnt_
     from kart k
     where not exists
      (select * from s_reu_trest t where t.reu=k.reu);

   if cnt_ <> 0 then
     err_str_:='—топ, код REU не найден в представлении s_reu_trest!';
     err_:=11;
     return;
   end if;

    --провер€ем кол-во проживающих в карточках (кроме дополнительных счетов, - там не провер€ть! ред. 03.11.2015) 
   cnt_:=0;
    select nvl(count(*),0) into cnt_ from kart k, v_lsk_tp tp where
    k.fk_tp=tp.id and tp.cd='LSK_TP_MAIN' and k.kpr <>(select nvl(count(*),0)
                   from c_kart_pr t
                  where t.lsk = k.lsk
                   and t.status <> 6 --не берЄм временно проживающих
                   and (case when nvl(rec_params.is_fullmonth,0)=0 and t.status = 4 and --если выписан до 15 то не считать
                       nvl(t.dat_ub, to_date('19000101', 'YYYYMMDD')) <= --если нет даты выписки, то как будто бы выписан давно (в 1900 году)))
                       to_date((select period || '15' from params), 'YYYYMMDD') then
                       0
                             when nvl(rec_params.is_fullmonth,0)=0 and t.status in (1,5) and --если прописан после 15 то не считать
                       nvl(t.dat_prop, to_date('19000101', 'YYYYMMDD')) >= --если нет даты прописки, то как будто бы прописан давно (в 1900 году)))
                       to_date((select period || '15' from params), 'YYYYMMDD') then
                       0
                             when nvl(rec_params.is_fullmonth,0)=1 and t.status = 4 then
                             0  --если выписан, то не считать (не гл€д€ на дату выписки из за fullmonth=1)
                             when nvl(rec_params.is_fullmonth,0)=1 and t.status in (1,5) then
                             1  --если прописан, то считать (не гл€д€ на дату прописки из за fullmonth=1)
                       else
                       1
                       end = 1)
                    );
    if cnt_ <> 0 then
      err_str_:='—топ, кол-во проживающих в л.с. не соответствует прописке-выписке, продолжение не возможно!';
      err_:=1;
      return;
    end if;

   select nvl(a.summa,0)-nvl(b.summa,0) into cnt_
     from (select nvl(sum(summa),0)+nvl(sum(penya),0) as summa from c_kwtp t
       where t.dat_ink between init.g_dt_start and init.g_dt_end
     ) a,
     (select nvl(sum(summa),0)+nvl(sum(penya),0) as summa from c_kwtp_mg t
       where t.dat_ink between init.g_dt_start and init.g_dt_end
     ) b;
   if cnt_ <> 0 then
     err_str_:='—топ, обща€ сумма в c_kwtp<>c_kwtp_mg!';
     err_:=6;
     return;
   end if;
   
  select count(*), 
    rtrim(xmlagg(xmlelement(e, a.nkom,',').extract('//text()')),',')
     into cnt_, l_str
   from (select distinct t.nkom from c_kwtp t where nvl(t.nink, 0) = 0) a; 
--если раскомментировать, то будет мешать при формировании (не проверит, что выполнена инкассаци€)
--     and c.dat_ink between init.g_dt_start and init.g_dt_end;
   if cnt_ <> 0 then
     err_str_:='—топ, не проинкассированы деньги на компьютерах: '||l_str;
     err_:=4;
     return;
   end if;
 elsif var_ =2 then
  select count(*), 
    rtrim(xmlagg(xmlelement(e, a.nkom,',').extract('//text()')),',')
     into cnt_, l_str
   from (select distinct t.nkom from c_kwtp t where nvl(t.nink, 0) = 0) a; 
--если раскомментировать, то будет мешать при формировании (не проверит, что выполнена инкассаци€)
--     and c.dat_ink between init.g_dt_start and init.g_dt_end;
   if cnt_ <> 0 then
     err_str_:='—топ, не проинкассированы деньги на компьютерах: '||l_str;
     err_:=4;
     return;
   end if;
 elsif var_ =3 then
  select count(*), 
    rtrim(xmlagg(xmlelement(e, a.nkom,',').extract('//text()')),',')
     into cnt_, l_str
   from (select distinct t.nkom from c_kwtp t where nvl(t.nink, 0) = 0) a; 
--если раскомментировать, то будет мешать при формировании (не проверит, что выполнена инкассаци€)
--     and c.dat_ink between init.g_dt_start and init.g_dt_end;
   if cnt_ <> 0 then
     err_str_:='—топ, не проинкассированы деньги на компьютерах: '||l_str;
     err_:=4;
     return;
   end if;

  select nvl(a.summa,0)-nvl(b.summa,0) into cnt_
   from (select nvl(sum(summa),0)+nvl(sum(penya),0) as summa from c_kwtp t
    where t.dat_ink between init.g_dt_start and init.g_dt_end) a,
   (select sum(summa) as summa from kwtp_day t
    where t.dat_ink between init.g_dt_start and init.g_dt_end) b;
   if cnt_ <> 0 then
     err_str_:='—топ, SUMMA c_kwtp<>kwtp_day!';
     err_:=8;
     return;
   end if;

 if init.get_state = 0 then
    err_str_:='—топ, не выполнено итоговое формирование за мес€ц, переход не возможен!';
    err_:=5;
    return;
  end if;
 elsif var_ =4 then
  --проверки до ѕ≈–≈’ќƒј!
  --проверка, что сальдо исх идЄт (бывает, когда удал€т платЄж без переформировани€)
   select nvl(count(*),0) into cnt_
    from (select * from xitog3_lsk where mg=rec_params.period) t 
     full outer join 
         (select * from saldo_usl where mg=l_mg1) s
    on t.lsk=s.lsk and t.usl=s.usl and t.org=s.org
    where nvl(t.outdebet,0)+nvl(t.outkredit,0) <> nvl(s.summa,0);
    if cnt_ <> 0 then
      err_str_:='Ќе идЄт исх.сальдо., возможно требуетс€ итоговое формирование, продолжение не возможно!';
      err_:=13;
      return;
    end if;
    

  --проверка, что начисление идЄт с начислением в оборотке (да, да, без учЄта перерасчетов - не получилось с ними)
   select nvl(count(*),0) into cnt_
    from (select * from xitog3_lsk where mg=rec_params.period) t 
     full outer join 
         (select r.lsk, r.usl, o.fk_org2 as org, sum(r.summa) as summa
           from c_charge r, nabor n, t_org o 
           where r.lsk=n.lsk and r.type=1 and r.usl=n.usl 
           and n.org=o.id
           group by r.lsk, r.usl, o.fk_org2
           ) s
    on t.lsk=s.lsk and t.usl=s.usl and t.org=s.org
    where nvl(t.charges,0)-nvl(t.changes,0)-nvl(t.changes2,0) <> nvl(s.summa,0);
    if cnt_ <> 0 then
      err_str_:='Ќе идЄт начисление с обороткой, возможно требуетс€ итоговое формирование, продолжение не возможно!';
      err_:=13;
      return;
    end if;

  --проверка, что перерасчет идЄт в совокупности с начислением в оборотке 
   select nvl(count(*),0) into cnt_
    from (select lsk, nvl(sum(changes),0)+nvl(sum(changes2),0) as summa from xitog3_lsk where mg=rec_params.period group by lsk) t 
     full outer join 
         (select r.lsk, sum(r.summa) as summa
           from c_change r
           group by r.lsk
           ) s
    on t.lsk=s.lsk
    where nvl(t.summa,0) <> nvl(s.summa,0);
    if cnt_ <> 0 then
      err_str_:='Ќе идут перерасчеты с обороткой, возможно требуетс€ итоговое формирование, продолжение не возможно!';
      err_:=13;
      return;
    end if;

  --проверка, что оплата идЄт с оплатой в оборотке
   select nvl(count(*),0) into cnt_
    from (select * from xitog3_lsk where mg=rec_params.period) t 
     full outer join 
         (select r.lsk, r.usl, r.org, sum(r.summa) as summa
           from kwtp_day r where r.priznak=1
           and r.dat_ink between init.g_dt_start and init.g_dt_end
           group by r.lsk, r.usl, r.org
           ) s
    on t.lsk=s.lsk and t.usl=s.usl and t.org=s.org
    where nvl(t.payment,0) <> nvl(s.summa,0);
    if cnt_ <> 0 then
      err_str_:='Ќе идЄт оплата с обороткой, возможно требуетс€ итоговое формирование, продолжение не возможно!';
      err_:=13;
      return;
    end if;

    if utils.get_int_param('GEN_CHK_C_DEB_USL') = 1 then
     --по-периодный способ распределени€ оплаты
     --сравниваем сальдо с задолжностью по периодам,
     --здесь формируетс€ c_deb_usl, ...получаетс€ только дл€ ведомости задолжников 
     --(раньше по ней распредел€лась оплата...теперь по xitog3_lsk)

     --по л/c
      select nvl(count(*),0)
        into cnt_
        from kart c, (select t.lsk, sum(summa) as summa
                from c_deb_usl t, params p
               where t.period = p.period
               group by t.lsk) a,
             (select t.lsk, sum(summa) as summa
                from saldo_usl t, params p
               where mg =
                     to_char(add_months(to_date(p.period || '01', 'YYYYMMDD'),
                                        1),
                             'YYYYMM')
              group by t.lsk) b
              where c.lsk=a.lsk(+) and c.lsk=b.lsk(+)
              and nvl(a.summa,0) <> nvl(b.summa,0);
      if cnt_ <> 0 then
        err_str_:='—топ, сумма —альдо <> —умма в c_deb_usl, продолжение не возможно!';
        err_:=13;
        return;
      end if;
    end if;

    --сравниваем сальдо с движением в совокупности
    select nvl(a.summa, 0) - nvl(b.summa, 0)
      into cnt_
      from (select sum(decode(type, 1, -1 * summa, summa)) as summa
              from c_chargepay t, params p
             where t.period = p.period) a,
           (select sum(summa) as summa
              from saldo_usl t, params p
             where mg =
                   to_char(add_months(to_date(p.period || '01', 'YYYYMMDD'),
                                      1),
                           'YYYYMM')) b;
    if cnt_ <> 0 then
      err_str_:='—топ, сумма —альдо <> —умма в движении в совокупности, продолжение не возможно!';
      err_:=2;
      return;
    end if;

    --сравниваем сальдо с движением по c_lsk_id
    select nvl(count(*),0)
      into cnt_
      from kart c, (select t.lsk, sum(decode(type, 1, -1 * summa, summa)) as summa
              from c_chargepay t, params p
             where t.period = p.period
             group by t.lsk) a,
           (select t.lsk, sum(summa) as summa
              from saldo_usl t, params p
             where mg =
                   to_char(add_months(to_date(p.period || '01', 'YYYYMMDD'),
                                      1),
                           'YYYYMM')
            group by t.lsk) b
            where c.lsk=a.lsk(+) and c.lsk=b.lsk(+)
            and nvl(a.summa,0) <> nvl(b.summa,0);
/* --дл€ запроса:
select c.lsk, a.*, b.*, a.summa-b.summa as diff
      from kart c, (select t.lsk, sum(decode(type, 1, -1 * summa, summa)) as summa
              from c_chargepay t, params p
             where t.period = p.period
             group by t.lsk) a,
           (select t.lsk, sum(summa) as summa
              from saldo_usl t, params p
             where mg =
                   to_char(add_months(to_date(p.period || '01', 'YYYYMMDD'),
                                      1),
                           'YYYYMM')
            group by t.lsk) b
            where c.lsk=a.lsk(+) and c.lsk=b.lsk(+)
            and nvl(a.summa,0) <> nvl(b.summa,0)
            order by c.lsk
*/

    if cnt_ <> 0 then
      err_str_:='—топ, сумма —альдо <> —умма в движении по c_lsk_id, возможно произошли изменени€ в карточках. продолжение не возможно!';
      err_:=3;
      return;
    end if;

  --проверка что в сальдо не присутствуют организации ниже уровн€ 1
    select count(*) into cnt_ from (
      select level as lvl, t.id, t.name from scott.t_org t
      connect by prior t.id=t.parent_id2
      start with t.parent_id2 is null
      order by level
    ) a where a.lvl > 1
    and exists
    (select * from saldo_usl s, v_params p where
    s.mg=p.period1 and s.org = a.id);
   if cnt_ <> 0 then
      err_str_:='—топ, в сальдо присутствуют организации > 1 уровн€!';
      err_:=10;
      return;
   end if;
   
   
 elsif var_ =5 then
  --проверка перед формированием корректности л.с.
   select nvl(count(*),0) into cnt_ from kart k where nvl(k.fk_err,0)<>0;
   if cnt_ <> 0 then
      err_:=9;
   end if;
   return;

 elsif var_ =6 then
  --проверка распределени€ пени, после формировани€ сальдо
  select nvl(a.summa,0) - nvl(b.summa,0) into cnt_ from
    (select sum(penya) as summa from c_penya c) a,
    (select sum(summa) as summa from t_chpenya_for_saldo c) b;
   if cnt_ <> 0 then
    err_:=12;
--    Raise_application_error(-20000, '¬нимание! ќшибка в процессе распределени€ начисленной пени по услугам!');
   end if;

 elsif var_ =7 then
  --проверка до итогового формировани€, перехода, на получение всех показаний счетчиков
  --(при наличии Ћ )
  if utils.get_int_param('HAVE_LK') = 1 then

    execute immediate
     'select proc.check_is_acpt_sch@Apex(:l_cd_org) from dual'
    into cnt_
    using l_cd_org;
    if cnt_ <> 0 then
      err_:=14;
      err_str_:='Ќе все показани€ счетчиков из личного кабинета были учтены в базе!';
    end if;
  end if;

 elsif var_ =8 then
  --проверка до итогового формировани€, на корректность периода в личном кабинете

  if utils.get_int_param('HAVE_LK') = 1 then

    execute immediate
     'select proc.check_period@Apex(:l_cd_org, p.period) from params p'
    into cnt_
    using l_cd_org;
    if cnt_ <> 0 then
      err_:=15;
      err_str_:='Ќе соответствующий период в личном кабинете!';
    end if;
  end if;

 end if;
 end;

  procedure gen_check_lst (var_ in number,
                           prep_refcursor IN OUT rep_refcursor) is
  begin
  --проверка перед формированием, с выводом л.с.
  --содержащих ошибки
  if var_=12 then
    --список лс. по которым не корректно распр.пен€
      OPEN prep_refcursor FOR
        select nvl(a.lsk,b.lsk) as lsk from --либо тот лск либо другой
        (select c.lsk, sum(penya) as summa from c_penya c group by lsk) a full outer join
        (select c.lsk, sum(summa) as summa from t_chpenya_for_saldo c group by lsk) b
        on a.lsk=b.lsk
        where nvl(a.summa,0) - nvl(b.summa,0) <> 0;
    else
        OPEN prep_refcursor FOR
          select lsk from kart k where nvl(k.fk_err,0)<>0;
  end if;
  end;

  procedure smpl_chk (p_var in number,
                           prep_refcursor IN OUT rep_refcursor) is
  begin
  --проверка перед формированием, с выводом л.с.
  --содержащих ошибки
  if p_var=1 then
    --список лс. по которым не корректно распр.пен€
      OPEN prep_refcursor FOR
        select 'Ќекорректные лицевые, содержащие услугу х.в.ќƒЌ, но у прочих л.с. дома услуги ќƒЌ нет' as lsk
        from dual
        union all
        select k.lsk from kart k, nabor n, usl u where
        k.lsk=n.lsk and k.psch not in (8,9)
        and n.usl=u.usl
        and u.cd='х.вода'
        and exists
        (select * from nabor r, usl u2 where r.lsk=k.lsk
          and r.usl=u2.usl --есть услуга ќƒЌ
          and u2.cd='х.вода.ќƒЌ')
        and not exists --а у других л.с. нет этой услуги
        (select * from kart t, nabor r, usl u2 where r.lsk<>k.lsk
          and r.usl=u2.usl
          and u2.cd='х.вода.ќƒЌ'
          and t.lsk=r.lsk
          and t.house_id=k.house_id)
        and exists
        (select a.house_id from kart a where a.house_id=k.house_id
         having count(*)>1
         group by a.house_id);
  elsif p_var=2 then
    --список лс. по которым не корректно распр.пен€
      OPEN prep_refcursor FOR
        select 'Ќекорректные лицевые, Ќ≈ содержащие х.в.услугу ќƒЌ, но у прочих л.с. дома услуга ќƒЌ есть' as lsk
        from dual
        union all
        select k.lsk from kart k, nabor n, usl u where
        k.lsk=n.lsk and k.psch not in (8,9)
        and n.usl=u.usl
        and u.cd='х.вода'
        and exists
        (select * from nabor r, usl u2 where r.lsk=k.lsk
          and r.usl=u2.usl --есть услуга ќƒЌ
          and u2.cd='х.вода.ќƒЌ')
        and not exists --а у других л.с. нет этой услуги
        (select * from kart t, nabor r, usl u2 where r.lsk<>k.lsk
          and r.usl=u2.usl
          and u2.cd='х.вода.ќƒЌ'
          and t.lsk=r.lsk
          and t.house_id=k.house_id)
        and exists
        (select a.house_id from kart a where a.house_id=k.house_id
         having count(*)>1
         group by a.house_id);
  elsif p_var=3 then
    --список лс. по которым не корректно распр.пен€
      OPEN prep_refcursor FOR
        select 'Ќекорректные лицевые, содержащие услугу г.в.ќƒЌ, но у прочих л.с. дома услуги ќƒЌ нет' as lsk
        from dual
        union all
        select k.lsk from kart k, nabor n, usl u where
        k.lsk=n.lsk and k.psch not in (8,9)
        and n.usl=u.usl
        and u.cd='г.вода'
        and exists
        (select * from nabor r, usl u2 where r.lsk=k.lsk
          and r.usl=u2.usl --есть услуга ќƒЌ
          and u2.cd='г.вода.ќƒЌ')
        and not exists --а у других л.с. нет этой услуги
        (select * from kart t, nabor r, usl u2 where r.lsk<>k.lsk
          and r.usl=u2.usl
          and u2.cd='г.вода.ќƒЌ'
          and t.lsk=r.lsk
          and t.house_id=k.house_id)
        and exists
        (select a.house_id from kart a where a.house_id=k.house_id
         having count(*)>1
         group by a.house_id);
  elsif p_var=4 then
    --список лс. по которым не корректно распр.пен€
      OPEN prep_refcursor FOR
        select 'Ќекорректные лицевые, Ќ≈ содержащие г.в.услугу ќƒЌ, но у прочих л.с. дома услуга ќƒЌ есть' as lsk
        from dual
        union all
        select k.lsk from kart k, nabor n, usl u where
        k.lsk=n.lsk and k.psch not in (8,9)
        and n.usl=u.usl
        and u.cd='г.вода'
        and exists
        (select * from nabor r, usl u2 where r.lsk=k.lsk
          and r.usl=u2.usl --есть услуга ќƒЌ
          and u2.cd='г.вода.ќƒЌ')
        and not exists --а у других л.с. нет этой услуги
        (select * from kart t, nabor r, usl u2 where r.lsk<>k.lsk
          and r.usl=u2.usl
          and u2.cd='г.вода.ќƒЌ'
          and t.lsk=r.lsk
          and t.house_id=k.house_id)
        and exists
        (select a.house_id from kart a where a.house_id=k.house_id
         having count(*)>1
         group by a.house_id);
  end if;
  end;

  procedure prep_kart_pr is
  time_ date;
  --ѕодготовка льготников дл€ статистики
  begin
    /*  time_ := SYSDATE;
    EXECUTE IMMEDIATE 'TRUNCATE TABLE lg_pr';
    UPDATE KART_PR SET id = kart_pr_id.NEXTVAL;
    INSERT INTO LG_PR
      (kart_pr_id, lg_id, main, TYPE)
      SELECT id,
             SUBSTR(lp, 1, 3) AS lg_id,
             DECODE(trim(k.osno_lp1), NULL, 0, 1) AS main,
             1 AS TYPE
        FROM KART_PR k
       WHERE SUBSTR(lp, 1, 3) NOT IN ('   ', '001')
      UNION ALL
      SELECT id,
             SUBSTR(lp, 5, 3) AS lg_id,
             DECODE(trim(k.osno_lp2), NULL, 0, 1) AS main,
             1 AS TYPE
        FROM KART_PR k
       WHERE SUBSTR(lp, 5, 3) NOT IN ('   ', '001')
      UNION ALL
      SELECT id,
             SUBSTR(lp, 9, 3) AS lg_id,
             DECODE(trim(k.osno_lp3), NULL, 0, 1) AS main,
             1 AS TYPE
        FROM KART_PR k
       WHERE SUBSTR(lp, 9, 3) NOT IN ('   ', '001')
      UNION ALL
      SELECT id,
             SUBSTR(lp, 13, 3) AS lg_id,
             DECODE(trim(k.osno_lp4), NULL, 0, 1) AS main,
             1 AS TYPE
        FROM KART_PR k
       WHERE SUBSTR(lp, 13, 3) NOT IN ('   ', '001')
      UNION ALL
      SELECT id,
             SUBSTR(lpk, 1, 3) AS lg_id,
             DECODE(trim(k.osno_lp1), NULL, 0, 1) AS main,
             0 AS TYPE
        FROM KART_PR k
       WHERE SUBSTR(lpk, 1, 3) NOT IN ('   ', '001')
      UNION ALL
      SELECT id,
             SUBSTR(lpk, 5, 3) AS lg_id,
             DECODE(trim(k.osno_lp2), NULL, 0, 1) AS main,
             0 AS TYPE
        FROM KART_PR k
       WHERE SUBSTR(lpk, 5, 3) NOT IN ('   ', '001')
      UNION ALL
      SELECT id,
             SUBSTR(lpk, 9, 3) AS lg_id,
             DECODE(trim(k.osno_lp3), NULL, 0, 1) AS main,
             0 AS TYPE
        FROM KART_PR k
       WHERE SUBSTR(lpk, 9, 3) NOT IN ('   ', '001')
      UNION ALL
      SELECT id,
             SUBSTR(lpk, 13, 3) AS lg_id,
             DECODE(trim(k.osno_lp4), NULL, 0, 1) AS main,
             0 AS TYPE
        FROM KART_PR k
       WHERE SUBSTR(lpk, 13, 3) NOT IN ('   ', '001');
    COMMIT;
    ADMIN.ANALYZE('lg_pr');*/
    logger.log_(time_, 'gen.prep_kart_pr');
  end prep_kart_pr;

  procedure gen_opl_xito3 is
    stmt varchar2(2500);
    type_otchet constant number := 3; --тип отчета - оплата по пункатм (XITO3)
    time_ date;
    mg_ params.period%type;
  begin
    select period into mg_ from params p;
    time_ := sysdate;
    --«ј ћ≈—я÷
    --ќплата по пунктам начислени€
    delete from xxito3 where mg = mg_;
    insert into xxito3
      (trest, reu, usl, dopl, summa, mg)
      select s.trest,
             s.reu,
             u.usl,
             t.dopl,
             sum(summa) summa,
             mg_ as mg
        from kwtp_day t, usl u, kart k, s_reu_trest s, oper o
       where t.usl = u.usl
         and t.lsk = k.lsk
         and k.reu = s.reu
         and t.oper = o.oper
         and substr(o.oigu, 1, 1) = '1'
         and to_char(t.dat_ink, 'YYYYMM') = mg_
         and t.priznak = 1
         and t.dat_ink between init.g_dt_start and init.g_dt_end
       group by u.usl, s.trest, s.reu, t.dopl;
    delete from period_reports p
     where p.id = type_otchet
       and p.mg = mg_; --обновл€ем период дл€ отчета
    stmt := 'insert into period_reports (id, mg) values(:id, :mg)';
    execute immediate stmt
      using type_otchet, mg_;
    commit;
    logger.log_(time_, 'gen.gen_opl_xito3 ' || mg_);
  end;

  procedure gen_opl_xito5_ is
    stmt varchar2(2500);
    type_otchet constant number := 5; --тип отчета - оплата по операци€м (XITO10)
    time_ date;
    mg_ params.period%type;
  begin
    select period into mg_ from params p;
    time_ := sysdate;
    --«ј ћ≈—я÷
    --ќплата по операци€м (дл€ оборотной ведомости)
    delete from xito5_ where mg = mg_;
    insert into xito5_
      (ska, pn, trest, reu, from_reu, other, nal, ink, oper, mg)
      select sum(ska) ska,
             sum(pn) pn,
             trest,
             reu,
             from_reu,
             other,
             nal,
             ink,
             oper,
             mg_ as mg
        from v_xito5_all_ v
       group by trest,
                reu,
                from_reu,
                other,
                nal,
                ink,
                oper,
                mg_,
                to_char(sysdate, 'DD/MM/YYYY HH24:MI');
    delete from period_reports p
     where p.id = type_otchet
       and p.mg = mg_; --обновл€ем период дл€ отчета
    stmt := 'insert into period_reports (id, mg) values(:id, :mg)';
    execute immediate stmt
      using type_otchet, mg_;
    commit;
    logger.log_(time_, 'gen.gen_opl_xito5_ ' || mg_);
  end;

  procedure gen_opl_xito5 is
    stmt varchar2(2500);
    type_otchet  constant number := 4; --тип отчета - оплата по операци€м (XITO5)
    type_otchet2 constant number := 10; --тип отчета - пен€ (‘.8.1)
    time_ date;
    mg_ params.period%type;
  begin
    select period into mg_ from params p;
    time_ := sysdate;
    --«ј ћ≈—я÷
    --ќплата по операци€м (по инкассаци€м)
    delete from xito5 where mg = mg_;
    insert into xito5
      (ska, pn, trest, reu, other, nal, ink, oper, mg)
      select sum(ska) ska,
             sum(pn) pn,
             trest,
             reu,
             other,
             nal,
             ink,
             oper,
             mg_ as mg
        from v_xito5_all v
       group by trest,
                reu,
                other,
                nal,
                ink,
                oper,
                mg_,
                to_char(sysdate, 'DD/MM/YYYY HH24:MI');
    delete from period_reports p
     where p.id = type_otchet
       and p.mg = mg_; --обновл€ем период дл€ отчета
    stmt := 'insert into period_reports (id, mg) values(:id, :mg)';
    execute immediate stmt
      using type_otchet, mg_;
    delete from period_reports p
     where p.id = type_otchet2
       and p.mg = mg_; --обновл€ем период дл€ отчета
    stmt := 'insert into period_reports (id, mg) values(:id, :mg)';
    execute immediate stmt
      using type_otchet2, mg_;
    commit;
    logger.log_(time_, 'gen.gen_opl_xito5 ' || mg_);
  end;

  procedure gen_opl_xito5day(dat1_ in xito5.dat%type,
                             dat2_ in xito5.dat%type) is
    stmt varchar2(2500);
    type_otchet  constant number := 4; --тип отчета - оплата по операци€м (XITO10)
    type_otchet2 constant number := 10; --тип отчета - пен€ (‘.8.1)
    time_ date;
  begin
    time_ := sysdate;
    --«ј ƒ≈Ќ№
    --ќплата по операци€м (дл€ оборотки)
    for a in to_char(dat1_, 'YYYYMMDD') .. to_char(dat2_, 'YYYYMMDD') loop
      delete from xito5 where to_char(dat, 'YYYYMMDD') = a;
      insert into xito5
        (ska, pn, trest, reu, other, nal, ink, oper, nkom, nink, dat)
        select sum(ska) ska,
               sum(pn) pn,
               trest,
               reu,
               other,
               nal,
               ink,
               oper,
               nkom,
               nink,
               to_date(a, 'YYYYMMDD') as dat
          from v_xito5_allday v
         where v.md = to_date(a, 'YYYYMMDD')
         group by trest,
                  reu,
                  other,
                  nal,
                  ink,
                  oper,
                  nkom,
                  nink,
                  to_date(a, 'YYYYMMDD'),
                  to_char(sysdate, 'DD/MM/YYYY HH24:MI');
      delete from period_reports p
       where p.id = type_otchet
         and to_char(dat, 'YYYYMMDD') = a; --обновл€ем период дл€ отчета
      stmt := 'insert into period_reports (id, dat) values(:id, :dat)';
      execute immediate stmt
        using type_otchet, to_date(a, 'YYYYMMDD');
      stmt := 'insert into period_reports (id, dat) values(:id, :dat)';

      delete from period_reports p
       where p.id = type_otchet2
         and to_char(dat, 'YYYYMMDD') = a; --обновл€ем период дл€ отчета
      execute immediate stmt
        using type_otchet2, to_date(a, 'YYYYMMDD');
      commit;
    end loop;
    logger.log_(time_,
                'gen.gen_opl_xito5day ' || to_char(dat1_) || ' ' ||
                to_char(dat2_));
  end;

  procedure gen_opl_xito5day_(dat1_ in xito5_.dat%type,
                              dat2_ in xito5_.dat%type) is
    stmt varchar2(2500);
    type_otchet constant number := 5; --тип отчета - оплата по операци€м (XITO10)
    time_ date;
  begin
    --«ј ƒ≈Ќ№
    --ќплата по операци€м (по инкассаци€м)
    time_ := sysdate;
    for a in to_char(dat1_, 'YYYYMMDD') .. to_char(dat2_, 'YYYYMMDD') loop
      delete from xito5_ where to_char(dat, 'YYYYMMDD') = a;
      insert into xito5_
        (ska, pn, trest, reu, from_reu, other, nal, ink, oper, dat)
        select sum(ska) ska,
               sum(pn) pn,
               trest,
               reu,
               from_reu,
               other,
               nal,
               ink,
               oper,
               to_date(a, 'YYYYMMDD') as dat
          from v_xito5_allday_ v
         where v.md = to_date(a, 'YYYYMMDD')
         group by trest,
                  reu,
                  from_reu,
                  other,
                  nal,
                  ink,
                  oper,
                  to_date(a, 'YYYYMMDD'),
                  to_char(sysdate, 'DD/MM/YYYY HH24:MI');
      delete from period_reports p
       where p.id = type_otchet
         and to_char(dat, 'YYYYMMDD') = a; --обновл€ем период дл€ отчета
      stmt := 'insert into period_reports (id, dat) values(:id, :dat)';
      execute immediate stmt
        using type_otchet, to_date(a, 'YYYYMMDD');
      commit;
    end loop;
    admin.send_message('—формирована оплата ‘.3.1. за текущий период, c ' ||
                       to_char(dat1_, 'DD/MM/YYYY') || ' по ' ||
                       to_char(dat2_, 'DD/MM/YYYY'));
    logger.log_(time_,
                'gen.gen_opl_xito5day_ ' || to_char(dat1_) || ' ' ||
                to_char(dat2_));
  end;

  procedure gen_opl_xito10day(dat1_ in xxito10.dat%type,
                              dat2_ in xxito10.dat%type) is
    time_ date;
    mg_ params.period%type;
  begin
    --«а день
    --ќплата по предпри€ти€м/трестам/услугам
    time_ := sysdate;
    select p.period into mg_ from params p;
    for a in to_char(dat1_, 'YYYYMMDD') .. to_char(dat2_, 'YYYYMMDD') loop
      -- xxito11 детализаци€ до кода операции
      delete from xxito11 t where t.dat = to_date(a, 'YYYYMMDD')
       and t.mg=mg_;
      insert into xxito11
        (usl,
         oper,
         org,
         summa,
         trest,
         reu,
         dat,
         var,
         forreu,
         oborot,
         dopl,
         mg)
        select v.usl,
               v.oper,
               v.org,
               sum(v.summar) as summar,
               v.trest,
               v.reu,
               to_date(a, 'YYYYMMDD') as dat,
               v.var,
               v.forreu,
               v.oborot,
               v.dopl,
               mg_
          from (select t.lsk, t.usl, t.org, substr(t.nkom, 1, 2) AS reu, s.trest, 0 as var,
            s.reu as forreu, to_number(substr(op.oigu, 1, 1)) AS oborot,
            t.summa as summar, t.oper, t.dat_ink as dat, t.usl as usl_b, t.org as org_b, t.dopl
             from kwtp_day t, kart k, s_reu_trest s, oper op
           where t.lsk=k.lsk and k.reu=s.reu and t.oper=op.oper and t.priznak = 1
         and t.dat_ink between init.g_dt_start and init.g_dt_end) v
         where v.dat = to_date(a, 'YYYYMMDD')
         group by usl,
                  oper,
                  org,
                  trest,
                  reu,
                  to_date(a, 'YYYYMMDD'),
                  to_char(sysdate, 'DD/MM/YYYY HH24:MI'),
                  var,
                  forreu,
                  oborot,
                  dopl;

      -- xxito12 детализаци€ до статуса жиль€, адреса
      delete from xxito12 t where t.dat = to_date(a, 'YYYYMMDD')
       and t.mg=mg_;
      insert into xxito12
        (usl,
         org,
         summa,
         trest,
         reu,
         dat,
         var,
         forreu,
         kul,
         nd,
         status,
         dopl,
         mg)
        select v.usl,
               v.org,
               sum(v.summar) as summar,
               v.trest,
               v.reu,
               to_date(a, 'YYYYMMDD') as dat,
               v.var,
               v.forreu,
               k.kul,
               k.nd,
               decode(k.status, 1, 0, 1),
               v.dopl,
               mg_
          from (select t.lsk, t.usl, t.org, substr(t.nkom, 1, 2) AS reu, s.trest, 0 as var,
            s.reu as forreu, to_number(substr(op.oigu, 1, 1)) AS oborot,
            t.summa as summar, t.oper, t.dat_ink as dat, t.usl as usl_b, t.org as org_b, t.dopl
             from kwtp_day t, kart k, s_reu_trest s, oper op
           where t.lsk=k.lsk and k.reu=s.reu and t.oper=op.oper and t.priznak = 1
           and t.dat_ink between init.g_dt_start and init.g_dt_end) v, kart k
         where v.dat = to_date(a, 'YYYYMMDD')
           and k.lsk = v.lsk
           and v.oborot = 1
         group by v.usl,
                  v.org,
                  v.trest,
                  v.reu,
                  to_date(a, 'YYYYMMDD'),
                  to_char(sysdate, 'DD/MM/YYYY HH24:MI'),
                  v.var,
                  v.forreu,
                  k.kul,
                  k.nd,
                  decode(k.status, 1, 0, 1),
                  v.dopl;
      -- xxito14
      delete from xxito14_lsk t where t.dat = to_date(a, 'YYYYMMDD')
       and t.mg=mg_;
      insert into xxito14_lsk
        (lsk, usl, org, summa, dat, var, status, dopl, oper, cd_tp, mg)
        select v.lsk,
               v.usl,
               v.org,
               sum(v.summar) as summar,
               to_date(a, 'YYYYMMDD') as dat,
               v.var,
               decode(k.status, 1, 0, 1),
               v.dopl,
               v.oper,
               v.cd_tp,
               mg_
          from (select t.lsk, t.usl, t.org, substr(t.nkom, 1, 2) AS reu, s.trest, 0 as var,
            s.reu as forreu, to_number(substr(op.oigu, 1, 1)) AS oborot,
            t.summa as summar, t.sum_distr, t.fk_distr,
            t.oper, t.dat_ink as dat, t.usl as usl_b, t.org as org_b, t.dopl,
            t.priznak as cd_tp
             from kwtp_day t, kart k, s_reu_trest s, oper op
           where t.lsk=k.lsk and k.reu=s.reu and t.oper=op.oper/* ред.21.06.11 and t.priznak = 1*/
           and t.dat_ink between init.g_dt_start and init.g_dt_end) v, kart k
         where v.dat = to_date(a, 'YYYYMMDD')
           and k.lsk = v.lsk
           and v.oborot = 1
         group by v.lsk,
                  v.usl,
                  v.org,
                  v.fk_distr,
                  to_date(a, 'YYYYMMDD'),
                  v.var,
                  decode(k.status, 1, 0, 1),
                  v.dopl,
                  v.oper,
                  v.cd_tp;

      delete from xxito14 t where t.dat = to_date(a, 'YYYYMMDD')
       and t.mg=mg_;
      insert into xxito14
        (usl,
         org,
         summa,
         sum_distr,
         fk_distr,
         trest,
         reu,
         dat,
         var,
         forreu,
         kul,
         nd,
         status,
         dopl,
         oper,
         cd_tp,
         mg)
        select v.usl,
               v.org,
               sum(v.summar) as summar,
               sum(v.sum_distr) as sum_distr,
               v.fk_distr,
               v.trest,
               v.reu,
               to_date(a, 'YYYYMMDD') as dat,
               v.var,
               v.forreu,
               k.kul,
               k.nd,
               decode(k.status, 1, 0, 1),
               v.dopl,
               v.oper,
               v.cd_tp,
               mg_
          from (select t.lsk, t.usl, t.org, substr(t.nkom, 1, 2) AS reu, s.trest, 0 as var,
            s.reu as forreu, to_number(substr(op.oigu, 1, 1)) AS oborot,
            t.summa as summar, t.sum_distr,
               t.fk_distr, t.oper, t.dat_ink as dat, t.usl as usl_b, t.org as org_b, t.dopl,
               t.priznak as cd_tp
             from kwtp_day t, kart k, s_reu_trest s, oper op
           where t.lsk=k.lsk and k.reu=s.reu and t.oper=op.oper/* ред.21.06.11 and t.priznak = 1*/
           and t.dat_ink between init.g_dt_start and init.g_dt_end) v, kart k
         where v.dat = to_date(a, 'YYYYMMDD')
           and k.lsk = v.lsk
           and v.oborot = 1
         group by v.usl,
                  v.org,
                  v.trest,
                  v.reu,
                  v.fk_distr,
                  to_date(a, 'YYYYMMDD'),
                  to_char(sysdate, 'DD/MM/YYYY HH24:MI'),
                  v.var,
                  v.forreu,
                  k.kul,
                  k.nd,
                  decode(k.status, 1, 0, 1),
                  v.dopl,
                  v.oper,
                  v.cd_tp;
      -- xxito10 детализаци€ до кода организации
      delete from xxito10 t where t.dat = to_date(a, 'YYYYMMDD')
       and t.mg=mg_;
      insert into xxito10
        (usl, org, summa, trest, reu, dat, var, forreu, oborot, dopl, mg)
        select v.usl,
               v.org,
               sum(v.summa),
               v.trest,
               v.reu,
               to_date(a, 'YYYYMMDD') as dat,
               v.var,
               v.forreu,
               v.oborot,
               dopl,
               mg_
          from xxito11 v
         where v.dat = to_date(a, 'YYYYMMDD') and
               v.mg=mg_
         group by v.usl,
                  v.org,
                  v.trest,
                  v.reu,
                  to_date(a, 'YYYYMMDD'),
                  to_char(sysdate, 'DD/MM/YYYY HH24:MI'),
                  v.var,
                  v.forreu,
                  v.oborot,
                  dopl;

    logger.ins_period_rep('7', null, to_date(a, 'YYYYMMDD'), 0);
    logger.ins_period_rep('2', null, to_date(a, 'YYYYMMDD'), 0);
    logger.ins_period_rep('15', null, to_date(a, 'YYYYMMDD'), 0);
    logger.ins_period_rep('17', null, to_date(a, 'YYYYMMDD'), 0);
    logger.ins_period_rep('23', null, to_date(a, 'YYYYMMDD'), 0);
    logger.ins_period_rep('35', null, to_date(a, 'YYYYMMDD'), 0);
    logger.ins_period_rep('61', null, to_date(a, 'YYYYMMDD'), 0);
    logger.ins_period_rep('65', null, to_date(a, 'YYYYMMDD'), 0);
    commit;
    end loop;

    logger.log_(time_,
                'gen_opl_xito10day ' || to_char(dat1_) || ' ' ||
                to_char(dat2_));
    admin.send_message('—формирована оплата ‘.2.1.‘.2.2.‘.2.3. за текущий период, c ' ||
                       to_char(dat1_, 'DD/MM/YYYY') || ' по ' ||
                       to_char(dat2_, 'DD/MM/YYYY'));
  end;

  procedure gen_opl_xito10 is
    time_ date;
    mg_ params.period%type;
  begin
    select period into mg_ from params p;

    --«ј ћ≈—я÷
    --ќплата по предпри€ти€м/трестам/услугам
    time_ := sysdate;
    delete from xxito11 t where t.mg = mg_;
    insert into xxito11
      (usl,
       oper,
       org,
       summa,
       trest,
       reu,
       mg,
       var,
       forreu,
       oborot,
       dopl,
       dat)
      select v.usl,
             v.oper,
             v.org,
             sum(v.summar) as summar,
             v.trest,
             v.reu,
             mg_,
             v.var,
             v.forreu,
             v.oborot,
             v.dopl,
             v.dat
        from (select t.lsk, t.usl, t.org, substr(t.nkom, 1, 2) AS reu, s.trest, 0 as var,
            s.reu as forreu, to_number(substr(op.oigu, 1, 1)) AS oborot,
            t.summa as summar, t.oper, t.dat_ink as dat, t.usl as usl_b, t.org as org_b, t.dopl
             from kwtp_day t, kart k, s_reu_trest s, oper op
           where t.lsk=k.lsk and k.reu=s.reu and t.oper=op.oper and t.priznak = 1
           and t.dat_ink between init.g_dt_start and init.g_dt_end) v
       group by usl,
                oper,
                org,
                trest,
                reu,
                mg_,
                to_char(sysdate, 'DD/MM/YYYY HH24:MI'),
                var,
                forreu,
                oborot,
                dopl,
                dat;

    delete from xxito12 t where t.mg = mg_;
    insert into xxito12
      (usl,
       org,
       summa,
       trest,
       reu,
       mg,
       var,
       forreu,
       kul,
       nd,
       status,
       dopl,
       dat)
      select v.usl,
             v.org,
             sum(v.summar) as summar,
             v.trest,
             v.reu,
             mg_,
             v.var,
             k.reu,
             k.kul,
             k.nd,
             decode(k.status, 1, 0, 1),
             v.dopl,
             v.dat
        from (select t.lsk, t.usl, t.org, substr(t.nkom, 1, 2) AS reu, s.trest, 0 as var,
            s.reu as forreu, to_number(substr(op.oigu, 1, 1)) AS oborot,
            t.summa as summar, t.oper, t.dat_ink as dat, t.usl as usl_b, t.org as org_b, t.dopl
             from kwtp_day t, kart k, s_reu_trest s, oper op
           where t.lsk=k.lsk and k.reu=s.reu and t.oper=op.oper and t.priznak = 1
           and t.dat_ink between init.g_dt_start and init.g_dt_end) v, kart k
       where k.lsk = v.lsk
         and v.oborot = 1
       group by v.usl,
                v.org,
                v.trest,
                v.reu,
                mg_,
                to_char(sysdate, 'DD/MM/YYYY HH24:MI'),
                v.var,
                k.reu,
                k.kul,
                k.nd,
                decode(k.status, 1, 0, 1),
                v.dopl,
                v.dat;

    delete from xxito14_lsk t where t.mg = mg_;
    insert into xxito14_lsk
      (lsk, usl, org, summa, mg, var, status, dopl, oper, cd_tp, dat)
      select k.lsk,
             v.usl,
             v.org,
             sum(v.summar) as summar,
             mg_ as mg,
             v.var,
             decode(k.status, 1, 0, 1),
             v.dopl,
             v.oper,
             v.cd_tp,
             v.dat
        from (select t.lsk, t.usl, t.org, substr(t.nkom, 1, 2) AS reu, s.trest, 0 as var,
            s.reu as forreu, to_number(substr(op.oigu, 1, 1)) AS oborot,
            t.summa as summar, t.oper, t.dat_ink as dat, t.usl as usl_b, t.org as org_b, t.dopl,
            t.priznak as cd_tp
             from kwtp_day t, kart k, s_reu_trest s, oper op
           where t.lsk=k.lsk and k.reu=s.reu and t.oper=op.oper
           and t.dat_ink between init.g_dt_start and init.g_dt_end) v, kart k
       where k.lsk = v.lsk
         and v.oborot = 1
       group by k.lsk,
                v.usl,
                v.org,
                v.var,
                decode(k.status, 1, 0, 1),
                v.dopl,
                v.oper,
                v.cd_tp,
                v.dat;

    delete from xxito14 t where t.mg = mg_;
    insert into xxito14
      (usl,
       org,
       summa,
       sum_distr,
       fk_distr,
       trest,
       reu,
       mg,
       var,
       forreu,
       kul,
       nd,
       status,
       dopl,
       oper,
       cd_tp,
       dat)
      select v.usl,
             v.org,
             sum(v.summar) as summar,
             sum(v.sum_distr) as sum_distr,
             v.fk_distr as fk_distr,
             v.trest,
             v.reu,
             mg_,
             v.var,
             k.reu,
             k.kul,
             k.nd,
             decode(k.status, 1, 0, 1),
             v.dopl,
             v.oper,
             v.cd_tp,
             v.dat
        from (select t.lsk, t.usl, t.org, substr(t.nkom, 1, 2) AS reu, s.trest, 0 as var,
            s.reu as forreu, to_number(substr(op.oigu, 1, 1)) AS oborot,
            t.summa as summar, t.sum_distr, t.fk_distr, t.oper, t.dat_ink as dat,
            t.usl as usl_b, t.org as org_b, t.dopl, t.priznak as cd_tp
             from kwtp_day t, kart k, s_reu_trest s, oper op
           where t.lsk=k.lsk and k.reu=s.reu and t.oper=op.oper
           and t.dat_ink between init.g_dt_start and init.g_dt_end) v, kart k
       where k.lsk = v.lsk
         and v.oborot = 1
       group by v.usl,
                v.org,
                v.trest,
                v.reu,
                v.fk_distr,
                mg_,
                to_char(sysdate, 'DD/MM/YYYY HH24:MI'),
                v.var,
                k.reu,
                k.kul,
                k.nd,
                decode(k.status, 1, 0, 1),
                v.dopl,
                v.oper,
                v.cd_tp,
                v.dat;

    delete from xxito10 t where t.mg = mg_;
    insert into xxito10
      (usl, org, summa, trest, reu, mg, var, forreu, oborot, dopl, dat)
      select v.usl,
             v.org,
             sum(v.summa),
             v.trest,
             v.reu,
             mg_,
             v.var,
             v.forreu,
             v.oborot,
             v.dopl,
             v.dat
        from xxito11 v
       where v.mg = mg_
       group by v.usl,
                v.org,
                v.trest,
                v.reu,
                mg_,
                to_char(sysdate, 'DD/MM/YYYY HH24:MI'),
                v.var,
                v.forreu,
                v.oborot,
                v.dopl,
                v.dat;
    logger.log_(time_, 'gen.gen_opl_xito10 ' || mg_);

    logger.ins_period_rep('7', mg_, null, 0);
    logger.ins_period_rep('2', mg_, null, 0);
    logger.ins_period_rep('15', mg_, null, 0);
    logger.ins_period_rep('17', mg_, null, 0);
    logger.ins_period_rep('23', mg_, null, 0);
    logger.ins_period_rep('35', mg_, null, 0);
    logger.ins_period_rep('59', mg_, null, 0);
    logger.ins_period_rep('61', mg_, null, 0);
    logger.ins_period_rep('65', mg_, null, 0);
    commit;
  end;

  procedure gen_c_charges(lsk_ in kart.lsk%type) is
    cnt_ number;
    time_ date;
  begin
    time_ := sysdate;
    --формирование начислени€ за мес€ц.
    if lsk_ is null then
      --все лицевые с промежуточным коммитом, по каждому лицевому...
--      cnt_ := c_charges.gen_charges(null, null, null, null, 2, 1);
      c_charges.gen_chrg_all(0, null, null, null);
      --«агрузка субсидии по электроэнергии
      agent.load_subs_el;
    else
      --по одному лицевому, без коммита
      cnt_ := c_charges.gen_charges(lsk_, lsk_, null, null, 0, 0);
    end if;

    --льготы
    if lsk_ is null then
      execute immediate 'truncate table privs';
      insert into privs
        (lsk, summa, nomer, usl_id, lg_id, main)
        select c.lsk,
               sum(c.summa) as summa,
               c.kart_pr_id,
               c.usl,
               c.spk_id,
               c.main
          from c_charge c
         where c.type = 4
           and c.summa <> 0
         group by c.lsk, c.kart_pr_id, c.usl, c.spk_id, c.main;
    else
      delete from privs c
       where c.lsk=lsk_;
      insert into privs
        (lsk, summa, nomer, usl_id, lg_id, main)
        select c.lsk,
               sum(c.summa) as summa,
               c.kart_pr_id,
               c.usl,
               c.spk_id,
               c.main
          from c_charge c
         where c.type = 4
           and c.summa <> 0
           and c.lsk=lsk_
         group by c.lsk, c.kart_pr_id, c.usl, c.spk_id, c.main;
    end if;
    commit;
    if lsk_ is null then
    logger.log_(time_,
                'gen.gen_c_charges (Ќачисление по Ћ/C)');
    end if;
  end;

  procedure gen_lg
  -- ‘ормирование льготников
   is
    type_otchet  constant number := 8; --тип возмещение по льготникам (‘.8.1.)
    type_otchet2 constant number := 11; --тип льготники дл€ статистики (‘.9.1.)
    type_otchet3 constant number := 20; --тип возмещение по льготникам (‘.7.5.)
    time_ date;
    mg_ params.period%type;
  begin
    select period into mg_ from params p;
    time_ := sysdate;

    --льготники дл€ списка льготников
    delete from xito_lg4 x where x.mg = mg_;
    insert into xito_lg4
      (lsk,
       reu,
       kul,
       nd,
       kw,
       trest,
       usl,
       lg_id,
       org,
       nomer,
       cnt_main,
       cnt,
       summa,
       mg)
      select lsk,
             reu,
             kul,
             nd,
             kw,
             trest,
             usl,
             lg_id,
             org,
             nomer,
             cnt_main,
             cnt,
             summa,
             period
        from v_gen_lg4;

    delete from xito_lg3 x where x.mg = mg_;
    --    /*+ INDEX (t PRIVS_I) */
    insert into xito_lg3
      (reu,
       trest,
       kul,
       nd,
       usl_id,
       lg_id,
       org_id,
       summa,
       cnt_main,
       cnt,
       mg)
      select a.reu,
             a.trest,
             a.kul,
             a.nd,
             a.usl,
             a.lg_id,
             a.org,
             sum(a.summa) summa,
             sum(a.cnt_main) cnt_main,
             sum(a.cnt) cnt,
             a.period
        from (select *
                from v_gen_lg3
              union all
              select * from v_gen_lg3_c) a
       group by a.reu,
                a.trest,
                a.kul,
                a.nd,
                a.usl,
                a.lg_id,
                a.org,
                a.period;

    delete from xito_lg2 x where x.mg = mg_;
    /*+ INDEX (t PRIVS_I) */
    insert into xito_lg2
      (reu,
       trest,
       kul,
       nd,
       uslm_id,
       lg_id,
       org_id,
       summa,
       cnt_main,
       cnt,
       mg)
      select a.reu,
             a.trest,
             a.kul,
             a.nd,
             a.uslm,
             a.lg_id,
             a.org,
             sum(summa),
             sum(cnt_main),
             sum(cnt),
             a.period
        from (select *
                from v_gen_lg2
              union all
              select * from v_gen_lg2_c) a
       group by a.reu,
                a.trest,
                a.kul,
                a.nd,
                a.uslm,
                a.lg_id,
                a.org,
                a.period;

    delete from xito_lg1 x where x.mg = mg_;
    insert into xito_lg1
      (reu, trest, kul, nd, lg_id, summa, cnt_main, cnt, mg)
      select reu,
             trest,
             kul,
             nd,
             lg_id,
             sum(summa) as summa,
             sum(cnt_main),
             sum(cnt),
             period
        from (select s.reu,
                     s.trest,
                     k.kul,
                     k.nd,
                     x.lg_id,
                     sum(x.summa) as summa,
                     sum(x.cnt_main) as cnt_main,
                     count(*) as cnt,
                     p.period
                from (select lsk, lg_id, nomer, cnt_main, sum(summa) as summa
                        from (select t.lsk,
                                     t.lg_id,
                                     t.nomer,
                                     t.main as cnt_main,
                                     t.summa
                                from privs t
                               where t.main not in (2)
                              union all
                              select t.lsk,
                                     t.lg_id,
                                     0 as nomer,
                                     t.main as cnt_main,
                                     t.summa
                                from t_corrects_lg t,
                                     kart          e,
                                     usl           u,
                                     s_reu_trest   s,
                                     params        p
                               where e.lsk = t.lsk
                                 and t.usl = u.usl
                                 and e.reu = s.reu
                                 and t.mg = p.period)
                       group by lsk, lg_id, nomer, cnt_main) x,
                     kart k,
                     s_reu_trest s,
                     params p
               where x.lsk = k.lsk
                 and k.reu = s.reu
               group by s.reu, s.trest, k.kul, k.nd, x.lg_id, p.period

              union all

              select s.reu,
                     s.trest,
                     k.kul,
                     k.nd,
                     x.lg_id,
                     sum(x.summa) as summa,
                     0 as cnt_main,
                     0 as cnt,
                     p.period
                from (select lsk, lg_id, nomer, cnt_main, sum(summa) as summa
                        from (select t.lsk,
                                     t.lg_id,
                                     t.nomer,
                                     t.main as cnt_main,
                                     t.summa
                                from privs t
                               where t.main in (2))
                       group by lsk, lg_id, nomer, cnt_main) x,
                     kart k,
                     s_reu_trest s,
                     params p
               where x.lsk = k.lsk
                 and k.reu = s.reu
               group by s.reu, s.trest, k.kul, k.nd, x.lg_id, p.period)
       group by reu, trest, kul, nd, lg_id, period;

    delete from period_reports p
     where p.id = type_otchet
       and p.mg = mg_; --обновл€ем период дл€ отчета
    insert into period_reports (id, mg) values (type_otchet, mg_);

    delete from period_reports p
     where p.id = type_otchet2
       and p.mg = mg_; --обновл€ем период дл€ отчета
    insert into period_reports (id, mg) values (type_otchet2, mg_);

    delete from period_reports p
     where p.id = type_otchet3
       and p.mg = mg_; --обновл€ем период дл€ отчета
    insert into period_reports (id, mg) values (type_otchet3, mg_);
    commit;
    logger.log_(time_, 'gen.gen_lg ' || mg_);
  end gen_lg;

  procedure gen_saldo(lsk_ in kart.lsk%type)
  --‘ормирование исход€щего сальдо по концу месца mg_ - текущий мес€ц, по Ћ/—
    --¬нимание! следующий код при выполнении формировани€ за мес€ц может вести к нестабильности
    --получени€ счетов пользовател€ми из за выполнени€ truncate-ов
   is
    stmt   varchar2(2000);
    mg_    params.period%type;
    mg1_   params.period%type;
    init_mg_   params.period%type;
    old_mg_   params.period%type;
    cnt_ number;
    time1_ date;
    time_ date;
  begin
    select period into mg_ from params p;
    --¬ычисл€ем следующий мес€ц
    mg1_ := to_char(add_months(to_date(mg_ || '01', 'YYYYMMDD'), 1),
                    'YYYYMM');
    --¬ычисл€ем пердыдущий мес€ц
    old_mg_ := to_char(add_months(to_date(mg_ || '01', 'YYYYMMDD'), -1),
                    'YYYYMM');

    if lsk_ is null then
      time1_ := sysdate;
      --¬ычисл€ем после-следующий мес€ц, дл€ partitions
      trunc_part('saldo_usl', mg1_);
      --ѕодготовка временных таблиц...
      execute immediate 'TRUNCATE TABLE t_charges_for_saldo';
      execute immediate 'TRUNCATE TABLE t_changes_for_saldo';
--      execute immediate 'TRUNCATE TABLE t_changes_mg_for_saldo';
      execute immediate 'TRUNCATE TABLE t_payment_for_saldo';
      execute immediate 'TRUNCATE TABLE t_privs_for_saldo';
      execute immediate 'TRUNCATE TABLE t_penya_for_saldo';
      execute immediate 'TRUNCATE TABLE t_subsidii_for_saldo';

     --ред.12.11.12
     --готовилось видимо дл€ распределени€ средств по задолжности...
     --пока убрал
     -- delete from deb_usl_mg c
     --  where c.period = mg_;
    else
      delete from saldo_usl c
       where mg = mg1_
         and c.lsk=lsk_;
      delete from t_charges_for_saldo c
       where c.lsk=lsk_;
      delete from t_changes_for_saldo c
       where c.lsk=lsk_;
      delete from t_payment_for_saldo c
       where c.lsk=lsk_;
      delete from t_privs_for_saldo c
       where c.lsk=lsk_;
      delete from t_penya_for_saldo c
       where c.lsk=lsk_;
      delete from t_subsidii_for_saldo c
       where c.lsk=lsk_;
    end if;

    --“екущее начисление
    if lsk_ is null then
      time_ := sysdate;
      insert into t_charges_for_saldo
        (lsk, summa, org, usl)
        select
         p.lsk, sum(p.summa) as summa, t.fk_org2, p.usl
          from c_charge p, nabor k, t_org t, params m
         where p.type = 1
           and k.usl = p.usl
           and k.lsk=p.lsk
           and k.org=t.id
         group by p.lsk, p.usl, t.fk_org2;
      commit;
      logger.log_(time_, 'INSERT INTO t_charges_for_saldo (USL)');
    else
        insert into t_charges_for_saldo
          (lsk, summa, org, usl)
          select
           p.lsk, sum(p.summa) as summa, t.fk_org2, p.usl
            from c_charge p, nabor k, t_org t, params m
           where p.type = 1
             and k.usl = p.usl
             and k.lsk=p.lsk
             and p.lsk=lsk_
             and k.org=t.id
           group by p.lsk, p.usl, t.fk_org2;
    end if;

  --## надо быть готовым к отсуствию орг в c_change при выполнении перерасчетов суммами
  --
  --перерасчеты
    if lsk_ is null then
      time_ := sysdate;
      --1 часть - дл€ формировани€ сальдо
      insert into t_changes_for_saldo
        (lsk, summa, org, usl, type)
      select lsk, sum(summa) as summa, org, usl, type
        from (
          select
          p.lsk, p.summa, p.usl, t.fk_org2 as org, decode(p.type,1,1,2,1,0) as type
           from a_nabor k, c_change p, t_org t, params m
          where k.lsk = p.lsk
            and p.mg2 = k.mg
            and k.usl = p.usl
            and k.org=t.id
            and p.org is null  -- где не указан код орг и старые периоды
            and exists             --и где найдена услуга в архивном справочнике
            (select * from a_nabor n where n.lsk=k.lsk and n.mg=p.mg2 and n.usl=k.usl)
            and p.mg2 < m.period
            and to_char(p.dtek, 'YYYYMM') = m.period
         union all
          select
          p.lsk, p.summa, p.usl, t.fk_org2, decode(p.type,1,1,2,1,0) as type
           from nabor k, c_change p, t_org t, params m
          where k.lsk = p.lsk
            and k.usl = p.usl  --не должно быть такого, так как не пон€тно где брать орг
            and p.org is null  -- где не указан код орг и старые периоды
            and k.org=t.id
            and not exists             --и где Ќ≈ найдена услуга в архивном справочнике
            (select * from a_nabor n where n.lsk=k.lsk and n.mg=p.mg2 and n.usl=k.usl)
            and p.mg2 < m.period
            and to_char(p.dtek, 'YYYYMM') = m.period
         union all
         select
          p.lsk, p.summa, p.usl, t.fk_org2, decode(p.type,1,1,2,1,0) as type
           from nabor k, c_change p, t_org t, params m
          where k.lsk = p.lsk
            and k.usl = p.usl
            and k.org=t.id
            and p.org is null  -- где не указан код орг и новые периоды
            and p.mg2 >= m.period
            and to_char(p.dtek, 'YYYYMM') = m.period
         union all
          select
          p.lsk, p.summa, p.usl, nvl(t.fk_org2, 0) as org, decode(p.type,1,1,2,1,0) as type
           from kart r, c_change p, t_org t, params m
          where r.lsk = p.lsk
            and p.org=t.id
            and p.org is not null  -- где указан код орг и не важно какой период
            and to_char(p.dtek, 'YYYYMM') = m.period)
             group by lsk, org, usl, type;
      --2 часть - дл€ формировани€ задолжности по периодам

    --¬ќѕ–ќ—: √де используетс€ t_changes_mg_for_saldo?????????????
    --ред. 02.04.14
/*    insert into t_changes_mg_for_saldo
      (lsk, usl, org, mg, summa)
      select lsk, usl, org, mgchange, sum(summa) as summa
        from (
          select
          p.lsk, p.summa, p.usl, t.fk_org2 as org, p.mgchange
           from a_nabor k, c_change p, t_org t, params m
          where k.lsk = p.lsk
            and p.mgchange = k.mg
            and k.usl = p.usl
            and k.org=t.id
            and p.org is null  -- где не указан код орг и старые периоды
            and exists             --и где найдена услуга в архивном справочнике
            (select * from a_nabor n where n.lsk=k.lsk and n.mg=p.mgchange and n.usl=k.usl)
            and p.mgchange < m.period
            and to_char(p.dtek, 'YYYYMM') = m.period
         union all
          select
          p.lsk, p.summa, p.usl, t.fk_org2, p.mgchange
           from nabor k, c_change p, t_org t, params m
          where k.lsk = p.lsk
            and k.usl = p.usl  --не должно быть такого, так как не пон€тно где брать орг
            and p.org is null  -- где не указан код орг и старые периоды
            and k.org=t.id
            and not exists             --и где Ќ≈ найдена услуга в архивном справочнике
            (select * from a_nabor n where n.lsk=k.lsk and n.mg=p.mgchange and n.usl=k.usl)
            and p.mgchange < m.period
            and to_char(p.dtek, 'YYYYMM') = m.period
         union all
         select
          p.lsk, p.summa, p.usl, t.fk_org2, p.mgchange
           from nabor k, c_change p, t_org t, params m
          where k.lsk = p.lsk
            and k.usl = p.usl
            and k.org=t.id
            and p.org is null  -- где не указан код орг и новые периоды
            and p.mgchange >= m.period
            and to_char(p.dtek, 'YYYYMM') = m.period
         union all
          select
          p.lsk, p.summa, p.usl, nvl(t.fk_org2, 0) as org, p.mgchange
           from kart r, c_change p, t_org t, params m
          where r.lsk = p.lsk
            and p.org=t.id
            and p.org is not null  -- где указан код орг и не важно какой период
            and to_char(p.dtek, 'YYYYMM') = m.period)
             group by lsk, org, usl, mgchange; */
      commit;
      logger.log_(time_, 'INSERT INTO t_changes_for_saldo (USL)');
    else
      insert into t_changes_for_saldo
        (lsk, summa, org, usl, type)
      select lsk, sum(summa) as summa, org, usl, type
        from (
          select
          p.lsk, p.summa, p.usl, t.fk_org2 as org, decode(p.type,1,1,2,1,0) as type
           from a_nabor k, c_change p, t_org t, params m
          where k.lsk = p.lsk and k.lsk=lsk_
            and p.mg2 = k.mg
            and k.usl = p.usl
            and k.org=t.id
            and p.org is null  -- где не указан код орг и старые периоды
            and exists             --и где найдена услуга в архивном справочнике
            (select * from a_nabor n where n.lsk=k.lsk and n.mg=p.mg2 and n.usl=k.usl)
            and p.mg2 < m.period
            and to_char(p.dtek, 'YYYYMM') = m.period
         union all
          select
          p.lsk, p.summa, p.usl, t.fk_org2, decode(p.type,1,1,2,1,0) as type
           from nabor k, c_change p, t_org t, params m
          where k.lsk = p.lsk and k.lsk=lsk_
            and k.usl = p.usl
            and k.org=t.id     --не должно быть такого, так как не пон€тно где брать орг
            and p.org is null  -- где не указан код орг и старые периоды
            and not exists             --и где Ќ≈ найдена услуга в архивном справочнике
            (select * from a_nabor n where n.lsk=k.lsk and n.mg=p.mg2 and n.usl=k.usl)
            and p.mg2 < m.period
            and to_char(p.dtek, 'YYYYMM') = m.period
         union all
         select
          p.lsk, p.summa, p.usl, t.fk_org2, decode(p.type,1,1,2,1,0) as type
           from nabor k, c_change p, t_org t, params m
          where k.lsk = p.lsk and k.lsk=lsk_
            and k.usl = p.usl
            and k.org=t.id
            and p.org is null  -- где не указан код орг и новые периоды
            and p.mg2 >= m.period
            and to_char(p.dtek, 'YYYYMM') = m.period
         union all
         select
          p.lsk, p.summa, p.usl, nvl(t.fk_org2, 0) as org, decode(p.type,1,1,2,1,0) as type
           from kart r, c_change p, t_org t, params m
          where r.lsk = p.lsk and r.lsk=lsk_
            and p.org=t.id
            and p.org is not null  -- где указан код орг и не важно какой период
            and to_char(p.dtek, 'YYYYMM') = m.period)
             group by lsk, org, usl, type;
    end if;

   --оплата
    if lsk_ is null then
      time_ := sysdate;
      insert into t_payment_for_saldo
        (lsk, summa, org, usl)
        select t.lsk, sum(t.summa) as summa, t.org, t.usl
          from kwtp_day t
         where t.priznak=1 and t.dat_ink between init.g_dt_start and init.g_dt_end
         group by t.lsk, t.org, t.usl;
      commit;
      logger.log_(time_, 'INSERT INTO t_payment_for_saldo (USL)');
    else
      insert into t_payment_for_saldo
        (lsk, summa, org, usl)
        select t.lsk, sum(t.summa) as summa, t.org, t.usl
          from kwtp_day t
         where t.priznak=1 and t.lsk=lsk_ and t.dat_ink between init.g_dt_start and init.g_dt_end
         group by t.lsk, t.org, t.usl;
    end if;

    --льготы
    if lsk_ is null then
      time_ := sysdate;
      insert into t_privs_for_saldo
        (lsk, summa, org, usl)
        select lsk, summa, org, usl from v_privs_for_saldo;
      commit;
      logger.log_(time_, 'INSERT INTO t_privs_for_saldo (USL)');
    else
      insert into t_privs_for_saldo
        (lsk, summa, org, usl)
        select lsk, summa, org, usl
          from v_privs_for_saldo c
         where c.lsk=lsk_;
    end if;

    --пен€
    if lsk_ is null then
      time_ := sysdate;
      insert into t_penya_for_saldo
        (lsk, summa, org, usl)
      select p.lsk, sum(p.summa) as summa, p.org, p.usl
        from kwtp_day p
       where p.priznak=0 and p.dat_ink between init.g_dt_start and init.g_dt_end
       group by p.lsk, p.usl, p.org;
      commit;
      logger.log_(time_, 'INSERT INTO t_penya_for_saldo (USL)');
    else
      insert into t_penya_for_saldo
        (lsk, summa, org, usl)
      select p.lsk, sum(p.summa) as summa, p.org, p.usl
        from kwtp_day p
       where p.priznak=0 and p.lsk=lsk_
       and p.dat_ink between init.g_dt_start and init.g_dt_end
       group by p.lsk, p.usl, p.org;
    end if;

    --субсидии
    if lsk_ is null then
      time_ := sysdate;
      insert into t_subsidii_for_saldo
        (lsk, summa, org, usl)
        select p.lsk, sum(p.summa) as summa, k.org, p.usl
          from nabor k, c_charge p, params m
         where p.type = 2
           and k.usl = p.usl
         group by p.lsk, p.usl, k.org;
      commit;
      logger.log_(time_, 'INSERT INTO t_subsidii_for_saldo (USL)');
    else
      insert into t_subsidii_for_saldo
        (lsk, summa, org, usl)
        select p.lsk, sum(p.summa) as summa, k.org, p.usl
          from nabor k, c_charge p, params m
         where k.lsk = lsk_
           and p.type = 2
           and k.usl = p.usl
         group by p.lsk, p.usl, k.org;
    end if;

     --ред.12.11.12
     --готовилось видимо дл€ распределени€ средств по задолжности...
     --пока убрал
/*    if lsk_ is null then
     --формирование задолжности по периодам
     --вычисл€ем самый старый период, не включа€ '000000'

     select min(mg) into init_mg_ from deb_usl_mg t where t.period=old_mg_
      and t.mg <> '000000';
     if init_mg_ is null then
      init_mg_:=mg_;
     end if;
     insert into deb_usl_mg
       (lsk, usl, org, summa, mg, period)
        select lsk, usl, org, sum(summa) as summa, mg, mg_ as period from
        (select t.lsk, t.usl, t.org, t.summa, t.mg
          from deb_usl_mg t
        where t.period=old_mg_
        union all
        select c.lsk, c.usl, c.org, c.summa, mg_
          from t_charges_for_saldo c
        union all
        select c.lsk, c.usl, c.org, c.summa, case when c.mg < init_mg_ then '000000'
         else c.mg end as mg --чтобы не допустить по€влени€ в таблице старых периодов
          from t_changes_mg_for_saldo c
        union all
        select c.lsk, c.usl, c.org, c.summa * -1, mg_
          from t_privs_for_saldo c
        union all
        select c.lsk, c.usl, c.org, c.summa * -1, mg_
          from t_subsidii_for_saldo c
         where c.usl <> '024' --эл.эн.субс не отображаетс€ на сальдо
        union all
        select c.lsk, c.usl, c.org, c.summa * -1, case when c.dopl < init_mg_ then '000000'
         else c.dopl end as mg
          from kwtp_day c
         where c.priznak=1) a
         group by lsk, usl, org, mg
         having sum(summa) <> 0;
    end if;*/

    if lsk_ is null then
      time_ := sysdate;
      --‘ормирование исход€щего сальдо USL
      --учитываем субсидию в оборотах
      insert into saldo_usl
        (lsk, org, usl, uslm, summa, mg)
        select t.lsk,
               t.org,
               t.usl,
               u.uslm,
               sum(t.summa) as summa,
               mg1_ as mg
          from (select lsk, org, usl, summa
                  from saldo_usl
                 where mg = mg_
                union all
                select c.lsk, c.org, c.usl, c.summa
                  from t_charges_for_saldo c
                union all
                select c.lsk, c.org, c.usl, c.summa
                  from t_changes_for_saldo c
                union all
                select c.lsk, c.org, c.usl, c.summa * -1
                  from t_privs_for_saldo c
                union all
                select c.lsk, c.org, c.usl, c.summa * -1
                  from t_subsidii_for_saldo c
                 where c.usl <> '024' --эл.эн.субс не отображаетс€ на сальдо
                union all
                select c.lsk, c.org, c.usl, c.summa * -1
                  from t_payment_for_saldo c) t,
               kart k,
               usl u
         where k.lsk = t.lsk
           and t.usl = u.usl
         group by t.lsk, t.org, t.usl, u.uslm
         having sum(t.summa)<>0; --исключить нулевое сальдо

      if utils.get_int_param('GEN_CHK_C_DEB_USL') = 1 then
       --по-периодный способ распределени€ оплаты
       --(сформировать задолжность)
       c_dist_pay.gen_deb_usl_all;
      end if;
      logger.log_(time1_, 'gen_saldo');
    else
      insert into saldo_usl
        (lsk, org, usl, uslm, summa, mg)
        select t.lsk,
               t.org,
               t.usl,
               u.uslm,
               sum(t.summa) as summa,
               mg1_ as mg
          from (select lsk, org, usl, summa
                  from saldo_usl
                 where mg = mg_
                union all
                select c.lsk, c.org, c.usl, c.summa
                  from t_charges_for_saldo c
                union all
                select c.lsk, c.org, c.usl, c.summa
                  from t_changes_for_saldo c
                union all
                select c.lsk, c.org, c.usl, c.summa * -1
                  from t_privs_for_saldo c
                union all
                select c.lsk, c.org, c.usl, c.summa * -1
                  from t_subsidii_for_saldo c
                 where c.usl <> '024' --эл.эн.субс не отображаетс€ на сальдо
                union all
                select c.lsk, c.org, c.usl, c.summa * -1
                  from t_payment_for_saldo c) t,
               usl u
         where t.usl = u.usl
           and t.lsk = lsk_
         group by t.lsk, t.org, t.usl, u.uslm
         having sum(t.summa)<>0; --исключить нулевое сальдо
    end if;
    commit;
  end gen_saldo;

  procedure gen_saldo_houses
  -- ‘ормирование сальдо по домам mg_ - текущий мес€ц
    -- ¬џѕќЋЌя“№ ѕќ—Ћ≈ ‘ќ–ћ»–ќ¬јЌ»я GEN_PREP_OPL!!!
   is
    stmt varchar2(5000);
    mg1_ varchar2(6);
    time_ date;
    mg_ params.period%type;
  begin
    select period into mg_ from params p;
    time_ := sysdate;
    --¬ычисл€ем следующий мес€ц
    mg1_ := to_char(add_months(to_date(mg_ || '01', 'YYYYMMDD'), 1),
                    'YYYYMM');

    --ƒобавл€ем во временную таблицу
    execute immediate 'TRUNCATE TABLE t_saldo_lsk';
    insert into t_saldo_lsk
      (lsk, org, usl, uslm, status)
      select distinct k.lsk, a.org, a.usl, u.uslm, k.status
        from (select a.lsk, a.org, a.usl
                from saldo_usl a, v_params v
               where a.mg = v.period1
              union all
              select e.lsk, e.org, e.usl
                from t_charges_for_saldo e
              union all
              select e.lsk, e.org, e.usl
                from t_chpenya_for_saldo e --должно попасть так как есть начисление
              union all
              select e.lsk, e.org, e.usl
                from t_changes_for_saldo e
              union all
              select e.lsk, e.org, e.usl
                from t_subsidii_for_saldo e
              union all
              select e.lsk, e.org, e.usl
                from t_payment_for_saldo e
              union all
              select e.lsk, e.org, e.usl
                from t_privs_for_saldo e
              union all
              select e.lsk, e.org, e.usl from t_penya_for_saldo e) a,
             kart k,
             usl u
       where k.lsk = a.lsk
         and a.usl = u.usl;
    commit;

    delete from xitog3_lsk t where t.mg = mg_;
    insert into xitog3_lsk
      (lsk,
       org,
       usl,
       uslm,
       status,
       indebet,
       inkredit,
       charges,
       pcharges,
       changes,
       ch_full,
       changes2,
       subsid,
       privs,
       payment,
       pn,
       outdebet,
       outkredit,
       mg)
      select t.lsk,
             t.org,
             t.usl,
             t.uslm,
             nvl(t.status, 0),
             sum(a.summa) indebet,
             sum(b.summa) inkredit,
             sum(nvl(e.summa, 0) + nvl(f.summa, 0) + nvl(w.summa, 0) -
                 nvl(o.summa, 0) - nvl(g.summa, 0)) charges,
             sum(nvl(p.summa, 0)) pcharges,
             sum(nvl(f.summa, 0)) changes,  --скидки
             sum(nvl(e.summa, 0)) ch_full,
             sum(nvl(w.summa, 0)) changes2, --доборы, возвраты
             sum(g.summa) subsid,
             sum(o.summa) privs,
             sum(h.summa) payment,
             sum(j.summa) pn,
             sum(k.summa) outdebet,
             sum(l.summa) outkredit,
             mg_ as mg
        from t_saldo_lsk t,
             (select t.lsk, t.org, t.usl, t.uslm, sum(summa) as summa
                from saldo_usl t
               where sign(summa) >= 0
                 and mg = mg_
               group by t.lsk, t.org, t.usl, t.uslm) a,
             (select t.lsk, t.org, t.usl, t.uslm, sum(summa) as summa
                from saldo_usl t
               where sign(summa) < 0
                 and mg = mg_
               group by t.lsk, t.org, t.usl, t.uslm) b,
             (select t.lsk, t.org, t.usl, t.uslm, sum(summa) as summa
                from saldo_usl t
               where sign(summa) >= 0
                 and mg = mg1_
               group by t.lsk, t.org, t.usl, t.uslm) k,
             (select t.lsk, t.org, t.usl, t.uslm, sum(summa) as summa
                from saldo_usl t
               where sign(summa) < 0
                 and mg = mg1_
               group by t.lsk, t.org, t.usl, t.uslm) l,
             t_charges_for_saldo e,
             t_privs_for_saldo o,
             (select t.lsk, t.org, t.usl, t.summa
                from t_changes_for_saldo t
               where t.type in (0)) f, --скидки
             (select t.lsk, t.org, t.usl, t.summa
                from t_changes_for_saldo t
               where t.type in (1)) w, --доборы, возвраты
             t_subsidii_for_saldo g,
             t_payment_for_saldo h,
             t_penya_for_saldo j,
             t_chpenya_for_saldo p
       where t.lsk = a.lsk(+)
         and t.org = a.org(+)
         and t.usl = a.usl(+)

         and t.lsk = b.lsk(+)
         and t.org = b.org(+)
         and t.usl = b.usl(+)

         and t.lsk = k.lsk(+)
         and t.org = k.org(+)
         and t.usl = k.usl(+)

         and t.lsk = l.lsk(+)
         and t.org = l.org(+)
         and t.usl = l.usl(+)

         and t.lsk = e.lsk(+)
         and t.org = e.org(+)
         and t.usl = e.usl(+)

         and t.lsk = o.lsk(+)
         and t.org = o.org(+)
         and t.usl = o.usl(+)

         and t.lsk = f.lsk(+)
         and t.org = f.org(+)
         and t.usl = f.usl(+)

         and t.lsk = w.lsk(+)
         and t.org = w.org(+)
         and t.usl = w.usl(+)

         and t.lsk = g.lsk(+)
         and t.org = g.org(+)
         and t.usl = g.usl(+)

         and t.lsk = h.lsk(+)
         and t.org = h.org(+)
         and t.usl = h.usl(+)

         and t.lsk = j.lsk(+)
         and t.org = j.org(+)
         and t.usl = j.usl(+)

         and t.lsk = p.lsk(+)
         and t.org = p.org(+)
         and t.usl = p.usl(+)
       group by t.lsk, t.org, t.usl, t.uslm, nvl(t.status, 0)
       having
       nvl(sum(a.summa), 0) <> 0 or
       nvl(sum(b.summa), 0) <> 0 or
       sum(nvl(e.summa, 0) + nvl(f.summa, 0) + nvl(w.summa, 0) -
           nvl(o.summa, 0) - nvl(g.summa, 0)) <> 0 or
       sum(nvl(p.summa, 0)) <> 0 or
       sum(nvl(f.summa, 0)) <> 0 or
       sum(nvl(e.summa, 0)) <> 0 or
       sum(nvl(w.summa, 0)) <> 0 or
       nvl(sum(g.summa), 0) <> 0 or
       nvl(sum(o.summa), 0) <> 0 or
       nvl(sum(h.summa), 0) <> 0 or
       nvl(sum(j.summa), 0) <> 0 or
       nvl(sum(k.summa), 0) <> 0 or
       nvl(sum(l.summa), 0) <> 0;


    -- выбираем уникальные дома + орг. + усл. дл€ формировани€ отчетности по сальдо
    delete from t_saldo_lsk2;
    insert into t_saldo_lsk2
      (lsk, org, usl)
      select distinct t.lsk, t.org, t.usl from xitog3_lsk t;

    commit;

    delete from xitog3 where mg = mg_;
    insert into xitog3 t
      (reu,
       trest,
       kul,
       nd,
       org,
       usl,
       uslm,
       status,
       indebet,
       inkredit,
       charges,
       pcharges,
       changes,
       ch_full,
       changes2,
       subsid,
       privs,
       payment,
       pn,
       outdebet,
       outkredit,
       mg)
      select s.reu,
             s.trest,
             k.kul,
             k.nd,
             x.org,
             x.usl,
             x.uslm,
             k.status,
             sum(x.indebet),
             sum(x.inkredit),
             sum(x.charges),
             sum(x.pcharges),
             sum(x.changes),
             sum(x.ch_full),
             sum(x.changes2),
             sum(x.subsid),
             sum(x.privs),
             sum(x.payment),
             sum(x.pn),
             sum(x.outdebet),
             sum(x.outkredit),
             x.mg
        from xitog3_lsk x, kart k, s_reu_trest s
       where x.mg = mg_
         and x.lsk = k.lsk
         and k.reu = s.reu
       group by s.reu,
                s.trest,
                k.kul,
                k.nd,
                x.org,
                x.usl,
                x.uslm,
                k.status,
                x.mg;

    -- выбираем уникальные дома + орг. + усл. дл€ формировани€ отчетности по сальдо
    delete from t_saldo_reu_kul_nd_st;
    insert into t_saldo_reu_kul_nd_st
      (reu, kul, nd, status, org, usl, uslm)
      select distinct t.reu, t.kul, t.nd, t.status, t.org, t.usl, t.uslm
        from xitog3 t;

    logger.ins_period_rep('1', mg_, null, 0);
    logger.ins_period_rep('14', mg_, null, 0);
    logger.ins_period_rep('81', mg_, null, 0);
    logger.ins_period_rep('89', mg_, null, 0);
    logger.ins_period_rep('90', mg_, null, 0);

    commit;
    logger.log_(time_, 'gen_saldo_houses');
  end gen_saldo_houses;

  procedure gen_xito13 is
    type_otchet constant number := 19; --начисление по услугам
    time_ date;
  begin
    time_ := sysdate;
    --«ј ћ≈—я÷
    --Ќачисление по услугам
    delete from xito13 x where x.mg = (select p.period from params p);
    insert into xito13
      (usl, uslm, reu, kul, nd, trest, mg, summa)
      select c.usl,
             u.uslm,
             k.reu,
             k.kul,
             k.nd,
             s.trest,
             p.period,
             sum(c.summa)
        from c_charge c, kart k, s_reu_trest s, params p, usl u
       where c.lsk = k.lsk
         and c.type = 1
         and k.reu = s.reu
         and c.usl = u.usl
       group by c.usl, u.uslm, k.reu, k.kul, k.nd, s.trest, p.period;

    delete from period_reports p
     where p.id = type_otchet
       and p.mg = (select p.period from params p); --обновл€ем период дл€ отчета
    insert into period_reports
      (id, mg)
    values
      (type_otchet, (select p.period from params p));
    commit;
    logger.log_(time_, 'gen.gen_xito13');
  end;

  procedure gen_debits_lsk_month(dat_ in date) is
    mg_  params.period%type;
    mg1_ params.period%type;
    mg3_ params.period%type;
    var_ params.kan_var%type;
    time_ date;
  begin
    time_ := sysdate;
    --задолжники по лицевым
    --формировать после архивных карточек
    --выполн€ть ƒќ перехода, выгружать, - когда угодно
    select period into mg_ from params;
    --¬ычисл€ем следующий мес€ц
    mg1_ := to_char(add_months(to_date(mg_ || '01', 'YYYYMMDD'), 1),
                    'YYYYMM');
    --¬ычисл€ем передыдущ мес€ц
    mg3_ := to_char(add_months(to_date(mg_ || '01', 'YYYYMMDD'), -1),
                    'YYYYMM');
    select nvl(p.kan_var, 0) into var_ from params p;
    if dat_ is not null then
      delete from debits_lsk_month d where d.dat = dat_;
    else
      delete from debits_lsk_month d where d.mg = mg_;
    end if;
    if var_ = 0 then
      -- иселевск - не работает ветка скорее всего))
      insert into debits_lsk_month
        (lsk, reu, kul, name, nd, kw, fio, status, opl, cnt_month, dolg,
         nachisl, penya, payment, pay_pen, mg, dat)
        select a.lsk, a.reu, a.kul, s.name, a.nd, a.kw, a.fio, a.status,
               a.opl,
               round(decode(b.summa, 0, 0, a.dolg / b.summa), 0) as cnt_month,
               a.dolg, b.summa as nachisl, a.penya, c.summa, a.pay_pen, case when dat_ is null then mg_
                                                             else null end,
               dat_ --1 - часть - долги по текущему фонду
          from (select t.k_lsk_id, t.lsk, t.reu, t.kul, t.nd,
                        t.kw, t.fio, t.status, t.opl, s.dolg as dolg,
                        e.penya as penya, f.pay_pen
                   from arch_kart t,
                        (select lsk, sum(summa) as dolg
                            from saldo_usl
                           where usl not in (select u.usl_id from usl_excl u)
                             and mg = mg1_
                           group by lsk) s,
                        (select lsk, sum(penya) as penya
                            from a_penya
                           where mg = mg_
                           group by lsk) e,
                        (select lsk, sum(t.penya) as pay_pen
                            from a_kwtp_mg t
                           where mg = mg_
                           group by lsk) f, v_lsk_tp tp
                  where t.mg = mg_
                    and t.lsk = s.lsk(+)
                    and t.lsk = e.lsk(+)
                    and t.lsk = f.lsk(+)
                    and t.fk_tp=tp.id and tp.cd in ('LSK_TP_MAIN')-- ис.просили исключить счета капрем 30.07.2015
                    and t.psch <> 8) a,
               (select k.k_lsk_id, sum(d.summa_it) as summa
                   from arch_kart k, arch_charges d, usl u, v_lsk_tp tp
                  where d.mg = mg_
                    and k.mg = mg_
                    and k.lsk = d.lsk
                    and d.usl_id=u.usl
                    and d.usl_id not in (select u.usl_id from usl_excl u)
                    and k.fk_tp=tp.id and tp.cd in ('LSK_TP_MAIN')-- ис.просили исключить счета капрем 30.07.2015
                    --and u.cd not in ('кап.' , 'кап/св.нор') -- ис.просили исключить капрем 30.07.2015
                    and k.psch <> 8
                  group by k.k_lsk_id) b,
               (select k.lsk, sum(d.summa) as summa
                   from arch_kart k, a_kwtp_mg d, v_lsk_tp tp
                  where d.mg = mg_
                    and k.mg = mg_
                    and k.lsk = d.lsk
                    and k.fk_tp=tp.id and tp.cd in ('LSK_TP_MAIN')-- ис.просили исключить счета капрем 30.07.2015
                  group by k.lsk) c, spul s
         where a.k_lsk_id = b.k_lsk_id(+)
           and a.kul = s.id
           and a.lsk = c.lsk(+)
           and round(decode(b.summa, 0, 0, a.dolg / b.summa), 0) > 0
        union all
        select a.lsk, a.reu, a.kul, s.name, a.nd, a.kw, a.fio, a.status,
               a.opl,
               case when a.dolg > 0 then 2 else 0 end as cnt_month,
               a.dolg, b.summa as nachisl, a.penya, c.summa, a.pay_pen, case when dat_ is null then mg_
                                                             else null end,
               dat_--2 - часть - долги по закрытому фонду
          from (select t.lsk, t.k_lsk_id, t.reu, t.kul, t.nd,
                        t.kw, t.fio, t.status, t.opl, s.dolg as dolg,
                        e.penya as penya, f.pay_pen
                   from arch_kart t,
                        (select lsk, sum(summa) as dolg
                            from saldo_usl
                           where usl not in (select u.usl_id from usl_excl u)
                             and mg = mg1_
                           group by lsk) s,
                        (select lsk, sum(penya) as penya
                            from a_penya
                           where mg = mg_
                           group by lsk) e,
                        (select lsk, sum(t.penya) as pay_pen
                            from a_kwtp_mg t
                           where mg = mg_
                           group by lsk) f, v_lsk_tp tp
                  where t.mg = mg_
                    and t.lsk = s.lsk(+)
                    and t.lsk = e.lsk(+)
                    and t.lsk = f.lsk(+)
                    and t.fk_tp=tp.id and tp.cd in ('LSK_TP_MAIN')
                    and t.psch = 8) a,
               (select k.k_lsk_id, sum(d.summa_it) as summa
                   from arch_kart k, arch_charges d, usl u, v_lsk_tp tp
                  where d.mg = mg_
                    and k.mg = mg_
                    and k.lsk = d.lsk
                    and d.usl_id=u.usl
                    and d.usl_id not in (select u.usl_id from usl_excl u)
                    and k.fk_tp=tp.id and tp.cd in ('LSK_TP_MAIN')-- ис.просили исключить счета капрем 30.07.2015
                    --and u.cd not in ('кап.' , 'кап/св.нор') -- ис.просили исключить капрем 30.07.2015
                    and k.psch <> 8
                  group by k.k_lsk_id) b,
               (select k.lsk, sum(d.summa) as summa
                   from arch_kart k, a_kwtp_mg d, v_lsk_tp tp
                  where d.mg = mg_
                    and k.mg = mg_
                    and k.fk_tp=tp.id and tp.cd in ('LSK_TP_MAIN')
                    and k.lsk = d.lsk
                  group by k.lsk) c, spul s
         where a.k_lsk_id = b.k_lsk_id(+)
           and a.kul = s.id
           and a.lsk = c.lsk(+)
           and a.dolg > 0;
    elsif var_=1 then
      --“—∆
      insert into debits_lsk_month
        (lsk, reu, kul, name, nd, kw, fk_deb_org, fio, status, opl,
         cnt_month, dolg, cnt_month2, dolg2, nachisl, penya, payment, mg, dat)
        select a.lsk, a.reu, a.kul, s.name, a.nd, a.kw, a.fk_deb_org, a.fio,
               a.status, a.opl,
                 case when a.psch not in (8,9) and nvl(b.summa,0) <> 0 then
                      a.cnt_month
                     when a.psch in (8,9) and nvl(b.summa,0) = 0 and nvl(a.dolg,0)  > 0 --по закрытым например
                     then 2 --ставим 2 мес.задолжности  (поправил 2 мес. дл€ кис 07.08.2015) 
                     else 0
                     end 
                     as cnt_month,
                     nvl(a.dolg,0) /* долг же уже с учетом оплаты и изменений ред 22.03.12 - nvl(c.summa, 0) + nvl(e.summa, 0)*/
                     as dolg, --долг с учетом оплаты
               case when nvl(b.summa,0) <> 0 and (nvl(a.dolg,0)+ nvl(c.summa, 0)) / nvl(b.summa,0) >= 1
                    then a.cnt_month --(nvl(a.dolg,0)+ nvl(c.summa, 0)) / nvl(b.summa,0) ред.19.09.14
                    when nvl(b.summa,0) <> 0 and (nvl(a.dolg,0)+ nvl(c.summa, 0)) / nvl(b.summa,0) < 1
                    then 0
                    when nvl(b.summa,0) = 0 and nvl(a.dolg,0)+ nvl(c.summa, 0) > 0 --по закрытым например
                    then 1 --ставим 1 мес.задолжности
                    else 0
                    end as cnt_month2, nvl(a.dolg,0) + nvl(c.summa, 0) as dolg2,--долг без учета оплаты
               b.summa as nachisl, a.penya, c.summa, case when dat_ is null then mg_
                                                             else null end,
                                                               dat_
          from (select t.psch, t.k_lsk_id, t.lsk, t.fk_deb_org, t.reu, t.kul, t.nd, t.kw,
                        t.fio, t.status, t.opl, e.dolg as dolg,
                        e.penya as penya, e.cnt_month
                   from arch_kart t,
                        (select k.k_lsk_id, sum(a.summa) as dolg, sum(penya) as penya, 
                            sum(case when a.penya >0 then 1 else 0 end) as cnt_month
                            from kart k, a_penya a, v_lsk_tp tp
                           where k.lsk=a.lsk and a.mg = mg_
                                 and k.fk_tp=tp.id and tp.cd in ('LSK_TP_MAIN')
                           group by k.k_lsk_id) e, v_lsk_tp tp
                  where t.mg = mg_
                    and t.k_lsk_id = e.k_lsk_id(+)
                    and t.fk_tp=tp.id and tp.cd in ('LSK_TP_MAIN')
                    and t.psch <> 8
                    ) a,
               (select k.k_lsk_id, sum(d.summa_it) as summa
                   from kart k, arch_charges d, v_lsk_tp tp --начисление
                  where k.lsk=d.lsk and d.mg = mg_
                        and k.fk_tp=tp.id and tp.cd in ('LSK_TP_MAIN')
                  group by k.k_lsk_id) b,
               (select k.k_lsk_id, sum(d.summa) as summa
                   from kart k, a_kwtp_mg d, v_lsk_tp tp --оплата
                  where k.lsk=d.lsk and d.mg = mg_
                        and k.fk_tp=tp.id and tp.cd in ('LSK_TP_MAIN')
                  group by k.k_lsk_id) c,
               (select k.k_lsk_id, sum(d.summa) as summa
                   from kart k, a_change d, v_lsk_tp tp  --изменени€
                  where k.lsk=d.lsk and d.mg = mg_
                        and k.fk_tp=tp.id and tp.cd in ('LSK_TP_MAIN')
                  group by k.k_lsk_id) e,
                  spul s
         where a.k_lsk_id = b.k_lsk_id(+)
           and a.kul = s.id
           and a.k_lsk_id = c.k_lsk_id(+)
           and a.k_lsk_id = e.k_lsk_id(+)
           and nvl(a.dolg,0) > 0;
    elsif var_ in (2,4) then
    --дл€ “—∆, задолжность по л.с. (реально кол-во мес)
    --и задолжностью считаетс€ не текущий период, а период по которому начислена пен€
      insert into debits_lsk_month
        (lsk, reu, kul, name, nd, kw, fk_deb_org, fio, status, opl,
         cnt_month, dolg, cnt_month2, dolg2, nachisl, penya, payment, pay_pen, mg, dat)
        select a.lsk, a.reu, a.kul, s.name, a.nd, a.kw, a.fk_deb_org, a.fio,
               a.status, a.opl, a.cnt_month
/*
               case when a.psch not in (8,9) and nvl(b.summa,0) <> 0 then
                      a.cnt_month
                     when a.psch in (8,9) and nvl(b.summa,0) = 0 and nvl(a.dolg,0)  > 0 --по закрытым например
                     then 2 --ставим 2 мес.задолжности  (поправил 2 мес. дл€ кис 07.08.2015) 
                     else 0
                     end */

                      as cnt_month,
                     nvl(a.dolg,0) /* долг же уже с учетом оплаты и изменений ред 22.03.12 - nvl(c.summa, 0) + nvl(e.summa, 0)*/
                     as dolg, --долг с учетом оплаты
               a.cnt_month as cnt_month2, nvl(a.dolg,0) + nvl(c.summa, 0) as dolg2,--долг без учета оплаты
               b.summa as nachisl, a.penya, c.summa, c.penya, case when dat_ is null then mg_
                                                             else null end,
                                                               dat_
          from (select t.psch, t.lsk, t.fk_deb_org, t.reu, t.kul, t.nd, t.kw,
                        t.fio, t.status, t.opl, e.dolg as dolg,
                        e.penya as penya,  e.cnt_month
                   from arch_kart t,
                        (select k.lsk, count(*) as cnt_month,
                        sum(a.summa) as dolg, sum(penya) as penya
                            from kart k, a_penya a, v_lsk_tp tp
                           where k.lsk=a.lsk and a.mg = mg_
                           and k.fk_tp=tp.id and tp.cd in ('LSK_TP_MAIN')
                           and (var_=4 and nvl(a.penya,0) <> 0 or var_<>4) --поправил по просьбе —воб., 14.12.2015
                           group by k.lsk) e, v_lsk_tp tp
                  where t.mg = mg_
                    and t.fk_tp=tp.id and tp.cd in ('LSK_TP_MAIN')
                    and t.lsk = e.lsk(+)
                    --and t.psch <> 8
                    ) a,
               (select k.lsk, sum(d.summa_it) as summa
                   from kart k, arch_charges d, v_lsk_tp tp --начисление
                  where k.lsk=d.lsk and d.mg = mg_
                    and k.fk_tp=tp.id and tp.cd in ('LSK_TP_MAIN')
                  group by k.lsk) b,
               (select k.lsk, sum(d.summa) as summa, sum(d.penya) as penya
                   from kart k, a_kwtp_mg d, v_lsk_tp tp --оплата
                  where k.lsk=d.lsk and d.mg = mg_
                    and k.fk_tp=tp.id and tp.cd in ('LSK_TP_MAIN')
                  group by k.lsk) c,
               (select k.lsk, sum(d.summa) as summa
                   from kart k, a_change d, v_lsk_tp tp  --изменени€
                  where k.lsk=d.lsk and d.mg = mg_
                    and k.fk_tp=tp.id and tp.cd in ('LSK_TP_MAIN')
                  group by k.lsk) e,
                  spul s
         where a.lsk = b.lsk(+)
           and a.kul = s.id
           and a.lsk = c.lsk(+)
           and a.lsk = e.lsk(+)
           and nvl(a.dolg,0) > 0;
    elsif var_=3 then
    --дл€ ѕќЋџ— ¬–≈ћ≈ЌЌџ… ¬ј–»јЌ“!!! (задолжностью считаетс€ всЄ что -1 мес€ц назад гл€д€ на пеню), задолжность по л.с. (реально кол-во мес)
    --и задолжностью считаетс€ не текущий период, а период по которому начислена пен€
      insert into debits_lsk_month
        (lsk, k_lsk_id, reu, kul, name, nd, kw, fk_deb_org, fio, status, opl,
         cnt_month, dolg, cnt_month2, dolg2, nachisl, penya, payment, mg, dat)
        select a.lsk, a.k_lsk_id, a.reu, a.kul, s.name, a.nd, a.kw, a.fk_deb_org, a.fio,
               a.status, a.opl,
               a.cnt_month as cnt_month,
                     nvl(a.dolg,0) /* долг же уже с учетом оплаты и изменений ред 22.03.12 - nvl(c.summa, 0) + nvl(e.summa, 0)*/
                     as dolg, --долг с учетом оплаты
               a.cnt_month as cnt_month2, nvl(a.dolg,0) + nvl(c.summa, 0) as dolg2,--долг без учета оплаты
               b.summa as nachisl, a.penya, c.summa, case when dat_ is null then mg_
                                                             else null end,
                                                               dat_
          from (select t.psch, t.k_lsk_id, t.lsk, t.fk_deb_org, t.reu, t.kul, t.nd, t.kw,
                        t.fio, t.status, t.opl, e.dolg as dolg,
                        e.penya as penya, e.cnt_month
                   from arch_kart t, v_lsk_tp tp,
                        (select k.k_lsk_id, count(*) as cnt_month,
                        sum(a.summa) as dolg, sum(penya) as penya
                            from kart k, a_penya a
                           where k.lsk=a.lsk and a.mg = mg_
                           and nvl(a.summa,0) <> 0
                           and a.mg1 <= mg3_ --бред
                           group by k.k_lsk_id) e
                  where t.mg = mg_
                    and t.k_lsk_id = e.k_lsk_id(+)
                    and t.psch <> 8
                    and t.fk_tp=tp.id
                    and tp.cd='LSK_TP_MAIN' --долг показать по основному лиц.счету
                    ) a,
               (select k.k_lsk_id, sum(d.summa_it) as summa
                   from kart k, arch_charges d --начисление
                  where k.lsk=d.lsk and d.mg = mg_
                  group by k.k_lsk_id) b,
               (select k.k_lsk_id, sum(d.summa) as summa
                   from kart k, a_kwtp_mg d --оплата
                  where k.lsk=d.lsk and d.mg = mg_
                  group by k.k_lsk_id) c,
               (select k.k_lsk_id, sum(d.summa) as summa
                   from kart k, a_change d  --изменени€
                  where k.lsk=d.lsk and d.mg = mg_
                  group by k.k_lsk_id) e,
                  spul s
         where a.k_lsk_id = b.k_lsk_id(+)
           and a.kul = s.id
           and a.k_lsk_id = c.k_lsk_id(+)
           and a.k_lsk_id = e.k_lsk_id(+)
           and nvl(a.dolg,0) > 0;
    end if;


    if dat_ is not null then
      logger.ins_period_rep('54', null, dat_, 0);
      logger.ins_period_rep('69', null, dat_, 0);
      logger.ins_period_rep('82', null, dat_, 0);
      logger.ins_period_rep('80', null, dat_, 0);
    else
      logger.ins_period_rep('54', mg_, null, 0);
      logger.ins_period_rep('69', mg_, null, 0);
      logger.ins_period_rep('82', mg_, null, 0);
      logger.ins_period_rep('80', mg_, null, 0);
    end if;
    commit;
    logger.log_(time_, 'gen.gen_debits_lsk_month');
  end;

  procedure load_saldo(mg_ in varchar2)
  --ѕервоначальна€ загрузка сальдо mg_ - текущий мес€ц
   is
    stmt varchar2(2000);
    time_ date;
  begin
    time_ := sysdate;
    stmt  := 'TRUNCATE TABLE saldo';
    execute immediate stmt;
    stmt := 'INSERT INTO saldo (lsk, org, uslm, summa, mg)
               SELECT lsk, kod, USLM, SUM(SWX) summa, :mg1
               FROM SWX t
               GROUP BY lsk, kod, USLM';
    execute immediate stmt
      using mg_;
    commit;
    logger.log_(time_, 'gen.load_saldo');
  end load_saldo;

/*  procedure distrib_vols
  --–аспределение кубов по домам, в конце мес€ца
   is
    time_ date;
  begin
  --устарело - закрыто!!!!
  --ред.06.11.12

    time_ := sysdate;
    --„тоб сработал триггер, где и произойдЄт распределение
    update c_vvod t set t.kub = t.kub, t.vol_add = t.vol_add
       where kub <> 0;
    commit;
    logger.log_(time_, 'gen.distrib_vols');
  end distrib_vols;
*/
/*  procedure prepare_arch_lsk(lsk_     in kart.lsk%type,
                             lsk_end_ in kart.lsk%type) is
  bill_pen_ number;
  begin
    --подготовка счета индивидуально по c_lsk_id
    for c in (select distinct c_lsk_id
                from kart k
               where k.lsk between lsk_ and lsk_end_) loop
      --начисление
      gen_c_charges(c.c_lsk_id);
      --сальдо
      gen_saldo(c.c_lsk_id);
      --архив
      prepare_arch(c.c_lsk_id);
      select nvl(p.bill_pen,0) into bill_pen_ from params p;
      if bill_pen_ = 1 then
        --пен€ по тек. дате
        c_cpenya.gen_penya(c.c_lsk_id, 0);
      else
        --пен€ по конечной дате мес€ца
        c_cpenya.gen_penya(c.c_lsk_id, 1);
      end if;
    end loop;
  end;
*/
  procedure prepare_arch_lsk(lsk_     in kart.lsk%type,
                             var_     in number) is
  bill_pen_ number;
  begin
    --подготовка счета индивидуально по lsk
    if var_ = 0 then
      --начисление
      gen_c_charges(lsk_);
      --сальдо
      gen_saldo(lsk_);
      --архив
      prepare_arch(lsk_);
    end if;
    --движение
    c_cpenya.gen_charge_pay(lsk_, 0);
    --пен€ в любом случае
    select nvl(p.bill_pen,0) into bill_pen_ from params p;
    if bill_pen_ = 1 then
      --пен€ по тек. дате
      c_cpenya.gen_penya(lsk_, 0, 0);
    else
      --пен€ по конечной дате мес€ца
      c_cpenya.gen_penya(lsk_, 1, 0);
    end if;
    commit;
  end;

  procedure prepare_arch_k_lsk(k_lsk_id_     in kart.k_lsk_id%type,
                             pen_last_month_ in number,
                             var_     in number) is
  begin
    --подготовка счета индивидуально k_lsk
    for c in (select distinct c_lsk_id, k.lsk
                from kart k
               where k.k_lsk_id = k_lsk_id_) loop
      if var_ = 0 then
      --включить еще формирование архива
        --начисление
        gen_c_charges(c.lsk);
        --сальдо
        gen_saldo(c.lsk);
        --архив
        prepare_arch(c.lsk);
      end if;
      --движение
      c_cpenya.gen_charge_pay(c.lsk, 1);
      --пен€
      c_cpenya.gen_penya(c.lsk, nvl(pen_last_month_,0), 0);
      --пор€док листов в счете
      upd_arch_kart2(k_lsk_id_, null);
      
    end loop;
    commit;
  end;

  procedure prepare_arch_adr(kul_ in kart.kul%type,
                             nd_  in kart.nd%type,
                             kw_  in kart.kw%type,
                             var_ in number) is
  begin
    --подготовка счета индивидуально по адресу
    for c in (select distinct c_lsk_id
                from kart k
               where k.kul = kul_
                 and k.nd = nd_
                 and k.kw = kw_) loop
      if var_ = 0 then
        --начисление
        gen_c_charges(c.c_lsk_id);
        --сальдо
        gen_saldo(c.c_lsk_id);
        --архив
        prepare_arch(c.c_lsk_id);
        --пен€
        c_cpenya.gen_charge_pay(c.c_lsk_id, 1);
        c_cpenya.gen_penya(c.c_lsk_id, 1, 0);
      elsif var_ = 1 then
        --только пен€
        c_cpenya.gen_charge_pay(c.c_lsk_id, 1);
        c_cpenya.gen_penya(c.c_lsk_id, 0, 0);
      end if;
    end loop;
    commit;
  end;

  procedure prepare_arch_all is
  begin
  Raise_application_error(-20000, 'ѕроцедура prepare_arch_all не работает!');
    --подготовка всех счетов (по окончанию мес€ца)
    for c in (select k.lsk from kart k
      where not exists (--только те л/c, где нужен перерасчет
           select *
                  from t_objxpar x, u_list s, u_listtp tp where
                  s.fk_listtp=tp.id and tp.cd='ѕараметры лиц.счета'
                  and x.fk_list=s.id and s.cd='gen_bill'
                  and x.fk_lsk=k.lsk
                  and x.n1=0)
                  )
    loop
      prepare_arch(c.lsk);
    end loop;
  end;

  procedure prepare_arch(lsk_ in kart.lsk%type) is
    cnt_ number;
    mg_  varchar2(6);
    mg1_  varchar2(6);
    old_mg_  varchar2(6);
    -- јрхив
    time_ date;
  begin
    time_ := sysdate;
    -- —оздаем архивы
    --текущий мес€ц
    select p.period into mg_ from params p;
    --мес€ц вперед
    mg1_:=to_char(add_months(to_date(mg_, 'YYYYMM'), 1), 'YYYYMM');
    --мес€ц назад
    old_mg_:=to_char(add_months(to_date(mg_||'01','YYYYMMDD'),-1), 'YYYYMM');
    --архив расценок
    if lsk_ is null then
      trunc_part('a_prices', mg_);
      insert into a_prices
        (usl, summa, summa2, summa3, fk_org, mg)
        select usl, summa, summa2, summa3, fk_org, p.period from prices c, params p;
    end if;

    --архив платежей
    if lsk_ is null then
      trunc_part('a_kwtp', mg_);
      insert into a_kwtp
        (lsk,
         summa,
         penya,
         oper,
         dopl,
         nink,
         nkom,
         dtek,
         nkvit,
         dat_ink,
         ts,
         id,
         iscorrect,
         num_doc,
         dat_doc,
         mg)
        select c.lsk,
               c.summa,
               c.penya,
               c.oper,
               c.dopl,
               c.nink,
               c.nkom,
               c.dtek,
               c.nkvit,
               c.dat_ink,
               c.ts,
               c.id,
               c.iscorrect,
               c.num_doc,
               c.dat_doc,
               p.period
          from c_kwtp c, params p
         where 
         c.dat_ink between init.g_dt_start and init.g_dt_end;
    else
      delete from a_kwtp a
       where a.lsk=lsk_ and a.mg = mg_;
      insert into a_kwtp
        (lsk,
         summa,
         penya,
         oper,
         dopl,
         nink,
         nkom,
         dtek,
         nkvit,
         dat_ink,
         ts,
         id,
         iscorrect,
         num_doc,
         dat_doc,
         mg)
        select c.lsk,
               c.summa,
               c.penya,
               c.oper,
               c.dopl,
               c.nink,
               c.nkom,
               c.dtek,
               c.nkvit,
               c.dat_ink,
               c.ts,
               c.id,
               c.iscorrect,
               c.num_doc,
               c.dat_doc,
               p.period
          from c_kwtp c, params p
         where c.dat_ink between init.g_dt_start and init.g_dt_end
         and c.lsk = lsk_; --по дате (здесь dtek!!!)
    end if;

    if lsk_ is null then
      trunc_part('a_kwtp_mg', mg_);
      insert into a_kwtp_mg
        (id,
         lsk,
         summa,
         penya,
         oper,
         dopl,
         nink,
         nkom,
         dtek,
         nkvit,
         dat_ink,
         ts,
         c_kwtp_id,
         mg)
        select c.id,
               c.lsk,
               c.summa,
               c.penya,
               c.oper,
               c.dopl,
               c.nink,
               c.nkom,
               c.dtek,
               c.nkvit,
               c.dat_ink,
               c.ts,
               c.c_kwtp_id,
               p.period
          from c_kwtp_mg c, params p
          where c.dat_ink between init.g_dt_start and init.g_dt_end;
    else
      delete from a_kwtp_mg a
       where a.lsk=lsk_ and a.mg = mg_;
      insert into a_kwtp_mg
        (id,
         lsk,
         summa,
         penya,
         oper,
         dopl,
         nink,
         nkom,
         dtek,
         nkvit,
         dat_ink,
         ts,
         c_kwtp_id,
         mg)
        select c.id,
               c.lsk,
               c.summa,
               c.penya,
               c.oper,
               c.dopl,
               c.nink,
               c.nkom,
               c.dtek,
               c.nkvit,
               c.dat_ink,
               c.ts,
               c.c_kwtp_id,
               p.period
          from c_kwtp_mg c, params p
         where c.lsk = lsk_
               and c.dat_ink between init.g_dt_start and init.g_dt_end;
    end if;

--архив распределЄнной оплаты
    if lsk_ is null then
        trunc_part('a_kwtp_day', mg_);
        insert into a_kwtp_day
          (kwtp_id, summa, lsk, oper, dopl, nkom, nink, dat_ink, priznak, usl, org, fk_distr, sum_distr, id, mg, dtek)
        select
          t.kwtp_id, t.summa, t.lsk, t.oper, t.dopl, t.nkom, t.nink, t.dat_ink, t.priznak,
          t.usl, t.org, t.fk_distr, t.sum_distr, t.id,
          p.period, t.dtek
        from kwtp_day t, params p
        where t.dat_ink between init.g_dt_start and init.g_dt_end;
    else
        delete from a_kwtp_day a
          where a.lsk=lsk_ and a.mg = mg_;
        insert into a_kwtp_day
          (kwtp_id, summa, lsk, oper, dopl, nkom, nink, dat_ink, priznak, usl, org, fk_distr, sum_distr, id, mg, dtek)
        select
          t.kwtp_id, t.summa, t.lsk, t.oper, t.dopl, t.nkom, t.nink, t.dat_ink, t.priznak,
          t.usl, t.org, t.fk_distr, t.sum_distr, t.id,
          p.period, t.dtek
        from kwtp_day t, params p
        where t.lsk=lsk_
        and t.dat_ink between init.g_dt_start and init.g_dt_end;
    end if;

    --архив начислени€
    if lsk_ is null then
      trunc_part('a_charge', mg_);
      insert into a_charge
        (lsk,
         usl,
         summa,
         kart_pr_id,
         spk_id,
         type,
         test_opl,
         test_cena,
         test_tarkoef,
         test_spk_koef,
         main,
         lg_doc_id,
         npp,
         sch,
         mg,
         kpr, kprz, kpro, kpr2, opl
         )
        select c.lsk,
               c.usl,
               c.summa,
               c.kart_pr_id,
               c.spk_id,
               c.type,
               c.test_opl,
               c.test_cena,
               c.test_tarkoef,
               c.test_spk_koef,
               c.main,
               c.lg_doc_id,
               c.npp,
               c.sch,
               p.period,
         c.kpr, c.kprz, c.kpro, c.kpr2, c.opl
          from c_charge c, params p;
    else
      delete from a_charge a
       where a.lsk=lsk_ and a.mg = mg_;
      insert into a_charge
        (lsk,
         usl,
         summa,
         kart_pr_id,
         spk_id,
         type,
         test_opl,
         test_cena,
         test_tarkoef,
         test_spk_koef,
         main,
         lg_doc_id,
         npp,
         sch,
         mg,
         kpr, kprz, kpro, kpr2, opl)
        select c.lsk,
               c.usl,
               c.summa,
               c.kart_pr_id,
               c.spk_id,
               c.type,
               c.test_opl,
               c.test_cena,
               c.test_tarkoef,
               c.test_spk_koef,
               c.main,
               c.lg_doc_id,
               c.npp,
               c.sch,
               p.period,
         c.kpr, c.kprz, c.kpro, c.kpr2, c.opl
          from c_charge c, params p
         where c.lsk = lsk_;
    end if;

    --архив изменени€ начислени€
    if lsk_ is null then
      trunc_part('a_change', mg_);
      insert into a_change
        (lsk,
         usl,
         summa,
         proc,
         mgchange,
         nkom,
         org,
         type,
         dtek,
         ts,
         user_id,
         doc_id,
         cnt_days,
         show_bill,
         id,
         mg,
         mg2)
        select c.lsk,
               c.usl,
               c.summa,
               c.proc,
               c.mgchange,
               c.nkom,
               c.org,
               c.type,
               c.dtek,
               c.ts,
               c.user_id,
               c.doc_id,
               c.cnt_days,
               c.show_bill,
               c.id,
               p.period,
               c.mg2
          from c_change c, params p
         where to_char(c.dtek, 'YYYYMM') = p.period; --по дате
    else
      delete from a_change a
       where a.lsk=lsk_ and a.mg = mg_;
      insert into a_change
        (lsk,
         usl,
         summa,
         proc,
         mgchange,
         nkom,
         org,
         type,
         dtek,
         ts,
         user_id,
         doc_id,
         cnt_days,
         show_bill,
         id,
         mg,
         mg2)
        select c.lsk,
               c.usl,
               c.summa,
               c.proc,
               c.mgchange,
               c.nkom,
               c.org,
               c.type,
               c.dtek,
               c.ts,
               c.user_id,
               c.doc_id,
               c.cnt_days,
               c.show_bill,
               c.id,
               p.period,
               c.mg2
          from c_change c, params p
         where to_char(c.dtek, 'YYYYMM') = p.period
           and c.lsk = lsk_; --по дате
    end if;

    --архив документов по изменению начислени€
    if lsk_ is null then
      trunc_part('a_change_docs', mg_);
      insert into a_change_docs
        (id, mgchange, dtek, ts, user_id, text, mg)
        select c.id, c.mgchange, c.dtek, c.ts, c.user_id, c.text, p.period
          from c_change_docs c, params p
         where to_char(c.dtek, 'YYYYMM') = p.period; --по дате
    end if;

    if lsk_ is null then
      --архив домов
      trunc_part('a_houses', mg_);
      insert into a_houses
        (id, reu, kul, nd, uch, house_type, fk_pasp_org, psch, mg, fk_other_org)
        select c.id, c.reu, c.kul, c.nd, c.uch, c.house_type, c.fk_pasp_org, c.psch, p.period, c.fk_other_org
          from c_houses c, params p;

      --архив вводов
      trunc_part('a_vvod', mg_);
      insert into a_vvod
        (house_id,
         id,
         kub,
         edt_norm,
         usl,
         kub_man,
         kpr,
         kub_sch,
         sch_cnt,
         sch_kpr,
         cnt_lsk,
         vvod_num,
         vol_add,
         sch_add,
         kub_fact,
         kub_norm,
         kub_nrm_fact,
         kub_sch_fact,
         vol_add_fact,
         itg_fact,
         opl_add,
         use_sch,
         dist_tp,
         opl_ar,
         kub_ar,
         kub_ar_fact,
         kub_dist,
         nrm,
         mg)
        select c.house_id,
               c.id,
               c.kub,
               c.edt_norm,
               c.usl,
               c.kub_man,
               c.kpr,
               c.kub_sch,
               c.sch_cnt,
               c.sch_kpr,
               c.cnt_lsk,
               c.vvod_num,
               c.vol_add,
               c.sch_add,
               c.kub_fact,
               c.kub_norm,
               c.kub_nrm_fact,
               c.kub_sch_fact,
               c.vol_add_fact,
               c.itg_fact,
               c.opl_add,
               c.use_sch,
               c.dist_tp,
               c.opl_ar,
               c.kub_ar,
               c.kub_ar_fact,
               c.kub_dist,
               c.nrm,
               p.period
          from c_vvod c, params p;
    elsif lsk_ is not null then
      --архив домов
      delete from a_houses c where c.mg=mg_ and
        exists (select * from kart k where k.house_id=c.id
            and k.lsk=lsk_);
      insert into a_houses
        (id, reu, kul, nd, uch, house_type, fk_pasp_org, psch, mg, fk_other_org)
        select c.id, c.reu, c.kul, c.nd, c.uch, c.house_type, c.fk_pasp_org, c.psch, p.period, c.fk_other_org
          from c_houses c, params p
           where exists (select * from kart k where k.house_id=c.id
            and k.lsk=lsk_);

      --архив вводов
      delete from a_vvod c where c.mg=mg_ and
        exists (select * from kart k where k.house_id=c.house_id
            and k.lsk=lsk_);
      insert into a_vvod
        (house_id,
         id,
         kub,
         edt_norm,
         usl,
         kub_man,
         kpr,
         kub_sch,
         sch_cnt,
         sch_kpr,
         cnt_lsk,
         vvod_num,
         vol_add,
         sch_add,
         kub_fact,
         kub_norm,
         kub_nrm_fact,
         kub_sch_fact,
         vol_add_fact,
         itg_fact,
         opl_add,
         use_sch,
         dist_tp,
         opl_ar,
         kub_ar,
         kub_ar_fact,
         nrm,
         mg)
        select c.house_id,
               c.id,
               c.kub,
               c.edt_norm,
               c.usl,
               c.kub_man,
               c.kpr,
               c.kub_sch,
               c.sch_cnt,
               c.sch_kpr,
               c.cnt_lsk,
               c.vvod_num,
               c.vol_add,
               c.sch_add,
               c.kub_fact,
               c.kub_norm,
               c.kub_nrm_fact,
               c.kub_sch_fact,
               c.vol_add_fact,
               c.itg_fact,
               c.opl_add,
               c.use_sch,
               c.dist_tp,
               c.opl_ar,
               c.kub_ar,
               c.kub_ar_fact,
               c.nrm, 
               p.period
          from c_vvod c, params p
           where exists (select * from kart k where k.house_id=c.house_id
              and k.lsk=lsk_);
    end if;

    if lsk_ is null then
      --справочник льгот
      trunc_part('a_spk_usl', mg_);
      insert into a_spk_usl
        (spk_id, usl_id, koef, mg)
        select c.spk_id, c.usl_id, c.koef, p.period
          from c_spk_usl c, params p;

    end if;

    --карточки проживающих
    if lsk_ is null then
      trunc_part('a_kart_pr', mg_);
      insert into a_kart_pr
        (id, lsk, fio, status, dat_rog, pol, dok, dok_c, dok_n,
        dok_d, dok_v, dat_prop, dat_ub, relat_id,
        status_datb, status_dat, status_chng, k_fam, k_im, k_ot,
        fk_doc_tp, fk_nac, b_place, fk_frm_cntr, fk_frm_regn,
        fk_frm_distr, frm_town, frm_dat, fk_frm_kul, frm_nd,
        frm_kw, w_place, fk_ub, fk_to_cntr, fk_to_regn,
        fk_to_distr, to_town, fk_to_kul, to_nd, to_kw,
        fk_citiz, fk_milit, fk_milit_regn, priv_proc, mg)
        select c.id, c.lsk, c.fio, c.status, c.dat_rog, c.pol, c.dok, c.dok_c, c.dok_n,
          c.dok_d, c.dok_v, c.dat_prop, c.dat_ub, c.relat_id,
          c.status_datb, c.status_dat, c.status_chng, c.k_fam, c.k_im, c.k_ot,
          c.fk_doc_tp, c.fk_nac, c.b_place, c.fk_frm_cntr, c.fk_frm_regn,
          c.fk_frm_distr, c.frm_town, c.frm_dat, c.fk_frm_kul, c.frm_nd,
          c.frm_kw, c.w_place, c.fk_ub, c.fk_to_cntr, c.fk_to_regn,
          c.fk_to_distr, c.to_town, c.fk_to_kul, c.to_nd, c.to_kw,
          c.fk_citiz, c.fk_milit, c.fk_milit_regn, c.priv_proc, p.period
        from c_kart_pr c, params p;
    else
      delete from a_kart_pr a
       where a.lsk=lsk_ and a.mg = mg_;
      insert into a_kart_pr
        (id, lsk, fio, status, dat_rog, pol, dok, dok_c, dok_n,
        dok_d, dok_v, dat_prop, dat_ub, relat_id,
        status_datb, status_dat, status_chng, k_fam, k_im, k_ot,
        fk_doc_tp, fk_nac, b_place, fk_frm_cntr, fk_frm_regn,
        fk_frm_distr, frm_town, frm_dat, fk_frm_kul, frm_nd,
        frm_kw, w_place, fk_ub, fk_to_cntr, fk_to_regn,
        fk_to_distr, to_town, fk_to_kul, to_nd, to_kw,
        fk_citiz, fk_milit, fk_milit_regn, priv_proc, mg)
        select c.id, c.lsk, c.fio, c.status, c.dat_rog, c.pol, c.dok, c.dok_c, c.dok_n,
          c.dok_d, c.dok_v, c.dat_prop, c.dat_ub, c.relat_id,
          c.status_datb, c.status_dat, c.status_chng, c.k_fam, c.k_im, c.k_ot,
          c.fk_doc_tp, c.fk_nac, c.b_place, c.fk_frm_cntr, c.fk_frm_regn,
          c.fk_frm_distr, c.frm_town, c.frm_dat, c.fk_frm_kul, c.frm_nd,
          c.frm_kw, c.w_place, c.fk_ub, c.fk_to_cntr, c.fk_to_regn,
          c.fk_to_distr, c.to_town, c.fk_to_kul, c.to_nd, c.to_kw,
          c.fk_citiz, c.fk_milit, c.fk_milit_regn, c.priv_proc, p.period
        from c_kart_pr c, params p
         where c.lsk = lsk_;
    end if;

    if lsk_ is null then
      --документы по льготам проживающих
      trunc_part('a_lg_docs', mg_);
      insert into a_lg_docs
        (id, c_kart_pr_id, doc, dat_begin, dat_end, main, mg)
        select c.id,
               c.c_kart_pr_id,
               c.doc,
               c.dat_begin,
               c.dat_end,
               c.main,
               p.period
          from c_lg_docs c, params p;

      --льготы проживающих
      trunc_part('a_lg_pr', mg_);
      insert into a_lg_pr
        (c_lg_docs_id, spk_id, type, mg)
        select c.c_lg_docs_id, c.spk_id, c.type, p.period
          from c_lg_pr c, params p;
    else
      --документы по льготам проживающих
      delete from a_lg_docs c where
       c.mg = mg_ and
       exists (select * from c_kart_pr p
             where p.lsk=lsk_
              and p.id=c.c_kart_pr_id);
      insert into a_lg_docs
        (id, c_kart_pr_id, doc, dat_begin, dat_end, main, mg)
        select c.id,
               c.c_kart_pr_id,
               c.doc,
               c.dat_begin,
               c.dat_end,
               c.main,
               p.period
          from c_lg_docs c, params p
           where exists (select * from c_kart_pr p
             where p.lsk=lsk_
              and p.id=c.c_kart_pr_id);

      --льготы проживающих
      delete from a_lg_pr c where
       c.mg = mg_ and
       exists (select * from c_lg_docs d, c_kart_pr p
             where p.lsk=lsk_
              and p.id=d.c_kart_pr_id and d.id=c.c_lg_docs_id);
      insert into a_lg_pr
        (c_lg_docs_id, spk_id, type, mg)
        select c.c_lg_docs_id, c.spk_id, c.type, p.period
          from c_lg_pr c, params p where
         exists (select * from c_lg_docs d, c_kart_pr p
             where p.lsk=lsk_
              and p.id=d.c_kart_pr_id and d.id=c.c_lg_docs_id);
    end if;

    --пен€
    if lsk_ is null then
      trunc_part('a_penya', mg_);
      insert into a_penya
        (summa, penya, mg1, mg, lsk, days)
        select c.summa, c.penya, c.mg1, p.period, c.lsk, c.days
          from c_penya c, params p;
    else
      delete from a_penya a
       where a.lsk = lsk_
         and a.mg = mg_;
      insert into a_penya
        (summa, penya, mg1, mg, lsk, days)
        select c.summa, c.penya, c.mg1, p.period, c.lsk, c.days
          from c_penya c, params p
          where c.lsk = lsk_;
    end if;
    --корректировки пени
    if lsk_ is null then
      trunc_part('a_pen_corr', mg_);
      insert into a_pen_corr
        (id, lsk, penya, dopl, dtek, ts, fk_user, mg)
        select c.id, c.lsk, c.penya, c.dopl, c.dtek, c.ts, c.fk_user, p.period
          from c_pen_corr c, params p;
    else
      delete from a_pen_corr a
       where a.lsk = lsk_
         and a.mg = mg_;
      insert into a_pen_corr
        (id, lsk, penya, dopl, dtek, ts, fk_user, mg)
        select c.id, c.lsk, c.penya, c.dopl, c.dtek, c.ts, c.fk_user, p.period
          from c_pen_corr c, params p
          where c.lsk = lsk_;
    end if;
    --текущее начисление пени
    if lsk_ is null then
      trunc_part('a_pen_chrg', mg_);
       insert into a_pen_chrg
        (lsk, mg1, days, summa, penya, iter, mg)
        select c.lsk, c.mg1, c.days, c.summa, c.penya, c.iter, p.period
          from c_pen_chrg c, params p;
    else
      delete from a_pen_chrg a
       where a.lsk = lsk_
         and a.mg = mg_;
       insert into a_pen_chrg
        (lsk, mg1, days, summa, penya, iter, mg)
        select c.lsk, c.mg1, c.days, c.summa, c.penya, c.iter, p.period
          from c_pen_chrg c, params p
          where c.lsk = lsk_;
    end if;

    --наборы услуг
    if lsk_ is null then
      trunc_part('a_nabor', mg_);

      insert into a_nabor
        (lsk,
         usl,
         org,
         koeff,
         norm,
         fk_vvod,
         vol,
         vol_add,
         mg,
         fk_tarif,
         kf_kpr,
         nrm_kpr,
         nrm_kpr2,
         kf_kpr_wrz,
         kf_kpr_wro,
         kf_kpr_wrz_sch,
         kf_kpr_wro_sch,
         limit)
        select c.lsk,
               c.usl,
               c.org,
               c.koeff,
               c.norm,
               c.fk_vvod,
               c.vol,
               c.vol_add,
               p.period,
               c.fk_tarif,
               c.kf_kpr,
               c.nrm_kpr,
               c.nrm_kpr2,
               c.kf_kpr_wrz,
               c.kf_kpr_wro,
               c.kf_kpr_wrz_sch,
               c.kf_kpr_wro_sch,
               c.limit
          from nabor c, params p;
    --сжать наборы
--    compress_nabor(null); -пока убрал 07.07.2015
    else
      delete from a_nabor a
       where a.lsk = lsk_
         and a.mg = mg_;
      insert into a_nabor
        (lsk,
         usl,
         org,
         koeff,
         norm,
         fk_vvod,
         vol,
         vol_add,
         mg,
         fk_tarif,
         kf_kpr,
         nrm_kpr,
         nrm_kpr2,
         kf_kpr_wrz,
         kf_kpr_wro,
         kf_kpr_wrz_sch,
         kf_kpr_wro_sch,
         limit)
        select c.lsk,
               c.usl,
               c.org,
               c.koeff,
               c.norm,
               c.fk_vvod,
               c.vol,
               c.vol_add,
               p.period,
               c.fk_tarif,
               c.kf_kpr,
               c.nrm_kpr,
               c.nrm_kpr2,
               c.kf_kpr_wrz,
               c.kf_kpr_wro,
               c.kf_kpr_wrz_sch,
               c.kf_kpr_wro_sch,
               c.limit
          from nabor c, params p
         where c.lsk = lsk_;
    --сжать наборы
--    compress_nabor(lsk_); пока убрал 07.07.2015
    end if;

    if lsk_ is null then
      delete from a_nabor_progs a where a.mg=mg_;
      insert into a_nabor_progs
        (id, lsk, usl, fk_tarif, mg)
      select t.id, t.lsk, t.usl, t.fk_tarif, p.period
       from nabor_progs t, params p;
    else
      delete from a_nabor_progs a
       where a.lsk = lsk_
         and a.mg = mg_;
      insert into a_nabor_progs
        (id, lsk, usl, fk_tarif, mg)
      select c.id, c.lsk, c.usl, c.fk_tarif, p.period
       from nabor_progs c, params p
       where c.lsk=lsk_;
    end if;

    -- —оздаЄм архив начислени€ (без льгот и субсидий) по Ћ/C
    if lsk_ is null then
      trunc_part('arch_charges', mg_);
      insert into arch_charges
        (lsk, usl_id, summa, summa_it, mg)
        select n.lsk, n.usl, b.summa, a.summa, p.period
          from nabor n,
               params p,
               (select lsk, usl, sum(summa) as summa
                  from c_charge c
                 where c.type = 1
                 group by lsk, usl) a,
               (select lsk, usl, sum(summa) as summa
                  from (select lsk, usl, summa as summa
                          from c_charge c
                         where c.type = 1
                        union all
                        select lsk, usl, -1 * summa
                          from c_charge c
                         where c.type = 2
                        union all
                        select lsk, usl, -1 * summa
                          from c_charge c
                         where c.type = 4)
                 group by lsk, usl) b
         where n.lsk = a.lsk(+)
           and n.usl = a.usl(+)
           and n.lsk = b.lsk(+)
           and n.usl = b.usl(+)
           and (a.summa <> 0 or b.summa <> 0);
    else
      delete from arch_charges a
       where a.lsk = lsk_
         and a.mg = mg_;
      insert into arch_charges
        (lsk, usl_id, summa, summa_it, mg)
        select n.lsk, n.usl, b.summa, a.summa, p.period
          from nabor n,
               params p,
               (select lsk, usl, sum(summa) as summa
                  from c_charge c
                 where c.lsk=lsk_
                   and c.type = 1
                 group by lsk, usl) a,
               (select lsk, usl, sum(summa) as summa
                  from (select lsk, usl, summa as summa
                          from c_charge c
                         where c.lsk=lsk_
                           and c.type = 1
                        union all
                        select lsk, usl, -1 * summa
                          from c_charge c
                         where c.lsk=lsk_
                           and c.type = 2
                        union all
                        select lsk, usl, -1 * summa
                          from c_charge c
                         where c.lsk=lsk_
                           and c.type = 4)
                 group by lsk, usl) b
         where n.lsk = a.lsk(+)
           and n.usl = a.usl(+)
           and n.lsk = b.lsk(+)
           and n.usl = b.usl(+)
           and (a.summa <> 0 or b.summa <> 0)
           and n.lsk=lsk_;
    end if;

    --ƒобавл€ем закрытые лицевые и лицевые с пустым начисл. (чтоб тоже печатались в счетах)
    if lsk_ is null then
      insert into arch_charges
        (lsk, usl_id, summa, mg, summa_it)
        select lsk, '003', 0, p.period, 0
          from kart t, params p
         where not exists (select *
                  from arch_charges a
                 where a.mg = p.period
                   and a.lsk = t.lsk);
    end if;

    -- —оздаЄм архивные карточки лицевых
    if lsk_ is null then
      trunc_part('arch_kart', mg_);
    insert into arch_kart --данный sql выполн€етс€ строго после insert into arch_charges!
      (lsk, kul, nd, kw, fio, kpr, kpr_wr, kpr_ot,
      kpr_cem, kpr_s, opl, ppl, pldop, ki, psch,
      psch_dt, status, kwt, lodpl, bekpl, balpl,
      komn, et, kfg, kfot, phw, mhw,
      pgw, mgw, pel, mel, sub_nach, subsidii,
      sub_data, polis, sch_el, reu, text, schel_dt,
      eksub1, eksub2, kran, kran1, el, el1, sgku,
      doppl, subs_cor, house_id, c_lsk_id,
      mg1, mg2, kan_sch, subs_inf,
      k_lsk_id, dog_num, schel_end, fk_deb_org,
      subs_cur, k_fam, k_im, k_ot, memo, fk_distr,
      law_doc, law_doc_dt, prvt_doc, prvt_doc_dt,
      fk_pasp_org, fk_err, mg, dolg, cpn, penya,
      kpr_wrp, pn_dt, fk_tp, for_bill, sel1)
      select
      k.lsk, k.kul, k.nd, k.kw, k.fio, k.kpr, k.kpr_wr, k.kpr_ot,
      k.kpr_cem, k.kpr_s, k.opl, k.ppl, k.pldop, k.ki, k.psch,
      k.psch_dt, k.status, k.kwt, k.lodpl, k.bekpl, k.balpl,
      k.komn, k.et, k.kfg, k.kfot, k.phw, k.mhw,
      k.pgw, k.mgw, k.pel, k.mel, k.sub_nach, k.subsidii,
      k.sub_data, k.polis, k.sch_el, k.reu, k.text, k.schel_dt,
      k.eksub1, k.eksub2, k.kran, k.kran1, k.el, k.el1, k.sgku,
      k.doppl, k.subs_cor, k.house_id, k.c_lsk_id,
      k.mg1, k.mg2, k.kan_sch, k.subs_inf,
      k.k_lsk_id, k.dog_num, k.schel_end, k.fk_deb_org,
      k.subs_cur, k.k_fam, k.k_im, k.k_ot, k.memo, k.fk_distr,
      k.law_doc, k.law_doc_dt, k.prvt_doc, k.prvt_doc_dt,
      k.fk_pasp_org, k.fk_err, p.period, a.dolg, k.cpn,
      nvl(d.penya,0)-nvl(b.penya,0) as penya,
      k.kpr_wrp, pn_dt, k.fk_tp,
      case when nvl(e.summa,0) <> 0 or nvl(b.dolg/*b.penya*/,0) <> 0 then 1 --счет будет выбиратьс€ дл€ печати если есть долг или текущ начисление))
        else 0 end as for_bill, k.sel1 
      from kart k, params p,
      (select t.k_lsk_id, nvl(sum(summa),0) as dolg from saldo_usl s, kart t where
        t.lsk=s.lsk and s.mg=mg1_
        group by t.k_lsk_id) a,
      (select c.lsk, sum(c.penya) as penya, sum(c.summa) as dolg
          from c_penya c
          group by c.lsk) b,
      (select c.lsk, sum(c.penya) as penya
          from a_penya c
          where c.mg=old_mg_
          group by c.lsk) d,
      (select a.lsk, sum(a.summa) as summa
       from scott.c_charge a where 
       nvl(a.summa,0) <>0
       and a.type=1
       group by a.lsk) e --полное начисление (по тарифу)
      where k.k_lsk_id=a.k_lsk_id(+)
      and k.lsk=b.lsk(+)
      and k.lsk=d.lsk(+)
      and k.lsk=e.lsk(+);
      --обновление є листов (важен пор€док вызова процедур!)              
      upd_arch_kart2(null, p_mg => mg_);
    else
      upd_acrh_kart(p_lsk => lsk_,
                    p_mg => mg_,
                    p_mg1 => mg1_,
                    p_old_mg => old_mg_);
    end if;

    -- —оздаЄм архив изменений начислени€ по Ћ/C
    if lsk_ is null then
      trunc_part('arch_changes', mg_);
      insert into arch_changes
        (lsk, usl_id, summa, mg, id, show_bill, proc)
        select c.lsk, c.usl, sum(c.summa), p.period, c.type, c.show_bill, sum(proc) as proc
          from kart k, c_change c, params p --раз.изм.текущие
         where k.lsk = c.lsk
           and to_char(c.dtek, 'YYYYMM') = p.period --по дате
         group by c.lsk, c.usl, p.period, c.type, c.show_bill;
    else
      delete from arch_changes a
       where a.lsk=lsk_ and a.mg = mg_;
      insert into arch_changes
        (lsk, usl_id, summa, mg, id, show_bill, proc)
        select c.lsk, c.usl, sum(c.summa), p.period, c.type, c.show_bill, sum(proc) as proc --раз.изм.текущие
          from kart k, c_change c, params p
         where k.lsk = c.lsk
           and to_char(c.dtek, 'YYYYMM') = p.period --по дате
           and k.lsk=lsk_
         group by c.lsk, c.usl, p.period, c.type, c.show_bill;
    end if;

    -- —оздаЄм архив субсидий по Ћ/C
    if lsk_ is null then
      trunc_part('arch_subsidii', mg_);
      insert into arch_subsidii
        (lsk, usl_id, summa, mg)
        select lsk, usl, sum(summa), p.period
          from c_charge c, params p
         where c.type = 2
         group by lsk, usl, p.period;
    else
      delete from arch_subsidii a
       where a.lsk=lsk_ and a.mg = mg_;
      insert into arch_subsidii
        (lsk, usl_id, summa, mg)
        select lsk, usl, sum(summa), p.period
          from c_charge c, params p
         where c.type = 2
           and c.lsk=lsk_
         group by lsk, usl, p.period;
    end if;

    -- —оздаЄм архив льгот по Ћ/C
    if lsk_ is null then
      trunc_part('arch_privs', mg_);
      insert into arch_privs
        (lsk, summa, usl_id, lg_id, mg, cnt_main, cnt)
        select lsk,
               sum(summa),
               usl_id,
               lg_id,
               p.period,
               sum(c.main),
               count(*)
          from privs c, params p
         group by c.lsk, c.usl_id, p.period, lg_id;
    else
      delete from arch_privs a
       where a.lsk=lsk_ and a.mg = mg_;
      insert into arch_privs
        (lsk, summa, usl_id, lg_id, mg, cnt_main, cnt)
        select lsk,
               sum(summa),
               usl_id,
               lg_id,
               p.period,
               sum(c.main),
               count(*)
          from privs c, params p
         where c.lsk=lsk_
         group by c.lsk, c.usl_id, p.period, lg_id;
    end if;

    -- —оздаЄм архив подготовительных объемов дл€ начислени€
    if lsk_ is null then
      trunc_part('a_charge_prep', mg_);
       insert into a_charge_prep
         (lsk, usl, vol, kpr, kprz, kpro, sch, dt1, dt2, tp, vol_nrm, vol_sv_nrm, mg, kpr2, opl, fk_spk)
       select
         lsk, usl, vol, kpr, kprz, kpro, sch, dt1, dt2, tp, vol_nrm, vol_sv_nrm, mg_ as mg, kpr2, opl, fk_spk
       from c_charge_prep t;
    else
      delete from a_charge_prep a
       where a.lsk=lsk_ and a.mg = mg_;
       insert into a_charge_prep
         (lsk, usl, vol, kpr, kprz, kpro, sch, dt1, dt2, tp, vol_nrm, vol_sv_nrm, mg, kpr2, opl, fk_spk)
       select
         lsk, usl, vol, kpr, kprz, kpro, sch, dt1, dt2, tp, vol_nrm, vol_sv_nrm, mg_ as mg, kpr2, opl, fk_spk
       from c_charge_prep t
       where t.lsk=lsk_;
    end if;

    -- —оздаЄм архив оплаты по Ћ/C
    --ARCH_KWTP больше не обслуживаем .....мл€€€€€ используетс€ в архивной справке

    --обновл€ем период дл€ отчета
    if lsk_ is null then
    logger.ins_period_rep('12', mg_, null, 0); --тип отчета (архивы)
    logger.ins_period_rep('52', mg_, null, 0); --списки по субсидии
    logger.ins_period_rep('56', mg_, null, 0); --—писок льготников
    logger.ins_period_rep('58', mg_, null, 0); --—писок квартиросъемщиков, имеющих счетчики учета воды
    logger.ins_period_rep('60', mg_, null, 0); --тип статистика по программам/пакетам (Ё+)
    logger.ins_period_rep('62', mg_, null, 0);
    logger.ins_period_rep('63', mg_, null, 0);
    logger.ins_period_rep('64', mg_, null, 0);

    logger.ins_period_rep('66', mg_, null, 0);
    logger.ins_period_rep('67', mg_, null, 0);
    logger.ins_period_rep('68', mg_, null, 0);
    logger.ins_period_rep('73', mg_, null, 0);
    logger.ins_period_rep('74', mg_, null, 0);
    logger.ins_period_rep('75', mg_, null, 0);
    logger.ins_period_rep('77', mg_, null, 0);
    logger.ins_period_rep('79', mg_, null, 0);
    logger.ins_period_rep('80', mg_, null, 0);

    logger.ins_period_rep('84', mg_, null, 0);
    logger.ins_period_rep('85', mg_, null, 0);
    logger.ins_period_rep('86', mg_, null, 0);
    logger.ins_period_rep('88', mg_, null, 0);
    logger.ins_period_rep('91', mg_, null, 0);
    logger.ins_period_rep('92', mg_, null, 0);

    logger.log_(time_, 'gen.prepare_arch');
    end if;
/*    if lsk_ is not null then
      --установить статус "пересчитано"
      c_valid.set_valid_lsk(lsk_, 0, 'gen_bill');
    end if;*/
    commit;
  end prepare_arch;

  procedure upd_acrh_kart(p_lsk in kart.lsk%type,
     p_mg in params.period%type,
     p_mg1 in params.period%type,
     p_old_mg in params.period%type
     ) is
  p_rec arch_kart%rowtype;
  begin
    begin
    select a.* into p_rec
     from arch_kart a
      where a.lsk = p_lsk
         and a.mg = p_mg and rownum=1; --rownum=1 - потому что по каким то причинам, (у ѕ. бывают по две записи в arch_kart!!!)
    exception
    --обработка ситуации, когда еще не было записей в архиве
      when no_data_found then
        null;
    end;
    delete from arch_kart a
      where a.lsk = p_lsk
         and a.mg = p_mg;
    insert into arch_kart --данный sql выполн€етс€ строго после insert into arch_charges!
      (lsk, kul, nd, kw, fio, kpr, kpr_wr, kpr_ot,
      kpr_cem, kpr_s, opl, ppl, pldop, ki, psch,
      psch_dt, status, kwt, lodpl, bekpl, balpl,
      komn, et, kfg, kfot, phw, mhw,
      pgw, mgw, pel, mel, sub_nach, subsidii,
      sub_data, polis, sch_el, reu, text, schel_dt,
      eksub1, eksub2, kran, kran1, el, el1, sgku,
      doppl, subs_cor, house_id, c_lsk_id,
      mg1, mg2, kan_sch, subs_inf,
      k_lsk_id, dog_num, schel_end, fk_deb_org,
      subs_cur, k_fam, k_im, k_ot, memo, fk_distr,
      law_doc, law_doc_dt, prvt_doc, prvt_doc_dt,
      fk_pasp_org, fk_err, mg, dolg, cpn, penya,
      kpr_wrp, pn_dt, fk_tp, for_bill, prn_num, prn_new, sel1)
      select
      k.lsk, k.kul, k.nd, k.kw, k.fio, k.kpr, k.kpr_wr, k.kpr_ot,
      k.kpr_cem, k.kpr_s, k.opl, k.ppl, k.pldop, k.ki, k.psch,
      k.psch_dt, k.status, k.kwt, k.lodpl, k.bekpl, k.balpl,
      k.komn, k.et, k.kfg, k.kfot, k.phw, k.mhw,
      k.pgw, k.mgw, k.pel, k.mel, k.sub_nach, k.subsidii,
      k.sub_data, k.polis, k.sch_el, k.reu, k.text, k.schel_dt,
      k.eksub1, k.eksub2, k.kran, k.kran1, k.el, k.el1, k.sgku,
      k.doppl, k.subs_cor, k.house_id, k.c_lsk_id,
      k.mg1, k.mg2, k.kan_sch, k.subs_inf,
      k.k_lsk_id, k.dog_num, k.schel_end, k.fk_deb_org,
      k.subs_cur, k.k_fam, k.k_im, k.k_ot, k.memo, k.fk_distr,
      k.law_doc, k.law_doc_dt, k.prvt_doc, k.prvt_doc_dt,
      k.fk_pasp_org, k.fk_err, p.period, a.dolg, k.cpn,
      nvl(d.penya,0)-nvl(b.penya,0) as penya,
      k.kpr_wrp, pn_dt, k.fk_tp,
      case when nvl(e.summa,0) <> 0 or nvl(b.dolg/*b.penya*/,0) <> 0 then 1 --счет будет выбиратьс€ дл€ печати если есть долг или текущ начисление))
        else 0 end as for_bill, p_rec.prn_num, p_rec.prn_new, k.sel1
      from kart k, params p,
      (select t.k_lsk_id, nvl(sum(summa),0) as dolg from saldo_usl s, kart t where
        t.lsk=s.lsk and s.mg=p_mg1
        group by t.k_lsk_id) a,
      (select sum(c.penya) as penya, sum(c.summa) as dolg
          from c_penya c
          where c.lsk = p_lsk) b,
      (select sum(c.penya) as penya
          from a_penya c
          where c.mg=p_old_mg
          and c.lsk = p_lsk) d,
      (select a.lsk, sum(a.summa) as summa
       from scott.c_charge a where 
       nvl(a.summa,0) <>0
       and a.type=1
       group by a.lsk) e --полное начисление (по тарифу)
      where k.k_lsk_id=a.k_lsk_id(+)
      and k.lsk = p_lsk
      and k.lsk=e.lsk(+);
  end;

procedure upd_arch_kart2(p_klsk in number, p_mg in params.period%type) is
 i number;
 k_lsk_old number;
 l_mg params.period%type;
begin
--обновление пор€дк номера листа дл€ печати 
--выполн€етс€ только дл€ всех счетов!!! (дл€ лиц. счета - не имеет смысла)

if p_mg is null then
  select p.period into l_mg from params p;
  else
    l_mg:=p_mg;
end if;

if p_klsk is null then
  update arch_kart t set t.prn_num=null, t.prn_new=null
    where t.mg=l_mg;
else
  update arch_kart t set t.prn_num=null, t.prn_new=null
    where t.mg=l_mg and t.k_lsk_id=p_klsk;
end if;  

for c2 in (select distinct t.reu from s_reu_trest t)
loop
  i:=0;
  k_lsk_old:=-1;
  for c in (select t.rowid as rd, t.k_lsk_id, tp.cd as lsk_tp
      from arch_kart t, spul s, v_lsk_tp tp where t.mg=l_mg 
      and t.reu=c2.reu and t.fk_tp=tp.id and t.for_bill=1
      and t.kul=s.id and nvl(p_klsk, t.k_lsk_id)=t.k_lsk_id
      order by s.name, scott.utils.f_ord_digit(t.nd), --¬нимание! пор€док точно такой как и в Form_print_bills.OD_main!!!
       scott.utils.f_ord3(t.nd) desc, 
       scott.utils.f_ord_digit(t.kw),
       scott.utils.f_ord3(t.kw) desc, 
        t.k_lsk_id, tp.npp
    ) 
  loop
    
    if k_lsk_old<>c.k_lsk_id then
      --новый лист
      i:=i+1;
      k_lsk_old:=c.k_lsk_id;
      update arch_kart t set t.prn_num=i, t.prn_new=1
        where t.rowid=c.rd;
    else
      --тот же лист, другой счет
      update arch_kart t set t.prn_num=i, t.prn_new=0
        where t.rowid=c.rd;
    end if;
  end loop;
end loop;
  
end;
  
  procedure gen_stat_debits is
    stmt varchar2(2500);
    type_otchet constant number := 22; --тип отчета
    dat_   date;
    time1_ date;
  begin
    time1_ := sysdate;
    select period_debits into dat_ from params;
    delete from debits_kw where dat = (select period_debits from params);
    delete from debits_houses
     where dat = (select period_debits from params);
    delete from debits_trest
     where dat = (select period_debits from params);

    insert into debits_kw
      (reu, kul, nd, kw, lsk, summa, mg, dat, kol_month)
      select k.reu, kul, nd, kw, d.lsk, summa, mg, period_debits, kol
        from kart k,
             params p,
             debits d,
             (select lsk, count(*) kol
                from debits
               where summap <> 0
               group by lsk) u
       where d.lsk = u.lsk(+)
         and d.lsk = k.lsk;

    insert into debits_houses
      (reu, kul, nd, summa, mg, dat, kol_month)
      select reu, kul, nd, sum(summa), mg, period_debits, kol_month
        from debits_kw, params
       where dat = period_debits
       group by reu, kul, nd, mg, period_debits, kol_month;

    insert into debits_trest
      (reu, summa, mg, dat, kol_month)
      select reu, sum(summa), mg, period_debits, kol_month
        from debits_houses, params
       where dat = period_debits
       group by reu, mg, period_debits, kol_month;

    delete from period_reports p
     where p.id = type_otchet
       and to_char(dat, 'YYYYMMDD') = to_char(dat_, 'YYYYMMDD'); --обновл€ем период дл€ отчета

    stmt := 'insert into period_reports (id, dat,signed) values(:id, :dat,1)';
    execute immediate stmt
      using type_otchet, dat_;
    logger.log_(time1_, 'gen.oraparser stat_debits');
    commit;
  end;

  procedure go_next_month_year is
  begin
    --ѕереход на следующий мес€ц - год
    c_charges.trg_proc_next_month:=1;
    go_nye_phase1;
    go_nye_phase2;
    go_nye_phase3;
    c_charges.trg_proc_next_month:=0;
  end go_next_month_year;

  procedure go_nye_phase1 is
    type_otchet_  constant number := 50; --дл€ таблицы long_table
    type_otchet2_ constant number := 51; --новые архивы
    summa_ number;
    cnt_ number;
    part_  number;
    mg_ params.period%type;
    l_cd_org t_org.cd%type;
  begin
    -- 1 - этап (сам переход)
    logger.log_(null, 'Ќачало I фазы перехода...');
    select period into mg_ from params;
    --ѕроверка
    --наличие оплаты не проинкассированной
      select nvl(count(*),0)
        into cnt_
        from c_kwtp c
       where to_char(c.dtek, 'YYYYMM') = mg_
         and nvl(c.nink, 0) = 0;
      if cnt_ <> 0 then
        raise_application_error(-20001,
                                '—топ, есть не проинкассированные средства, в сумме:' ||
                                to_char(cnt_));
        return;
      end if;

    if init.get_state = 0 then
      raise_application_error(-20001,
                              '—топ, не выполнено итоговое формирование за мес€ц, переход не возможен!');
      return;
    end if;

    --повторное формирование движени€ нужно, так как некоторые – ÷ принимают оплату уже будущим периодом
    --(до очистки итоговых таблиц!)
    logger.log_(null, 'ѕовторное формирование движени€, начало');
    c_cpenya.gen_charge_pay_pen;
    logger.log_(null, 'ѕовторное формирование движени€, окончание');
    ---
    
    select p.part into part_ from params p;
    -- чистим итоговые таблицы
    logger.log_(null, 'ќчистка итоговых таблиц, начало');
    gen.gen_clear_tables;
    logger.log_(null, 'ќчистка итоговых таблиц, окончание');

    --периоды пени (добавл€ем, в случае их отсутстви€)
    insert into c_spr_pen
      (mg, dat, fk_lsk_tp, reu)
      select t.period1, add_months(p.dat,1), p.fk_lsk_tp, p.reu
       from c_spr_pen p, v_params t
       where p.mg=t.period and not exists
       (select * from c_spr_pen p1,
         v_params m where p1.mg=m.period1
         and p1.fk_lsk_tp=p.fk_lsk_tp
         );

    --периоды новых архивов фиксируем здесь
    delete from period_reports p
     where p.id in (type_otchet2_)
       and p.mg = mg_; --обновл€ем период дл€ отчета
    insert into period_reports
      (id, mg, signed)
      select type_otchet2_, mg_, 1 from dual;

    --узнаем, будет ли переход года
    --если будет, сбрасывам номера квитанций и инкассаций
    select case when substr(mg_,1,4) <>
       substr(to_char(add_months(
         to_date(mg_ || '01', 'YYYYMMDD'), 1), 'YYYYMM'),1,4) then 1
         else 0 end into cnt_
        from dual;
    if cnt_ = 1 then
      update c_comps t set t.nink=1, t.nkvit=1;
    end if;
    -- мен€ем отчетный период
    update params
       set period    = to_char(add_months(to_date(period || '01', 'YYYYMMDD'),
                                          1),
                               'YYYYMM'),
           period_pl = to_char(add_months(to_date(period || '01', 'YYYYMMDD'),
                                          1),
                               'YYYYMM');
    select period into mg_ from params;
    --об€зательно мен€ем отчетный период глобальных переменных (чтоб их!)
    init.g_dt_start:=to_date(mg_||'01', 'YYYYMMDD');
    init.g_dt_end:=last_day(init.g_dt_start);

    --нулим текущий период компьютеров
    update c_comps t set t.period=null 
      where t.period is not null;
    delete from period_reports p
     where p.id in (type_otchet_)
       and p.mg = (select period from params); --обновл€ем период дл€ таблицы long_table

    --в форму по тарифам добавить период
    logger.ins_period_rep('78', mg_, null, 0);
    --новый период дл€ сверки инкассаций
    logger.ins_period_rep('36', mg_, null, 0);
    commit;  --здесь коммит перехода, I - фазы
    logger.log_(null, 'ќкончание I - фазы перехода...');
  end;

  procedure go_nye_phase2 is
    part_  number;
    type_otchet_  constant number := 50; --дл€ таблицы long_table
    l_cnt number;
  begin
    logger.log_(null, 'Ќачало II - фазы перехода...');
    select p.part into part_ from params p;
    -- добавл€ем, удал€ем партиции
    if nvl(part_, 0) = 1 then
      gen.gen_del_add_partitions;
    end if;

    --обновл€ем последний период оплаты, раз изменений
    --на 12 мес.вперЄд
    update params p set p.period_forwrd=
      (select to_char(add_months(to_date(p.period||'01','YYYYMMDD'),12),'YYYYMM') as mg
         from params p);

    insert into period_reports
      (id, mg)
    values
      (type_otchet_,
       (select to_char(add_months(to_date(period || '01', 'YYYYMMDD'), 60),
                       'YYYYMM')
          from params)); -- +60 мес€цев
    --установить новые мес€цы в long_table, чтобы каждый раз не вычисл€ть
    insert into long_table
    select "MG" from (
    select to_char(add_months(to_date(p.period||'01','YYYYMMDD'),-1*a.lvl+1),'YYYYMM')  as mg
                            from (select level as lvl
                                    from dual
                                  connect by level < 1200) a, params p
    ) a
    where to_char(mg) >= utils.get_str_param('FIRST_MONTH')
    and not exists
    (select * from long_table s where s.mg=a.mg);


    logger.log_(null, 'ѕереход-распределение оплаты, прин€той будущим периодом, начало');
     if utils.get_int_param('DIST_PAY_TP') = 0 then
     --по-сальдовый способ распределени€ оплаты
       c_gen_pay.dist_pay_lsk_force; 
     else
     --по-периодный способ распределени€ оплаты
       null; --пока не написал
     end if;
    logger.log_(null, 'ѕереход-распределение оплаты, прин€той будущим периодом, окончание');
     
    logger.log_(null, 'ѕереход-установка признаков закрытых домов начало');
    update c_houses t set t.psch=1
     where nvl(t.psch,0)=0 and
    not exists (select * from kart k where k.house_id=t.id
    and k.psch not in (8,9));
    commit;
    logger.log_(null, 'ѕереход-установка признаков закрытых домов окончание');
    --обнул€ем vol_add по услуге с fk_calc=23 (Ёл.энерг.ћќѕ), ред.26.03.13
    logger.log_(null, 'ѕереход-начало обнулени€ расхода по fc_calc=23 услуге');
    update nabor n set n.vol_add=null where exists
      (select * from usl u where u.usl=n.usl and u.fk_calc_tp=23);
    commit;
    logger.log_(null, 'ѕереход-ќкончание обнулени€ расхода по fc_calc=23 услуге');

    --устанавливаем кол-во прожив, с учетом выбывших и зарегистрированных
    --(например человек прописалс€ в конце прошлого мес€ца)

--перенес в расчет начислени€ 11.04.14
--    logger.log_(null, 'ѕереход-utils.set_kpr начало');
--    utils.set_kpr(null);
--    logger.log_(null, 'ѕереход-utils.set_kpr окончание');

    --измен€ем признаки счетчиков, в л.с. где они должны помен€тьс€ по срокам
    logger.log_(null, 'ѕереход-utils.upd_krt_sch_state начало');
    utils.upd_krt_sch_state(null);
    logger.log_(null, 'ѕереход-utils.upd_krt_sch_state окончание');
    --измен€ем признаки проживающих, в л.с. где они должны помен€тьс€ по срокам
    logger.log_(null, 'ѕереход-utils.upd_c_kart_pr_state начало');
    utils.upd_c_kart_pr_state(null);
    logger.log_(null, 'ѕереход-utils.upd_c_kart_pr_state окончание');
    --обновл€ем доли проживающих, дл€ долевого расчета начислени€
    --только по тем, где существуют даты окончани€ (ред. 20.02.2012)
    --не об€зательно, выполн€етс€ в процедуре начисление (ред.21.05.2012)

    --ќЅя«ј“≈Ћ№Ќќ, вынес из c_charge, надо выполн€ть здесь,
    --в c_charge приводит к DEADLOCK!!!
    --временно отменил, так как поставил в c_charge COMMIT ред.29.11.12
    --logger.log_(null, 'ѕереход-gen.c_kart.set_part_kpr_all_lsk начало');
    --c_kart.set_part_kpr_all_lsk;
    -- logger.log_(null, 'ѕереход-gen.c_kart.set_part_kpr_all_lsk окончание');

    --сброс признака итогового формировани€ отчетов
    init.set_state(0);
    commit; --коммит по окончанию I фазы

    --очистить таблицу оплаты, иначе вли€ет на сальдо...
    --еЄ не надо уже чистить, сама почиститс€ выше, в триггере, ред.10.01.13
    --execute immediate 'truncate table kwtp_day';

    --установить признак пересчета по начислению
    --(дл€ всех не закрытых л/c)
    logger.log_(null, 'ѕереход-c_valid.set_valid_all (gen_chrgpay) начало');
    --пересчет начислени€ вызовет внутри еще и пересчет движени€ ('gen_chrgpay')
    c_valid.set_valid_all(1, 'gen_chrgpay');
    logger.log_(null, 'ѕереход-c_valid.set_valid_all окончание');

    --установить признак пересчета по движению
    --ред.12.09.13 пересчет движени€ будет вызван тогда же когда
    --выше будет вызван пересчет начислени€

/*    logger.log_(null, 'ѕереход-c_valid.set_valid_all (gen_chrgpay) начало');
    c_valid.set_valid_all(1,'gen_chrgpay');
    logger.log_(null, 'ѕереход-c_valid.set_valid_all (gen_chrgpay) окончание');
  */

    --после I фазы, открываем базу
    admin.set_state_base(0);
    --выполнение автоначисление счетчиков
    logger.log_(null, 'ѕереход-gen.auto_charge начало');
    auto_charge;
    logger.log_(null, 'ѕереход-gen.auto_charge окончание');
    --подготовка сальдо, дл€ возможности распределени€ начисленной пени по услугам
    gen_saldo(null);
    --подготовка послепереходной информации
    l_cnt:=c_charges.gen_charges(null, null, null, null, 1, 0);
    --«ј„≈ћ здесь выполн€ть формирование движени€ и пени??
    --если при вызове л.с, и прочем они всЄ равно рассчитываютс€
    --(тем более что помечены как дл€ пересчета выше)
    --ред.22.11.12

    --движение по лицевым за новый период
    --c_cpenya.gen_charge_pay(null, 1);
    --пен€ за новый период
    --for c in (select distinct lsk from kart) loop
    --  c_cpenya.gen_penya(c.lsk, 0, 0);
    --end loop;
    commit;
    logger.log_(null, 'ќкончание II - фазы перехода...');
  end;

  procedure go_nye_phase3 is
  l_p_mg1 params.period%type;
  l_p_mg2 params.period%type;
  l_cd_org t_org.cd%type;
  begin
  --‘аза III перехода
    logger.log_(null, 'Ќачало III - фазы перехода...');
    if utils.get_int_param('HAVE_LK') = 1 then
       --≈сли присутствует функци€ личного кабинета
       --то выполнение перехода в нЄм
        logger.log_(null, 'Ќачало выполнени€ перехода в Ћ ...');
        select o.cd into l_cd_org
         from scott.t_org o, scott.t_org_tp tp
        where tp.id=o.fk_orgtp and tp.cd='– ÷';
       execute immediate 'begin proc.go_next_month_year@apex(:cd_org_); end;'
        using l_cd_org;
        logger.log_(null, 'ќкончание выполнени€ перехода в Ћ ...');
        logger.log_(null, 'Ќачало выгрузки архивов в Ћ ...');
        --отправл€ем архивы
        execute immediate
          'select min(t.mg), max(t.mg) from t_mg@Apex t, t_org@Apex o, scott.params p
             where t.mg<>p.period and t.fk_org=o.id
             and o.cd=:cd_org_'
          into l_p_mg1, l_p_mg2 using l_cd_org;
        ext_pkg.exp_base(1, l_p_mg1, l_p_mg2);
        logger.log_(null, 'ќкончание выгрузки архивов в Ћ ...');
    end if;
    logger.log_(null, 'ќкончание III - фазы перехода...');
  end;

  procedure gen_clear_dates is
  begin
  --¬ыполн€етс€ после смены периода в params (во врем€ перехода)
  --отменить не возможно!
  --чистка статусов вр.зарегистр c просроченной датой
   null;
  end;

  procedure gen_clear_tables is
  begin
    --¬ыполн€ть после сброса таблиц в архив!!!!

    --чистка кубов и корректировки субс по л/счетам и по домам
    p_vvod.g_tp:=3;--установить глобальную переменную - признак очистки по переходу
    update kart k set k.mhw = 0, k.mgw = 0, k.mel = 0, k.subs_cor = 0;
    p_vvod.g_tp:=0;
    --ред.12.11.12 зачем update nabor? если ниже через c_vvod он по сути выполн€етс€...
    --update nabor n set n.vol=null, n.vol_add=null;

    --чистить поле edt_norm - не надо (переходит из мес€ца в мес€ц)
    update c_vvod c
       set c.kub     = 0,
           c.kub_man = 0,
           c.kpr     = 0,
           c.kub_sch = 0,
           c.sch_cnt = 0,
           c.sch_kpr = 0,
           c.cnt_lsk = 0,
           c.vol_add = 0,
           c.vol_add_fact = 0,
           c.kub_fact = 0,
           c.itg_fact = 0,
           c.opl_add = 0,
           c.kub_norm = 0,
           c.kub_nrm_fact = 0,
           c.kub_sch_fact = 0,
           c.opl_ar = 0,
           c.kub_ar = 0,
           c.kub_ar_fact = 0,
           c.nrm = null
           where (nvl(c.kub, 0) <> 0 or nvl(c.vol_add, 0) <> 0);

    --чистка таблиц от информации текущего мес€ца
/*    execute immediate 'truncate table c_change';
    execute immediate 'truncate table c_change_docs';
    execute immediate 'truncate table c_kwtp_mg';
    execute immediate 'truncate table c_kwtp';*/
    --переделал delete, очень медленно работает, ред.10.01.13

    delete from c_change_docs t where t.dtek between init.g_dt_start and init.g_dt_end;
    delete from c_change t where t.dtek between init.g_dt_start and init.g_dt_end;
    delete from c_kwtp t where t.dat_ink between init.g_dt_start and init.g_dt_end;
--    delete from c_kwtp_mg c; - не надо - удалитс€ в триггере

/*    delete from c_change_docs c
     where to_char(c.dtek, 'YYYYMM') = (select period from params);
    delete from c_change c
     where to_char(c.dtek, 'YYYYMM') = (select period from params);

    delete from c_kwtp_mg c
     where to_char(c.dat_ink, 'YYYYMM') = (select period from params);
    delete from c_kwtp c
     where to_char(c.dat_ink, 'YYYYMM') = (select period from params);
  */
    --чистка периодов в сальдо
    --„»—“»“№ —јЋ№ƒќ Ќ≈Ћ№«я (”дал€етс€ сальдо в счетах)
--    delete from saldo_usl t where t.mg < (select period from params p);
-- запрещенны комиты!... хот€ может не хватить UNDO....
--    commit;

    -- чистка прошлых периодов
    delete from xxito10 t
     where dat <
           (select add_months(to_date(period, 'YYYYMM'), -1) from params)
           and t.mg is null;
    delete from xito5 t
     where dat <
           (select add_months(to_date(period, 'YYYYMM'), -1) from params)
           and t.mg is null;
    delete from xito5_ t
     where dat <
           (select add_months(to_date(period, 'YYYYMM'), -1) from params)
           and t.mg is null;
    delete from xxito11 t
     where dat <
           (select add_months(to_date(period, 'YYYYMM'), -1) from params)
           and t.mg is null;
    delete from xxito12 t
     where dat <
           (select add_months(to_date(period, 'YYYYMM'), -1) from params)
           and t.mg is null;
    delete from xxito14 t
     where dat <
           (select add_months(to_date(period, 'YYYYMM'), -1) from params)
           and t.mg is null;
    delete from debits_kw
     where dat <
           (select add_months(to_date(period, 'YYYYMM'), -1) from params);
    delete from debits_houses
     where dat <
           (select add_months(to_date(period, 'YYYYMM'), -1) from params);
    delete from debits_trest
     where dat <
           (select add_months(to_date(period, 'YYYYMM'), -1) from params);
    delete from period_reports
     where dat <
           (select add_months(to_date(period, 'YYYYMM'), -1) from params)
       and id <> 17;
  --поставил коммит, ред.10.01.13
  commit;
  end gen_clear_tables;

  procedure gen_del_add_partitions is
    new_period_ char(6);
  begin
    select period1
      into new_period_
      from v_params;

    make_part('c_chargepay', 'data', 'MG' || new_period_, new_period_);

    make_part('saldo_usl',
              'data',
              'MG' || to_char(add_months(to_date(new_period_, 'YYYYMM'), 1),
                              'YYYYMM'),
              to_char(add_months(to_date(new_period_, 'YYYYMM'), 1),
                      'YYYYMM'));
 make_part('arch_changes', 'arch', 'MG' || new_period_, new_period_);
 make_part('arch_charges', 'arch', 'MG' || new_period_, new_period_);
 make_part('arch_kart', 'arch', 'MG' || new_period_, new_period_);
 make_part('arch_kwtp', 'arch', 'MG' || new_period_, new_period_);
 make_part('arch_privs', 'arch', 'MG' || new_period_, new_period_);
 make_part('arch_subsidii', 'arch', 'MG' || new_period_, new_period_);
 make_part('a_prices', 'arch', 'MG' || new_period_, new_period_);
 make_part('a_change', 'arch', 'MG' || new_period_, new_period_);
 make_part('a_change_docs', 'arch', 'MG' || new_period_, new_period_);
 make_part('a_charge', 'arch', 'MG' || new_period_, new_period_);
 make_part('a_houses', 'arch', 'MG' || new_period_, new_period_);
 make_part('a_houses', 'arch', 'MG' || new_period_, new_period_);
 make_part('a_kart_pr', 'arch', 'MG' || new_period_, new_period_);
 make_part('a_kwtp', 'arch', 'MG' || new_period_, new_period_);
 make_part('a_kwtp_mg', 'arch', 'MG' || new_period_, new_period_);
 make_part('a_lg_docs', 'arch', 'MG' || new_period_, new_period_);
 make_part('a_lg_pr', 'arch', 'MG' || new_period_, new_period_);
 make_part('a_nabor', 'arch', 'MG' || new_period_, new_period_);
 make_part('a_penya', 'arch', 'MG' || new_period_, new_period_);
 make_part('a_spk_usl', 'arch', 'MG' || new_period_, new_period_);
 make_part('a_vvod', 'arch', 'MG' || new_period_, new_period_);
 make_part('xitog3', 'data', 'MG' || new_period_, new_period_);
 make_part('statistics', 'data', 'MG' || new_period_, new_period_);
 make_part('statistics_lsk', 'data', 'MG' || new_period_, new_period_);
 make_part('xitog3_lsk', 'data', 'MG' || new_period_, new_period_);
 make_part('xito_lg4', 'data', 'MG' || new_period_, new_period_);
 make_part('t_corrects_payments', 'data', 'MG' || new_period_, new_period_);
 make_part('expkartw', 'data', 'MG' || new_period_, new_period_);
 make_part('expprivs', 'data', 'MG' || new_period_, new_period_);
 make_part('xxito10', 'data', 'MG' || new_period_, new_period_);
 make_part('xxito11', 'data', 'MG' || new_period_, new_period_);
 make_part('xxito12', 'arch', 'MG' || new_period_, new_period_);
 make_part('xxito14', 'arch', 'MG' || new_period_, new_period_);
 make_part('xxito14_lsk', 'arch', 'MG' || new_period_, new_period_);
 make_part('a_charge_prep', 'arch', 'MG' || new_period_, new_period_);
 make_part('a_kwtp_day', 'arch', 'MG' || new_period_, new_period_);
 make_part('a_pen_chrg', 'arch', 'MG' || new_period_, new_period_);
end;

  procedure make_part(tablename_ in varchar2,
                      tabspc_    in varchar2,
                      partname_  in varchar2,
                      mg_        in varchar2) is
    stmt varchar2(500);
    i    number;
  begin
    --удал€ем партицию
    i := 12;
    loop
      exit when i = -1;
      begin
        stmt := ' alter table ' || tablename_ || '
              drop partition MG' ||
                to_char(add_months(to_date(mg_, 'YYYYMM'), i), 'YYYYMM') || '' ||
                ' update global indexes';
        execute immediate stmt;
      exception
        when others then
          null;
      end;
      i := i - 1;
    end loop;
    --создаем партицию
    stmt := 'alter table ' || tablename_ || '
          add partition ' || partname_ || '
          values less than(''' || mg_ || ''')
          tablespace ' || tabspc_ || '' || '';
    execute immediate stmt;

  end;

  procedure drop_part(tablename_ in varchar2, mg_ in varchar2) is
    stmt varchar2(500);
  begin
    --удал€ем партицию
    begin
      stmt := ' alter table ' || tablename_ || '
              drop partition MG' || mg_;
      execute immediate stmt;
    exception
      when others then
        null;
    end;
  end;

  procedure trunc_part(tablename_ in varchar2, mg_ in varchar2) is
    stmt  varchar2(500);
    mg1_  varchar2(6);
    part_ number;
  begin
    select p.part into part_ from params p;
    --чистим партицию
    --особенность -  мес€ц партиции +1 от текущего
    if nvl(part_, 0) = 1 then
      mg1_ := to_char(add_months(to_date(mg_, 'YYYYMM'), 1), 'YYYYMM');
      stmt := ' alter table ' || tablename_ || '
            truncate partition MG' || mg1_ ||
              ' update global indexes';
      execute immediate stmt;
    elsif tablename_='c_chargepay' then
      stmt := ' delete from ' || tablename_ || ' where period=' || mg_;
      execute immediate stmt;
      commit;
    else
      stmt := ' delete from ' || tablename_ || ' where mg=' || mg_;
      execute immediate stmt;
      commit;
    end if;
  end;






  procedure auto_charge is
    cnt_sch_ number;
    part_ number;
  begin
  --автоначисление счетчиков
  --средний расход за прошлые 3 мес€ца начислить, у кого не начислено
  --выполн€ть сразу после перехода!

  --вначале заполн€ем аудит
  part_:=0;
  loop
    insert into log_actions
      (text, ts, fk_user_id, lsk, fk_type_act)
      select 'јвтоначисление индивидуального прибора учета г.в., по-среднему за последние 3 мес€ца' as text,
       sysdate as ts, t.id, k.lsk as lsk, 2 as fk_type_act
      from kart k, t_user t where t.cd=user
        and
         nvl(decode(part_,0, k.mgw, k.mhw),0) = 0 and
         exists
         (select * from nabor n, usl u where k.lsk=n.lsk and n.sch_auto = 1
           and n.usl=u.usl and case when part_=0 and u.fk_calc_tp in (4, 18) then 1
                                              when part_=1 and u.fk_calc_tp in (3, 17) then 1
                                              else 0
                                              end =1)
           and
           case when part_=0 and k.psch in (1,3) then 1
                when part_=1 and k.psch in (1,2) then 1
                else 0
                end =1;

    exit when part_=1;
    part_:=part_+1;
  end loop;

  select nvl(p.cnt_sch,0) into cnt_sch_ from params p;
  if cnt_sch_ = 0 then
    --х.в.
    update kart k set k.mhw=
      (select round(avg(t.mhw),3) from arch_kart t, params p where t.k_lsk_id=k.k_lsk_id
             and t.mg between utils.add_months2(p.period,-3) and utils.add_months2(p.period,-1)
       and t.psch in (1,2))
       where
       nvl(k.mhw,0) = 0 and
       exists
       (select * from nabor n, usl u where k.lsk=n.lsk and n.sch_auto = 1
         and n.usl=u.usl and u.fk_calc_tp in (3, 17)
         )
         and k.psch in (1,2);
    --г.в.
    update kart k set k.mgw=
      (select round(avg(t.mgw),3) from arch_kart t, params p where t.k_lsk_id=k.k_lsk_id
             and t.mg between utils.add_months2(p.period,-3) and utils.add_months2(p.period,-1)
      and t.psch in (1,3))
       where
       nvl(k.mgw,0) = 0 and
       exists
       (select * from nabor n, usl u where k.lsk=n.lsk and n.sch_auto = 1
         and n.usl=u.usl and u.fk_calc_tp in (4, 18)
         )
         and k.psch in (1,3);
    else
    --х.в.
    --mhw посчитаетс€ само
    update kart k set k.phw=
      nvl(k.phw,0)+(select nvl(round(avg(t.mhw),3),0) from arch_kart t, params p where t.k_lsk_id=k.k_lsk_id
             and t.mg between utils.add_months2(p.period,-3) and utils.add_months2(p.period,-1)
      and t.psch in (1,2))
       where
       nvl(k.mhw,0) = 0 and
       exists
       (select * from nabor n, usl u where k.lsk=n.lsk and n.sch_auto = 1
         and n.usl=u.usl and u.fk_calc_tp in (3, 17)
         )
         and k.psch in (1,2);
    --г.в.
    --mgw посчитаетс€ само
    update kart k set k.pgw=
      nvl(k.pgw,0)+(select nvl(round(avg(t.mgw),3),0) from arch_kart t, params p where t.k_lsk_id=k.k_lsk_id
      and t.mg between utils.add_months2(p.period,-3) and utils.add_months2(p.period,-1)
      and t.psch in (1,3))
      where
       nvl(k.mgw,0) = 0 and
       exists
       (select * from nabor n, usl u where k.lsk=n.lsk and n.sch_auto = 1
         and n.usl=u.usl and u.fk_calc_tp in (4, 18)
         )
         and k.psch in (1,3);
  end if;


  logger.log_(null, 'gen.auto_charge (автоначисление счетчиков)');
  commit;
  end;




end gen;
/

prompt
prompt Creating package body GENERATOR
prompt ===============================
prompt
CREATE OR REPLACE PACKAGE BODY SCOTT.generator IS

  PROCEDURE disable_keys(var_ IN NUMBER) IS
    stmt VARCHAR2(2000);
    TYPE empcurtyp IS REF CURSOR;
    c     empcurtyp;
    tname VARCHAR2(50);
    cname VARCHAR2(50);
  BEGIN
    time_ := SYSDATE;
      stmt := 'select table_name,constraint_name from sys.user_constraints t
    WHERE constraint_type=''R'' ORDER BY constraint_type DESC';
    OPEN c FOR stmt;
    LOOP
      FETCH c
        INTO tname, cname;
      EXIT WHEN c%NOTFOUND;
      BEGIN
        stmt := 'ALTER TABLE ' || tname || ' DISABLE CONSTRAINT ' || cname ||
                ' CASCADE ';
        EXECUTE IMMEDIATE stmt;
      EXCEPTION
        WHEN OTHERS THEN
          NULL;
      END;
    END LOOP;
    CLOSE c;

    stmt := 'select table_name,constraint_name from sys.user_constraints t
    WHERE (constraint_type=''P'' OR constraint_type=''U''  OR constraint_type=''C'') ORDER BY constraint_type DESC';
    OPEN c FOR stmt;
    LOOP
      FETCH c
        INTO tname, cname;
      EXIT WHEN c%NOTFOUND;
      BEGIN
        stmt := 'ALTER TABLE ' || tname || ' DISABLE CONSTRAINT ' || cname ||
                ' CASCADE ';
        EXECUTE IMMEDIATE stmt;
      EXCEPTION
        WHEN OTHERS THEN
          NULL;
      END;
    END LOOP;
    CLOSE c;
    logger.log_(time_, 'generator.disable_keys');
  END disable_keys;

  PROCEDURE enable_keys(var_ IN NUMBER) IS
    stmt VARCHAR2(2000);
    TYPE empcurtyp IS REF CURSOR;
    c     empcurtyp;
    tname VARCHAR2(50);
    cname VARCHAR2(50);
  BEGIN
    time_ := SYSDATE;
      stmt := 'select table_name,constraint_name from sys.user_constraints t
    WHERE (constraint_type=''P'' OR constraint_type=''U'' OR constraint_type=''C'')';
    OPEN c FOR stmt;
    LOOP
      FETCH c
        INTO tname, cname;
      EXIT WHEN c%NOTFOUND;
      BEGIN
        stmt := 'ALTER TABLE ' || tname || ' ENABLE CONSTRAINT ' || cname;
        EXECUTE IMMEDIATE stmt;
      EXCEPTION
        WHEN OTHERS THEN
          NULL;
      END;
    END LOOP;
    CLOSE c;

      stmt := 'select table_name,constraint_name from sys.user_constraints t
    WHERE constraint_type=''R''';

    OPEN c FOR stmt;
    LOOP
      FETCH c
        INTO tname, cname;
      EXIT WHEN c%NOTFOUND;
      BEGIN
        stmt := 'ALTER TABLE ' || tname || ' ENABLE CONSTRAINT ' || cname;
        EXECUTE IMMEDIATE stmt;
      EXCEPTION
        WHEN OTHERS THEN
          NULL;
      END;
    END LOOP;
    CLOSE c;
    logger.log_(time_, 'generator.enable_keys');
  END enable_keys;

  PROCEDURE test_constr_errs(cnt_ OUT NUMBER, var_ IN NUMBER)
  --»спользуетс€ при загрузке дневных
   IS
    stmt VARCHAR2(2000);
    TYPE empcurtyp IS REF CURSOR;
    c    empcurtyp;
    rec_ sys.user_constraints%ROWTYPE;
  BEGIN
    IF var_ = 0 THEN
      --“екущие платежи
      stmt := 'select * from sys.user_constraints t where status=''DISABLED''
     AND table_name  IN (SELECT tname FROM TABLELIST WHERE var IN (0))';
    ELSE
      --«а период
      stmt := 'select * from sys.user_constraints t where status=''DISABLED''
     AND table_name  IN (SELECT tname FROM TABLELIST WHERE var IN (0,1))';
    END IF;
    OPEN c FOR stmt;
    FETCH c
      INTO rec_;
    IF c%FOUND THEN
      cnt_ := 1;
    ELSE
      cnt_ := 0;
    END IF;
    CLOSE c;
  END test_constr_errs;

  PROCEDURE del_table_rows(tname_      IN VARCHAR2,
                           field_name_ IN VARCHAR2,
                           dat1_       IN DATE,
                           dat2_       IN DATE) IS
    stmt VARCHAR2(2000);
  BEGIN
    --„истка таблицы tname_
    stmt := 'DELETE FROM ' || tname_ || ' WHERE ' || field_name_ ||
            ' BETWEEN :dat1 AND :dat2';
    EXECUTE IMMEDIATE stmt
      USING dat1_, dat2_;
    COMMIT;
  END del_table_rows;

  PROCEDURE del_table_rows_allxito(dat_ IN VARCHAR2) IS
    stmt VARCHAR2(2000);
  BEGIN
    --„истка всех итоговых таблиц , дневных платежей, за период (как правило прошлый мес€ц)
    --„истка всех дней в таблице доступных периодов
    stmt := 'DELETE FROM period_reports WHERE TO_CHAR(dat,''YYYYMM'') = :dat_ AND ID IN (2,3,4,5)';
    EXECUTE IMMEDIATE stmt
      USING dat_;

    stmt := 'DELETE FROM xito5 WHERE TO_CHAR(dat,''YYYYMM'') = :dat_';
    EXECUTE IMMEDIATE stmt
      USING dat_;
    COMMIT;
    stmt := 'DELETE FROM xito5_ WHERE TO_CHAR(dat,''YYYYMM'') = :dat_';
    EXECUTE IMMEDIATE stmt
      USING dat_;
    COMMIT;
    stmt := 'DELETE FROM xxito10 WHERE TO_CHAR(dat,''YYYYMM'') = :dat_';
    EXECUTE IMMEDIATE stmt
      USING dat_;
    COMMIT;
  END del_table_rows_allxito;

  PROCEDURE insert_charges(lsk_   IN VARCHAR2,
                           usl_   IN VARCHAR2,
                           mg_    IN VARCHAR2,
                           summa_ IN NUMBER)
  --‘ормирование начислени€ через OLE
   IS
    stmt VARCHAR2(2000);
  BEGIN
    stmt := 'INSERT INTO charges (lsk, usl, summa, mg) VALUES (:lsk_, :usl_, :mg_, :summa_)';
    EXECUTE IMMEDIATE stmt
      USING lsk_, usl_, summa_, mg_;
    --    COMMIT;
  END insert_charges;

  PROCEDURE delete_charges(lsk1_ IN VARCHAR2, lsk2_ IN VARCHAR2)
  --„истка таблицы начислени€ текущего мес€ца
   IS
    stmt VARCHAR2(2000);
  BEGIN
    stmt := 'DELETE FROM charges WHERE lsk BETWEEN :lsk1_ AND :lsk2_';
    EXECUTE IMMEDIATE stmt
      USING lsk1_, lsk2_;
    COMMIT;
  END delete_charges;

  PROCEDURE delete_subsidii(lsk1_ IN VARCHAR2, lsk2_ IN VARCHAR2)
  --„истка таблицы начислени€ текущего мес€ца
   IS
    stmt VARCHAR2(2000);
  BEGIN
    stmt := 'DELETE FROM subsidii WHERE lsk BETWEEN :lsk1_ AND :lsk2_';
    EXECUTE IMMEDIATE stmt
      USING lsk1_, lsk2_;
    COMMIT;
  END delete_subsidii;

  PROCEDURE insert_subsidii(lsk_   IN VARCHAR2,
                            usl_   IN VARCHAR2,
                            mg_    IN VARCHAR2,
                            summa_ IN NUMBER) IS
    stmt VARCHAR2(2000);
  BEGIN
    stmt := 'INSERT INTO subsidii (lsk, usl, summa, mg) VALUES (:lsk_, :usl_, :mg_, :summa_)';
    EXECUTE IMMEDIATE stmt
      USING lsk_, usl_, summa_, mg_;
  END insert_subsidii;

  PROCEDURE report_saldo(reu_           IN VARCHAR2,
                         trest_         IN VARCHAR2,
                         mg_            IN VARCHAR2,
                         mg1_           IN VARCHAR2,
                         prep_refcursor IN OUT rep_refcursor) IS
    --ќборотка по –Ё”/домам
  BEGIN
    NULL;
    RETURN;
    --”далить процедуру, перенесена в pakage  rep_saldo

    IF reu_ IS NOT NULL THEN
      OPEN prep_refcursor FOR 'SELECT e_0.REU
  , s.trest
  , p.name
  , LTRIM(e_0.ND, ''0'') AS nd
  , e_1.UCH
  , NVL(e_1.INDEBET, 0) AS indebet
  , NVL(e_1.INKREDIT, 0) AS inkredit
  , NVL(o.CHARGES, 0) AS CHARGES
  , NVL(o.CHANGES, 0) AS CHANGES
  , NVL(o.subsid, 0) AS subsid
  , NVL(o.payment, 0) AS payment
  , NVL(o.pn, 0) AS pn
  , NVL(e.OUTDEBET, 0) AS outdebet
  , NVL(e.OUTKREDIT, 0) AS outkredit
FROM HOUSES e_0
  , XITOG1 x
  , S_REU_TREST s
  , XITOG1 e_1
  , (SELECT /*+ FULL (t) */
       reu
       , kul
       , nd
       , SUM(CHARGES) AS CHARGES
       , SUM(CHANGES) AS CHANGES
       , SUM(subsid) AS subsid
       , SUM(payment) AS payment
       , SUM(pn) AS pn
     FROM XITOG1 t
     WHERE t.mg
         BETWEEN :mg_ AND :mg1_
     GROUP BY reu, kul, nd) o
  , XITOG1 e
  , SPUL p
WHERE e_0.REU = e_1.REU (+)
  AND e_0.KUL = e_1.KUL (+)
  AND e_0.ND = e_1.ND (+)
  AND e_0.REU = o.reu(+)
  AND e_0.KUL = o.kul(+)
  AND e_0.ND = o.nd(+)
  AND e_0.REU = e.REU (+)
  AND e_0.KUL = e.KUL (+)
  AND e_0.ND = e.ND (+)
  AND e_0.KUL = p.id
  AND e_0.reu = :reu_
  AND e_0.reu = x.reu(+)
  AND e_0.kul = x.kul(+)
  AND e_0.nd = x.nd(+)
  AND e_0.reu = s.reu
  AND x.mg = :mg1_
  AND e_1.mg (+) = :mg_
  AND e.mg (+) = :mg1_
ORDER BY e_0.REU
  , NVL(x.uch, 0)
  , e_0.KUL
  , e_0.ND'
        USING mg_, mg1_, reu_, mg1_, mg_, mg1_;
    ELSIF trest_ IS NOT NULL THEN
      OPEN prep_refcursor FOR 'SELECT /*+ ORDERED USE_HASH (p) */
  e_0.REU
  , s.trest AS tr
  , s.name_tr AS trest
  , SUM(e_1.INDEBET) AS indebet
  , SUM(e_1.INKREDIT) AS inkredit
  , SUM(o.CHARGES) AS CHARGES
  , SUM(o.CHANGES) AS CHANGES
  , SUM(o.subsid) AS subsid
  , SUM(o.payment) AS payment
  , SUM(o.pn) AS pn
  , SUM(e.OUTDEBET) AS outdebet
  , SUM(e.OUTKREDIT) AS outkredit
FROM HOUSES e_0
  , S_REU_TREST s
  , XITOG1 e_1
  , (SELECT reu
       , kul
       , nd
       , SUM(CHARGES) AS CHARGES
       , SUM(CHANGES) AS CHANGES
       , SUM(subsid) AS subsid
       , SUM(payment) AS payment
       , SUM(pn) AS pn
     FROM XITOG1 t
     WHERE t.mg
         BETWEEN :mg_ AND :mg1_
     GROUP BY reu, kul, nd) o
  , XITOG1 e
  , SPUL p
WHERE e_0.REU = e_1.REU (+)
  AND e_0.KUL = e_1.KUL (+)
  AND e_0.ND = e_1.ND (+)
  AND e_0.REU = o.reu(+)
  AND e_0.KUL = o.kul(+)
  AND e_0.ND = o.nd(+)
  AND e_0.REU = e.REU (+)
  AND e_0.KUL = e.KUL (+)
  AND e_0.ND = e.ND (+)
  AND e_0.KUL = p.id
  AND e_0.reu = s.reu
  AND s.trest = :trest_
  AND e_1.mg (+) = :mg_
  AND e.mg (+) = :mg1_
GROUP BY s.trest, s.name_tr, e_0.REU'
        USING mg_, mg1_, trest_, mg_, mg1_;
    ELSIF reu_ IS NULL AND trest_ IS NULL THEN
      OPEN prep_refcursor FOR 'SELECT /*+ USE_HASH (e_0) */
            e_0.REU
            , s.trest AS tr
            , s.name_tr AS trest
            , SUM(e_1.INDEBET) AS indebet
            , SUM(e_1.INKREDIT) AS inkredit
            , SUM(o.CHARGES) AS CHARGES
            , SUM(o.CHANGES) AS CHANGES
            , SUM(o.subsid) AS subsid
            , SUM(o.payment) AS payment
            , SUM(o.pn) AS pn
            , SUM(e.OUTDEBET) AS outdebet
            , SUM(e.OUTKREDIT) AS outkredit
          FROM HOUSES e_0
            , S_REU_TREST s
            , XITOG1 e_1
            , (SELECT reu
                 , kul
                 , nd
                 , SUM(CHARGES) AS CHARGES
                 , SUM(CHANGES) AS CHANGES
                 , SUM(subsid) AS subsid
                 , SUM(payment) AS payment
                 , SUM(pn) AS pn
               FROM XITOG1 t
               WHERE t.mg
                   BETWEEN :mg_ AND :mg1_
               GROUP BY reu, kul, nd) o
            , XITOG1 e
            , SPUL p
          WHERE e_0.REU = e_1.REU (+)
            AND e_0.KUL = e_1.KUL (+)
            AND e_0.ND = e_1.ND (+)
            AND e_0.REU = o.reu(+)
            AND e_0.KUL = o.kul(+)
            AND e_0.ND = o.nd(+)
            AND e_0.REU = e.REU (+)
            AND e_0.KUL = e.KUL (+)
            AND e_0.ND = e.ND (+)
            AND e_0.KUL = p.id
            AND e_0.reu = s.reu
            AND e_1.mg (+) = :mg_
            AND e.mg (+) = :mg1_
          GROUP BY s.trest, s.name_tr, e_0.REU'
        USING mg_, mg1_, mg_, mg1_;
    END IF;
  END report_saldo;

  PROCEDURE report_debit(type_          IN NUMBER,
                         trest_         IN S_REU_TREST.trest%TYPE,
                         prep_refcursor IN OUT rep_refcursor) IS
    --«адолженность по предпри€ти€м
  BEGIN
    IF trest_ IS NOT NULL THEN
      --по тресту
      IF type_ = 1 THEN
        --с учетом текущих сборов
        OPEN prep_refcursor FOR 'SELECT (x.summa-z.summa)/1000 AS summa, x.type, x.org, o.name||'' ''||t.name_tr AS org_name, s.name, (SELECT MAX(dat) FROM xxito10) AS dat
          FROM
          (SELECT NVL(SUM(a.outdebet),0)+NVL(SUM(a.outkredit),0) AS summa, u.TYPE, a.ORG, a.trest
              FROM XITOG2 a, USLM u, v_params v
               WHERE a.mg=v.period3 AND a.USLM=u.USLM AND a.trest=:trest_
               GROUP BY u.TYPE, a.ORG, a.trest) x,
          (SELECT NVL(SUM(b.summa),0) AS summa, b.ORG, b.trest
              FROM XXITO10 b, v_params v
               WHERE TO_CHAR(b.dat,''YYYYMM'')=v.period
               GROUP BY b.ORG, b.trest) z,
          SPRORG s, (SELECT * FROM ORG WHERE ORG.id=2) o, s_trest t
          WHERE x.ORG=z.ORG(+) AND x.trest=t.trest(+)
               AND x.trest=z.trest(+) AND x.ORG=s.kod
          ORDER BY x.TYPE, x.ORG'
          USING trest_;
      ELSE
        --без учета текущих сборов
        OPEN prep_refcursor FOR 'SELECT (x.summa)/1000 AS summa, x.type, x.org, o.name  AS org_name, s.name, TO_DATE(''01''||TO_CHAR(sysdate,''MMYYYY''), ''DDMMYYYY'') AS dat
          FROM
          (SELECT NVL(SUM(a.outdebet),0)+NVL(SUM(a.outkredit),0) AS summa, u.TYPE, a.ORG
              FROM XITOG2 a, USLM u, v_params v
               WHERE a.mg=v.period3 AND a.USLM=u.USLM AND a.trest=:trest_
               GROUP BY u.TYPE, a.ORG) x,
          SPRORG s, ORG o
          WHERE x.ORG=s.kod AND o.id=1
          ORDER BY x.TYPE, x.ORG'
          USING trest_;
      END IF;
    ELSE
      --по ћѕ ”≈«∆ ”
      IF type_ = 1 THEN
        --с учетом текущих сборов
        OPEN prep_refcursor FOR 'SELECT (x.summa-z.summa)/1000 AS summa, x.type, x.org, o.name AS org_name, s.name, (SELECT MAX(dat) FROM xxito10) AS dat
          FROM
          (SELECT NVL(SUM(a.outdebet),0)+NVL(SUM(a.outkredit),0) AS summa, u.TYPE, a.ORG
              FROM XITOG2 a, USLM u, v_params v
               WHERE a.mg=v.period3 AND a.USLM=u.USLM
               GROUP BY u.TYPE, a.ORG) x,
          (SELECT NVL(SUM(b.summa),0) AS summa, b.ORG
              FROM XXITO10 b, v_params v
               WHERE TO_CHAR(b.dat,''YYYYMM'')=v.period
               GROUP BY b.ORG) z,
          SPRORG s, ORG o
          WHERE x.ORG=z.ORG AND x.ORG=s.kod AND o.id=1
          ORDER BY x.TYPE, x.ORG';
      ELSE
        --без учета текущих сборов
        /*        open prep_refcursor for 'SELECT (x.summa)/1000 AS summa, x.type, x.org, o.name  AS org_name, s.name, TO_DATE(''01''||TO_CHAR(sysdate,''MMYYYY''), ''DDMMYYYY'') AS dat
        FROM
        (SELECT NVL(sum(a.outdebet),0)+NVL(sum(a.outkredit),0) AS summa, u.type, a.org
            FROM xitog2 a, uslm u
             WHERE a.mg=''200412'' AND a.uslm=u.uslm
             GROUP BY u.type, a.org) x,
        sprorg s, org o
        WHERE x.org=s.kod AND o.id=1
        ORDER BY x.type, x.org';*/
        OPEN prep_refcursor FOR 'SELECT (x.summa)/1000 AS summa, x.type, x.org, o.name  AS org_name, s.name, TO_DATE(''01''||TO_CHAR(sysdate,''MMYYYY''), ''DDMMYYYY'') AS dat
          FROM
          (SELECT NVL(SUM(a.outdebet),0)+NVL(SUM(a.outkredit),0) AS summa, u.TYPE, a.ORG
              FROM XITOG2 a, USLM u, v_params v
               WHERE a.mg=v.period3 AND a.USLM=u.USLM
               GROUP BY u.TYPE, a.ORG) x,
          SPRORG s, ORG o
          WHERE x.ORG=s.kod AND o.id=1
          ORDER BY x.TYPE, x.ORG';
      END IF;
    END IF;
  END report_debit;

  PROCEDURE report_proc_org(prep_refcursor IN OUT rep_refcursor) IS
    --выполнение по предпри€ти€м
  BEGIN
    OPEN prep_refcursor FOR 'select sum(charges),sum(payment),
          NVL(ROUND(SUM(CHARGES)/SUM(payment),2)*100,0) proc, ORG
          FROM XITOG2 t
          WHERE mg=''200410''
          GROUP BY ORG';
  END report_proc_org;

  PROCEDURE report_proc_plan(reu_           IN S_REU_TREST.reu%TYPE,
                             trest_         IN S_REU_TREST.trest%TYPE,
                             dat1_          IN PROC_PLAN_LOADED.dat%TYPE,
                             dat2_          IN PROC_PLAN_LOADED.dat%TYPE,
                             prep_refcursor IN OUT rep_refcursor) IS
  BEGIN
    IF reu_ IS NOT NULL THEN
      --          case when p.sumplan<>0 then ROUND((a.summa+b.summa)/10/p.sumplan,2) else 0 end as procplan,
      OPEN prep_refcursor FOR 'select s.reu, s.name_tr, a.summa, b.summa as penya,
          c.summa AS sumbn, b.summa+a.summa AS sumall, p.sumplan,
          CASE WHEN p.sumplan<>0 THEN ROUND((a.summa)/10/p.sumplan,2) ELSE 0 END AS procplan,
           p.sumplan*1000-a.summa AS plan_no
           FROM
          v_trest_plan s, PROC_PLAN p, PARAMS m,
          (SELECT SUM(ska) AS summa, k.reu FROM PROC_PLAN_LOADED k, OPER o
          WHERE k.OPER=o.OPER AND SUBSTR(o.oigu,1,1)=''1''
               AND k.dat BETWEEN :dat1_ AND :dat2_ AND k.reu=:reu_
          GROUP BY k.reu) a,
          (SELECT SUM(pn) AS summa, k.reu FROM PROC_PLAN_LOADED k, OPER o
          WHERE k.OPER=o.OPER
               AND k.dat BETWEEN :dat1_ AND :dat2_ AND k.reu=:reu_
          GROUP BY k.reu) b,
          (SELECT SUM(ska) AS summa, k.reu FROM PROC_PLAN_LOADED k, OPER o
          WHERE k.OPER=o.OPER AND SUBSTR(o.oigu,1,2)=''10''
               AND k.dat BETWEEN :dat1_ AND :dat2_ AND k.reu=:reu_
          GROUP BY k.reu) c
          WHERE s.reu=a.reu(+) AND s.reu=b.reu(+) AND s.reu=c.reu(+) AND s.reu=p.reu
               AND m.period_pl=p.mg AND s.reu=:reu_ ORDER BY s.trest, s.reu'
        USING dat1_, dat2_, reu_, dat1_, dat2_, reu_, dat1_, dat2_, reu_, reu_;
    ELSIF trest_ IS NOT NULL THEN
      --          case when p.sumplan<>0 then ROUND((a.summa+b.summa)/10/p.sumplan,2) else 0 end as procplan,
      OPEN prep_refcursor FOR 'select s.reu, s.name_tr, a.summa, b.summa as penya,
          c.summa AS sumbn, b.summa+a.summa AS sumall, p.sumplan,
          CASE WHEN p.sumplan<>0 THEN ROUND((a.summa)/10/p.sumplan,2) ELSE 0 END AS procplan,
          p.sumplan*1000-a.summa AS plan_no
           FROM
          v_trest_plan s, PROC_PLAN p, PARAMS m,
          (SELECT SUM(ska) AS summa, k.reu FROM PROC_PLAN_LOADED k, OPER o
          WHERE k.OPER=o.OPER AND SUBSTR(o.oigu,1,1)=''1''
               AND k.dat BETWEEN :dat1_ AND :dat2_
          GROUP BY k.reu) a,
          (SELECT SUM(pn) AS summa, k.reu FROM PROC_PLAN_LOADED k, OPER o
          WHERE k.OPER=o.OPER
               AND k.dat BETWEEN :dat1_ AND :dat2_
          GROUP BY k.reu) b,
          (SELECT SUM(ska) AS summa, k.reu FROM PROC_PLAN_LOADED k, OPER o
          WHERE k.OPER=o.OPER AND SUBSTR(o.oigu,1,2)=''10''
               AND k.dat BETWEEN :dat1_ AND :dat2_
          GROUP BY k.reu) c
          WHERE s.reu=a.reu(+) AND s.reu=b.reu(+) AND s.reu=c.reu(+) AND s.reu=p.reu
               AND m.period_pl=p.mg AND s.trest=:trest_ ORDER BY s.trest, s.reu'
        USING dat1_, dat2_, dat1_, dat2_, dat1_, dat2_, trest_;
    ELSE
      --          case when p.sumplan<>0 then ROUND((a.summa+b.summa)/10/p.sumplan,2) else 0 end as procplan,
      OPEN prep_refcursor FOR 'select s.reu, s.name_tr, a.summa, b.summa as penya,
          c.summa AS sumbn, b.summa+a.summa AS sumall, p.sumplan,
          CASE WHEN p.sumplan<>0 THEN ROUND((a.summa)/10/p.sumplan,2) ELSE 0 END AS procplan,
           p.sumplan*1000-a.summa AS plan_no
           FROM
          v_trest_plan s, PROC_PLAN p, PARAMS m,
          (SELECT SUM(ska) AS summa, k.reu FROM PROC_PLAN_LOADED k, OPER o
          WHERE k.OPER=o.OPER AND SUBSTR(o.oigu,1,1)=''1''
               AND k.dat BETWEEN :dat1_ AND :dat2_
          GROUP BY k.reu) a,
          (SELECT SUM(pn) AS summa, k.reu FROM PROC_PLAN_LOADED k, OPER o
          WHERE k.OPER=o.OPER
               AND k.dat BETWEEN :dat1_ AND :dat2_
          GROUP BY k.reu) b,
          (SELECT SUM(ska) AS summa, k.reu FROM PROC_PLAN_LOADED k, OPER o
          WHERE k.OPER=o.OPER AND SUBSTR(o.oigu,1,2)=''10''
               AND k.dat BETWEEN :dat1_ AND :dat2_
          GROUP BY k.reu) c
          WHERE s.reu=a.reu(+) AND s.reu=b.reu(+) AND s.reu=c.reu(+) AND s.reu=p.reu
               AND m.period_pl=p.mg ORDER BY s.trest, s.reu'
        USING dat1_, dat2_, dat1_, dat2_, dat1_, dat2_;
    END IF;
  END report_proc_plan;

  PROCEDURE report_opl_tr_own(prep_refcursor IN OUT rep_refcursor) IS
    --—редства, собранные трестами, собой
  BEGIN
    OPEN prep_refcursor FOR 'select o.name, u.nm1, s.trest, s.name_tr, sum(summa) as summa
               FROM XXITO10 t, S_REU_TREST s, USL u, SPRORG o
               WHERE t.reu=s.reu AND t.USL=u.USL AND t.ORG=o.kod
               GROUP BY o.name, u.nm1, s.trest, s.name_tr';
  END report_opl_tr_own;







  PROCEDURE report_pen(var_            IN NUMBER,
                       reu_            IN VARCHAR2,
                       trest_          IN VARCHAR2,
                       dat_            IN DATE,
                       dat1_           IN DATE,
                       mg_             IN VARCHAR2,
                       mg1_            IN VARCHAR2,
                       v_rep_refcursor IN OUT rep_refcursor) IS
  BEGIN
    IF var_ = 0 THEN
      --ѕен€, прин€та€ за ∆Ёќ, кроме сборов этого ∆Ёќ
      IF trest_ IS NOT NULL THEN
        --ѕо трестам
        IF dat_ IS NOT NULL AND dat1_ IS NOT NULL THEN
          OPEN v_rep_refcursor FOR 'select sum(pn) as summa, s.name_tr, x.from_reu
          FROM XITO5_ x, S_REU_TREST s, S_REU_TREST d
          WHERE dat BETWEEN :dat_ AND :dat1_ AND x.from_reu=s.reu AND x.reu=d.reu
          AND d.trest=:trest_ AND s.trest<>d.trest AND x.pn<>0
          GROUP BY s.trest, s.name_tr, x.from_reu
          ORDER BY s.trest, x.from_reu'
            USING dat_, dat1_, trest_;
        ELSIF mg_ IS NOT NULL AND mg1_ IS NOT NULL THEN
          OPEN v_rep_refcursor FOR 'select sum(pn) as summa, s.name_tr, x.from_reu
          FROM XITO5_ x, S_REU_TREST s, S_REU_TREST d
          WHERE mg BETWEEN :mg_ AND :mg1_ AND x.from_reu=s.reu AND x.reu=d.reu
          AND d.trest=:trest_ AND s.trest<>d.trest AND x.pn<>0
          GROUP BY s.trest, s.name_tr, x.from_reu
          ORDER BY s.trest, x.from_reu'
            USING mg_, mg1_, trest_;
        END IF;
      ELSIF reu_ IS NOT NULL THEN
        --ѕо –Ё”
        IF dat_ IS NOT NULL AND dat1_ IS NOT NULL THEN
          OPEN v_rep_refcursor FOR 'select sum(pn) as summa, s.name_tr, x.from_reu
          FROM XITO5_ x, S_REU_TREST s, S_REU_TREST d
          WHERE dat BETWEEN :dat_ AND :dat1_ AND x.from_reu=s.reu AND x.reu=d.reu
          AND d.reu=:reu_ AND s.trest<>d.trest AND x.pn<>0
          GROUP BY s.trest, s.name_tr, x.from_reu
          ORDER BY s.trest, x.from_reu'
            USING dat_, dat1_, reu_;
        ELSIF mg_ IS NOT NULL AND mg1_ IS NOT NULL THEN
          OPEN v_rep_refcursor FOR 'select sum(pn) as summa, s.name_tr, x.from_reu
          FROM XITO5_ x, S_REU_TREST s, S_REU_TREST d
          WHERE mg BETWEEN :mg_ AND :mg1_ AND x.from_reu=s.reu AND x.reu=d.reu
          AND d.reu=:reu_ AND s.trest<>d.trest AND x.pn<>0
          GROUP BY s.trest, s.name_tr, x.from_reu
          ORDER BY s.trest, x.from_reu'
            USING mg_, mg1_, reu_;
        END IF;
      ELSE
        --ѕо всем ∆Ёќ
        IF dat_ IS NOT NULL AND dat1_ IS NOT NULL THEN
          OPEN v_rep_refcursor FOR 'select sum(pn) as summa, s.name_tr, x.from_reu
          FROM XITO5_ x, S_REU_TREST s
          WHERE dat BETWEEN :dat_ AND :dat1_ AND x.from_reu=s.reu
          AND x.pn<>0
          GROUP BY s.trest, s.name_tr, x.from_reu
          ORDER BY s.trest, x.from_reu'
            USING dat_, dat1_;
        ELSIF mg_ IS NOT NULL AND mg1_ IS NOT NULL THEN
          OPEN v_rep_refcursor FOR 'select sum(pn) as summa, s.name_tr, x.from_reu
          FROM XITO5_ x, S_REU_TREST s
          WHERE mg BETWEEN :mg_ AND :mg1_ AND x.from_reu=s.reu
          AND x.pn<>0
          GROUP BY s.trest, s.name_tr, x.from_reu
          ORDER BY s.trest, x.from_reu'
            USING mg_, mg1_;
        END IF;
      END IF;
    ELSE
      --ѕен€, прин€та€ ∆Ёќ за других, кроме сборов за этот ∆Ёќ
      IF trest_ IS NOT NULL THEN
        --ѕо трестам
        IF dat_ IS NOT NULL AND dat1_ IS NOT NULL THEN
          OPEN v_rep_refcursor FOR 'select sum(pn) as summa, s.name_tr, x.reu as from_reu
          FROM XITO5_ x, S_REU_TREST s, S_REU_TREST d
          WHERE dat BETWEEN :dat_ AND :dat1_ AND x.reu=s.reu AND x.from_reu=d.reu
          AND d.trest=:trest_ AND s.trest<>d.trest AND x.pn<>0
          GROUP BY s.trest, s.name_tr, x.reu
          ORDER BY s.trest, x.reu'
            USING dat_, dat1_, trest_;
        ELSIF mg_ IS NOT NULL AND mg1_ IS NOT NULL THEN
          OPEN v_rep_refcursor FOR 'select sum(pn) as summa, s.name_tr, x.reu as from_reu
          FROM XITO5_ x, S_REU_TREST s, S_REU_TREST d
          WHERE mg BETWEEN :mg_ AND :mg1_ AND x.reu=s.reu AND x.from_reu=d.reu
          AND d.trest=:trest_ AND s.trest<>d.trest AND x.pn<>0
          GROUP BY s.trest, s.name_tr, x.reu
          ORDER BY s.trest, x.reu'
            USING mg_, mg1_, trest_;
        END IF;
      ELSIF reu_ IS NOT NULL THEN
        --ѕо –Ё”
        IF dat_ IS NOT NULL AND dat1_ IS NOT NULL THEN
          OPEN v_rep_refcursor FOR 'select sum(pn) as summa, s.name_tr, x.reu as from_reu
          FROM XITO5_ x, S_REU_TREST s, S_REU_TREST d
          WHERE dat BETWEEN :dat_ AND :dat1_ AND x.reu=s.reu AND x.from_reu=d.reu
          AND d.reu=:reu_ AND s.trest<>d.trest AND x.pn<>0
          GROUP BY s.trest, s.name_tr, x.reu
          ORDER BY s.trest, x.reu'
            USING dat_, dat1_, reu_;
        ELSIF mg_ IS NOT NULL AND mg1_ IS NOT NULL THEN
          OPEN v_rep_refcursor FOR 'select sum(pn) as summa, s.name_tr, x.reu as from_reu
          FROM XITO5_ x, S_REU_TREST s, S_REU_TREST d
          WHERE mg BETWEEN :mg_ AND :mg1_ AND x.reu=s.reu AND x.from_reu=d.reu
          AND d.reu=:reu_ AND s.trest<>d.trest AND x.pn<>0
          GROUP BY s.trest, s.name_tr, x.reu
          ORDER BY s.trest, x.reu'
            USING mg_, mg1_, reu_;
        END IF;
      ELSE
        --ѕо всем ∆Ёќ
        IF dat_ IS NOT NULL AND dat1_ IS NOT NULL THEN
          OPEN v_rep_refcursor FOR 'select sum(pn) as summa, s.name_tr, x.reu as from_reu
          FROM XITO5_ x, S_REU_TREST s
          WHERE dat BETWEEN :dat_ AND :dat1_ AND x.reu=s.reu
          AND x.pn<>0
          GROUP BY s.trest, s.name_tr, x.reu
          ORDER BY s.trest, x.reu'
            USING dat_, dat1_;
        ELSIF mg_ IS NOT NULL AND mg1_ IS NOT NULL THEN
          OPEN v_rep_refcursor FOR 'select sum(pn) as summa, s.name_tr, x.reu as from_reu
          FROM XITO5_ x, S_REU_TREST s
          WHERE mg BETWEEN :mg_ AND :mg1_ AND x.reu=s.reu
          AND x.pn<>0
          GROUP BY s.trest, s.name_tr, x.reu
          ORDER BY s.trest, x.reu'
            USING mg_, mg1_;
        END IF;
      END IF;
    END IF;
  END report_pen;

  PROCEDURE report_check_rep(var_            IN NUMBER,
                             mg_             IN XITOG3.mg%TYPE,
                             mg1_            IN XITOG3.mg%TYPE,
                             v_rep_refcursor IN OUT rep_refcursor) IS
  BEGIN
    --ќтчет: —верка по концу мес€ца - ќборотка с оплатой по операци€м
    IF var_ = 0 THEN
      OPEN v_rep_refcursor FOR '(select s.trest, s.name_tr, sum(x.summa) as summa1, sum(i.summa) as summa2,
         NVL(SUM(x.summa),0) - NVL(SUM(i.summa),0) AS diff
               FROM (SELECT reu, SUM(payment) AS summa
               FROM XITOG2 d WHERE d.mg BETWEEN :mg_ AND :mg1_
               AND NOT EXISTS (SELECT USLM FROM USLM u WHERE TYPE IN (0) AND u.USLM=d.USLM)
                    GROUP BY reu) x,
               (SELECT from_reu AS reu, SUM(ska) AS summa
               FROM XITO5_ d WHERE d.other=1 AND d.mg BETWEEN :mg_ AND :mg1_ GROUP BY from_reu) i,
               S_REU_TREST s
               WHERE s.reu=i.reu(+) AND s.reu=x.reu(+)
               GROUP BY s.trest, s.name_tr)
          ORDER BY s.trest'
        USING mg_, mg1_, mg_, mg1_;
    ELSIF var_ = 1 THEN
      OPEN v_rep_refcursor FOR '(select s.trest, s.name_tr, sum(x.summa) as summa1, sum(i.summa) as summa2,
         NVL(SUM(x.summa),0) - NVL(SUM(i.summa),0) AS diff
               FROM (SELECT reu, SUM(pn) AS summa
               FROM XITOG2 d WHERE d.mg BETWEEN :mg_ AND :mg1_
               AND NOT EXISTS (SELECT USLM FROM USLM u WHERE TYPE IN (0) AND u.USLM=d.USLM)
                    GROUP BY reu) x,
               (SELECT from_reu AS reu, SUM(pn) AS summa
               FROM XITO5_ d WHERE d.other=1 AND d.mg BETWEEN :mg_ AND :mg1_ GROUP BY from_reu) i,
               S_REU_TREST s
               WHERE s.reu=i.reu(+) AND s.reu=x.reu(+)
               GROUP BY s.trest, s.name_tr)
          ORDER BY s.trest'
        USING mg_, mg1_, mg_, mg1_;
    ELSIF var_ = 2 THEN
      OPEN v_rep_refcursor FOR '(select s.trest, s.name_tr, sum(x.summa) as summa1, sum(i.summa) as summa2,
         NVL(SUM(x.summa),0) - NVL(SUM(i.summa),0) AS diff
               FROM (SELECT reu, SUM(NVL(payment,0)+NVL(pn,0)) AS summa
               FROM XITOG2 d WHERE d.mg BETWEEN :mg_ AND :mg1_
               AND NOT EXISTS (SELECT USLM FROM USLM u WHERE TYPE IN (0) AND u.USLM=d.USLM)
                    GROUP BY reu) x,
               (SELECT  from_reu AS reu, SUM(NVL(ska,0)+NVL(pn,0)) AS summa
               FROM XITO5_ d WHERE d.other=1 AND d.mg BETWEEN :mg_ AND :mg1_ GROUP BY from_reu) i,
               S_REU_TREST s
               WHERE s.reu=i.reu(+) AND s.reu=x.reu(+)
               GROUP BY s.trest, s.name_tr)
          ORDER BY s.trest'
        USING mg_, mg1_, mg_, mg1_;
    END IF;
  END;

/*  procedure report_lg_usl_org(var_           in number,
                              var1_          in number,
                              reu_           in xito_lg2.reu%type,
                              trest_         in xito_lg2.trest%type,
                              houses_        in number,
                              org_           in xito_lg2.org_id%type,
                              mg_            in xito_lg2.mg%type,
                              mg1_           in xito_lg2.mg%type,
                              prep_refcursor in out rep_refcursor) is
    --ќтчет: Ћьготники (по услугам или предпри€ти€м)
  begin
    if var_ = 1 then
      --ѕо услугам
      if var1_ = 0 then
        --—уммы возмещени€
        if trest_ is not null then
          --ѕо трестам
          open prep_refcursor for
            select substr(g.name, 1, 60) as gr_name,
                   substr(to_char(s.id) || ' ' || s.name, 1, 15) as name,
                   substr(u.nm1, 1, 15) as nm1,
                   sum(x.summa) as summa
              from xito_lg2 x, spk s, spk_gr g, uslm u
             where x.uslm_id = u.uslm
               and x.lg_id = s.id
               and mg between mg_ and mg1_
               and x.trest = trest_
               and s.gr_id = g.id
             group by substr(g.name, 1, 60),
                      substr(to_char(s.id) || ' ' || s.name, 1, 15),
                      substr(u.nm1, 1, 15);
        elsif reu_ is not null then
          --ѕо –Ё”
          open prep_refcursor for
            select substr(g.name, 1, 60) as gr_name,
                   substr(to_char(s.id) || ' ' || s.name, 1, 15) as name,
                   substr(u.nm1, 1, 15) as nm1,
                   sum(x.summa) as summa
              from xito_lg2 x, spk s, spk_gr g, uslm u
             where x.uslm_id = u.uslm
               and x.lg_id = s.id
               and mg between mg_ and mg1_
               and x.reu = reu_
               and s.gr_id = g.id
             group by substr(g.name, 1, 60),
                      substr(to_char(s.id) || ' ' || s.name, 1, 15),
                      substr(u.nm1, 1, 15);
        elsif houses_ is not null then
          --ѕо ƒомам
          open prep_refcursor for
            select substr(g.name, 1, 60) as gr_name,
                   substr(to_char(s.id) || ' ' || s.name, 1, 15) as name,
                   substr(u.nm1, 1, 15) as nm1,
                   sum(x.summa) as summa
              from xito_lg2 x, spk s, spk_gr g, uslm u
             where x.uslm_id = u.uslm
               and x.lg_id = s.id
               and mg between mg_ and mg1_
               and exists (select *
                      from list_choices l
                     where l.reu = x.reu
                       and l.kul = x.kul
                       and l.nd = x.nd
                       and l.sel = 0)
               and s.gr_id = g.id
             group by substr(g.name, 1, 60),
                      substr(to_char(s.id) || ' ' || s.name, 1, 15),
                      substr(u.nm1, 1, 15);
        else
          --ѕо всем ∆Ёќ
          open prep_refcursor for
            select substr(g.name, 1, 60) as gr_name,
                   substr(to_char(s.id) || ' ' || s.name, 1, 15) as name,
                   substr(u.nm1, 1, 15) as nm1,
                   sum(x.summa) as summa
              from xito_lg2 x, spk s, spk_gr g, uslm u
             where x.uslm_id = u.uslm
               and x.lg_id = s.id
               and mg between mg_ and mg1_
               and s.gr_id = g.id
             group by substr(g.name, 1, 60),
                      substr(to_char(s.id) || ' ' || s.name, 1, 15),
                      substr(u.nm1, 1, 15);
        end if;
      elsif var1_ = 1 then
        -- ол-во льготников
        if trest_ is not null then
          --ѕо трестам
          open prep_refcursor for
            select substr(g.name, 1, 60) as gr_name,
                   substr(to_char(s.id) || ' ' || s.name, 1, 15) as name,
                   substr(u.nm1, 1, 15) as nm1,
                   sum(x.cnt_main) as cnt_main,
                   sum(x.cnt) as cnt
              from (select reu,
                           trest,
                           kul,
                           nd,
                           uslm_id,
                           lg_id,
                           mg,
                           max(cnt_main) as cnt_main,
                           max(cnt) as cnt
                      from xito_lg2
                     group by reu, trest, kul, nd, uslm_id, lg_id, mg) x,
                   spk s,
                   spk_gr g,
                   uslm u
             where x.uslm_id = u.uslm
               and x.lg_id = s.id
               and mg between mg_ and mg1_
               and x.trest = trest_
               and s.gr_id = g.id
             group by substr(g.name, 1, 60),
                      substr(to_char(s.id) || ' ' || s.name, 1, 15),
                      substr(u.nm1, 1, 15);
        elsif reu_ is not null then
          --ѕо –Ё”
          open prep_refcursor for
            select substr(g.name, 1, 60) as gr_name,
                   substr(to_char(s.id) || ' ' || s.name, 1, 15) as name,
                   substr(u.nm1, 1, 15) as nm1,
                   sum(x.cnt_main) as cnt_main,
                   sum(x.cnt) as cnt
              from (select reu,
                           trest,
                           kul,
                           nd,
                           uslm_id,
                           lg_id,
                           mg,
                           max(cnt_main) as cnt_main,
                           max(cnt) as cnt
                      from xito_lg2
                     group by reu, trest, kul, nd, uslm_id, lg_id, mg) x,
                   spk s,
                   spk_gr g,
                   uslm u
             where x.uslm_id = u.uslm
               and x.lg_id = s.id
               and mg between mg_ and mg1_
               and x.reu = reu_
               and s.gr_id = g.id
             group by substr(g.name, 1, 60),
                      substr(to_char(s.id) || ' ' || s.name, 1, 15),
                      substr(u.nm1, 1, 15);
        elsif houses_ is not null then
          --ѕо домам
          open prep_refcursor for
            select substr(g.name, 1, 60) as gr_name,
                   substr(to_char(s.id) || ' ' || s.name, 1, 15) as name,
                   substr(u.nm1, 1, 15) as nm1,
                   sum(x.cnt_main) as cnt_main,
                   sum(x.cnt) as cnt
              from (select reu,
                           trest,
                           kul,
                           nd,
                           uslm_id,
                           lg_id,
                           mg,
                           max(cnt_main) as cnt_main,
                           max(cnt) as cnt
                      from xito_lg2
                     group by reu, trest, kul, nd, uslm_id, lg_id, mg) x,
                   spk s,
                   spk_gr g,
                   uslm u
             where x.uslm_id = u.uslm
               and x.lg_id = s.id
               and mg between mg_ and mg1_
               and exists (select *
                      from list_choices l
                     where l.reu = x.reu
                       and l.kul = x.kul
                       and l.nd = x.nd
                       and l.sel = 0)
               and s.gr_id = g.id
             group by substr(g.name, 1, 60),
                      substr(to_char(s.id) || ' ' || s.name, 1, 15),
                      substr(u.nm1, 1, 15);
        else
          --ѕо всем ∆Ёќ
          open prep_refcursor for
            select substr(g.name, 1, 60) as gr_name,
                   substr(to_char(s.id) || ' ' || s.name, 1, 15) as name,
                   substr(u.nm1, 1, 15) as nm1,
                   sum(x.cnt_main) as cnt_main,
                   sum(x.cnt) as cnt
              from (select reu,
                           trest,
                           kul,
                           nd,
                           uslm_id,
                           lg_id,
                           mg,
                           max(cnt_main) as cnt_main,
                           max(cnt) as cnt
                      from xito_lg2
                     group by reu, trest, kul, nd, uslm_id, lg_id, mg) x,
                   spk s,
                   spk_gr g,
                   uslm u
             where x.uslm_id = u.uslm
               and x.lg_id = s.id
               and mg between mg_ and mg1_
               and s.gr_id = g.id
             group by substr(g.name, 1, 60),
                      substr(to_char(s.id) || ' ' || s.name, 1, 15),
                      substr(u.nm1, 1, 15);
        end if;
      end if;
    elsif var_ = 0 then
      --ѕо организаци€м
      if var1_ = 0 then
        --—уммы возмещени€
        if trest_ is not null then
          --ѕо трестам
          open prep_refcursor for
            select substr(g.name, 1, 60) as gr_name,
                   substr(to_char(s.id) || ' ' || s.name, 1, 15) as name,
                   substr(u.name, 1, 25) as nm1,
                   sum(x.summa) as summa
              from xito_lg2 x, spk s, spk_gr g, sprorg u
             where x.org_id = u.kod
               and x.lg_id = s.id
               and mg between mg_ and mg1_
               and x.trest = trest_
               and s.gr_id = g.id
             group by substr(g.name, 1, 60),
                      substr(to_char(s.id) || ' ' || s.name, 1, 15),
                      substr(u.name, 1, 25);
        elsif reu_ is not null then
          --ѕо –Ё”
          open prep_refcursor for
            select substr(g.name, 1, 60) as gr_name,
                   substr(to_char(s.id) || ' ' || s.name, 1, 15) as name,
                   substr(u.name, 1, 25) as nm1,
                   sum(x.summa) as summa
              from xito_lg2 x, spk s, spk_gr g, sprorg u
             where x.org_id = u.kod
               and x.lg_id = s.id
               and mg between mg_ and mg1_
               and x.reu = reu_
               and s.gr_id = g.id
             group by substr(g.name, 1, 60),
                      substr(to_char(s.id) || ' ' || s.name, 1, 15),
                      substr(u.name, 1, 25);
        elsif houses_ is not null then
          --ѕо домам
          open prep_refcursor for
            select substr(g.name, 1, 60) as gr_name,
                   substr(to_char(s.id) || ' ' || s.name, 1, 15) as name,
                   substr(u.name, 1, 25) as nm1,
                   sum(x.summa) as summa
              from xito_lg2 x, spk s, spk_gr g, sprorg u
             where x.org_id = u.kod
               and x.lg_id = s.id
               and mg between mg_ and mg1_
               and exists (select *
                      from list_choices l
                     where l.reu = x.reu
                       and l.kul = x.kul
                       and l.nd = x.nd
                       and l.sel = 0)
               and s.gr_id = g.id
             group by substr(g.name, 1, 60),
                      substr(to_char(s.id) || ' ' || s.name, 1, 15),
                      substr(u.name, 1, 25);
        else
          --ѕо всем ∆Ёќ
          open prep_refcursor for
            select substr(g.name, 1, 60) as gr_name,
                   substr(to_char(s.id) || ' ' || s.name, 1, 15) as name,
                   substr(u.name, 1, 25) as nm1,
                   sum(x.summa) as summa
              from xito_lg2 x, spk s, spk_gr g, sprorg u
             where x.org_id = u.kod
               and x.lg_id = s.id
               and mg between mg_ and mg1_
               and s.gr_id = g.id
             group by substr(g.name, 1, 60),
                      substr(to_char(s.id) || ' ' || s.name, 1, 15),
                      substr(u.name, 1, 25);
        end if;
      elsif var1_ = 1 then
        -- ол-во льготников
        if trest_ is not null then
          --ѕо трестам
          open prep_refcursor for
            select substr(g.name, 1, 60) as gr_name,
                   substr(to_char(s.id) || ' ' || s.name, 1, 15) as name,
                   substr(u.name, 1, 15) as nm1,
                   sum(x.cnt_main) as cnt_main,
                   sum(x.cnt) as cnt
              from (select reu,
                           trest,
                           kul,
                           nd,
                           org_id,
                           lg_id,
                           mg,
                           max(cnt_main) as cnt_main,
                           max(cnt) as cnt
                      from xito_lg2
                     group by reu, trest, kul, nd, org_id, lg_id, mg) x,
                   spk s,
                   spk_gr g,
                   sprorg u
             where x.org_id = u.kod
               and x.lg_id = s.id
               and mg between mg_ and mg1_
               and x.trest = trest_
               and s.gr_id = g.id
             group by substr(g.name, 1, 60),
                      substr(to_char(s.id) || ' ' || s.name, 1, 15),
                      substr(u.name, 1, 15);
        elsif reu_ is not null then
          --ѕо –Ё”
          open prep_refcursor for
            select substr(g.name, 1, 60) as gr_name,
                   substr(to_char(s.id) || ' ' || s.name, 1, 15) as name,
                   substr(u.name, 1, 15) as nm1,
                   sum(x.cnt_main) as cnt_main,
                   sum(x.cnt) as cnt
              from (select reu,
                           trest,
                           kul,
                           nd,
                           org_id,
                           lg_id,
                           mg,
                           max(cnt_main) as cnt_main,
                           max(cnt) as cnt
                      from xito_lg2
                     group by reu, trest, kul, nd, org_id, lg_id, mg) x,
                   spk s,
                   spk_gr g,
                   sprorg u
             where x.org_id = u.kod
               and x.lg_id = s.id
               and mg between mg_ and mg1_
               and x.reu = reu_
               and s.gr_id = g.id
             group by substr(g.name, 1, 60),
                      substr(to_char(s.id) || ' ' || s.name, 1, 15),
                      substr(u.name, 1, 15);
        elsif houses_ is not null then
          --ѕо домам
          open prep_refcursor for
            select substr(g.name, 1, 60) as gr_name,
                   substr(to_char(s.id) || ' ' || s.name, 1, 15) as name,
                   substr(u.name, 1, 15) as nm1,
                   sum(x.cnt_main) as cnt_main,
                   sum(x.cnt) as cnt
              from (select reu,
                           trest,
                           kul,
                           nd,
                           org_id,
                           lg_id,
                           mg,
                           max(cnt_main) as cnt_main,
                           max(cnt) as cnt
                      from xito_lg2
                     group by reu, trest, kul, nd, org_id, lg_id, mg) x,
                   spk s,
                   spk_gr g,
                   sprorg u
             where x.org_id = u.kod
               and x.lg_id = s.id
               and mg between mg_ and mg1_
               and exists (select *
                      from list_choices l
                     where l.reu = x.reu
                       and l.kul = x.kul
                       and l.nd = x.nd
                       and l.sel = 0)
               and s.gr_id = g.id
             group by substr(g.name, 1, 60),
                      substr(to_char(s.id) || ' ' || s.name, 1, 15),
                      substr(u.name, 1, 15);
        else
          --ѕо всем ∆Ёќ
          open prep_refcursor for
            select substr(g.name, 1, 60) as gr_name,
                   substr(to_char(s.id) || ' ' || s.name, 1, 15) as name,
                   substr(u.name, 1, 15) as nm1,
                   sum(x.cnt_main) as cnt_main,
                   sum(x.cnt) as cnt
              from (select reu,
                           trest,
                           kul,
                           nd,
                           org_id,
                           lg_id,
                           mg,
                           max(cnt_main) as cnt_main,
                           max(cnt) as cnt
                      from xito_lg2
                     group by reu, trest, kul, nd, org_id, lg_id, mg) x,
                   spk s,
                   spk_gr g,
                   sprorg u
             where x.org_id = u.kod
               and x.lg_id = s.id
               and mg between mg_ and mg1_
               and s.gr_id = g.id
             group by substr(g.name, 1, 60),
                      substr(to_char(s.id) || ' ' || s.name, 1, 15),
                      substr(u.name, 1, 15);
        end if;
      end if;
    elsif var_ = 2 then
      --¬озмещение, кол-во льготников (по выбранной организации)
      if trest_ is not null then
        --ѕо трестам
        open prep_refcursor for
          select substr(g.name, 1, 60) as gr_name,
                 substr(to_char(s.id) || ' ' || s.name, 1, 15) as name,
                 substr(u.nm1, 1, 15) as nm1,
                 sum(x.summa) as summa,
                 sum(x.cnt_main) as cnt_main,
                 sum(x.cnt) as cnt
            from xito_lg2 x, spk s, spk_gr g, uslm u
           where x.uslm_id = u.uslm
             and x.lg_id = s.id
             and mg between mg_ and mg1_
             and x.trest = trest_
             and s.gr_id = g.id
             and x.org_id = org_
           group by substr(g.name, 1, 60),
                    substr(to_char(s.id) || ' ' || s.name, 1, 15),
                    substr(u.nm1, 1, 15);
      elsif reu_ is not null then
        --ѕо –Ё”
        open prep_refcursor for
          select substr(g.name, 1, 60) as gr_name,
                 substr(to_char(s.id) || ' ' || s.name, 1, 15) as name,
                 substr(u.nm1, 1, 15) as nm1,
                 sum(x.summa) as summa,
                 sum(x.cnt_main) as cnt_main,
                 sum(x.cnt) as cnt
            from xito_lg2 x, spk s, spk_gr g, uslm u
           where x.uslm_id = u.uslm
             and x.lg_id = s.id
             and mg between mg_ and mg1_
             and x.reu = reu_
             and s.gr_id = g.id
             and x.org_id = org_
           group by substr(g.name, 1, 60),
                    substr(to_char(s.id) || ' ' || s.name, 1, 15),
                    substr(u.nm1, 1, 15);
      elsif houses_ is not null then
        --ѕо домам
        open prep_refcursor for
          select substr(g.name, 1, 60) as gr_name,
                 substr(to_char(s.id) || ' ' || s.name, 1, 15) as name,
                 substr(u.nm1, 1, 15) as nm1,
                 sum(x.summa) as summa,
                 sum(x.cnt_main) as cnt_main,
                 sum(x.cnt) as cnt
            from xito_lg2 x, spk s, spk_gr g, uslm u
           where x.uslm_id = u.uslm
             and x.lg_id = s.id
             and mg between mg_ and mg1_
             and exists (select *
                    from list_choices l
                   where l.reu = x.reu
                     and l.kul = x.kul
                     and l.nd = x.nd
                     and l.sel = 0)
             and s.gr_id = g.id
             and x.org_id = org_
           group by substr(g.name, 1, 60),
                    substr(to_char(s.id) || ' ' || s.name, 1, 15),
                    substr(u.nm1, 1, 15);
      else
        --ѕо всем ∆Ёќ
        open prep_refcursor for
          select substr(g.name, 1, 60) as gr_name,
                 substr(to_char(s.id) || ' ' || s.name, 1, 15) as name,
                 substr(u.nm1, 1, 15) as nm1,
                 sum(x.summa) as summa,
                 sum(x.cnt_main) as cnt_main,
                 sum(x.cnt) as cnt
            from xito_lg2 x, spk s, spk_gr g, uslm u
           where x.uslm_id = u.uslm
             and x.lg_id = s.id
             and mg between mg_ and mg1_
             and s.gr_id = g.id
             and x.org_id = org_
           group by substr(g.name, 1, 60),
                    substr(to_char(s.id) || ' ' || s.name, 1, 15),
                    substr(u.nm1, 1, 15);
        /*        OPEN prep_refcursor FOR
        SELECT substr(g.NAME, 1, 60) AS gr_name,
               substr(to_char(s.id) || ' ' || s.NAME, 1, 15) AS NAME,
               substr(u.nm1, 1, 15) AS nm1, SUM(x.summa) AS summa,
               SUM(x.cnt_main) AS cnt_main, SUM(x.cnt) AS cnt
          FROM (SELECT reu, trest, kul, nd, uslm_id, lg_id, mg,
                        SUM(summa) AS summa, SUM(cnt_main) AS cnt_main,
                        SUM(cnt) AS cnt
                   FROM xito_lg2
                  WHERE org_id = org_
                  GROUP BY reu, trest, kul, nd, uslm_id, lg_id, mg) x,
               spk s, spk_gr g, uslm u
         WHERE x.uslm_id = u.uslm
           AND x.lg_id = s.id
           AND mg BETWEEN mg_ AND mg1_
           AND s.gr_id = g.id
         GROUP BY substr(g.NAME, 1, 60),
                  substr(to_char(s.id) || ' ' || s.NAME, 1, 15),
                  substr(u.nm1, 1, 15);*/
/*      end if;
    elsif var_ = 3 then
      --¬озмещение, кол-во льготников (по совокупности)
      if trest_ is not null then
        --ѕо трестам
        open prep_refcursor for
          select substr(g.name, 1, 160) as gr_name,
                 substr(to_char(s.id) || ' ' || s.name, 1, 45) as name,
                 sum(x.summa) as summa,
                 sum(x.cnt_main) as cnt_main,
                 sum(x.cnt) as cnt
            from xito_lg1 x, spk s, spk_gr g
           where x.lg_id = s.id
             and mg between mg_ and mg1_
             and x.trest = trest_
             and s.gr_id = g.id
           group by g.id,
                    s.id,
                    substr(g.name, 1, 160),
                    substr(to_char(s.id) || ' ' || s.name, 1, 45)
           order by g.id, s.id;
      elsif reu_ is not null then
        --ѕо –Ё”
        open prep_refcursor for
          select substr(g.name, 1, 160) as gr_name,
                 substr(to_char(s.id) || ' ' || s.name, 1, 45) as name,
                 sum(x.summa) as summa,
                 sum(x.cnt_main) as cnt_main,
                 sum(x.cnt) as cnt
            from xito_lg1 x, spk s, spk_gr g
           where x.lg_id = s.id
             and mg between mg_ and mg1_
             and x.reu = reu_
             and s.gr_id = g.id
           group by g.id,
                    s.id,
                    substr(g.name, 1, 160),
                    substr(to_char(s.id) || ' ' || s.name, 1, 45)
           order by g.id, s.id;
      elsif houses_ is not null then
        --ѕо домам
        open prep_refcursor for
          select substr(g.name, 1, 160) as gr_name,
                 substr(to_char(s.id) || ' ' || s.name, 1, 45) as name,
                 sum(x.summa) as summa,
                 sum(x.cnt_main) as cnt_main,
                 sum(x.cnt) as cnt
            from xito_lg1 x, spk s, spk_gr g
           where x.lg_id = s.id
             and mg between mg_ and mg1_
             and exists (select *
                    from list_choices l
                   where l.reu = x.reu
                     and l.kul = x.kul
                     and l.nd = x.nd
                     and l.sel = 0)
             and s.gr_id = g.id
           group by g.id,
                    s.id,
                    substr(g.name, 1, 160),
                    substr(to_char(s.id) || ' ' || s.name, 1, 45)
           order by g.id, s.id;
      else
        --ѕо всем ∆Ёќ
        open prep_refcursor for
          select substr(g.name, 1, 160) as gr_name,
                 substr(to_char(s.id) || ' ' || s.name, 1, 45) as name,
                 sum(x.summa) as summa,
                 sum(x.cnt_main) as cnt_main,
                 sum(x.cnt) as cnt
            from xito_lg1 x, spk s, spk_gr g
           where x.lg_id = s.id
             and mg between mg_ and mg1_
             and s.gr_id = g.id
           group by g.id,
                    s.id,
                    substr(g.name, 1, 160),
                    substr(to_char(s.id) || ' ' || s.name, 1, 45)
           order by g.id, s.id;
      end if;
    elsif var_ = 4 then
      --¬озмещение, кол-во льготников (»“ќ√» по совокупности)
      if trest_ is not null then
        --ѕо трестам
        open prep_refcursor for
          select substr(u.nm1, 1, 25) as nm1,
                 sum(x.summa) as summa,
                 sum(x.cnt_main) as cnt_main,
                 sum(x.cnt) as cnt
            from xito_lg2 x, uslm u
           where x.uslm_id = u.uslm
             and mg between mg_ and mg1_
             and x.trest = trest_
           group by substr(u.nm1, 1, 25);
      elsif reu_ is not null then
        --ѕо –Ё”
        open prep_refcursor for
          select substr(u.nm1, 1, 25) as nm1,
                 sum(x.summa) as summa,
                 sum(x.cnt_main) as cnt_main,
                 sum(x.cnt) as cnt
            from xito_lg2 x, uslm u
           where x.uslm_id = u.uslm
             and mg between mg_ and mg1_
             and x.reu = reu_
           group by substr(u.nm1, 1, 25);
      elsif houses_ is not null then
        --ѕо ƒомам
        open prep_refcursor for
          select substr(u.nm1, 1, 25) as nm1,
                 sum(x.summa) as summa,
                 sum(x.cnt_main) as cnt_main,
                 sum(x.cnt) as cnt
            from xito_lg2 x, uslm u
           where x.uslm_id = u.uslm
             and mg between mg_ and mg1_
             and exists (select *
                    from list_choices l
                   where l.reu = x.reu
                     and l.kul = x.kul
                     and l.nd = x.nd
                     and l.sel = 0)
           group by substr(u.nm1, 1, 25);
      else
        --ѕо всем ∆Ёќ
        open prep_refcursor for
          select substr(u.nm1, 1, 25) as nm1,
                 sum(x.summa) as summa,
                 sum(x.cnt_main) as cnt_main,
                 sum(x.cnt) as cnt
            from (select reu,
                         trest,
                         kul,
                         nd,
                         uslm_id,
                         lg_id,
                         mg,
                         sum(summa) as summa,
                         max(cnt_main) as cnt_main,
                         max(cnt) as cnt
                    from xito_lg2
                   group by reu, trest, kul, nd, uslm_id, lg_id, mg) x,
                 uslm u
           where x.uslm_id = u.uslm
             and mg between mg_ and mg1_
           group by substr(u.nm1, 1, 25);
      end if;
    end if;
  end report_lg_usl_org;
*/




  PROCEDURE report_bank(var_           IN NUMBER,
                        dat_           IN XITO5.dat%TYPE,
                        dat1_          IN XITO5.dat%TYPE,
                        mg_            IN XITO5.mg%TYPE,
                        mg1_           IN XITO5.mg%TYPE,
                        prep_refcursor OUT rep_refcursor) IS
    reu_  CONSTANT CHAR(2) := '90'; --Id Ѕанковского компьютера
    oper_ CONSTANT CHAR(2) := '39'; --Id Ѕанковского компьютера
  BEGIN

    IF mg_ IS NOT NULL AND mg1_ IS NOT NULL THEN
      IF var_ = 0 THEN
        --ќплата банка без детских пл., включа€ пеню
        OPEN prep_refcursor FOR
          SELECT SUM(x.ska + x.pn) AS summa, s.name_tr
            FROM XITO5_ x, S_REU_TREST s
           WHERE x.mg BETWEEN mg_ AND mg1_
             AND x.OPER NOT IN (oper_)
             AND x.from_reu = reu_
             AND x.reu = s.reu AND x.trest NOT IN ('04','17') --без кировского (и мупа кировского)
           GROUP BY s.trest, s.name_tr
           ORDER BY s.trest;
      ELSIF var_ = 1 THEN
        --ќплата банка (включа€ детские площадки, по дн€м)
        OPEN prep_refcursor FOR
          SELECT SUM(x.ska) AS summa, SUM(x.pn) AS penya, x.dat
            FROM XITO5_ x, S_REU_TREST s
           WHERE TO_CHAR(x.dat, 'YYYYMM') BETWEEN mg_ AND mg1_
             AND x.from_reu = reu_ AND x.trest NOT IN ('04','17') --без кировского (и мупа кировского)
             AND x.reu = s.reu
           GROUP BY x.dat
           ORDER BY x.dat;
      END IF;
    ELSE
      IF var_ = 0 THEN
        --ќплата банка без детских пл., включа€ пеню
        OPEN prep_refcursor FOR
          SELECT SUM(x.ska + x.pn) AS summa, s.name_tr
            FROM XITO5_ x, S_REU_TREST s
           WHERE x.dat BETWEEN dat_ AND dat1_
             AND x.OPER NOT IN (oper_)
             AND x.from_reu = reu_ AND x.trest NOT IN ('04','17') --без кировского (и мупа кировского)
             AND x.reu = s.reu
           GROUP BY s.trest, s.name_tr
           ORDER BY s.trest;
      ELSIF var_ = 1 THEN
        --ќплата банка (включа€ детские площадки, по дн€м)
        OPEN prep_refcursor FOR
          SELECT SUM(x.ska) AS summa, SUM(x.pn) AS penya, x.dat
            FROM XITO5_ x, S_REU_TREST s
           WHERE x.dat BETWEEN dat_ AND dat1_
             AND x.from_reu = reu_ AND x.trest NOT IN ('04','17') --без кировского (и мупа кировского)
             AND x.reu = s.reu
           GROUP BY x.dat
           ORDER BY x.dat;
      END IF;
    END IF;
  END;



  PROCEDURE list_choice(clr_           IN NUMBER,
                        prep_refcursor IN OUT rep_refcursor) IS
    --¬ременна€ таблица дл€ выбора домов
  BEGIN
    IF clr_ = 1 THEN
      DELETE FROM LIST_CHOICES;
      INSERT INTO LIST_CHOICES t
        (reu, kul, nd, uch, house_id, sel)
        SELECT h.reu, h.kul, h.nd, h.uch, h.id, 1
          FROM c_houses h, v_permissions_reu p
         WHERE h.reu = p.reu;
    END IF;
    OPEN prep_refcursor FOR 'SELECT t.rowid, t.reu, upper(LTRIM(t.nd, ''0'')) AS nd,
      uch, upper(s.name) as name, t.sel
           FROM LIST_CHOICES t, SPUL s
           WHERE t.kul=s.id
           ORDER BY t.sel, s.name, t.nd, t.reu, uch ';
  END;

  PROCEDURE list_choice_set(set_ IN NUMBER) IS
  BEGIN
    UPDATE LIST_CHOICES SET sel = set_;
  END;

  PROCEDURE list_choice_uch(clr_           IN NUMBER,
                            prep_refcursor IN OUT rep_refcursor) IS
    --¬ременна€ таблица дл€ выбора участков
  BEGIN
  --не работает в принципе
    IF clr_ = 1 THEN
      DELETE FROM LIST_CHOICES_UCH;
      INSERT INTO LIST_CHOICES_UCH t
        (reu, uch, sel)
        SELECT DISTINCT null as reu, null as uch, 1
          FROM v_permissions_reu p
         WHERE p.reu is null;
    END IF;
    OPEN prep_refcursor FOR 'SELECT t.rowid, t.reu, t.uch, t.sel
           FROM LIST_CHOICES_UCH t
           ORDER BY t.reu, t.uch ';
  END;

  PROCEDURE list_choice_set_uch(set_ IN NUMBER) IS
  BEGIN
    UPDATE LIST_CHOICES_UCH SET sel = set_;
  END;

  PROCEDURE list_choice_usl(clr_           IN NUMBER,
                            prep_refcursor IN OUT rep_refcursor) IS
    --¬ременна€ таблица дл€ выбора услуг
  BEGIN
    IF clr_ = 1 THEN
      DELETE FROM LIST_CHOICES_USL;
      INSERT INTO LIST_CHOICES_USL t
        (USLM, sel)
        SELECT r.USLM, 1 FROM USLM r;
    END IF;
    OPEN prep_refcursor FOR 'SELECT t.rowid,r.nm1, t.sel,r.uslm
           FROM LIST_CHOICES_USL t, USLM r
           WHERE t.USLM=r.USLM
           ORDER BY r.USLM';
  END list_choice_usl;

  PROCEDURE list_choice_usl_set(set_ IN NUMBER) IS
  BEGIN
    UPDATE LIST_CHOICES_USL SET sel = set_;
  END list_choice_usl_set;

  PROCEDURE list_choice_reu(clr_           IN NUMBER,
                            prep_refcursor IN OUT rep_refcursor) IS
    --¬ременна€ таблица дл€ выбора услуг
  BEGIN
    IF clr_ = 1 THEN
      delete from list_choices_reu;
      insert into list_choices_reu t
        (reu, sel)
        select t.reu, 1 from s_reu_trest t;
    END IF;
    OPEN prep_refcursor FOR 'select t.rowid, r.name_reu, t.sel, r.reu
           from list_choices_reu t, s_reu_trest r
           where t.reu=r.reu
           order by r.reu';
  END list_choice_reu;

  procedure list_choice_hs_set(set_ in number) is
  begin
    update list_choices_hs set sel = set_;
  end;

  procedure list_choice_hs(clr_           in number,
                        prep_refcursor in out rep_refcursor) is
    --¬ременна€ таблица дл€ выбора домов
  begin
    if clr_ = 1 then
      delete from list_choices_hs;
      insert into list_choices_hs t
        (kul, nd, sel)
        select distinct h.kul, h.nd, 1
          from kart h, v_permissions_reu p
         where h.reu = p.reu;
    end if;
    open prep_refcursor for 'SELECT t.rowid, upper(LTRIM(t.nd, ''0'')) AS nd,
         upper(s.name) as name,
         upper(s.name)||'',''||upper(LTRIM(t.nd, ''0'')) as adr,
         t.sel
           FROM list_choices_hs t, spul s
           WHERE t.kul=s.id
           ORDER BY t.sel, s.name, t.nd';
  end;

  PROCEDURE del_day_payments(mg_ IN VARCHAR2) IS
    --”даление текущих платежей по концу мес€ца
    stmt VARCHAR2(2000);
  BEGIN
    stmt := 'DELETE FROM period_reports  WHERE mg IS null AND TO_CHAR(dat, ''YYYYMM'')=:mg_';
    EXECUTE IMMEDIATE stmt
      USING mg_;
    stmt := 'DELETE FROM xito5   WHERE mg IS null AND TO_CHAR(dat, ''YYYYMM'')=:mg_';
    EXECUTE IMMEDIATE stmt
      USING mg_;
    stmt := 'DELETE FROM xito5_  WHERE mg IS null AND TO_CHAR(dat, ''YYYYMM'')=:mg_';
    EXECUTE IMMEDIATE stmt
      USING mg_;
    stmt := 'DELETE FROM xxito10 WHERE mg IS null AND TO_CHAR(dat, ''YYYYMM'')=:mg_';
    EXECUTE IMMEDIATE stmt
      USING mg_;
    stmt := 'DELETE FROM xxito11 WHERE mg IS null AND TO_CHAR(dat, ''YYYYMM'')=:mg_';
    EXECUTE IMMEDIATE stmt
      USING mg_;
    stmt := 'DELETE FROM xxito3  WHERE mg IS null AND TO_CHAR(dat, ''YYYYMM'')=:mg_';
    EXECUTE IMMEDIATE stmt
      USING mg_;
    COMMIT;
  END del_day_payments;

  PROCEDURE check_day_hints(cnt_ OUT NUMBER)
  --ѕроверка прочитан ли совет дн€.
   IS
    CURSOR c IS
      SELECT * FROM DAY_HINTS WHERE user_name = USER;
    record_ c%ROWTYPE;
  BEGIN
    OPEN c;
    FETCH c
      INTO record_;
    IF c%rowcount = 0 THEN
      INSERT INTO DAY_HINTS (user_name, dat) VALUES (USER, SYSDATE);
      COMMIT;
      CLOSE c;
      cnt_ := 0;
      RETURN;
    END IF;
    UPDATE DAY_HINTS SET dat = SYSDATE WHERE user_name = USER;
    COMMIT;
    CLOSE c;
    cnt_ := 1;
    RETURN;
  END check_day_hints;

END generator;
/

prompt
prompt Creating package body GEN_PREP
prompt ==============================
prompt
create or replace package body scott.GEN_PREP is



--распределение NPG по сальдо-3 вариант
procedure dist_npg_on_saldo3(p_lsk in scott.kart.lsk%type, p_round in number,
   p_mg in varchar2, p_mg_back in varchar2, p_i out number, p_i1 out number, p_err out number) is
l_summa number;
l_summa1 number;
l_summa2 number;
l_summa3 number;
l_enter number;
l_enter2 number;
l_found_id number;
l_lsk scott.kart.lsk%type;
l_id number;
i number;
i1 number;

cursor c_charge is
  select rec_saldo(b.mg, b.usl, b.org, 0, null, null) -- <--приводим к типу записи!!!
  from (
  select distinct a.mg, n.usl, n.org
           from scott.arch_charges a, a_nabor n
                where a.lsk=n.lsk and a.usl_id=n.usl and a.mg=n.mg
                and a.lsk=p_lsk
           ) b;
t_charge tab_saldo:= tab_saldo();

cursor c_deb is
    select rec_saldo(t.mg, null, null, t.summa, t.summa, 0)
     from scott.v_chargepay t
     where t.lsk=p_lsk and t.period=p_mg_back;
t_deb tab_saldo:= tab_saldo();

cursor c_inprep_sal is
  select rec_saldo(null, t.usl, t.org, t.summa, null, null)
     from scott.saldo_usl t
    where t.mg=p_mg
    and t.lsk=p_lsk
    and t.summa <> 0
    and exists (select * from table(t_charge) a--где есть начисление по данной орг и услуге (вообще есть)
               where a.org=t.org
               and a.usl=t.usl);
t_inprep_sal tab_saldo:= tab_saldo();
t_prep_saldo tab_saldo:= tab_saldo();

r_prep_saldo rec_saldo;


procedure load_prep_sal is
begin
  --почистить коллекции
  t_prep_saldo.Delete;
  t_charge.Delete;
  t_inprep_sal.Delete;

  --загрузить задолжности по мес€цам
  open c_deb;
  fetch c_deb bulk collect into t_deb;
  close c_deb;


  --загрузить начислени€ по мес€цам
  open c_charge;
  fetch c_charge bulk collect into t_charge;
  close c_charge;

  --загрузить вход€щее сальдо
  open c_inprep_sal;
  fetch c_inprep_sal bulk collect into t_inprep_sal;
  close c_inprep_sal;
end;

function find(t_tmp in tab_saldo,
   p_mg in varchar2, p_usl in varchar2, p_org number) return number is
 l_ret number;
begin
  --поиск элемента коллекции
  l_ret:=0;
  if t_tmp.count > 0 then
    for i in t_tmp.FIRST..t_tmp.LAST
    loop
       if p_mg is not null and p_usl is not null and p_org is not null then
         if t_tmp(i).mg=p_mg and t_tmp(i).usl=p_usl and t_tmp(i).org=p_org then
           l_ret:=i;
         end if;
       elsif p_mg is not null and p_usl is null and p_org is null then
         if t_tmp(i).mg=p_mg then
           l_ret:=i;
         end if;
       elsif p_mg is null and p_usl is not null and p_org is not null then
         if t_tmp(i).usl=p_usl and t_tmp(i).org=p_org then
           l_ret:=i;
         end if;
       end if;
    end loop;
  end if;
  return l_ret;
end;

function find2(t_tmp in tab_saldo,
   p_usl in varchar2, p_org number, p_usl2 in varchar2, p_org2 number) return number is
 l_ret number;
begin
  --поиск организации и услуги, котора€ имеет пару с тем же периодом, только с другим кодом usl+org
  l_ret:=0;
  if t_tmp.count > 0 then
    for i in t_tmp.FIRST..t_tmp.LAST
    loop
       if t_tmp(i).usl = p_usl2 and t_tmp(i).org = p_org2 and find(t_tmp, t_tmp(i).mg, p_usl, p_org) <> 0  then
         l_ret:=i;
       end if;
    end loop;
  end if;
  return l_ret;
end;



--       if t_tmp(i).mg=p_mg and (t_tmp(i).usl <> p_usl or t_tmp(i).org <> p_org) then

--0-задолжность по мес€цам
--1-вход€щее сальдо
--2-корректировки сальдо
--3-начисление по мес€цам
--4-временные суммы
begin
l_lsk:='x';

--delete from core_gen.temp_prep_saldo t where t.lsk=p_lsk;

  if l_lsk<>p_lsk then
  --первоначальна€ загрузка данных по лиц.сч.
    l_lsk:=p_lsk;
    select temp_prep_id.nextval into l_id from dual;
    load_prep_sal;
  end if;

  i1:=0;
  l_enter:=1;
  l_enter2:=0;
  while l_enter=1 and i1<=10000
  loop
  i1:=i1+1;
  l_enter:=0;
  for c3 in (
      select t.summa, t.usl, t.org,
             count(*) over (partition by 0) as cnt
              from
              table(t_inprep_sal) t
              where t.summa <> 0
              order by abs(t.summa) --начинать распределение от самых минимальных значений
      )
  loop
  for c2 in (select t.mg, t.summa, count(*) over (partition by 0) as cnt,
       sign(t.summa)*min(abs(t.summa)) over (partition by 0) as min_summ
     from table(t_deb) t
     where (exists (select * from table(t_charge) a--где есть начисление по данной орг и услуге в данном периоде
               where a.org=c3.org
               and a.usl=c3.usl
               and a.mg=t.mg)
            or (t.mg >= p_mg and t.summa<0)) --или будущие периоды, но только переплата по ним

     and abs(t.summa) >= 0.01
     )
  loop
      l_enter:=1;
      l_enter2:=1;

      l_summa1:=c3.summa/c2.cnt;
      l_summa2:=c2.min_summ/c3.cnt;

      if sign(l_summa1) < 0 and sign(l_summa2) < 0 then
        if abs(l_summa1) >= abs(l_summa2) then
          l_summa:=l_summa2;
        else
          l_summa:=l_summa1;
        end if;
      else
        if l_summa1 >= l_summa2 then
          l_summa:=l_summa2;
        else
          l_summa:=l_summa1;
        end if;
      end if;

      --только с 12 версии определ€ть Nested table можно в рамках пакета (и работать с ним)
      l_found_id:=find(t_inprep_sal, null, c3.usl, c3.org);

      if l_found_id = 0 then
         Raise_application_error(-20000, 'Ќе найдена услуга+орг в Nested table "t_inprep_sal":'||c3.usl||'-'||c3.org);
      else
         t_inprep_sal(l_found_id).summa:=nvl(t_inprep_sal(l_found_id).summa,0)-l_summa;
      end if;

      --корректировка сумм по периодам (из NPG)
      l_found_id:=find(t_deb, c2.mg, null, null);

      if l_found_id = 0 then
         Raise_application_error(-20000, 'Ќе найден период в Nested table "t_deb":'||c2.mg);
      else
           t_deb(l_found_id).summa:=nvl(t_deb(l_found_id).summa,0)-l_summa;
           t_deb(l_found_id).summa2:=nvl(t_deb(l_found_id).summa2,0)+l_summa;

            --итоговое сальдо
            l_found_id:=find(t_prep_saldo, c2.mg, c3.usl, c3.org);

            if l_found_id = 0 then
               t_prep_saldo.extend;

               r_prep_saldo:= rec_saldo(c2.mg, c3.usl, c3.org, l_summa, null, null);
               t_prep_saldo(t_prep_saldo.LAST):=r_prep_saldo;
            else
               t_prep_saldo(l_found_id).summa:=nvl(t_prep_saldo(l_found_id).summa,0)+l_summa;
            end if;
      end if;


  end loop;

  end loop;

end loop;

p_i:=i1;

--выполнить округление по периодам и выйти из распределенеи€
--begin
if l_enter2 <> 0 then
  for i in t_prep_saldo.FIRST..t_prep_saldo.LAST
  loop
  t_prep_saldo(i).summa:=round(t_prep_saldo(i).summa,2);
  end loop;
end if;
--exception when others then
--  dbms_output.put_line('ќшибка в лиц.счете:'||p_lsk);
--  Raise;
--end;

if l_enter2 <> 0 and nvl(p_round,0) =1 then
--если было что распределено и назначено округление
  for c in (select nvl(a.mg, b.mg) as mg,
    nvl(a.summa,0)-nvl(b.summa,0) as diff from
    (select t.mg, t.summa from
    SCOTT.v_chargepay t where t.lsk=p_lsk
    ) a
    full outer join
    (select t.mg, sum(round(summa,2)) as summa
    from table(t_prep_saldo) t
    group by t.mg) b
    on a.mg=b.mg
    where nvl(a.summa,0)<>nvl(b.summa,0))
  loop
  l_summa:=c.diff;

  for c2 in (select nvl(a.mg, b.mg) as mg,
      nvl(a.summa,0)-nvl(b.summa,0) as diff from
      (select t.mg, t.summa from
      SCOTT.v_chargepay t where t.lsk=p_lsk
      ) a
      full outer join
      (select t.mg, sum(round(summa,2)) as summa
      from table(t_prep_saldo) t
      group by t.mg) b
      on a.mg=b.mg
      where nvl(a.summa,0)<>nvl(b.summa,0)
      and sign(nvl(a.summa,0)-nvl(b.summa,0)) <> sign(c.diff)
      )
  loop
  --перенести на сумму с обратным знаком
    l_summa2:=0;
    l_found_id:=find(t_prep_saldo, c.mg, null, null);
    if abs(l_summa) > abs(c2.diff) then
      l_summa2:=c2.diff;
    else
      l_summa2:=l_summa;
    end if;
    l_summa:=l_summa-l_summa2;
    t_prep_saldo(l_found_id).summa:=t_prep_saldo(l_found_id).summa+l_summa2;
  end loop;
  if l_summa <> 0 then
  --невозможно перенести на сумму с обратным знаком
  --просто сн€ть(добавить) еЄ
  l_found_id:=find(t_prep_saldo, c.mg, null, null);
  if l_found_id = 0 then
    p_err:=2;
    insert into prep_sal(id, lsk, p_iter, p_iter1, p_err)
     values (l_id, p_lsk, p_i, p_i1, p_err);
    return;
  end if;
  l_summa2:=l_summa;
  t_prep_saldo(l_found_id).summa:=t_prep_saldo(l_found_id).summa+l_summa2;
  end if;
  end loop;
  --выполнить округление по услугам и орг
  l_enter:=1;
  i1:=0;
  while l_enter=1 and i1<=100
  loop
  i1:=i1+1;
  l_enter:=0;
  for c in (select nvl(a.usl,b.usl) as usl,
             nvl(a.org, b.org) as org, b.mg,
             nvl(a.summa,0)-nvl(b.summa,0) as diff from
            (select * from
            SCOTT.saldo_usl t where t.lsk=p_lsk
            and t.mg=p_mg
            order by usl, org) a
            full outer join
            (select usl, org, max(mg) as mg, sum(summa) as summa
            from table(t_prep_saldo) t
            group by usl, org
            order by usl, org) b
            on a.usl=b.usl and a.org=b.org
            where nvl(a.summa,0)<>nvl(b.summa,0)
            )
  loop
  l_enter:=1;
  l_summa:=c.diff;
    for c2 in (select nvl(a.usl,b.usl) as usl,
               nvl(a.org, b.org) as org,
               nvl(a.summa,0)-nvl(b.summa,0) as diff from
              (select * from
              SCOTT.saldo_usl t where t.lsk=p_lsk
              and t.mg=p_mg
              order by usl, org) a
              full outer join
              (select usl, org, sum(summa) as summa
              from table(t_prep_saldo) t
              group by usl, org
              order by usl, org) b
              on a.usl=b.usl and a.org=b.org
              where sign(nvl(a.summa,0)-nvl(b.summa,0)) <> sign(c.diff)
              and nvl(a.summa,0)<>nvl(b.summa,0)
              )
    loop
    --перенести на сумму с обратным знаком, в том же периоде, на другую usl+org
      l_summa2:=0;
      if abs(l_summa) > abs(c2.diff) then
        l_summa2:=sign(c.diff)*abs(c2.diff);
      else
        l_summa2:=l_summa;
      end if;
      --снимаем
      l_found_id:=find2(t_prep_saldo, c.usl, c.org, c2.usl, c2.org);
      if l_found_id = 0 then
        --не округл€ть дальше, так как не найдена usl+org дл€ переноса
        p_err:=1;
        insert into prep_sal(id, lsk, p_iter, p_iter1, p_err)
         values (l_id, p_lsk, p_i, p_i1, p_err);
        return;
      end if;
      t_prep_saldo(l_found_id).summa:=t_prep_saldo(l_found_id).summa-l_summa2;

      --ставим
      l_found_id:=find(t_prep_saldo, c.mg, c.usl, c.org);
      t_prep_saldo(l_found_id).summa:=t_prep_saldo(l_found_id).summa+l_summa2;

      l_summa:=l_summa-l_summa2;
      if l_summa = 0 then
        exit;
      end if;
    end loop;
  end loop;
  end loop;

  p_i1:=i1;
end if;
--выгрузить итоговое сальдо
p_err:=0;
insert into prep_sal(id, lsk, p_iter, p_iter1, p_err)
 values (l_id, p_lsk, p_i, p_i1, p_err);

for i in t_prep_saldo.FIRST..t_prep_saldo.LAST loop
  insert into prep_sal_det(fk_prep_sal, lsk, usl, org, summa, mg)
         values (l_id, p_lsk, t_prep_saldo(i).usl, t_prep_saldo(i).org, t_prep_saldo(i).summa, t_prep_saldo(i).mg);
end loop;

end dist_npg_on_saldo3;


end GEN_PREP;
/

prompt
prompt Creating package body GEN_STAT
prompt ==============================
prompt
create or replace package body scott.gen_stat is

procedure gen_stat_usl(dat_ in date) is
    --—татистика по услугам
    mg_ params.period%type;
    time_ date;
 begin
 time_ := sysdate;
 --заполн€ем временную таблицу дл€ расчета услуг по kart
 select p.period into mg_ from params p;
    if dat_ is not null then
      delete from statistics_lsk a where a.dat is not null;
      delete from statistics a where a.dat is not null;
    else
      gen.trunc_part('statistics_lsk', mg_);
      gen.trunc_part('statistics', mg_);
    end if;
--‘ормируем статистику с детализацией по лицевым счетам
insert into statistics_lsk
    (lsk, reu, kul, nd, kw, usl, kpr, is_empt, kpr_ot, kpr_wr, klsk, cnt, status,
     psch, sch, org, val_group, val_group2, cnt_subs, uch, mg, dat, limit, cena, fk_tp, opl, is_vol)
   select k.lsk, k.reu, k.kul, k.nd, k.kw, n.usl, a.kpr,
     case when u.is_iter = 1 and nvl(a.kpr,0)= 0 then 1  --ѕќƒ”ћј“№!
          when u.is_iter = 1 and nvl(a.kpr,0)<> 0 then 0
          when nvl(u.is_iter,0) = 0 and nvl(k.kpr,0)<> 0 then 0
          else 1 end as is_empt,
       a.kpro as kpr_ot,
       a.kprz as kpr_wr,
       decode(lag(k.lsk || u.uslm, 1) over(order by k.lsk, u.uslm, nvl(a.kpr,0) desc, nvl(a.cnt,0) desc), k.lsk || u.uslm, null, 1) as klsk,
       a.cnt,
       k.status,
       decode(k.psch, 9, 1, 8, 2, 0) as psch,
       nvl(a.sch,-1) as sch, --сделал -1, так как иногда показывает в ќтоплении NULL, или "норматив" а надо "нет", ред. 07.12.2105
       n.org,
       case when n.fk_tarif is not null then b.cena else round(n.koeff, 6) end as val_group,
       round(n.norm, 6) as val_group2, null as cnt_subs, c.uch,
       decode(dat_, null, mg_, null) as mg, dat_, n.limit,
       a.cena, k.fk_tp, 
       decode(lag(k.lsk || u.uslm, 1) over(order by k.lsk, u.uslm, nvl(a.kpr,0) desc, nvl(a.cnt,0) desc), k.lsk || u.uslm, null, k.opl) as opl,
       case when nvl(a.cnt,0) <> 0 then '≈сть' else 'Ќет' end as is_vol
        from arch_kart k, a_nabor n, a_houses c, usl u,
             (select s.* from spr_tarif_prices s where mg_ between s.mg1 and s.mg2) b,
             (select c.lsk, c.usl, nvl(c.sch,0) as sch,
              sum(c.kpr) as kpr, sum(c.kprz) as kprz, sum(c.kpro) as kpro, sum(c.test_opl) as cnt,
              max(c.test_cena) as cena
              from a_charge c
             where c.type = 1 and c.mg=mg_
              -- and c.test_opl <> 0
             group by c.lsk, c.usl, c.sch) a
      where k.lsk=n.lsk
      and n.lsk=a.lsk(+)
      and n.usl=a.usl(+)
      and k.mg=mg_
      and n.mg=mg_
      and c.mg=mg_
      and k.house_id=c.id
      and n.fk_tarif = b.fk_tarif(+)
      and n.usl=u.usl;

    if dat_ is not null then
    --итоговое кол-во лицевых, проживающих, без учета услуг
    insert into statistics_lsk
      (reu, kul, nd, kw, fio, kpr, is_empt, kpr_ot, kpr_wr, klsk, cnt, status, psch,
       sch, org, val_group, cnt_lg, cnt_subs, uch, mg, dat, cnt_room, fk_tp, opl, is_vol)
      select k.reu, k.kul, k.nd, k.kw, k.fio, k.kpr, null as is_empt, k.kpr_ot, k.kpr_wr,
             1 as klsk, k.opl as cnt, k.status, decode(k.psch,9,1,8,2,0) as psch,
              null as sch, null as org, null as val_group,
             ki as cnt_lg, null as cnt_subs, null as uch, null as mg, dat_ as dat,
             k.komn, k.fk_tp, k.opl, '≈сть' as is_vol
        from arch_kart k where k.mg=mg_;

      insert into statistics
        (reu, kul, nd, usl, kpr, is_empt, kpr_ot, kpr_wr, klsk, cnt, cena, status, psch,
         sch, org, val_group, val_group2, cnt_lg, cnt_subs, uch, mg, dat, fk_tp, opl, is_vol)
        select reu, kul, nd, usl, sum(kpr), s.is_empt, sum(kpr_ot), sum(kpr_wr),
               sum(klsk), sum(cnt), cena, status, psch, sch, org, val_group, val_group2,
               sum(cnt_lg), sum(cnt_subs), uch, mg, dat, s.fk_tp, sum(s.opl) as opl, s.is_vol
          from statistics_lsk s
         where dat = dat_ and /*s.uslm is null and ред.26.06.13*/ s.usl is not null
         group by reu, kul, nd, usl, status, psch, sch, cena, org, val_group, val_group2, uch,
                  mg, dat, s.is_empt, s.fk_tp, s.is_vol;

      --итоговое кол-во лицевых, проживающих
      insert into statistics
        (reu, kul, nd, kpr, is_empt, kpr_ot, kpr_wr, klsk, cnt, status, psch,
         sch, org, val_group, cnt_lg, cnt_subs, uch, mg, dat, cnt_room, fk_tp, opl, is_vol)
        select k.reu, k.kul, k.nd, sum(k.kpr), null as is_empt, sum(k.kpr_ot), sum(k.kpr_wr),
               count(*) as klsk, sum(k.opl) as cnt, k.status, decode(k.psch,9,1,8,2,0) as psch,
                null as sch, null as org, null as val_group,
               sum(ki) as cnt_lg, null as cnt_subs, null as uch, null as mg, dat_ as dat,
               sum(k.komn), k.fk_tp, sum(k.opl) as opl, '≈сть' as is_vol
          from arch_kart k where k.mg=mg_
         group by k.reu, k.kul, k.nd, k.status, decode(k.psch,9,1,8,2,0), dat_, k.fk_tp;

    else
    --за мес€ц
        insert into statistics_lsk
      (reu, kul, nd, kw, fio, kpr, is_empt, kpr_ot, kpr_wr, klsk, cnt, status, psch,
       sch, org, val_group, cnt_lg, cnt_subs, uch, mg, dat, cnt_room, fk_tp, opl, is_vol)
      select k.reu, k.kul, k.nd, k.kw, k.fio, k.kpr, null as is_empt, k.kpr_ot, k.kpr_wr,
             1 as klsk, k.opl as cnt, k.status, decode(k.psch,9,1,8,2,0) as psch,
              null as sch, null as org, null as val_group,
             ki as cnt_lg, null as cnt_subs, null as uch, mg_ as mg, null as dat,
             k.komn, k.fk_tp, k.opl, '≈сть' as is_vol
        from arch_kart k where k.mg=mg_;

      insert into statistics
        (reu, kul, nd, usl, kpr, is_empt, kpr_ot, kpr_wr, klsk, cnt, cena, status, psch,
         sch, org, val_group, val_group2, cnt_lg, cnt_subs, uch, mg, dat, fk_tp, opl, is_vol)
        select reu, kul, nd, usl, sum(kpr), s.is_empt, sum(kpr_ot), sum(kpr_wr),
               sum(klsk), sum(cnt), cena, status, psch, sch, org, val_group, val_group2,
               sum(cnt_lg), sum(cnt_subs), uch, mg, dat, s.fk_tp, sum(s.opl) as opl, s.is_vol
          from statistics_lsk s
         where s.mg = ''||mg_||'' and /*s.uslm is null and ред.26.06.13*/ s.usl is not null
         group by reu, kul, nd, usl, status, psch, sch, org, cena, val_group, val_group2, uch,
                  mg, dat, s.is_empt, s.fk_tp, s.is_vol;
      --итоговое кол-во лицевых, проживающих
      insert into statistics
        (reu, kul, nd, kpr, is_empt, kpr_ot, kpr_wr, klsk, cnt, status, psch,
         sch, org, val_group, cnt_lg, cnt_subs, uch, mg, dat, cnt_room, fk_tp, opl, is_vol)
        select k.reu, k.kul, k.nd, sum(k.kpr), null as is_empt, sum(k.kpr_ot), sum(k.kpr_wr),
               count(*) as klsk, sum(k.opl) as cnt, k.status, decode(k.psch,9,1,8,2,0) as psch,
                null as sch, null as org, null as val_group,
               sum(ki) as cnt_lg, null as cnt_subs, null as uch, mg_ as mg, null as dat,
               sum(k.komn), k.fk_tp, sum(k.opl) as opl, '≈сть' as is_vol
          from arch_kart k where k.mg=mg_
         group by k.reu, k.kul, k.nd, k.status, decode(k.psch,9,1,8,2,0), mg_, k.fk_tp;
    end if;

    --‘ормируем итоговую таблицу статистики без детализации
 if dat_ is not null then
  delete from statistics_trest b where b.dat is not null;
  insert into statistics_trest
    (usl, reu, cnt, cena, klsk, kpr, is_empt, kpr_ot, kpr_wr, org, val_group, val_group2, status, psch,
     sch, cnt_lg, cnt_subs, uch, mg, dat, fk_tp, opl, is_vol)
    select s.usl, s.reu, sum(s.cnt), s.cena, sum(s.klsk), sum(s.kpr), s.is_empt, sum(s.kpr_ot),
           sum(s.kpr_wr), s.org, val_group, val_group2, s.status, s.psch, s.sch,
           sum(s.cnt_lg), sum(s.cnt_subs), s.uch, s.mg, s.dat, s.fk_tp, sum(s.opl) as opl, s.is_vol
      from statistics s
     where s.dat = dat_ /*and s.uslm is null*/ and s.usl is not null
     group by s.reu, s.usl, s.org, s.cena, val_group, val_group2, s.status, s.psch, s.sch, s.uch,
              s.mg, s.dat, s.is_empt, s.fk_tp, s.is_vol;
   --итоговое кол-во лицевых, проживающих
   insert into statistics_trest
        (reu, kpr, is_empt, kpr_ot, kpr_wr, klsk, cnt, status, psch,
         sch, org, val_group, cnt_lg, cnt_subs, uch, mg, dat, cnt_room, fk_tp, opl, is_vol)
        select k.reu, sum(k.kpr), null as is_empt, sum(k.kpr_ot), sum(k.kpr_wr),
               count(*) as klsk, sum(k.opl) as cnt, k.status, decode(k.psch,9,1,8,2,0) as psch,
                null as sch, null as org, null as val_group,
               sum(ki) as cnt_lg, null as cnt_subs, null as uch, null as mg, dat_ as dat,
               sum(k.komn), k.fk_tp, sum(k.opl) as opl, '≈сть' as is_vol
          from arch_kart k where k.mg=mg_
         group by k.reu, k.status, decode(k.psch,9,1,8,2,0), dat_, k.fk_tp;
 else
  delete from statistics_trest b
   where b.mg = mg_;
  insert into statistics_trest
    (usl, reu, cnt, cena, klsk, kpr, is_empt, kpr_ot, kpr_wr, org, val_group, val_group2, status, psch,
     sch, cnt_lg, cnt_subs, uch, mg, dat, fk_tp, opl, is_vol)
    select s.usl, s.reu, sum(s.cnt), s.cena, sum(s.klsk), sum(s.kpr), s.is_empt, sum(s.kpr_ot),
           sum(s.kpr_wr), s.org, val_group, val_group2, s.status, s.psch, s.sch,
           sum(s.cnt_lg), sum(s.cnt_subs), s.uch, s.mg, s.dat, s.fk_tp, sum(s.opl) as opl, s.is_vol
      from statistics s
     where s.mg = ''||mg_||'' and /*s.uslm is null and */s.usl is not null
     group by s.reu, s.usl, s.cena, val_group, val_group2, s.org, s.status, s.psch, s.sch, s.uch,
              s.mg, s.dat, s.is_empt, s.fk_tp, s.is_vol;
   --итоговое кол-во лицевых, проживающих
   insert into statistics_trest
        (reu, kpr, is_empt, kpr_ot, kpr_wr, klsk, cnt, status, psch,
         sch, org, val_group, cnt_lg, cnt_subs, uch, mg, dat, cnt_room, fk_tp, opl, is_vol)
        select k.reu, sum(k.kpr), null as is_empt, sum(k.kpr_ot), sum(k.kpr_wr),
               count(*) as klsk, sum(k.opl) as cnt, k.status, decode(k.psch,9,1,8,2,0) as psch,
                null as sch, null as org, null as val_group,
               sum(ki) as cnt_lg, null as cnt_subs, null as uch, mg_ as mg, null as dat,
               sum(k.komn), k.fk_tp, sum(k.opl) as opl, '≈сть' as is_vol
          from arch_kart k where k.mg=mg_
         group by k.reu, k.status, decode(k.psch,9,1,8,2,0), k.fk_tp;
 end if;

  if dat_ is null then
    logger.ins_period_rep('13', mg_, null, 0);
    logger.ins_period_rep('18', mg_, null, 0);
    logger.ins_period_rep('57', mg_, null, 0);
    logger.ins_period_rep('83', mg_, null, 0);
  else
    logger.ins_period_rep('13', null, dat_, 0);
    logger.ins_period_rep('18', null, dat_, 0);
    logger.ins_period_rep('57', null, dat_, 0);
    logger.ins_period_rep('83', null, dat_, 0);
  end if;
  commit;
  logger.log_(time_, 'gen_stat_usl ' || to_char(dat_, 'DDMMYYYY'));
end gen_stat_usl;

end gen_stat;
/

prompt
prompt Creating package body INIT
prompt ==========================
prompt
CREATE OR REPLACE PACKAGE BODY SCOTT.init IS

l_mg params.period%type;

PROCEDURE set_default_nkom is
cnt_ number;

begin

  select count(*) into cnt_ from c_comps t, t_user u, c_users_perm m,
    u_list l
    where u.id=m.user_id and m.fk_comp = t.nkom and u.cd=user
    and l.cd='доступ к компьютерам'
    and m.fk_perm_tp=l.id;

   if cnt_ = 1 then -- найдено по умолчанию не более 1 компьтера
     select t.nkom into ncomp_ from c_comps t, t_user u, c_users_perm m,
    u_list l
     where u.id=m.user_id and m.fk_comp = t.nkom and u.cd=user
      and l.cd='доступ к компьютерам'
      and m.fk_perm_tp=l.id;
   else
     ncomp_:=null; --необходимо пользователю выбрать какой комп.
   end if;
end;

PROCEDURE set_nkom(nkom_ in c_comps.nkom%type) is
begin
   ncomp_:= nkom_;
end;

FUNCTION get_role
  return t_role.name%type is
  role_name_ t_role.name%type;
begin
/* не нужно, делалось дл€ подомового учета, коммент от 09.12.2010
  begin
   select t.role_name into role_name_ from v_cur_usxrl t;
   exception
     when others then
      Raise_application_error(-20000,
        '¬нимание! ѕодключаемый пользователь не имеет зарегистрированный ролей в справочнике ролей');
   end;*/
   role_name_:=null;
   return role_name_;
end;

FUNCTION get_login_acc
 return number is
cnt_ number;
begin
 --входов в программу максимально допустимое в таблице пользователей
  begin
   select case when nvl(t.cnt_enters,0) = 1 and nvl(v1.cnt,0)=1 then 0
            when nvl(t.cnt_enters,0) > 1 and nvl(v.cnt,0)<=nvl(t.cnt_enters,0) then 0
            else 2 end as cnt into cnt_
    from (select count(*) as cnt from (select distinct (utl_inaddr.get_host_address(terminal))
          from sys.v_$session v
         where v.username = sys_context('USERENV', 'SESSION_USER'))) v,
         (select count(*) as cnt
          from sys.v_$session v
         where v.username = sys_context('USERENV', 'SESSION_USER')) v1,
         (select max(u.cnt_enters) as cnt_enters from t_user u where u.cd=user) t;
/*   select case when nvl(count(*),0) <= max(t.cnt_enters) then 0
          else 2
          end into cnt_
    from (select distinct (utl_inaddr.get_host_address(terminal))
          from sys.v_$session v
         where v.username = sys_context('USERENV', 'SESSION_USER')) v,
         (select u.cnt_enters from t_user u where u.cd=user) t;
*/   exception
   when others then
   logger.log_(null, 'Ќе удалось определить IP терминала, из-за возникшего exception в sys.utl_inaddr.get_host_address(terminal)');
 end;

  return cnt_;
end;

FUNCTION get_fio
  return t_user.name%type is
fio_ t_user.name%type;
begin
--возвращает ‘»ќ кассира
   begin
   select name into fio_
     from t_user u where u.cd=user;
     exception
   when others then
      Raise_application_error(-20000,
        '¬нимание! ѕодключаемый пользователь не зарегистрирован в справочнике пользователей!');
   end;
   return fio_;
end;

FUNCTION get_def_reu
  return permissions.reu%type is
reu_ permissions.reu%type;
begin
--дл€ за€вок... –Ё” по умолчанию, дл€ справочника расценок по работам
   select MIN(trim(p.reu)) into reu_
     from t_user u, permissions p where u.cd=user and p.user_id=u.id and p.type = 0;
   return reu_;
end;

FUNCTION get_nkom
  return c_comps.nkom%type is
begin
  --возвращает текущий є компьютера
   return ncomp_;
end;

FUNCTION get_org_nkom
  return c_comps.fk_org%type is
fk_org_ number;
begin
  --возвращает организацию к которой принадлежит выбранный компьютер
begin
  select t.fk_org into fk_org_ from c_comps t where t.nkom=ncomp_;
  return fk_org_;
exception
  when no_data_found then
  Raise_application_error(-20000, 'Ќе выбран текущий компьютер!');
end;
end;

FUNCTION compare_org(p_fk_org1 IN t_org.id%TYPE, p_fk_org2 IN t_org.id%TYPE)
  return number is
l_cnt NUMBER;
begin
  --сравнить, входит ли fk_org2 в fk_org1
  --по дереву организаций
  
  --не работает, это правоприемничество в REDIR_PAY
  
  
  Raise_application_error(-20000, 'ERROR #2');
  
  SELECT nvl(count(*),0) INTO l_cnt
  FROM
  (
  SELECT t.* FROM t_org t
    CONNECT BY PRIOR t.id=t.parent_id
    START WITH t.id=p_fk_org1
  ) a
   WHERE a.id=p_fk_org2;
  --0 - не входит, 1 - входит
 IF l_cnt = 0 THEN
  RETURN 0;
 ELSE
  RETURN 1;
 END IF;
end;

FUNCTION get_cur_period
  return params.period%type is
mg_ params.period%type;
begin
  select period into mg_ from params p;
  return mg_;
end;

FUNCTION get_is_cnt_sch
  return params.cnt_sch%type is
  cnt_sch_ params.cnt_sch%type;
begin
  select nvl(cnt_sch,0) into cnt_sch_ from params p;
  return cnt_sch_;
end;

FUNCTION get_kart_ed1
  return params.kart_ed1%type is
  kart_ed1_ params.kart_ed1%type;
begin
  select nvl(kart_ed1,0) into kart_ed1_ from params p;
  return kart_ed1_;
end;

FUNCTION get_gen_exp_lst
  return params.gen_exp_lst%type is
  gen_exp_lst_ params.gen_exp_lst%type;
begin
  select nvl(gen_exp_lst,0) into gen_exp_lst_ from params p;
  return gen_exp_lst_;
end;

FUNCTION get_org_var
  return params.org_var%type is
  org_var_ params.org_var%type;
begin
  select nvl(org_var,0) into org_var_ from params p;
  return org_var_;
end;

FUNCTION get_show_exp_pay
  return params.show_exp_pay%type is
  show_exp_pay_ params.show_exp_pay%type;
begin
  --показывать оплату в развернутом виде или нет
  select nvl(show_exp_pay,0) into show_exp_pay_ from params p;
  return show_exp_pay_;
end;

FUNCTION get_have_splash
  return params.splash%type is
  splash_ params.splash%type;
begin
  select nvl(splash,0) into splash_ from params p;
  return splash_;
end;

FUNCTION recharge_bill
  return params.recharge_bill%type is
  recharge_bill_ params.recharge_bill%type;
begin
  --пересчитывать ли счет по умолчанию (галка на форме счета)
  select nvl(recharge_bill,0) into recharge_bill_ from params p;
  return recharge_bill_;
end;

FUNCTION get_errors
  return varchar2 is
  txt_ varchar2(4000);
  cnt_ number;
  i number;
begin
  i:=1;
  --ќтчет показывающий ошибки в базе
  txt_:='';
  select nvl(count(*),0) into cnt_ from t_org t, t_org_tp tp where
   t.fk_orgtp=tp.id and tp.cd='– ÷';
  if cnt_ = 0 then
   txt_:=txt_||to_char(i)||'ќтсутствует запись с cd="– ÷" в справочнике t_org или t_org_tp!'||chr(13)||chr(10);
   i:=i+1;
  end if;

  select nvl(count(*),0) into cnt_ from t_org t, t_org_tp tp where
   t.fk_orgtp=tp.id and tp.cd='– ÷';
  if cnt_ > 1 then
   txt_:=txt_||to_char(i)||' ол-во записей с cd="– ÷" в справочнике t_org или t_org_tp больше одной!'||chr(13)||chr(10);
   i:=i+1;
  end if;

  select nvl(count(*),0) into cnt_ from t_org t, t_org_tp tp where
   t.fk_orgtp=tp.id and tp.cd='√ород';
  if cnt_ = 0 then
   txt_:=txt_||to_char(i)||'ќтсутствует запись с cd="√ород" в справочнике t_org или t_org_tp!'||chr(13)||chr(10);
   i:=i+1;
  end if;

  select nvl(count(*),0) into cnt_ from t_org t, t_org_tp tp where
   t.fk_orgtp=tp.id and tp.cd='ѕаспортный стол';
  if cnt_ = 0 then
   txt_:=txt_||to_char(i)||'ќтсутствует запись с cd="ѕаспортный стол" в справочнике t_org или t_org_tp!'||chr(13)||chr(10);
   i:=i+1;
  end if;

  select nvl(count(*),0) into cnt_ from my_messages;
  if cnt_ <> 51 then
   txt_:=txt_||to_char(i)||'.Ќекорректное кол-во записей в my_messages... или поправить пакет init'||chr(12);
   i:=i+1;
  end if;

  select nvl(count(*),0) into cnt_ from load_memof;
  if cnt_ = 0 then
   txt_:=txt_||to_char(i)||'.Ќекорректное кол-во записей в load_memof (будут не корректно выводитьс€ счета)'||chr(13)||chr(10);
   i:=i+1;
  end if;

  select nvl(count(*),0) into cnt_ from spr_services;
  if cnt_ = 0 then
   txt_:=txt_||to_char(i)||'.Ќекорректное кол-во записей в spr_services (будут не корректно выводитьс€ счета)'||chr(13)||chr(10);
   i:=i+1;
  end if;

  select nvl(count(*),0) into cnt_ from c_status_pr;
  if cnt_ = 0 then
   txt_:=txt_||to_char(i)||'.Ќекорректное кол-во записей в c_status_pr'||chr(13)||chr(10);
   i:=i+1;
  end if;

  select nvl(count(*),0) into cnt_ from t_org_tp t
         where t.cd='ѕаспортный стол';
  if cnt_ = 0 then
   txt_:=txt_||to_char(i)||'.Ќет записи паспортного стола в t_org_tp'||chr(13)||chr(10);
   i:=i+1;
  end if;

  select nvl(count(*),0) into cnt_ from usl_bills t
         where t.mg1 is null or t.mg2 is null;
  if cnt_ <> 0 then
   txt_:=txt_||to_char(i)||'.Ќе заполнен период mg1 или mg2 в usl_bills'||chr(13)||chr(10);
   i:=i+1;
  end if;

  select nvl(count(*),0) into cnt_ from t_org_tp t
         where t.cd='√ород';
  if cnt_ = 0 then
   txt_:=txt_||to_char(i)||'.Ќет записи √орода в t_org_tp'||chr(13)||chr(10);
   i:=i+1;
  end if;

  select nvl(count(*),0) into cnt_ from t_org o, t_org_tp t
         where t.cd='√ород' and o.fk_orgtp=t.id;
  if cnt_ = 0 then
   txt_:=txt_||to_char(i)||'.Ќет записи √орода в t_org_tp'||chr(13)||chr(10);
   i:=i+1;
  end if;

  return txt_;
end;

FUNCTION get_dbid
  return varchar2 is
  txt_ varchar2(50);
begin
  txt_:='';
  select dbid into txt_ from sys.v_$database;
  return txt_;
end;

Function set_date(dat_ in c_kwtp.dtek%type)
  return number is
  l_val number;
  l_mg v_params.period%type;
  l_cur_mg params.period%type;
  l_dt date;
begin
   select p.period into l_cur_mg from params p;
    --проверить период, если не в допустимом диапазоне, запретить вход
   l_dt:=get_period_date(get_nkom);   

   if dat_ between to_date(to_char(l_dt,'YYYYMM')||'01', 'YYYYMMDD') and 
        last_day(l_dt) then
      --дата корректна
      --установить id пользовател€ в глобальную переменную
      l_mg:=to_char(l_dt, 'YYYYMM');
      set_user;
      dtek_:= dat_;
           
      --установить даты периода дл€ “≈ ”ў»’ ќѕ≈–ј÷»…, ¬џЅ–јЌЌјя ѕќЋ№«ќ¬ј“≈Ћ≈ћ ƒј“ј!!!
      g_dt_cur_start:=to_date(to_char(dat_,'YYYYMM')||'01', 'YYYYMMDD');
      g_dt_cur_end:=last_day(g_dt_cur_start);
            
      --честно говор€, не пон€л, зачем здесь устанавливаетс€ дата как дл€ текущих операций - ред. 09.02.15
      --странно. (поправил)
      --установить даты периода дл€ процедур ‘ќ–ћ»–ќ¬јЌ»я, ”—“јЌќ¬Ћ≈ЌЌџ… “≈ ”ў»… ѕ≈–»ќƒ!!!
--      g_dt_start:=to_date(l_mg||'01', 'YYYYMMDD');
--      g_dt_end:=last_day(g_dt_start);
      g_dt_start:=to_date(l_cur_mg||'01', 'YYYYMMDD');
      g_dt_end:=last_day(g_dt_start);

      --проверить админский доступ
      g_admin_acc:=is_allow('drx5_јдмин_доступ_к_базе');
      l_val:=1;
   else
      dtek_:= null;
      --закрыть админский доступ, ждать повторного входа в программу
      g_admin_acc:=0;
      l_val:=3;
   end if;
   return l_val;
end;

FUNCTION get_date
  return c_kwtp.dtek%type is
begin
 if dtek_ is null or g_admin_acc is null then
    --закрыть админский доступ, ждать повторного входа в программу
    g_admin_acc:=0;
    --пуста€ дата может быть следствием перекомпил€ции пакета
    Raise_application_error(-20000, '¬нимание! ќбновлен программный код, необходимо перезайти в приложение!');
 end if;
 return dtek_;
end;

function is_allow (name_ in varchar2) return number
  is
cnt_ number;
begin
  --провека доступа к ѕ–ќ÷≈ƒ”–≈ (drnx...)
  --√–јЌ“ Ќј drx5_админ_доступ_к_базе Ќјƒќ давать непосредственно
  --ѕќЋ№«ќ¬ј“≈Ћё!!!!!!!!!!
  --0 - даны права, 1 - не даны
  select nvl(count(*),0) into cnt_ from (
  select 1 from sys.table_privileges t
  where exists (select * from sys.dba_role_privs u where u.granted_role=t.grantee
   and t.grantee=user)
  and upper(t.table_name)=upper(name_)
  union all
  select 1 from sys.table_privileges t
  where upper(t.table_name)=upper(name_)
  and t.grantee=user);

  if cnt_ > 0 then
    cnt_:=1;
  end if;
  return cnt_;
end;

function is_allow_acc(l_obj_name in varchar2) return number
  is
l_cnt number;
begin
  --провека доступа к ѕ–ќ÷≈ƒ”–≈ (drnx...)
  --провер€ет в том числе пр€мой доступ к объекту, так и
  --через роль
  --1 - даны права, 0 - не даны
  select nvl(count(*),0) into l_cnt from (
    select 1 as cnt from sys.dba_tab_privs t where t.grantee=upper(user)
     and upper(t.table_name)=upper(l_obj_name)
    union all
    select 2 as cnt from sys.table_privileges t
     where exists
     (select granted_role from dba_role_privs d
       where d.GRANTED_ROLE=t.GRANTEE
       start with grantee = upper(user)
       connect by prior granted_role = grantee
     )
     and upper(t.table_name)=upper(l_obj_name)
 );

  if l_cnt > 0 then
    --даны
    l_cnt:=1;
    else
    --не даны
    l_cnt:=0;
  end if;
  return l_cnt;
end;

procedure set_user is
begin
   --установить id пользовател€ в глобальную переменную
   select u.id into g_user from t_user u where u.cd=user;
end;

Function check_date(dat_ in c_kwtp.dtek%type)
  return number is
  valid_ number;
begin
   select case when p.period=to_char(dat_,'YYYYMM') then 1 else 0 end  into valid_
    from params p;
   return valid_;
end;

function get_dt_start
  return c_kwtp.dtek%type is
begin
--вернуть начальную дату ”—“јЌќ¬Ћ≈ЌЌќ… —»—“≈ћќ… мес€ца (используетс€ обычно в запросах)
  if g_dt_start is null then
    Raise_application_error(-20000, '¬нимание! Ќе задано g_dt_start!');
  end if;
 return g_dt_start;   
end;

function get_dt_end
  return c_kwtp.dtek%type is
begin
--вернуть конечную дату ”—“јЌќ¬Ћ≈ЌЌќ… —»—“≈ћќ… мес€ца (используетс€ обычно в запросах)
  if g_dt_end is null then
    Raise_application_error(-20000, '¬нимание! Ќе задано g_dt_end!');
  end if;
 return g_dt_end;   
end;

function get_cur_dt_start
  return c_kwtp.dtek%type is
begin
--вернуть начальную дату ¬џЅ–јЌЌќ√ќ ѕќЋ№«ќ¬ј“≈Ћ≈ћ мес€ца (используетс€ обычно в запросах)
  if g_dt_cur_start is null then
    Raise_application_error(-20000, '¬нимание! Ќе задано g_dt_cur_start!');
  end if;
 return g_dt_cur_start;   
end;

function get_cur_dt_end
  return c_kwtp.dtek%type is
begin
--вернуть конечную дату ¬џЅ–јЌЌќ√ќ ѕќЋ№«ќ¬ј“≈Ћ≈ћ мес€ца (используетс€ обычно в запросах)
  if g_dt_cur_end is null then
    Raise_application_error(-20000, '¬нимание! Ќе задано g_dt_cur_end!');
  end if;
 return g_dt_cur_end;   
end;

FUNCTION get_period_date(p_nkom in c_comps.nkom%type)
  return c_kwtp.dtek%type is
  rec_ v_params%rowtype;
  l_period c_comps.period%type;
begin
 --рекомендовать дату дл€ выбора при старте программы
 select p.* into rec_
    from v_params p;
 select max(t.period) into l_period
   from c_comps t where t.nkom=p_nkom;   

 if l_period is null then
   --не указан рабочий период дл€ компьютера
   if trunc(sysdate) between to_date(rec_.period||'01', 'YYYYMMDD') 
       and last_day(to_date(rec_.period||'01', 'YYYYMMDD'))
       and rec_.period=to_char(sysdate, 'YYYYMM') then
     --если переход выполнен и системна€ дата в пределах текущего периода
     dtek_:=trunc(sysdate);
   else
     --если переход не выполнен и системна€ дата не в тек.периоде
     dtek_:=last_day( to_date(rec_.period||'01', 'YYYYMMDD'));
   end if;
 else
   --указан рабочий период дл€ компьютера
   if l_period=rec_.period1 then
    --указан будущий период 
    if trunc(sysdate) between to_date(rec_.period1||'01', 'YYYYMMDD') 
      and last_day(to_date(rec_.period1||'01', 'YYYYMMDD')) then
     --системна€ дата в текущем периоде
     dtek_:=trunc(sysdate);
    else
     --некорректна€ сист.дата
     dtek_:=to_date(rec_.period1||'01', 'YYYYMMDD');
    end if;
   else
    --указан почему то другой период (может и текущий), проверить его всЄ равно
    if trunc(sysdate) between to_date(rec_.period||'01', 'YYYYMMDD') 
      and last_day(to_date(rec_.period||'01', 'YYYYMMDD')) then
     --системна€ дата в текущем периоде
     dtek_:=trunc(sysdate);
    else
     --некорректна€ сист.дата
     dtek_:=to_date(rec_.period||'01', 'YYYYMMDD');
    end if;
   end if;
 end if;

   
 return dtek_;
end;

FUNCTION get_period
  return params.period%type is
begin
 --текущий период, установленный пользователем
 if g_period is null then
   g_period:=to_char(get_cur_dt_start,'YYYYMM');
 end if;
 return g_period;
end;

procedure set_state(state_ in params.state_base_%type) is
begin
  --установить состо€ние базы (выполнено ли итоговое формирование всех
  --отчетов)
  update params p set p.state_base_=state_;
  commit;
end;

Function get_state
  return number is
  state_ number;
begin
  --показать состо€ние базы (выполнено ли итоговое формирование всех
  --отчетов)
  select nvl(p.state_base_,0) into state_ from params p;
  return state_;
end;

Function get_user
  return number is
begin
  --вернуть ID пользовател€ из глобальной переменной,
  --установленой на входе в приложение
  if g_user is null then
    Raise_application_error(-20000,
     '¬нимание!Ќе обнаружен ID пользовател€, возможно обновлен программный код, необходимо перезайти в приложение!');
  end if;
  return g_user;
end;

Function get_load_dir
  return varchar2 is
 dir_ varchar2(1000);
begin
  --показать состо€ние базы (выполнено ли итоговое формирование всех
  --отчетов)
  select t.directory_path into dir_
   from sys.dba_directories t where t.directory_name='LOAD_FILE_DIR';
   return dir_;
end;

function get_unq_comp return number is
l_id number;
begin
  --получить уникальный номер компьютера,
  --который записан в licenses.ini  
  --примен€етс€ дл€ обновлени€ файлов дл€ программы
  select c_comp_id.nextval into l_id from dual;
  return l_id;
end;

--»Ќ»÷»јЋ»«ј÷»я PACKAGE--
begin
   --установить даты периода дл€ процедур ‘ќ–ћ»–ќ¬јЌ»я, ”—“јЌќ¬Ћ≈ЌЌџ… “≈ ”ў»… ѕ≈–»ќƒ!!!
    --проверить период, если больше текущего на 2 и более мес€цев, запретить
   select p.period
     into l_mg
    from params p;
    g_dt_start:=to_date(l_mg||'01', 'YYYYMMDD');
    g_dt_end:=last_day(g_dt_start);
    
END init;
/

prompt
prompt Creating package body LOGGER
prompt ============================
prompt
CREATE OR REPLACE PACKAGE BODY SCOTT.logger IS

procedure log_act(lsk_ in log_actions.lsk%type,
  text_ in log_actions.text%type,
  fk_type_act_ in log_actions.fk_type_act%type) is
begin
--јудит пользовательских действий
if lsk_ is not null and nvl(c_charges.debug_flag_,0)=0 then
  insert into log_actions (text, ts, fk_user_id, lsk, fk_type_act)
    values (text_, sysdate,
      (select t.id from t_user t where t.cd=user), lsk_, fk_type_act_);
end if;
end log_act;


function log_text(fld_ in varchar2, old_ in varchar2, new_  in varchar2) return varchar2 is
  Result varchar2(500);
begin
  Result:=' '||fld_||' '||old_||''||'-->'||new_;
  return(Result);
end log_text;


  PROCEDURE log_(time_ IN DATE, comments_ IN VARCHAR2) IS
    PRAGMA autonomous_transaction;
  BEGIN
    IF time_ IS NULL THEN
      INSERT INTO LOG
        (id, timestampm, timem, comments)
        SELECT UID, SYSDATE, ROUND((0) * 24 * 60, 2), substr(comments_,1,1000) FROM dual;
    ELSE
      INSERT INTO LOG
        (id, timestampm, timem, comments)
        SELECT UID,
               SYSDATE,
               ROUND((SYSDATE - time_) * 24 * 60, 2),
               comments_
          FROM dual;
    END IF;
    COMMIT;
  END log_;

  PROCEDURE log_ext_(time_ IN DATE, comments_ IN scott.log.comments_ext%type) IS
    PRAGMA autonomous_transaction;
  BEGIN
    IF time_ IS NULL THEN
      INSERT INTO LOG
        (id, timestampm, timem, comments_ext)
        SELECT UID, SYSDATE, ROUND((0) * 24 * 60, 2), substr(comments_,1,1000) FROM dual;
    ELSE
      INSERT INTO LOG
        (id, timestampm, timem, comments_ext)
        SELECT UID,
               SYSDATE,
               ROUND((SYSDATE - time_) * 24 * 60, 2),
               comments_
          FROM dual;
    END IF;
    COMMIT;
  END log_ext_;

  procedure log_sec_ is
    pragma autonomous_transaction;
  begin
    insert into log
      (id, timestampm, ip, terminal, event_id)
      select uid, sysdate, SYS_CONTEXT('USERENV','IP_ADDRESS'),
       SYS_CONTEXT('USERENV','SESSION_USER'), 1 from dual;
    commit;
  end log_sec_;

procedure ins_period_rep(cd_ in reports.cd%type,
   mg_ in period_reports.mg%type, dat_ in period_reports.dat%type,
    signed_in_ in period_reports.signed%type) is
signed_ number;
begin
  select nvl(auto_sign,0) into signed_ from params;
  if signed_ <> 0 then
    signed_:=1;
  else
    signed_:=signed_in_;
  end if;
  --фиксаци€ новых периодов по отчету
  if mg_ is not null then
    delete from period_reports p
     where exists (select * from reports t where t.id=p.id and t.cd=cd_)
       and p.mg = mg_;
    insert into period_reports (id, mg, signed)
    select t.id, mg_, signed_ from reports t where t.cd=cd_;
  elsif dat_ is not null then
    delete from period_reports p
     where exists (select * from reports t where t.id=p.id and t.cd=cd_)
       and p.dat = dat_;
    insert into period_reports (id, dat, signed)
    select t.id, dat_, signed_ from reports t where t.cd=cd_;
  else
  --по умолчанию, если не указан ни один период, фиксируем текущий период
    delete from period_reports p
     where exists (select * from reports t where t.id=p.id and t.cd=cd_)
       and p.mg = (select p.period from params p);
    insert into period_reports (id, mg, signed)
    select t.id, p.period, signed_ from reports t, params p where t.cd=cd_;
  end if;
  commit;
end ins_period_rep;

function prep_err return varchar2
is
  l_back_trace varchar2(4096) default DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
  l_pos integer;
begin
  if substr(l_back_trace, length(l_back_trace), 1) = chr(10)
  then
    l_back_trace := substr(l_back_trace, 1, length(l_back_trace)-1);
  end if;
  l_pos := instr(l_back_trace, chr(10), -1);
  if l_pos > 0 then
    l_back_trace := substr(l_back_trace, l_pos+1);
  end if;
  return l_back_trace || chr(10);
end prep_err;

procedure raiseError(
  error_source varchar2,
  error_message varchar2 default prep_err || sqlerrm,
  error_code number default -20001
)
is
begin
  if not error_source is null then
    raise_application_error(
      error_code, 'error in ' || error_source || chr(10) || error_message);
  else
    raise_application_error(
      error_code, error_message);
  end if;
end RaiseError;

END logger;
/

prompt
prompt Creating package body P_HOUSES
prompt ==============================
prompt
create or replace package body scott.P_HOUSES is

function create_house(reu_ in c_houses.reu%type, kul_ in c_houses.kul%type,
  nd_ in c_houses.nd%type) return number is
 cnt_ number;
 house_id_ number;
 k_lsk_id_ number;
 c_lsk_id_ number;
 --ID ввода
 vvod_hw_id_ number;
 vvod_gw_id_ number;
 vvod_rkc_id_ number;
 maxlsk_ kart.lsk%type;
begin
 select count(*) into cnt_ from c_houses c
  where c.reu=reu_ and c.kul=kul_ and c.nd=lpad(trim(nd_), 6, '0');
  if cnt_ > 0 then
    RAISE_APPLICATION_ERROR(-20001, '”казан существующий дом!');
  else
   --добавл€ем новый дом
   --сам дом
   if utils.get_int_param('HAVE_PASP') = 1 then
   --если есть паспортный - ставим null
     insert into c_houses h (h.id, h.reu, h.kul, h.nd)
      values(c_house_id.nextval, reu_, kul_, lpad(nd_,6,'0'));
     select c_house_id.currval into house_id_ from dual;
   else
   --если паспортного нет, берем первый id из базы (значит 1 имеетс€ код паспортного)
     insert into c_houses h (h.id, h.reu, h.kul, h.nd)
      values(c_house_id.nextval, reu_, kul_, lpad(nd_,6,'0'));
     select c_house_id.currval into house_id_ from t_org t,
     t_org_tp tp where t.fk_orgtp=tp.id and tp.cd='ѕаспортный стол';
   end if;

   --первый лицевой по дому
   select k_lsk_id.nextval into k_lsk_id_ from dual;
   insert into k_lsk (id, fk_addrtp)
     select k_lsk_id_, u.id
     from u_list u, u_listtp tp
     where
     u.cd='flat' and tp.cd='object_type';

   select c_lsk_id.nextval into c_lsk_id_ from dual;
   insert into c_lsk (id)
     values (c_lsk_id_);

--ред.31.07.12
--   select lpad(max(lsk)+1,8,'0') into maxlsk_ from
--     kart k where k.reu=reu_;
  maxlsk_:=find_unq_lsk(reu_, null);

/*   if maxlsk_ is null then
     select lpad(max(lsk)+1,8,'0') into maxlsk_ from
       kart k;
   else
     select count(*) into cnt_ from
       kart k where k.lsk=maxlsk_;
     if cnt_ > 0 then
       --данный л.с. существует, берем последний из базы
       select lpad(max(lsk)+1,8,'0') into maxlsk_ from
         kart k;
     end if;
   end if;
*/
   --добавл€ем 1 -ую квартиру
   insert into kart k (lsk, reu, kul, nd, kw, psch, kpr, kpr_wr,
     kpr_ot, status, kfg, kfot, house_id, k_lsk_id, c_lsk_id, mg1, mg2, fk_tp)
   select maxlsk_, reu_, kul_, lpad(nd_,6,'0'), '0000001',
      0, 0, 0, 0, 2, 2, 2, house_id_, k_lsk_id_, c_lsk_id_, p.period, '999999', tp.id as fk_tp
      from params p, v_lsk_tp tp
      where tp.cd='LSK_TP_MAIN';

   --набор услуг по дому
   --добавл€ть не надо, по просьбе кис. ред.02.07.12
/*   insert into nabor n (lsk, usl, org, koeff, norm)
    select k.lsk, u.usl, (select min(kod) from sprorg),
      decode(u.sptarn, 0, 0, null), decode(u.sptarn, 1, 0, null)
     from kart k, usl u
     where k.house_id = house_id_;*/
  end if;
  commit;
  return 1;
end;

PROCEDURE house_add_usl(p_lvl     IN NUMBER,
                        lsk_      IN kart.lsk%TYPE,
                        house_id_ IN c_houses.id%TYPE,
                        p_reu     IN kart.reu%TYPE,
                        p_trest   IN kart.reu%TYPE,
                        usl_      IN nabor.usl%TYPE,
                        org_      IN nabor.org%TYPE,
                        koeff_    IN NUMBER,
                        norm_     IN NUMBER,
                        p_chrg in number) IS
  sptarn_ NUMBER;
  p_lsk_tp varchar2(256);
BEGIN
  --ƒобавление услуги по лс/дому/фонду/городу, (по данному коэфф-нормативу, организации)
  --в те л.с. в которых их нет
  SELECT MAX(u.sptarn) INTO sptarn_ FROM usl u WHERE u.usl = usl_;
  p_lsk_tp:=utils.getScd_list_param('REP_TP_SCH_SEL');
  SELECT u.sptarn INTO sptarn_ FROM usl u WHERE u.usl = usl_;
  IF nvl(p_lvl, 0) = 0 THEN
    --по √ороду
    IF sptarn_ = 0 AND nvl(koeff_, 0) <> 0 THEN
      --коэфф
      INSERT INTO nabor
        (lsk, usl, org, koeff, norm)
        SELECT k.lsk, usl_, org_, koeff_, NULL AS norm
          FROM kart k, v_lsk_tp tp
         WHERE NOT EXISTS (SELECT *
                  FROM nabor n
                 WHERE n.lsk = k.lsk
                   AND n.usl = usl_)
         and k.fk_tp=tp.id
         and tp.cd=p_lsk_tp;
    ELSIF sptarn_ = 1 AND nvl(norm_, 0) <> 0 THEN
      --норматив
      INSERT INTO nabor
        (lsk, usl, org, koeff, norm)
        SELECT k.lsk, usl_, org_, NULL AS koeff, norm_
          FROM kart k, v_lsk_tp tp
         WHERE NOT EXISTS (SELECT *
                  FROM nabor n
                 WHERE n.lsk = k.lsk
                   AND n.usl = usl_)
         and k.fk_tp=tp.id
         and tp.cd=p_lsk_tp;
    ELSIF sptarn_ IN (2, 3) AND nvl(koeff_, 0) <> 0 AND nvl(norm_, 0) <> 0 THEN
      --и коэфф и норматив
      INSERT INTO nabor
        (lsk, usl, org, koeff, norm)
        SELECT k.lsk, usl_, org_, koeff_, norm_
          FROM kart k, v_lsk_tp tp
         WHERE NOT EXISTS (SELECT *
                  FROM nabor n
                 WHERE n.lsk = k.lsk
                   AND n.usl = usl_)
         and k.fk_tp=tp.id
         and tp.cd=p_lsk_tp;
    END IF;
  ELSIF nvl(p_lvl, 0) = 1 THEN
    --по ‘онду
    IF sptarn_ = 0 AND nvl(koeff_, 0) <> 0 THEN
      --коэфф
      INSERT INTO nabor
        (lsk, usl, org, koeff, norm)
        SELECT k.lsk, usl_, org_, koeff_, NULL AS norm
          FROM kart k, v_lsk_tp tp
         WHERE
           EXISTS (SELECT *
                FROM kart t, s_reu_trest s
               WHERE k.lsk = t.lsk
                 AND t.reu = s.reu
                 AND s.trest = p_trest)
           AND NOT EXISTS (SELECT *
                  FROM nabor n
                 WHERE n.lsk = k.lsk
                   AND n.usl = usl_)
           and k.fk_tp=tp.id
           and tp.cd=p_lsk_tp;
    ELSIF sptarn_ = 1 AND nvl(norm_, 0) <> 0 THEN
      --норматив
      INSERT INTO nabor
        (lsk, usl, org, koeff, norm)
        SELECT k.lsk, usl_, org_, NULL AS koeff, norm_
          FROM kart k, v_lsk_tp tp
         WHERE
          EXISTS (SELECT *
                FROM kart t, s_reu_trest s
               WHERE k.lsk = t.lsk
                 AND t.reu = s.reu
                 AND s.trest = p_trest)
           AND NOT EXISTS (SELECT *
                  FROM nabor n
                 WHERE n.lsk = k.lsk
                   AND n.usl = usl_)
           and k.fk_tp=tp.id
           and tp.cd=p_lsk_tp;
    ELSIF sptarn_ IN (2, 3) AND nvl(koeff_, 0) <> 0 AND nvl(norm_, 0) <> 0 THEN
      --и коэфф и норматив
      INSERT INTO nabor
        (lsk, usl, org, koeff, norm)
        SELECT k.lsk, usl_, org_, koeff_, norm_
          FROM kart k, v_lsk_tp tp
         WHERE
          EXISTS (SELECT *
                FROM kart t, s_reu_trest s
               WHERE k.lsk = t.lsk
                 AND t.reu = s.reu
                 AND s.trest = p_trest)
           AND NOT EXISTS (SELECT *
                  FROM nabor n
                 WHERE n.lsk = k.lsk
                   AND n.usl = usl_)
           and k.fk_tp=tp.id
           and tp.cd=p_lsk_tp;
    END IF;
  ELSIF nvl(p_lvl, 0) = 2 THEN
    --по ” 
    IF sptarn_ = 0 AND nvl(koeff_, 0) <> 0 THEN
      --коэфф
      INSERT INTO nabor
        (lsk, usl, org, koeff, norm)
        SELECT k.lsk, usl_, org_, koeff_, NULL AS norm
          FROM kart k, v_lsk_tp tp
         WHERE
           EXISTS (SELECT *
                FROM kart t
               WHERE k.lsk = t.lsk
                 AND t.reu = p_reu)
           AND NOT EXISTS (SELECT *
                  FROM nabor n
                 WHERE n.lsk = k.lsk
                   AND n.usl = usl_)
           and k.fk_tp=tp.id
           and tp.cd=p_lsk_tp;
    ELSIF sptarn_ = 1 AND nvl(norm_, 0) <> 0 THEN
      --норматив
      INSERT INTO nabor
        (lsk, usl, org, koeff, norm)
        SELECT k.lsk, usl_, org_, NULL AS koeff, norm_
          FROM kart k, v_lsk_tp tp
         WHERE
          EXISTS (SELECT *
            FROM kart t
           WHERE k.lsk = t.lsk
             AND t.reu = p_reu)
           AND NOT EXISTS (SELECT *
                  FROM nabor n
                 WHERE n.lsk = k.lsk
                   AND n.usl = usl_)
           and k.fk_tp=tp.id
           and tp.cd=p_lsk_tp;
    ELSIF sptarn_ IN (2, 3) AND nvl(koeff_, 0) <> 0 AND nvl(norm_, 0) <> 0 THEN
      --и коэфф и норматив
      INSERT INTO nabor
        (lsk, usl, org, koeff, norm)
        SELECT k.lsk, usl_, org_, koeff_, norm_
          FROM kart k, v_lsk_tp tp
         WHERE
          EXISTS (SELECT *
            FROM kart t
           WHERE k.lsk = t.lsk
             AND t.reu = p_reu)
           AND NOT EXISTS (SELECT *
                  FROM nabor n
                 WHERE n.lsk = k.lsk
                   AND n.usl = usl_)
           and k.fk_tp=tp.id
           and tp.cd=p_lsk_tp;
    END IF;
  ELSIF nvl(p_lvl, 0) = 3 THEN
    --по дому
    IF sptarn_ = 0 AND nvl(koeff_, 0) <> 0 THEN
      --коэфф
      INSERT INTO nabor
        (lsk, usl, org, koeff, norm)
        SELECT k.lsk, usl_, org_, koeff_, NULL AS norm
          FROM kart k, v_lsk_tp tp
         WHERE k.house_id = house_id_
           AND NOT EXISTS (SELECT *
                  FROM nabor n
                 WHERE n.lsk = k.lsk
                   AND n.usl = usl_)
           and k.fk_tp=tp.id
           and tp.cd=p_lsk_tp;
    ELSIF sptarn_ = 1 AND nvl(norm_, 0) <> 0 THEN
      --норматив
      INSERT INTO nabor
        (lsk, usl, org, koeff, norm)
        SELECT k.lsk, usl_, org_, NULL AS koeff, norm_
          FROM kart k, v_lsk_tp tp
         WHERE k.house_id = house_id_
           AND NOT EXISTS (SELECT *
                  FROM nabor n
                 WHERE n.lsk = k.lsk
                   AND n.usl = usl_)
           and k.fk_tp=tp.id
           and tp.cd=p_lsk_tp;
    ELSIF sptarn_ IN (2, 3) AND nvl(koeff_, 0) <> 0 AND nvl(norm_, 0) <> 0 THEN
      --и коэфф и норматив
      INSERT INTO nabor
        (lsk, usl, org, koeff, norm)
        SELECT k.lsk, usl_, org_, koeff_, norm_
          FROM kart k, v_lsk_tp tp
         WHERE k.house_id = house_id_
           AND NOT EXISTS (SELECT *
                  FROM nabor n
                 WHERE n.lsk = k.lsk
                   AND n.usl = usl_)
           and k.fk_tp=tp.id
           and tp.cd=p_lsk_tp;
    END IF;
  ELSIF nvl(p_lvl, 0) = 4 THEN
    --по л/с
    INSERT INTO nabor
      (lsk, usl, org, koeff, norm)
      SELECT k.lsk, usl_, org_, koeff_, norm_
        FROM kart k
       WHERE k.lsk = lsk_
         AND NOT EXISTS (SELECT *
                FROM nabor n
               WHERE n.lsk = k.lsk
                 AND n.usl = usl_);
    --по л/c коммит не делаетс€
  END IF;
  --переcчет начислений
  if p_chrg =1 then
   c_charges.gen_chrg_all(p_lvl, house_id_, p_reu, p_trest);
  end if;
  COMMIT;
END;

PROCEDURE house_chng_usl(p_lvl      IN NUMBER,
                         house_id_  IN c_houses.id%TYPE,
                         p_reu      IN kart.reu%TYPE,
                         p_trest    IN kart.reu%TYPE,
                         usl_       IN nabor.usl%TYPE,
                         old_org_   IN nabor.org%TYPE,
                         new_org_   IN nabor.org%TYPE,
                         old_koeff_ IN NUMBER,
                         old_norm_  IN NUMBER,
                         new_koeff_ IN NUMBER,
                         new_norm_  IN NUMBER,
                         p_chrg in number) IS
  sptarn_ NUMBER;
  p_lsk_tp varchar2(256);  
BEGIN
  --»зменение услуги (по данному коэфф-нормативу, организации)
  p_lsk_tp:=utils.getScd_list_param('REP_TP_SCH_SEL');
  SELECT u.sptarn INTO sptarn_ FROM usl u WHERE u.usl = usl_;
  IF nvl(p_lvl, 0) = 0 THEN
    --по √ороду
    IF sptarn_ = 0 THEN
      --коэфф
      UPDATE nabor n
         SET n.koeff = ROUND(nvl(new_koeff_, 0),10), n.org = new_org_
       WHERE n.usl = usl_
         AND ROUND(nvl(n.koeff, 0),10) = ROUND(nvl(old_koeff_, 0),10)
         AND n.org = old_org_
         and exists (select * from kart k, v_lsk_tp tp where k.lsk=n.lsk
                        and k.fk_tp=tp.id
                        and tp.cd=p_lsk_tp
                        );
    ELSIF sptarn_ = 1 THEN
      --норматив
      UPDATE nabor n
         SET n.norm = ROUND(nvl(new_norm_, 0),10), n.org = new_org_
       WHERE n.usl = usl_
         AND ROUND(nvl(n.norm, 0),10) = ROUND(nvl(old_norm_, 0),10)
         AND n.org = old_org_
                  and exists (select * from kart k, v_lsk_tp tp where k.lsk=n.lsk
                        and k.fk_tp=tp.id
                        and tp.cd=p_lsk_tp
                        );
    ELSIF sptarn_ IN (2, 3) THEN
      --и коэфф и норматив
      UPDATE nabor n
         SET n.koeff = ROUND(nvl(new_koeff_, 0),10),
           n.norm = ROUND(nvl(new_norm_, 0),10), n.org = new_org_
       WHERE n.usl = usl_
         AND ROUND(nvl(n.koeff, 0),10) = ROUND(nvl(old_koeff_, 0),10)
         AND ROUND(nvl(n.norm, 0),10) = ROUND(nvl(old_norm_, 0),10)
         AND n.org = old_org_
         and exists (select * from kart k, v_lsk_tp tp where k.lsk=n.lsk
                        and k.fk_tp=tp.id
                        and tp.cd=p_lsk_tp
                        );
        
    END IF;
  ELSIF nvl(p_lvl, 0) = 1 THEN
    --по ‘онду
    IF sptarn_ = 0 THEN
      --коэфф
      UPDATE nabor n
         SET n.koeff = ROUND(nvl(new_koeff_, 0),10), n.org = new_org_
       WHERE EXISTS (SELECT *
                FROM kart k, s_reu_trest s
               WHERE k.lsk = n.lsk
                 AND k.reu = s.reu
                 AND s.trest = p_trest)
         AND n.usl = usl_
         AND ROUND(nvl(n.koeff, 0),10) = ROUND(nvl(old_koeff_, 0),10)
         AND n.org = old_org_
         and exists (select * from kart k, v_lsk_tp tp where k.lsk=n.lsk
                        and k.fk_tp=tp.id
                        and tp.cd=p_lsk_tp
                        );

    ELSIF sptarn_ = 1 THEN
      --норматив
      UPDATE nabor n
         SET n.norm = ROUND(nvl(new_norm_, 0),10), n.org = new_org_
       WHERE EXISTS (SELECT *
                FROM kart k, s_reu_trest s
               WHERE k.lsk = n.lsk
                 AND k.reu = s.reu
                 AND s.trest = p_trest)
         AND n.usl = usl_
         AND ROUND(nvl(n.norm, 0),10) = ROUND(nvl(old_norm_, 0),10)
         AND n.org = old_org_
         and exists (select * from kart k, v_lsk_tp tp where k.lsk=n.lsk
                        and k.fk_tp=tp.id
                        and tp.cd=p_lsk_tp
                        );
         
    ELSIF sptarn_ IN (2, 3) THEN
      --и коэфф и норматив
      UPDATE nabor n
         SET n.koeff = ROUND(nvl(new_koeff_, 0),10),
             n.norm = ROUND(nvl(new_norm_, 0),10), n.org = new_org_
       WHERE EXISTS (SELECT *
                FROM kart k, s_reu_trest s
               WHERE k.lsk = n.lsk
                 AND k.reu = s.reu
                 AND s.trest = p_trest)
         AND n.usl = usl_
         AND ROUND(nvl(n.koeff, 0),10) = ROUND(nvl(old_koeff_, 0),10)
         AND ROUND(nvl(n.norm, 0),10) = ROUND(nvl(old_norm_, 0),10)
         AND n.org = old_org_
         and exists (select * from kart k, v_lsk_tp tp where k.lsk=n.lsk
                        and k.fk_tp=tp.id
                        and tp.cd=p_lsk_tp
                        );
         
    END IF;
  ELSIF nvl(p_lvl, 0) = 2 THEN
    --по ” 
    IF sptarn_ = 0 THEN
      --коэфф
      UPDATE nabor n
         SET n.koeff = ROUND(nvl(new_koeff_, 0),10), n.org = new_org_
       WHERE EXISTS (SELECT *
                FROM kart k
               WHERE k.lsk = n.lsk
                 AND k.reu = p_reu)
         AND n.usl = usl_
         AND ROUND(nvl(n.koeff, 0),10) = ROUND(nvl(old_koeff_, 0),10)
         AND n.org = old_org_
         and exists (select * from kart k, v_lsk_tp tp where k.lsk=n.lsk
                        and k.fk_tp=tp.id
                        and tp.cd=p_lsk_tp
                        );
         
    ELSIF sptarn_ = 1 THEN
      --норматив
      UPDATE nabor n
         SET n.norm = ROUND(nvl(new_norm_, 0),10), n.org = new_org_
       WHERE EXISTS (SELECT *
                FROM kart k
               WHERE k.lsk = n.lsk
                 AND k.reu = p_reu)
         AND n.usl = usl_
         AND ROUND(nvl(n.norm, 0),10) = ROUND(nvl(old_norm_, 0),10)
         AND n.org = old_org_
         and exists (select * from kart k, v_lsk_tp tp where k.lsk=n.lsk
                        and k.fk_tp=tp.id
                        and tp.cd=p_lsk_tp
                        );
         
    ELSIF sptarn_ IN (2, 3) THEN
      --и коэфф и норматив
      UPDATE nabor n
         SET n.koeff = ROUND(nvl(new_koeff_, 0),10),
             n.norm = ROUND(nvl(new_norm_, 0),10), n.org = new_org_
       WHERE EXISTS (SELECT *
                FROM kart k
               WHERE k.lsk = n.lsk
                 AND k.reu = p_reu)
         AND n.usl = usl_
         AND ROUND(nvl(n.koeff, 0),10) = ROUND(nvl(old_koeff_, 0),10)
         AND ROUND(nvl(n.norm, 0),10) = ROUND(nvl(old_norm_, 0),10)
         AND n.org = old_org_
         and exists (select * from kart k, v_lsk_tp tp where k.lsk=n.lsk
                        and k.fk_tp=tp.id
                        and tp.cd=p_lsk_tp
                        );
         
    END IF;
  ELSIF nvl(p_lvl, 0) = 3 THEN
    --по дому
    IF sptarn_ = 0 THEN
      --коэфф
      UPDATE nabor n
         SET n.koeff = ROUND(nvl(new_koeff_, 0),10), n.org = new_org_
       WHERE EXISTS (SELECT *
                FROM kart k
               WHERE k.lsk = n.lsk
                 AND k.house_id = house_id_)
         AND n.usl = usl_
         AND ROUND(nvl(n.koeff, 0),10) = ROUND(nvl(old_koeff_, 0),10)
         AND n.org = old_org_
         and exists (select * from kart k, v_lsk_tp tp where k.lsk=n.lsk
                        and k.fk_tp=tp.id
                        and tp.cd=p_lsk_tp
                        );
         
    ELSIF sptarn_ = 1 THEN
      --норматив
      UPDATE nabor n
         SET n.norm = ROUND(nvl(new_norm_, 0),10), n.org = new_org_
       WHERE EXISTS (SELECT *
                FROM kart k
               WHERE k.lsk = n.lsk
                 AND k.house_id = house_id_)
         AND n.usl = usl_
         AND ROUND(nvl(n.norm, 0),10) = ROUND(nvl(old_norm_, 0),10)
         AND n.org = old_org_
         and exists (select * from kart k, v_lsk_tp tp where k.lsk=n.lsk
                        and k.fk_tp=tp.id
                        and tp.cd=p_lsk_tp
                        );
         
    ELSIF sptarn_ IN (2, 3) THEN
      --и коэфф и норматив
      UPDATE nabor n
         SET n.koeff = ROUND(nvl(new_koeff_, 0),10),
             n.norm = ROUND(nvl(new_norm_, 0),10), n.org = new_org_
       WHERE EXISTS (SELECT *
                FROM kart k
               WHERE k.lsk = n.lsk
                 AND k.house_id = house_id_)
         AND n.usl = usl_
         AND ROUND(nvl(n.koeff, 0),10) = ROUND(nvl(old_koeff_, 0),10)
         AND ROUND(nvl(n.norm, 0),10) = ROUND(nvl(old_norm_, 0),10)
         AND n.org = old_org_
         and exists (select * from kart k, v_lsk_tp tp where k.lsk=n.lsk
                        and k.fk_tp=tp.id
                        and tp.cd=p_lsk_tp
                        );
         
    END IF;
  ELSIF nvl(p_lvl, 0) = 4 THEN
    --по л/с
    --нет, потому что измен€ютс€ параметры в самой карточке
    NULL;
  END IF;

  IF SQL%NOTFOUND THEN
      Raise_application_error(-20000, 'Ќе произведено изменений!');
  ELSE
    --переcчет начислений
    if p_chrg =1 then
      c_charges.gen_chrg_all(p_lvl, house_id_, p_reu, p_trest);
    end if;
    COMMIT;
  END IF;
END;

PROCEDURE house_del_usl(p_lvl     IN NUMBER,
                        lsk_      IN kart.lsk%TYPE,
                        house_id_ IN c_houses.id%TYPE,
                        p_reu      IN kart.reu%TYPE,
                        p_trest    IN kart.reu%TYPE,
                        usl_      IN nabor.usl%TYPE,
                        org_      IN nabor.org%TYPE,
                        koeff_    IN NUMBER,
                        norm_     IN NUMBER,
                        p_chrg in number) IS
  sptarn_ NUMBER;
  cnt_    NUMBER;
  l_sel varchar2(256);
BEGIN
  --”даление услуги (по данному коэфф-нормативу, организации)
  SELECT MAX(u.sptarn) INTO sptarn_ FROM usl u WHERE u.usl = usl_;
  l_sel:=utils.getScd_list_param('REP_TP_SCH_SEL');
  IF nvl(p_lvl, 0) = 0 THEN
    --по √ороду
    IF sptarn_ = 0 THEN
      --коэфф
      DELETE FROM nabor n
       WHERE
         n.usl = usl_
         AND n.org = org_
         AND nvl(n.koeff, 0) = nvl(koeff_, 0)
         and exists (select * from kart k, v_lsk_tp tp where k.lsk=n.lsk
                        and k.fk_tp=tp.id
                        and tp.cd=l_sel
                        );
         
    ELSIF sptarn_ = 1 THEN
      --норматив
      DELETE FROM nabor n
       WHERE
         n.usl = usl_
         AND n.org = org_
         AND nvl(n.koeff, 0) = nvl(norm_, 0)
         and exists (select * from kart k, v_lsk_tp tp where k.lsk=n.lsk
                        and k.fk_tp=tp.id
                        and tp.cd=l_sel
                        );
        
    ELSIF sptarn_ IN (2, 3) THEN
      --и коэфф и норматив
      DELETE FROM nabor n
       WHERE
         n.usl = usl_
         AND n.org = org_
         AND nvl(n.koeff, 0) = nvl(koeff_, 0)
         AND nvl(n.norm, 0) = nvl(norm_, 0)
         and exists (select * from kart k, v_lsk_tp tp where k.lsk=n.lsk
                        and k.fk_tp=tp.id
                        and tp.cd=l_sel
                        );
         
    END IF;
  ELSIF nvl(p_lvl, 0) = 1 THEN
    --по ‘онду
    IF sptarn_ = 0 THEN
      --коэфф
      DELETE FROM nabor n
       WHERE EXISTS (SELECT *
                FROM kart k, s_reu_trest s
               WHERE k.lsk = n.lsk
                 AND k.reu=s.reu
                 AND s.trest = p_trest)
         AND n.usl = usl_
         AND n.org = org_
         AND nvl(n.koeff, 0) = nvl(koeff_, 0)
         and exists (select * from kart k, v_lsk_tp tp where k.lsk=n.lsk
                        and k.fk_tp=tp.id
                        and tp.cd=l_sel
                        );
         
    ELSIF sptarn_ = 1 THEN
      --норматив
      DELETE FROM nabor n
       WHERE EXISTS (SELECT *
                FROM kart k, s_reu_trest s
               WHERE k.lsk = n.lsk
                 AND k.reu=s.reu
                 AND s.trest = p_trest)
         AND n.usl = usl_
         AND n.org = org_
         AND nvl(n.koeff, 0) = nvl(norm_, 0)
         and exists (select * from kart k, v_lsk_tp tp where k.lsk=n.lsk
                        and k.fk_tp=tp.id
                        and tp.cd=l_sel
                        );
         
    ELSIF sptarn_ IN (2, 3) THEN
      --и коэфф и норматив
      DELETE FROM nabor n
       WHERE EXISTS (SELECT *
                FROM kart k, s_reu_trest s
               WHERE k.lsk = n.lsk
                 AND k.reu=s.reu
                 AND s.trest = p_trest)
         AND n.usl = usl_
         AND n.org = org_
         AND nvl(n.koeff, 0) = nvl(koeff_, 0)
         AND nvl(n.norm, 0) = nvl(norm_, 0)
         and exists (select * from kart k, v_lsk_tp tp where k.lsk=n.lsk
                        and k.fk_tp=tp.id
                        and tp.cd=l_sel
                        );
         
    END IF;
  ELSIF nvl(p_lvl, 0) = 2 THEN
    --по ” 
    IF sptarn_ = 0 THEN
      --коэфф
      DELETE FROM nabor n
       WHERE EXISTS (SELECT *
                FROM kart k
               WHERE k.lsk = n.lsk
                 AND k.reu = p_reu)
         AND n.usl = usl_
         AND n.org = org_
         AND nvl(n.koeff, 0) = nvl(koeff_, 0)
         and exists (select * from kart k, v_lsk_tp tp where k.lsk=n.lsk
                        and k.fk_tp=tp.id
                        and tp.cd=l_sel
                        );
         
    ELSIF sptarn_ = 1 THEN
      --норматив
      DELETE FROM nabor n
       WHERE EXISTS (SELECT *
                FROM kart k
               WHERE k.lsk = n.lsk
                 AND k.reu = p_reu)
         AND n.usl = usl_
         AND n.org = org_
         AND nvl(n.koeff, 0) = nvl(norm_, 0)
         and exists (select * from kart k, v_lsk_tp tp where k.lsk=n.lsk
                        and k.fk_tp=tp.id
                        and tp.cd=l_sel
                        );
         
    ELSIF sptarn_ IN (2, 3) THEN
      --и коэфф и норматив
      DELETE FROM nabor n
       WHERE EXISTS (SELECT *
                FROM kart k
               WHERE k.lsk = n.lsk
                 AND k.reu = p_reu)
         AND n.usl = usl_
         AND n.org = org_
         AND nvl(n.koeff, 0) = nvl(koeff_, 0)
         AND nvl(n.norm, 0) = nvl(norm_, 0)
         and exists (select * from kart k, v_lsk_tp tp where k.lsk=n.lsk
                        and k.fk_tp=tp.id
                        and tp.cd=l_sel
                        );
         
    END IF;
  ELSIF nvl(p_lvl, 0) = 3 THEN
    --по дому
    IF sptarn_ = 0 THEN
      --коэфф
      DELETE FROM nabor n
       WHERE EXISTS (SELECT *
                FROM kart k
               WHERE k.lsk = n.lsk
                 AND k.house_id = house_id_)
         AND n.usl = usl_
         AND n.org = org_
         AND nvl(n.koeff, 0) = nvl(koeff_, 0)
         and exists (select * from kart k, v_lsk_tp tp where k.lsk=n.lsk
                        and k.fk_tp=tp.id
                        and tp.cd=l_sel
                        );
         
    ELSIF sptarn_ = 1 THEN
      --норматив
      DELETE FROM nabor n
       WHERE EXISTS (SELECT *
                FROM kart k
               WHERE k.lsk = n.lsk
                 AND k.house_id = house_id_)
         AND n.usl = usl_
         AND n.org = org_
         AND nvl(n.koeff, 0) = nvl(norm_, 0)
         and exists (select * from kart k, v_lsk_tp tp where k.lsk=n.lsk
                        and k.fk_tp=tp.id
                        and tp.cd=l_sel
                        );
         
    ELSIF sptarn_ IN (2, 3) THEN
      --и коэфф и норматив
      DELETE FROM nabor n
       WHERE EXISTS (SELECT *
                FROM kart k
               WHERE k.lsk = n.lsk
                 AND k.house_id = house_id_)
         AND n.usl = usl_
         AND n.org = org_
         AND nvl(n.koeff, 0) = nvl(koeff_, 0)
         AND nvl(n.norm, 0) = nvl(norm_, 0)
         and exists (select * from kart k, v_lsk_tp tp where k.lsk=n.lsk
                        and k.fk_tp=tp.id
                        and tp.cd=l_sel
                        );
         
    END IF;
  ELSIF nvl(p_lvl, 0) = 4 THEN
    --по л/с
    IF sptarn_ = 0 THEN
      --коэфф
      DELETE FROM nabor n
       WHERE n.lsk = lsk_
         AND n.usl = usl_
         AND n.org = org_
         AND n.koeff = koeff_;
    ELSIF sptarn_ = 1 THEN
      --норматив
      DELETE FROM nabor n
       WHERE n.lsk = lsk_
         AND n.usl = usl_
         AND n.org = org_
         AND n.koeff = norm_;
    ELSIF sptarn_ IN (2, 3) THEN
      --и коэфф и норматив
      DELETE FROM nabor n
       WHERE n.lsk = lsk_
         AND n.usl = usl_
         AND n.org = org_
         AND n.koeff = koeff_
         AND n.norm = norm_;
    END IF;
  END IF;
  IF SQL%NOTFOUND THEN
      Raise_application_error(-20000, 'Ќе произведено изменений!');
  ELSIF nvl(p_lvl, 0) <> 4 THEN
    --по л/c коммит и перерасчет не делаетс€
    --переcчет начислений
    if p_chrg =1 then
      c_charges.gen_chrg_all(p_lvl, house_id_, p_reu, p_trest);
    end if;
    COMMIT;
  END IF;
END;

PROCEDURE change_house_status(
   house_id_ in c_houses.id%TYPE,
   status_ in kart.status%TYPE,
   old_status_ in kart.status%TYPE) is
begin
--изменение статуса квартир дома (муницип, приват)
update kart k set k.status=status_ where k.status=old_status_
 and k.house_id=house_id_;
commit;

end;

PROCEDURE change_house_vvod(
   house_id_ in c_houses.id%TYPE,
   usl_ in nabor.usl%type,
   fk_vvod_new_ in nabor.fk_vvod%TYPE,
   fk_vvod_old_ in nabor.fk_vvod%TYPE) is
begin
--изменение є ввода квартир дома
update nabor n set n.fk_vvod=fk_vvod_new_
  where nvl(n.fk_vvod,0)=fk_vvod_old_
   and n.usl=usl_
   and exists
   (select * from kart k where
           k.house_id=house_id_ and k.lsk=n.lsk);
commit;

end;


 function change_tarif(tsource_ in number, tdest_ in number)
 return number is
  cnt_ number;
begin
-- замена тарифа в лицевых счетах
  --кол-во л.с., использующих тариф
  select count(*) into cnt_ from nabor n
    where n.fk_tarif=tsource_;
  if cnt_ <> 0 then
   update nabor n set n.fk_tarif=tdest_
     where n.fk_tarif=tsource_;
  end if;
----удал€ем из справочника тарифов--- зачем????
--  delete from spr_tarif s where s.id=tsource_;
--  commit;
  return cnt_;

end;

/* function add_prog(lsk_ in nabor_progs.lsk%type, fk_tarif_ in nabor_progs.fk_tarif%type,
   parent_id_ in nabor_progs.parent_id%type, usl_ in nabor_progs.usl%type)
 return number is
  cnt_ number;
  cnt2_ number;
  root_id_ number;
begin
-- добавление пакета/программы из справочника в набор абонента
  cnt_:=0;
  --кол-во л.с., использующих тариф
  select nvl(count(*),0) into cnt2_ from nabor_progs n
    where n.lsk=lsk_;
  if cnt2_ = 0 then
  --если нет вообще программ в наборе, добавим корневой
     insert into nabor_progs(id, parent_id, lsk, usl, fk_tarif)
     select nabor_progs_id.nextval, null, lsk_, usl_, t.id
      from spr_tarif t where t.cd='000';
    select nabor_progs_id.currval into root_id_ from dual;
  else
--    root_id_:=parent_id_;
   --запрещаем добавл€ть программы не в корень набора
    select n.id into root_id_ from
      nabor_progs n, spr_tarif t where n.lsk=lsk_ and
        n.fk_tarif=t.id
        and t.cd = '000';
  end if;

  --если нет программы в наборе
  select nvl(count(*),0) into cnt2_ from nabor_progs n
    where n.lsk=lsk_ and n.fk_tarif=fk_tarif_;
  if cnt2_ = 0 then
     select
     insert into nabor_progs(id, parent_id, lsk, usl, fk_tarif)
     select nabor_progs_id.nextval, root_id_, lsk_, usl_, s.id from
       spr_tarif s
       start with id=fk_tarif_
       connect by s.parent_id=prior s.id;
  else
    --программа уже существует в наборе абонента
    cnt_:=1;
  end if;
--  commit;
  return cnt_;

end;
*/

 function change_prog_tarif(id_ in spr_tarif.id%type,
   parent_id_ in spr_tarifxprogs.fk_tarif%type,
   old_parent_id_ in spr_tarifxprogs.fk_tarif%type)
 return number is
 cnt2_ number;
 cnt_ number;
begin
-- перемещение пакета/программы в справочнике тарифов
  cnt_:=0;

  delete from spr_tarifxprogs t where t.fk_tarif=parent_id_ and t.fk_prog=id_;
  delete from spr_tarifxprogs t where t.fk_tarif=old_parent_id_ and t.fk_prog=id_;
  insert into spr_tarifxprogs
    (fk_tarif, fk_prog)
  values
    (parent_id_, id_);
  return cnt_;
end;

 function copy_prog_tarif(id_ in spr_tarif.id%type,
   parent_id_ in spr_tarifxprogs.fk_tarif%type)
 return number is
 cnt2_ number;
 cnt_ number;
begin
-- копирование пакета/программы в справочнике тарифов
  cnt_:=0;

  delete from spr_tarifxprogs t where t.fk_tarif=parent_id_ and t.fk_prog=id_;
  insert into spr_tarifxprogs
    (fk_tarif, fk_prog)
  values
    (parent_id_, id_);
  return cnt_;
end;

 function del_prog_tarif(id_ in spr_tarif.id%type,
   parent_id_ in spr_tarifxprogs.fk_tarif%type)
 return number is
 cnt2_ number;
 cnt_ number;
begin
  -- ”даление программы из пакета в справочнике тарифов
  cnt_:=0;
  delete from spr_tarifxprogs t where t.fk_tarif=parent_id_ and t.fk_prog=id_;
  -- удаление вообще из справочника тарифов, если не используетс€
  -- другими пакетами и наборами абонента
  select nvl(count(*),0) into cnt2_ from (
  select 1 as cnt from nabor_progs n
   where n.fk_tarif=id_
   union all
  select 1 as cnt from nabor n
   where n.fk_tarif=id_);
  if cnt2_ <> 0 then
    cnt_:=1;
  else
    delete from spr_tarif t where t.id=id_ and not exists
      (select * from spr_tarifxprogs p where p.fk_prog=t.id);
  end if;
  return cnt_;
end;

PROCEDURE add_house_list(p_err OUT varchar2, p_fk_house IN t_housexlist.fk_house%TYPE,
                         p_fk_list  IN t_housexlist.fk_list%TYPE) IS
l_cnt number;
BEGIN

  if to_char(sysdate,'YYYYMM')>='201307' then
    --отловить, кто пользуетс€ этим функционалом
    --пользуетс€ Ё+ - сделать миграцию в нормальные параметры k_lsk_id!!!
    Raise_application_error(-20000, 'ќшибка #1554! в пакете P_HOUSES');
  end if;
  --добавить реквизит по дому (например ”часток)
  --если его еще не существует
  SELECT nvl(COUNT(*), 0)
    INTO l_cnt
    FROM t_housexlist t
   WHERE t.fk_house = p_fk_house
     AND EXISTS (SELECT * FROM
       u_list s, u_list u
       WHERE u.id=p_fk_list
         AND s.fk_listtp=u.fk_listtp
         AND s.id=t.fk_list);
  IF l_cnt <> 0 THEN
    --¬ернуть ошибку
    p_err:='–еквизит данным типом уже существует в доме!';
  ELSE
    --ƒобавить реквизит
    INSERT INTO t_housexlist
      (fk_list, fk_house, reu, kul, nd)
      SELECT p_fk_list, p_fk_house, t.reu, t.kul, t.nd
        FROM c_houses t
        WHERE
        t.id=p_fk_house;
    COMMIT;
    p_err:=null;
  END IF;
END;

PROCEDURE del_house_list(p_id IN t_housexlist.id%TYPE) IS
BEGIN
  if to_char(sysdate,'YYYYMM')>='201307' then
    --отловить, кто пользуетс€ этим функционалом
    --пользуетс€ Ё+ - сделать миграцию в нормальные параметры k_lsk_id!!!
    Raise_application_error(-20000, 'ќшибка #1555! в пакете P_HOUSES');
  end if;
  --удалить реквизит по дому (например ”часток)
  DELETE FROM t_housexlist t
     WHERE t.id=p_id;
  COMMIT;
END;

 function add_prog(lsk_ in nabor_progs.lsk%type, fk_tarif_ in nabor_progs.fk_tarif%type,
   usl_ in nabor_progs.usl%type, id_dvb_ in number)
 return number is
  cnt_ number;
  cnt2_ number;
  root_id_ number;
begin
-- добавление пакета/программы из справочника в набор абонента
  cnt_:=0;
--  select t.id into root_id_
--   from spr_tarif t where t.cd='000';
  --кол-во л.с., использующих тариф
--  select nvl(count(*),0) into cnt2_ from nabor_progs n
--    where n.lsk=lsk_;

--  if cnt2_ = 0 then
  --если нет вообще программ в наборе, добавим корневой
--     insert into nabor_progs(lsk, usl, fk_tarif)
--     values (lsk_, usl_, root_id_);
--  end if;

  --если нет программы в наборе ???????????
--  select nvl(count(*),0) into cnt2_ from nabor_progs n
--    where n.lsk=lsk_ and n.fk_tarif=fk_tarif_;
  select nvl(count(*),0) into cnt2_ from nabor_progs n
    where n.lsk=lsk_ and n.fk_tarif=fk_tarif_;/* and exists
    (select * from
       spr_tarif s
       where s.id=n.fk_tarif
       start with s.id=fk_tarif_
       connect by s.parent_id=prior s.id)*/

  if cnt2_ = 0 then
     insert into nabor_progs(lsk, usl, fk_tarif, id_dvb)
     select lsk_, usl_, s.id, id_dvb_ from
       spr_tarif s
       where s.id=fk_tarif_;
/*     select decode(level, 1, root_id_, s.parent_id), lsk_, usl_, s.id from
       spr_tarif s
       start with s.id=fk_tarif_
       connect by s.parent_id=prior s.id;*/
  else
    --программа уже существует в наборе абонента
    cnt_:=1;
  end if;
--  commit;
  return cnt_;

end;

 function del_prog(lsk_ in nabor_progs.lsk%type, id_ in nabor_progs.fk_tarif%type)
 return number is
 cnt_ number;
begin
-- удаление пакета/программы в наборе абонента
   delete from nabor_progs n
      where n.lsk=lsk_ and n.fk_tarif=id_;
      /* and exists (select * from
       spr_tarif s
       where s.id=n.fk_tarif
       start with s.id=id_
       connect by s.parent_id=prior s.id)*/
   --удал€ем из набора корневую запись
   --если кроме неЄ нет больше записей
   select nvl(count(*),0) into cnt_ from
     nabor_progs n, spr_tarif s where n.lsk=lsk_ and
     s.id=n.fk_tarif and s.cd<>'000';

   if cnt_ = 0 then
     delete from nabor_progs n where n.lsk=lsk_;
   end if;

 return 0;
end;

 function del_prog(lsk_ in nabor_progs.lsk%type)
 return number is
 cnt_ number;
begin
-- удаление всех пакетов/программ из набора абонента
   delete from nabor_progs n
      where n.lsk=lsk_;
   --удал€ем из набора корневую запись
   delete from nabor_progs n where n.lsk=lsk_;

 return 0;
end;

FUNCTION find_unq_lsk(p_reu IN kart.reu%type, 
                      p_lsk in kart.lsk%type --рекоммендованый лиц.сч.
  ) RETURN VARCHAR2 IS
  l_i   NUMBER;
  l_cnt NUMBER;
  l_maxlsk kart.lsk%type;
  l_lsk kart.lsk%type; 
BEGIN
  --поиск уникальных лицевых, "дырок" в списке л/с по ” 
  if p_lsk is null then
    FOR c IN (SELECT DISTINCT (substr(k.lsk, 1, 4)) AS sbstr
        FROM kart k WHERE k.reu = p_reu 
        ORDER BY sbstr) LOOP
--      l_i := 0;
      for c2 in (with a as (select rownum rn, c.sbstr||lpad(rownum-1,4,'0') as lsk
                 from (select level from dual connect by level <= 10000) k ),
            b as (select k.lsk from kart k)

            select a.lsk from a left join b on a.lsk=b.lsk
                    and b.lsk like c.sbstr||'%' 
            where b.lsk is null        
            order by a.rn)
      loop
        return c2.lsk;
        exit; --нужен ли тут exit?))
      end loop;      

      --не было получено из первой 1000, попробовать получить из следующей 5000
      
    END LOOP;
  else 
  --по рекоммендованному лиц.счету
      select trim(max(k.lsk))  into l_maxlsk
        FROM kart k where k.reu=p_reu and k.lsk like p_lsk||'%';
      if l_maxlsk is null then  
        l_i := rpad(p_lsk,8,'0');
      else
        l_i := l_maxlsk;
      end if;  
      WHILE l_i <= 99999999 loop
        l_lsk:=lpad(to_char(l_i),8,'0');
        SELECT NVL(COUNT(*), 0)
          INTO l_cnt
          FROM kart k
         WHERE k.lsk = l_lsk;
        IF l_cnt = 0 and lpad(to_char(l_i),8,'0') <> '00000000' THEN
          RETURN lpad(to_char(l_i),8,'0');
        END IF;
        l_i := l_i + 1;
      END LOOP;
  
  end if;
  
  --не найдено, просто вз€ть последний из базы
   select lpad(max(lsk)+1,8,'0') into l_maxlsk from
     kart k;
  RETURN l_maxlsk;
END;

--добавить к существующему основному, -дополнительный лицевой счет -по дому
--(например дл€ капремонта)
--(ѕќ ј не используетс€ в программе, сделал дл€ автоматизации добавлени€) ред.04.03.15
procedure kart_lsk_ext_add_house(p_house in kart.house_id%type) is
  a number;
begin
  for c in (select k.lsk from kart k where k.house_id=p_house and k.psch not in (8,9)) 
  loop
    --создать по каждому л.с.      
    a:=kart_lsk_ext_add(c.lsk, null);
  end loop;
  commit;
end;

--добавить к существующему основному, -дополнительный лицевой счет
--(например дл€ капремонта)
function kart_lsk_ext_add(p_lsk in kart.lsk%type, p_lsk_new in kart.lsk%type) return number is
  l_lsk kart.lsk%type;
  l_reu kart.reu%type;
  l_klsk kart.k_lsk_id%type;
  l_cnt number;
begin
  select t.reu, t.k_lsk_id into l_reu, l_klsk from kart t where t.lsk=p_lsk;

  if p_lsk_new is null then
    l_lsk:=find_unq_lsk(l_reu, null);
  else
    l_lsk:=trim(p_lsk_new);
  end if;
  
  begin
    select 1 into l_cnt
     from dual where regexP_like(l_lsk,'[[:digit:]]{8}')
     and length(l_lsk)=8
     and not exists (select * from kart k where k.lsk=l_lsk);
  exception
    when no_data_found then
      return 1; --формат лиц.счета не соответствует требовани€м
  end;
    
  --выполнить проверку на наличие открытого дополнительного счета
  select count(*) into l_cnt from kart k, params p, v_lsk_tp tp
   where k.fk_tp=tp.id and p.period between k.mg1 and k.mg2
   and k.k_lsk_id=l_klsk and k.psch not in (8,9)
   and tp.cd='LSK_TP_ADDIT';
  if l_cnt > 0 then
     rollback;
     return 4; 
--   Raise_application_error(-20000, 'ѕо данному лиц.счету уже существует дополнительный');
  end if;
  
  insert into kart k (lsk, reu, kul, nd, kw, k_fam, k_im, k_ot, psch, 
    status, kfg, kfot, house_id, k_lsk_id, c_lsk_id, mg1, mg2, fk_tp, kpr, kpr_wr, 
     kpr_ot, opl)
  select l_lsk, k.reu, k.kul, k.nd, k.kw, k.k_fam, k.k_im, k.k_ot,
    k.psch, k.status, 2 as kfg, 2 as kfot, k.house_id, k.k_lsk_id, k.c_lsk_id, 
    p.period as mg1, '999999' as mg2, tp.id as fk_tp, 0 as kpr, 0 as kpr_wr,
     0 as kpr_ot, k.opl
    from kart k, params p, v_lsk_tp tp
    where k.lsk=p_lsk
    and tp.cd='LSK_TP_ADDIT';
  if sql%rowcount=0 then
     rollback;
     return 3; 
--   Raise_application_error(-20000, 'ƒобавление произошло неудачно, лиц.счет не добавлен!');
  end if;   

  --обновить квартиросъемщика
--  update kart k set k.fio=(select t.fio from kart t where t.lsk=p_lsk)
--    where k.lsk=l_lsk;

--¬–≈ћяЌ ј!!! (hard code org=xxx and koeff!)
  begin
  insert into nabor
  (lsk, usl, org, koeff, norm)
   select l_lsk, u.usl, 801 as org, 1.18182 as koeff, null as norm
    from usl u where u.cd='кап.';

   if sql%rowcount=0 then
     rollback;
     return 2; --не добавлены услуги
   end if;  
  exception
    when no_data_found then
      rollback;
      return 2; --не добавлены услуги
  end;     
  --удалить в старом лиц.счете
  delete from nabor n
     where n.lsk=p_lsk and exists (select * from usl u where u.usl=n.usl and u.cd in ('кап.', 'кап/св.нор'));     

   
return 0;   
end;

procedure set_g_lsk_tp(p_tp in number) is
begin
  --установить глоб переменную
  g_sel_lsk_tp:=p_tp;
end;
  
function get_g_lsk_tp return number is
begin
  --прочитать глоб переменную
  if g_sel_lsk_tp is null then
     Raise_application_error(-20000, 'Ќе установленна глоб.перменна€ g_sel_lsk_tp!');
  end if;
  return g_sel_lsk_tp;
end;

--получить открытые лицевые счета которые прив€заны к основому (дополнительному) счету, включа€ вход€щий лицевой счет
function get_other_lsk(p_lsk in kart.lsk%type) return tab_lsk is
 l_lsk kart.lsk%type;
 t_lsk tab_lsk;
begin
  select rec_lsk(k.lsk) bulk collect into t_lsk from kart k
   where exists (select * from kart t where t.lsk=p_lsk 
     and t.k_lsk_id=k.k_lsk_id and t.psch not in (8,9));
  return t_lsk;                        

end;


end P_HOUSES;
/

prompt
prompt Creating package body P_VVOD
prompt ============================
prompt
create or replace package body scott.p_vvod is

  procedure gen_dist(p_klsk           in c_vvod.fk_k_lsk%type,
                     p_dist_tp        in c_vvod.dist_tp%type,
                     p_usl            in c_vvod.usl%type,
                     p_use_sch        in out c_vvod.use_sch%type,
                     p_old_use_sch    in c_vvod.use_sch%type,
                     p_kub_nrm_fact   in out c_vvod.kub_nrm_fact%type,
                     p_kub_sch_fact   in out c_vvod.kub_sch_fact%type,
                     p_kub_ar_fact    in out c_vvod.kub_ar_fact%type,
                     p_kub_ar         in out c_vvod.kub_ar%type,
                     p_opl_ar         in out c_vvod.opl_ar%type,
                     p_kub_sch        in out c_vvod.kub_sch%type,
                     p_sch_cnt        in out c_vvod.sch_cnt%type,
                     p_sch_kpr        in out c_vvod.sch_kpr%type,
                     p_kpr            in out c_vvod.kpr%type,
                     p_cnt_lsk        in out c_vvod.cnt_lsk%type,
                     p_kub_norm       in out c_vvod.kub_norm%type,
                     p_kub_fact       in out c_vvod.kub_fact%type,
                     p_kub_man        in out c_vvod.kub_man%type,
                     p_kub            in c_vvod.kub%type,
                     p_edt_norm       in c_vvod.edt_norm%type,
                     p_kub_dist       out c_vvod.kub%type,
                     p_id             in c_vvod.id%type,
                     p_opl_add        in out c_vvod.opl_add%type,
                     p_house_id       in c_vvod.house_id%type,
                     p_old_kub        in c_vvod.kub%type,
                     p_limit_proc     in c_vvod.limit_proc%type,
                     p_old_limit_proc in c_vvod.limit_proc%type,
                     p_gen_part_kpr   in number, --пересчитывать ли доли проживающих (обычно из триггера) (и начисление)
                     p_wo_limit       in c_vvod.wo_limit%type) is
    type rec_sch is record(
      kub_sch number,
      cnt     number,
      kpr     number,
      opl     number);
    type rec_norm is record(
      kub_norm number,
      cnt_lsk  number,
      kpr      number,
      opl      number);
    type rec_ is record(
      kub_sch number,
      cnt     number,
      kpr_sch number);
  
    type rec_cnt is record(
      vol     number,
      vol_add number);
  
    type rec_norm2 is record(
      cnt number,
      kpr number);
  
    type rec_ar_sch is record( --јрендаторы
      kub number,
      cnt number,
      opl number);
  
    rec_sch_     rec_sch;
    rec_cnt_     rec_cnt;
    rec_norm_    rec_norm;
    rec_ar_sch_  rec_ar_sch;
    kub_rec_     rec_;
    kpr_rec_     rec_norm2;
    koeff_       number;
    fk_calc_tp_  number;
    sptarn_      number;
    use_sch_     number; --”—“ј–≈¬ј≈“, ”ƒјЋ»“№ ѕќ—Ћ≈ 15.10.12
    otop_        number;
    tp_          number;
    dist_tp_     number;
    all_kub_     number;
    all_opl_     number;
    all_kpr_     number;
    fk_usl_chld_ usl.usl%type;
    l_proc       number;
    l_dist_vl    number;
    l_nbalans    number;
    l_vol        number; --временна€ переменна€ дл€ распр.экономии
    l_lsk_round  nabor.lsk%type; --временные переменные дл€ округлени€ небаланса
    l_vol_round  number; --временные переменные дл€ округлени€ небаланса
    l_flag       number;
    l_limit_vol  number; --допустимый лимит ќƒЌ по законодательству (общий)
  
    l_area_prop  number; --площадь общего имущества дома
    l_rate       number; --норматив по ќƒЌ
    l_limit_area number; --допустимый лимит ќƒЌ на 1 м2
  
    l_opl_man   number; -- площадь на одного проживающего на 1 чел., дл€ расчета ограничени€
    l_opl_liter number; --кол-во литров на метр2 по таблице, дл€ расчета ограничени€
    l_usl_cd    usl.cd%type;
    l_cnt       number;
    --переменна€ дл€ округлени€
    l_for_round number;
    l_time date;
    l_odn_nrm number; --ограничение по ќƒЌ (еще называют нормативом)
    cursor cur1 is --курсор дл€ расчета экономии
      select k.lsk,
             case
               when nvl(all_kpr_, 0) <> 0 then
                round(nvl((p_kub_dist - all_kub_) / all_kpr_, 0) *
                      (nvl(d.kpr2, 0) +
                       decode(use_sch_, 1, nvl(f.kpr2, 0), 0)),
                      3)
               else
                null
             end as dist_vl,
             
             f.vol as vol_add, --объем по счетчику
             d.vol as vol, --объем по нормативу
             nvl(f.vol, 0) + nvl(d.vol, 0) as lsk_vl --общий объем
        from kart k, nabor n, c_charge_prep f, c_charge_prep d
       where k.lsk = n.lsk
         and n.lsk = f.lsk(+)
         and n.usl = f.usl(+)
         and f.tp(+) = 6 --итог по счетчику итог без ќƒЌ
         and f.sch(+) = 1
         and n.lsk = d.lsk(+)
         and n.usl = d.usl(+)
         and d.tp(+) = 6 --итог по нормативу итог без ќƒЌ
         and d.sch(+) = 0
         and n.fk_vvod = p_id
         and n.usl = p_usl
         and k.psch not in (8, 9)
         and nvl(f.vol, 0) + nvl(d.vol, 0) > 0; --там, где вообще есть объемы > 0
  
    cursor cur2 is --курсор дл€ расчета экономии, без счетчиков
      select k.lsk,
             round(nvl((p_kub_dist - all_kub_) / all_kpr_, 0) *
                   nvl(d.kpr2, 0),
                   3) as dist_vl,
             0 as vol_add, --объем по счетчику (нельз€ NULL - логика мен€етс€)
             d.vol as vol, --объем по нормативу
             nvl(d.vol, 0) as lsk_vl --общий объем
        from kart k, nabor n, c_charge_prep d
       where k.lsk = n.lsk
         and n.lsk = d.lsk(+)
         and n.usl = d.usl(+)
         and d.tp(+) = 6 --итог по нормативу итог без ќƒЌ
         and d.sch(+) = 0
         and n.fk_vvod = p_id
         and n.usl = p_usl
         and k.psch not in (8, 9)
         and nvl(d.vol, 0) > 0 --там, где вообще есть объемы > 0
         and not exists (select *
                from c_charge_prep e
               where n.lsk = e.lsk
                 and n.usl = e.usl
                 and e.tp = 7 --где нет наличи€ счетчика в тек.периоде
                 and e.sch = 1);
  
    cursor cur3 is --курсор дл€ расчета экономии, либо по арендаторам, либо чтобы кто то проживал
      select k.lsk,
             round(nvl((p_kub_dist - all_kub_) / all_kpr_, 0) *
                   (nvl(d.kpr2, 0) + decode(use_sch_, 1, nvl(f.kpr2, 0), 0)),
                   3) as dist_vl,
             
             f.vol as vol_add, --объем по счетчику
             d.vol as vol, --объем по нормативу
             nvl(f.vol, 0) + nvl(d.vol, 0) as lsk_vl --общий объем
        from kart k, nabor n, c_charge_prep f, c_charge_prep d
       where k.lsk = n.lsk
         and n.lsk = f.lsk(+)
         and n.usl = f.usl(+)
         and f.tp(+) = 6 --итог по счетчику итог без ќƒЌ
         and f.sch(+) = 1
         and n.lsk = d.lsk(+)
         and n.usl = d.usl(+)
         and d.tp(+) = 6 --итог по нормативу итог без ќƒЌ
         and d.sch(+) = 0
         and n.fk_vvod = p_id
         and n.usl = p_usl
         and k.psch not in (8, 9)
         and nvl(f.vol, 0) + nvl(d.vol, 0) > 0 --там, где вообще есть объемы > 0
         and (k.status = 9 or exists
              (select *
                 from c_charge_prep e
                where k.lsk = e.lsk
                  and e.usl = p_usl
                  and e.tp = 6 --итог без ќƒЌ
                  and e.kpr2 <> 0));
    rec cur1%rowtype;
  begin
 
    --распределение воды по вводу с поддержкой последней редакции 307 постановлени€ от 06.05.11
    --(редакци€ приложени€ є 3) вз€то из http://www.consultant.ru/online/base/?req=doc;base=LAW;n=114247;p=7
    --»—ѕќЋ№«ќ¬ј“№ “јЅЋ»÷” C_VVOD ¬ «јѕ–ќ—ј’ в данном триггере - Ќ≈Ћ№«я, “ј   ј  ќЌј ћ”“»–”≈“
      
    --ќѕ–≈ƒ≈Ћ≈Ќ»≈:
    --«апись в таблице C_VVOD означает один, общий счетчик,
    --остальные счетчики (например подъездные) должны быть прикреплены к основному через PARENT_ID
    --(пока не реализовано)
    --TO DO: ¬нести зависимость от обновлени€ параметра площади общего имущества по дому (выполн€ть перерасчет)
    --сделать, начина€ с 01.07.2013
  
    l_time:=sysdate;
    p_kub_dist := p_kub;
  
    --тип распределени€ по вводу
    dist_tp_ := nvl(p_dist_tp, 0);
  
    --рассчитать доли объемов, проживающих, дл€ использовани€ в распределении
    --только в тех л.с, которые принадлежат вводу
    if p_gen_part_kpr = 1 then
      c_kart.set_part_kpr_vvod(p_id);
    end if;
  
    --вид расчета услуги
    select nvl(u.fk_calc_tp, 0), u.fk_usl_chld, u.cd
      into fk_calc_tp_, fk_usl_chld_, l_usl_cd
      from usl u
     where u.usl = p_usl;
    select nvl(u.sptarn, 0) into sptarn_ from usl u where u.usl = p_usl;
  
    --использовать ли счетчики при распределении объема х.в., г.в. (1-да, 0 - нет)
    use_sch_ := nvl(p_use_sch, 0);
  
    select case
             when substr(p.period, 5, 2) between to_char(p.dt_otop1, 'MM') and
                  to_char(p.dt_otop2, 'MM') then
              1
             else
              0
           end
      into otop_
      from params p;
  
    if fk_calc_tp_ in (3, 17, 4, 18, 31, 38, 40) then
      if fk_calc_tp_ in (3, 17, 38) then
        tp_ := 0; --х.в.
      elsif fk_calc_tp_ in (4, 18, 40) then
        tp_ := 1; --г.в.
      elsif fk_calc_tp_ in (31) then
        tp_ := 2; --эл.эн.
      end if;
    
      --ред.от
      --сумма кубов ’.¬./√.¬. по счетчикам, кол-во счетчиков, кол-во людей, площадь
      ---------------------------------------------------
      --------—Ѕќ– »Ќ‘ќ–ћј÷»» ƒЋя –ј—„≈“ј ќƒЌ------------
    
      if nvl(p_kub, 0) <> 0.001 then
        --p_kub <> 0.001
        --подсчет итогов
        select nvl(sum(e.vol), 0) as kub_sch,
               nvl(count(k.lsk), 0) as cnt,
               nvl(sum(e.kpr2), 0) as kpr_sch,
               nvl(sum(k.opl), 0) as opl
          into rec_sch_
          from kart k, nabor n, c_charge_prep e
         where k.lsk = n.lsk
           and k.lsk = e.lsk
           and n.fk_vvod = p_id
           and n.usl = e.usl
           and n.usl = p_usl
           and k.psch not in (8, 9)
           and e.sch = 1 --счетчики
           and e.tp = 6 --итог без ќƒЌ
           and k.status not in (9) /*без јрендаторов*/
           and exists (select *
                  from nabor r
                 where r.lsk = n.lsk --там где есть услуга ќƒЌ
                   and r.usl = fk_usl_chld_);
      
        p_kub_sch := rec_sch_.kub_sch;
        p_sch_cnt := rec_sch_.cnt;
        p_sch_kpr := rec_sch_.kpr;
      
        --кол-во кубов, людей по нормативу, кол-во лицевых, площадь
        select nvl(sum(e.vol), 0) as kub_norm,
               nvl(count(k.lsk), 0) as cnt,
               nvl(sum(e.kpr2), 0) as kpr,
               nvl(sum(k.opl), 0) as opl
          into rec_norm_
          from kart k, nabor n, c_charge_prep e
         where k.lsk = n.lsk
           and k.lsk = e.lsk
           and n.fk_vvod = p_id
           and n.usl = e.usl
           and n.usl = p_usl
           and k.psch not in (8, 9)
           and e.sch = 0 --нормативщики
           and e.tp = 6 --итог без ќƒЌ
           and k.status not in (9) /*без јрендаторов*/
           and exists (select *
                  from nabor r
                 where r.lsk = n.lsk --там где есть услуга ќƒЌ
                   and r.usl = fk_usl_chld_);
      
        p_kub_norm := rec_norm_.kub_norm;
        p_cnt_lsk  := rec_norm_.cnt_lsk;
        p_kpr      := rec_norm_.kpr;
      
        --общее кол-во прожив.
        if use_sch_ = 1 then
          all_kpr_ := rec_norm_.kpr + rec_sch_.kpr;
        else
          all_kpr_ := rec_norm_.kpr;
        end if;
        --кол-во кубов, кол-во лицевых, площадь по арендаторам (дл€ пост.354)
        --ёр.лица(арендаторы)
      
        select nvl(sum(e.vol), 0) as ar_kub_sch,
               nvl(count(k.lsk), 0) as ar_cnt,
               nvl(sum(k.opl), 0) as ar_opl
          into rec_ar_sch_
          from kart k, nabor n, c_charge_prep e
         where k.lsk = n.lsk
           and k.lsk = e.lsk
           and n.fk_vvod = p_id
           and n.usl = e.usl
           and n.usl = p_usl
           and k.psch not in (8, 9)
           and e.sch = 1 --счетчики
           and e.tp = 6 --итог без ќƒЌ
           and k.status in (9) /*јрендаторы*/
           and exists (select *
                  from nabor r
                 where r.lsk = n.lsk --там где есть услуга ќƒЌ
                   and r.usl = fk_usl_chld_);
      
        --объем арендаторов
        p_kub_ar := rec_ar_sch_.kub;
      
        --площадь арендаторов
        p_opl_ar := rec_ar_sch_.opl;
      
        --суммируем расход по вводу
        all_kub_ := rec_sch_.kub_sch + rec_norm_.kub_norm + rec_ar_sch_.kub;
      
        --суммируем площадь по вводу
        if dist_tp_ <> 3 and use_sch_ = 1 then
          --либо в т.ч. счетчики
          select nvl(sum(k.opl), 0)
            into all_opl_
            from kart k, nabor n
           where k.lsk = n.lsk
             and n.fk_vvod = p_id
             and n.usl = p_usl
             and k.psch not in (8, 9)
             and exists (select *
                    from nabor r
                   where r.lsk = n.lsk --там где есть услуга ќƒЌ
                     and r.usl = fk_usl_chld_);
        
        elsif dist_tp_ <> 3 and use_sch_ = 0 then
          --либо чтобы Ќ≈ были в этом периоде счетчики
          select nvl(sum(k.opl), 0)
            into all_opl_
            from kart k, nabor n
           where k.lsk = n.lsk
             and n.fk_vvod = p_id
             and n.usl = p_usl
             and k.psch not in (8, 9)
             and not exists (select *
                    from c_charge_prep e
                   where n.lsk = e.lsk
                     and n.usl = e.usl
                     and e.tp = 7 --наличие счетчика в тек.периоде
                     and e.sch = 1)
             and exists (select *
                    from nabor r
                   where r.lsk = n.lsk --там где есть услуга ќƒЌ
                     and r.usl = fk_usl_chld_);
        elsif dist_tp_ = 3 then
          --если тип распр.=3 то либо арендатор, либо должен кто-то быть прописан
          select nvl(sum(k.opl), 0)
            into all_opl_
            from kart k, nabor n
           where k.lsk = n.lsk
             and n.fk_vvod = p_id
             and n.usl = p_usl
             and k.psch not in (8, 9)
             and (k.status = 9 or exists
                  (select *
                     from c_charge_prep e
                    where k.lsk = e.lsk
                      and e.usl = p_usl
                      and e.tp = 6 --итог без ќƒЌ
                      and e.kpr2 <> 0))
             and exists (select *
                    from nabor r
                   where r.lsk = n.lsk --там где есть услуга ќƒЌ
                     and r.usl = fk_usl_chld_);
        end if;
      
        p_opl_add := all_opl_;
      
        ---------------------------------------------------
        --------ќ√–јЌ»„≈Ќ»≈ ѕќ ќƒЌ-------------------------
        if nvl(p_wo_limit, 0) = 0 then
          l_limit_vol := 0;
          begin
            if all_opl_ > 0 and all_kpr_ > 0 then
              --площадь > 0 и кол-во прожив > 0
            
              --ограничение ќƒЌ, дл€ поиска по таблице (округл. до целых)
              if tp_ in (0, 1) then
                --х.в. и г.в.
                l_opl_man   := round(all_opl_ / all_kpr_);
                l_opl_liter := opl_liter(l_opl_man);
                l_limit_vol := l_opl_liter / 1000 * all_opl_;
                --лимит на площадь
                l_limit_area := l_opl_liter / 1000;
                if p_dist_tp <> 2 then --кроме вводов, где нет услуги ќƒЌ (ввод должен быть)
                  l_odn_nrm:=l_opl_liter;
                else
                  l_odn_nrm:=null;
                end if;
              elsif tp_ = 2 then
                --эл.эн.
                --по эл.эн. - по особенному
                --дом без лифта = площадь общего имущества * 2.7 квт.
                begin
                  --площадь общ.имущ., норматив, объем на площадь
                  select x.n1, 2.7, nvl(round(x.n1 * 2.7, 4), 0)
                    into l_area_prop, l_rate, l_limit_vol
                    from t_objxpar x, v_house_pars u, c_houses h
                   where x.fk_list = u.id
                     and x.fk_k_lsk = h.k_lsk_id
                     and h.id = p_house_id
                     and u.cd = 'area_general_property'
                     and not exists
                   (select *
                            from t_objxpar x, v_house_pars u, c_houses h
                           where x.fk_list = u.id
                             and x.fk_k_lsk = h.k_lsk_id
                             and h.id = p_house_id
                             and u.cd = 'exist_lift'
                             and nvl(x.n1, 0) = 1
                          
                          );
                  l_odn_nrm:=2.7;
                
                  /*            and not exists  --убрал, так как есть такие дома, где лифт сидит в текущем содержании! ( ис)
                  (select * from kart k, nabor n, usl u where k.house_id=h.id
                      and k.lsk=n.lsk
                      and n.usl=u.usl
                      and u.cd in ('лифт')
                      and c_kart.get_is_chrg(u.sptarn, n.koeff, n.norm)=1
                      );*/
                exception
                  when no_data_found then
                    l_limit_vol := 0;
                end;
              
                if l_limit_vol = 0 then
                  --значит дом с лифтом
                  begin
                    --площадь общ.имущ., норматив, объем на площадь
                    select x.n1, 4.1, nvl(round(x.n1 * 4.1, 4), 0)
                      into l_area_prop, l_rate, l_limit_vol
                      from t_objxpar x, v_house_pars u, c_houses h
                     where x.fk_list = u.id
                       and x.fk_k_lsk = h.k_lsk_id
                       and h.id = p_house_id
                       and u.cd = 'area_general_property'
                       and exists
                     (select *
                              from t_objxpar x, v_house_pars u, c_houses h
                             where x.fk_list = u.id
                               and x.fk_k_lsk = h.k_lsk_id
                               and h.id = p_house_id
                               and u.cd = 'exist_lift'
                               and nvl(x.n1, 0) = 1
                            
                            );
                    /*                and exists
                    (select * from kart k, nabor n, usl u where k.house_id=h.id
                        and k.lsk=n.lsk
                        and n.usl=u.usl
                        and u.cd in ('лифт')
                        and c_kart.get_is_chrg(u.sptarn, n.koeff, n.norm)=1
                        );*/
                  exception
                    when no_data_found then
                      l_limit_vol := 0;
                  end;
                end if;
              
              end if;
            
            else
              l_limit_vol := 0;
            end if;
          exception
            when no_data_found then
              l_limit_vol := 0;
          end;
        
          if nvl(p_limit_proc, 0) <> 0 then
            --если установлено ограничение по доначислению ќƒЌ в %
            --¬ариант 2 расчета предельно допустимого объема ќƒЌ
            if p_kub >
               round(all_kub_ + p_kub / 100 * nvl(p_limit_proc, 0), 3) then
              --установить предельно допустимый объем по дому
              p_kub_dist := round(all_kub_ +
                                  p_kub / 100 * nvl(p_limit_proc, 0),
                                  3);
            end if;
          elsif l_limit_vol > 0 and tp_ in (0, 1, 2) then
            --только дл€ услуг х.в. и г.в. и эл.эн.
            --¬ариант ограничени€ ќƒЌ по формуле администрации
            if p_kub > round(all_kub_ + l_limit_vol, 3) then
              --установить предельно допустимый объем по дому
              p_kub_dist := round(all_kub_ + l_limit_vol, 3);
            end if;
          end if;
          ---------------------------------------------------
          --------ќ√–јЌ»„≈Ќ»≈ ѕќ ќƒЌ-------------------------
        end if;
      end if;
    
      ---------------------------------------------------
      --------—Ѕќ– »Ќ‘ќ–ћј÷»» ƒЋя –ј—„≈“ј ќƒЌ------------
    
      if nvl(p_kub_dist, 0) = 0.001 then
        p_kub_sch  := null;
        p_sch_cnt  := null;
        p_sch_kpr  := null;
        p_kub_norm := null;
        p_kpr      := null;
        p_cnt_lsk  := null;
        p_kub_ar   := null;
        p_opl_ar   := null;
        p_opl_ar   := null;
      end if;
    
      ---ќ„»—“ ј »Ќ‘ќ–ћј÷»» ќƒЌ-------------------------
      gen_clear_odn(p_usl      => p_usl,
                    p_usl_chld => fk_usl_chld_,
                    p_house    => null,
                    p_vvod     => p_id);
    
      if all_kub_ = 0 and p_kub_dist <> 0.001 then
        --p_kub <> 0.001
        --чтобы предотвратить ошибку деление на ноль
        null;
      else
        if dist_tp_ in (1, 2, 3) then
          --–ј—ѕ–≈ƒ≈Ћ≈Ќ»≈ пропорционально площади,объему (307, 354 пост.)
          if nvl(p_kub_dist, 0) <> 0 and p_kub_dist - all_kub_ <> 0 then
            ---------------------------------------------------
            --------–ј—ѕ–≈ƒ≈Ћ≈Ќ»≈ ќƒЌ--------------------------
            --если есть небаланс то дораспредел€ем
            if dist_tp_ in (1, 3) then
              if p_kub_dist - all_kub_ > 0 then
                --доначисление пропорционально площади (в т.ч.арендаторы), если небаланс > 0
                if dist_tp_ <> 3 and use_sch_ = 1 then
                  --либо в т.ч. счетчики
                  update nabor k
                     set k.vol_add = round((select t.opl
                                              from kart t
                                             where t.lsk = k.lsk) *
                                           (p_kub_dist - all_kub_) /
                                           (all_opl_),
                                           3),
                         k.limit   = round((select case
                                                    when tp_ in (0, 1) then
                                                     l_limit_area * t.opl --лимит ќƒЌ по л/с. г.в.,х.в.
                                                    when tp_ = 2 then
                                                     l_rate * l_area_prop *
                                                     t.opl / all_opl_ --лимит ќƒЌ по л/с. Ёл.эн.
                                                    else
                                                     null
                                                  end as limit
                                             from kart t
                                            where t.lsk = k.lsk),
                                           3)
                   where k.usl = fk_usl_chld_
                     and exists (select *
                            from kart t, nabor n
                           where k.lsk = t.lsk
                             and t.lsk = n.lsk
                             and nvl(t.opl, 0) <> 0 --где есть площадь
                             and t.psch not in (8, 9)
                             and n.usl = p_usl
                             and n.fk_vvod = p_id);
                  -- commit;
                  -- Raise_application_error(-20000, l_limit_area||'-'||l_rate||'-'||l_area_prop||'-'||all_opl_);
                
                elsif dist_tp_ <> 3 and use_sch_ = 0 then
                  --либо чтобы Ќ≈ были в этом периоде счетчики
                  update nabor k
                     set k.vol_add = round((select t.opl
                                              from kart t
                                             where t.lsk = k.lsk) *
                                           (p_kub_dist - all_kub_) /
                                           (all_opl_),
                                           3),
                         k.limit   = round((select case
                                                    when tp_ in (0, 1) then
                                                     l_limit_area * t.opl --лимит ќƒЌ по л/с. г.в.,х.в.
                                                    when tp_ = 2 then
                                                     l_rate * l_area_prop *
                                                     t.opl / all_opl_ --лимит ќƒЌ по л/с. Ёл.эн.
                                                    else
                                                     null
                                                  end as limit
                                             from kart t
                                            where t.lsk = k.lsk),
                                           3)
                   where k.usl = fk_usl_chld_
                     and exists
                   (select *
                            from kart t, nabor n
                           where k.lsk = t.lsk
                             and t.lsk = n.lsk
                             and nvl(t.opl, 0) <> 0 --где есть площадь
                             and t.psch not in (8, 9)
                             and n.usl = p_usl
                             and n.fk_vvod = p_id
                             and not exists (select *
                                    from c_charge_prep e
                                   where n.lsk = e.lsk
                                     and n.usl = e.usl
                                     and e.tp = 7 --наличие счетчика в тек.периоде
                                     and e.sch = 1));
                elsif dist_tp_ = 3 then
                  --если тип распр.=3 то либо арендатор, либо должен кто-то быть прописан
                  update nabor k
                     set k.vol_add = round((select t.opl
                                              from kart t
                                             where t.lsk = k.lsk) *
                                           (p_kub_dist - all_kub_) /
                                           (all_opl_),
                                           3),
                         k.limit   = round((select case
                                                    when tp_ in (0, 1) then
                                                     l_limit_area * t.opl --лимит ќƒЌ по л/с. г.в.,х.в.
                                                    when tp_ = 2 then
                                                     l_rate * l_area_prop *
                                                     t.opl / all_opl_ --лимит ќƒЌ по л/с. Ёл.эн.
                                                    else
                                                     null
                                                  end as limit
                                             from kart t
                                            where t.lsk = k.lsk),
                                           3)
                   where k.usl = fk_usl_chld_
                     and exists (select *
                            from kart t, nabor n
                           where k.lsk = t.lsk
                             and t.lsk = n.lsk
                             and nvl(t.opl, 0) <> 0 --где есть площадь
                             and t.psch not in (8, 9)
                             and n.usl = p_usl
                             and n.fk_vvod = p_id
                             and (t.status = 9 or exists
                                  (select *
                                     from c_charge_prep e
                                    where t.lsk = e.lsk
                                      and e.usl = p_usl
                                      and e.tp = 6 --итог без ќƒЌ
                                      and e.kpr2 <> 0)));
                end if;
              
                --добавить инфу по ќƒЌ.
                insert into c_charge
                  (lsk, usl, test_opl, type)
                  select k.lsk,
                         fk_usl_chld_,
                         k.vol_add    as test_opl,
                         5            as type
                    from nabor k
                   where k.usl = fk_usl_chld_
                     and nvl(k.vol_add, 0) <> 0
                     and exists (select *
                            from nabor n
                           where n.lsk = k.lsk
                             and n.usl = p_usl
                             and n.fk_vvod = p_id);
              else
                --сн€тие(экономи€) пропорционально кол-ва проживающих, если небаланс < 0
                --но не более потребленного объема
                --            Raise_application_error(-20000, all_kpr_||'-'||p_kub - all_kub_);
              
                if dist_tp_ <> 3 and use_sch_ = 1 then
                  --либо в т.ч. счетчики
                  open cur1;
                elsif dist_tp_ <> 3 and use_sch_ = 0 then
                  --либо чтобы Ќ≈ были в этом периоде счетчики
                  open cur2;
                elsif dist_tp_ = 3 then
                  --если тип распр.=3 то либо арендатор, либо должен кто-то быть прописан
                  open cur3;
                end if;
                loop
                  if dist_tp_ <> 3 and use_sch_ = 1 then
                  
                    fetch cur1
                      into rec;
                    exit when cur1%notfound;
                  elsif dist_tp_ <> 3 and use_sch_ = 0 then
                    fetch cur2
                      into rec;
                    exit when cur2%notfound;
                  elsif dist_tp_ = 3 then
                    fetch cur3
                      into rec;
                    exit when cur3%notfound;
                  end if;
                  --а вот снимаем как раз не по дочерней услуге (ќƒЌ) а по основной...
                  --ред 02.10.12
                  l_proc := rec.vol_add / rec.lsk_vl; --дол€ счетчика в объеме
                  l_vol  := 0;
                  if l_proc > 0 then
                    if abs(l_proc * rec.dist_vl) > rec.vol_add then
                      l_vol := round(l_proc * rec.vol_add, 3); --если ABS(распределенный небаланс) > расход
                    elsif abs(l_proc * rec.dist_vl) <= rec.vol_add then
                      l_vol := abs(round(l_proc * rec.dist_vl, 3)); --если ABS(распределенный небаланс) < расход
                    end if;
                    --установить лимит ќƒЌ дл€ статистики
                    update nabor n
                       set n.limit = round((select case
                                                    when tp_ in (0, 1) then
                                                     l_limit_area * t.opl --лимит ќƒЌ по л/с. г.в.,х.в.
                                                    when tp_ = 2 then
                                                     l_rate * l_area_prop *
                                                     t.opl / all_opl_ --лимит ќƒЌ по л/с. Ёл.эн.
                                                    else
                                                     null
                                                  end as limit
                                             from kart t
                                            where t.lsk = n.lsk),
                                           3)
                     where n.lsk = rec.lsk
                       and n.usl = fk_usl_chld_;
                  
                    --экономи€ распред.на счетчики
                    if l_vol > 0 then
                      --добавить инфу по ќƒЌ.
                      insert into c_charge_prep
                        (lsk, usl, vol, sch, tp)
                      values
                        (rec.lsk, p_usl, -1 * l_vol, 1, 4);
                    
                      insert into c_charge
                        (lsk, usl, test_opl, type)
                      values
                        (rec.lsk, fk_usl_chld_, -1 * l_vol, 5);
                    elsif l_vol < 0 then
                      raise_application_error(-20000,
                                              'Ќедопустимый объем распр.счетчиков в Ћ/—:' ||
                                              rec.lsk || ' ' || l_vol);
                    end if;
                  elsif l_proc < 0 then
                    raise_application_error(-20000,
                                            'Ќедопустимый % распределени€ в Ћ/—:' ||
                                            rec.lsk || ' ' || l_proc);
                  end if;
                  --остаток от объема дл€ распределени€
                  --экономи€ распред.на норматив
                  l_dist_vl := abs(rec.dist_vl) - l_vol;
                  if l_dist_vl > 0 and rec.vol > 0 then
                    --если осталась экономи€ и есть объем по нормативу
                    insert into c_charge_prep
                      (lsk, usl, vol, sch, tp)
                    values
                      (rec.lsk,
                       p_usl,
                       -1 * case when l_dist_vl > rec.vol then rec.vol --если ABS(распределенный небаланс) > расход
                       when l_dist_vl <= rec.vol then l_dist_vl --если ABS(распределенный небаланс) < расход
                       end,
                       0,
                       4);
                  
                    --добавить инфу по ќƒЌ.
                    --совместить с основным распр.
                    insert into c_charge
                      (lsk, usl, test_opl, type)
                    values
                      (rec.lsk,
                       fk_usl_chld_,
                       -1 * case when l_dist_vl > rec.vol then rec.vol --если ABS(распределенный небаланс) > расход
                       when l_dist_vl <= rec.vol then l_dist_vl --если ABS(распределенный небаланс) < расход
                       end,
                       5);
                  elsif l_dist_vl < 0 then
                    raise_application_error(-20000,
                                            'Ќедопустимый объем распр.остатка на норматив в Ћ/—:' ||
                                            rec.lsk || ' ' || l_dist_vl);
                  end if;
                end loop;
                if dist_tp_ <> 3 and use_sch_ = 1 then
                  --либо в т.ч. счетчики
                  close cur1;
                elsif dist_tp_ <> 3 and use_sch_ = 0 then
                  --либо чтобы Ќ≈ были в этом периоде счетчики
                  close cur2;
                elsif dist_tp_ = 3 then
                  --если тип распр.=3 то либо арендатор, либо должен кто-то быть прописан
                  close cur3;
                end if;
              
              end if;
            
            elsif dist_tp_ = 2 then
              --доначисление пропорционально потреб. объему
              --код не поддерживаетс€ 22.04.14
              raise_application_error(-20000,
                                      'Error #2-код не поддерживаетс€');
            
              /*             update nabor k
                             set k.vol_add = --доначисление по нормативщику, счетчику небаланс, (+ или -)
                                   round((select nvl(sum(t.vol),0)
                                         from c_charge_prep t where t.lsk = k.lsk --уже базируетс€ на сделанном распр.выше
                                          and t.usl=p_usl
                                          and t.tp=6 --итог без ќƒЌ
                                          )/(all_kub_) * (p_kub_dist - all_kub_) ,
                                         3)
                           where k.usl = fk_usl_chld_
                                  and k.fk_vvod = p_id
                                      and (use_sch_ = 1 or use_sch_ = 0 and not exists
                                      (select * from nabor n, c_charge_prep e where
                                        k.lsk=e.lsk --либо в т.ч. счетчики, либо чтобы Ќ≈ были в этом периоде счетчики
                                        and t.lsk=n.lsk
                                        and n.usl=p_usl
                                        and n.fk_vvod = p_id
                                        and e.usl=p_usl
                                        and e.tp=7 --наличие счетчика
                                         ))
                                      and (dist_tp_ <> 3 or dist_tp_ = 3 and (t.status = 9 or exists
                                      (select * from c_charge_prep e where
                                        t.lsk=e.lsk
                                        and e.usl=p_usl
                                        and e.tp=6 --итог без ќƒЌ
                                        and e.kpr2 <> 0) --если тип распр.=3 то либо арендатор, либо должен кто-то быть прописан
                                         ))
                                         );
              */
              null;
            
            end if;
            ---------------------------------------------------
            --------–ј—ѕ–≈ƒ≈Ћ≈Ќ»≈ ќƒЌ--------------------------
          
            ---------------------------------------------------
            --------ќ –”√Ћ≈Ќ»≈ ќƒЌ--------------------------
            --ќ –”√Ћ≈Ќ»≈ доначислени€ по 354 пост.
            if dist_tp_ in (1, 3) then
              --доначисление пропорционально площади
              if p_kub_dist - all_kub_ > 0 then
                --округление доначислени€ пропорционально площади (в т.ч.арендаторы), если небаланс > 0
                select sum(n.vol_add)
                  into l_for_round
                  from nabor n
                 where n.usl = fk_usl_chld_
                   and exists (select *
                          from nabor r, kart k
                         where n.lsk = r.lsk
                           and k.lsk = r.lsk
                           and k.psch not in (8, 9)
                           and r.fk_vvod = p_id
                           and r.usl = p_usl);
                logger.log_(null,
                            'p_vvod.gen_dist: округление по вводу ' || p_id || ' =' ||
                            to_char(p_kub_dist - all_kub_ - l_for_round));
                if p_kub_dist - all_kub_ - l_for_round > 0.5 then
                  raise_application_error(-20000,
                                          '—топ! «начение округлени€ составило ' ||
                                          to_char(p_kub_dist - all_kub_ -
                                                  l_for_round) ||
                                          ' по вводу: ' || p_id);
                end if;
                update nabor t
                   set t.vol_add = t.vol_add + p_kub_dist - all_kub_ -
                                   l_for_round
                 where t.lsk =
                       (select max(lsk)
                          from nabor n
                         where n.vol_add <> 0
                           and n.usl = fk_usl_chld_
                           and exists
                         (select *
                                  from nabor r, kart k
                                 where n.lsk = r.lsk
                                   and k.lsk = r.lsk
                                   and (dist_tp_ = 3 and
                                       (k.status = 9 or r.nrm_kpr <> 0) or
                                       dist_tp_ <> 3) --если тип распр.=3 то либо арендатор, либо должен кто-то быть прописан
                                   and k.psch not in (8, 9)
                                   and r.fk_vvod = p_id
                                   and r.usl = p_usl /*с јрендаторами*/
                                ))
                   and t.usl = fk_usl_chld_
                   and t.vol_add <> 0
                returning t.lsk, nvl(t.vol_add, 0) into l_lsk_round, l_vol_round;
              
                if l_lsk_round is not null and l_vol_round <> 0 then
                  --обновить инфу по ќƒЌ.
                  update c_charge t
                     set t.test_opl = l_vol_round
                   where t.lsk = l_lsk_round
                     and t.usl = fk_usl_chld_
                     and t.type = 5;
                end if;
              else
                --округление экономии пропорционально проживающим, если небаланс < 0
                --и не более собственного расхода!!
                select nvl(sum(n.test_opl), 0)
                  into l_nbalans --сумма распределенного небаланса
                  from c_charge n
                 where n.usl = fk_usl_chld_
                   and n.type = 5
                   and exists (select *
                          from nabor r, kart k
                         where n.lsk = r.lsk
                           and k.lsk = r.lsk
                           and k.psch not in (8, 9)
                           and r.fk_vvod = p_id
                           and r.usl = p_usl);
                if abs(p_kub_dist - all_kub_ - l_nbalans) < 0.01 then
                  --≈—Ћ» сумма небаланса - распределение небаланса меньше 0.01, то округлить
                  --на случайного —„≈“„» ј, ≈—Ћ» больше - то значит экономи€ вс€ использована, в пределах
                  --потреблени€
                  --       Raise_application_error(-20000, p_kub - all_kub_ -  l_nbalans);
                  for c in (select t.lsk,
                                   t.usl,
                                   p_kub_dist - all_kub_ - l_nbalans as corr_vol,
                                   1 as sch,
                                   4 as tp
                              from c_charge_prep t, nabor n
                             where t.tp in (0, 4)
                               and t.sch = 1
                               and t.usl = p_usl
                               and t.lsk = n.lsk
                               and n.fk_vvod = p_id
                             group by t.lsk, t.usl
                            having nvl(sum(t.vol), 0) > 0 --там где еще положительные объемы есть, куда округл€ть
                            ) loop
                    --добавл€ем корректировку
                    insert into c_charge_prep
                      (lsk, usl, vol, sch, tp)
                    values
                      (c.lsk, p_usl, c.corr_vol, c.sch, 4);
                    l_lsk_round := c.lsk;
                    exit;
                  end loop;
                
                  /*                update nabor t
                    set t.vol_add = t.vol_add + p_kub_dist - all_kub_ -
                                    l_nbalans
                  where t.lsk =
                        (select max(lsk)
                           from nabor n
                          where n.vol_add > 0.01
                            and n.usl =p_usl
                            and exists (select *
                                   from nabor r, kart k
                                  where n.lsk = r.lsk
                                    and k.lsk=r.lsk
                                    and k.psch not in (8, 9)
                                    and r.fk_vvod = p_id
                                    and r.usl = p_usl--без јрендаторов
                                    ))
                    and t.usl = p_usl
                    and t.vol_add > 0.01 --там где еще положительные объемы есть, куда округл€ть
                    returning t.lsk, nvl(t.vol_add,0) into l_lsk_round, l_vol_round; */
                
                  if sql%notfound then
                    --округлить по нормативщику, если не найдены счетчики
                    for c in (select t.lsk,
                                     t.usl,
                                     p_kub_dist - all_kub_ - l_nbalans as corr_vol,
                                     0 as sch,
                                     4 as tp
                                from c_charge_prep t, nabor n
                               where t.tp in (0, 4)
                                 and t.sch = 0
                                 and t.usl = p_usl
                                 and t.lsk = n.lsk
                                 and n.fk_vvod = p_id
                               group by t.lsk, t.usl
                              having nvl(sum(t.vol), 0) > 0 --там где еще положительные объемы есть, куда округл€ть
                              ) loop
                      --добавл€ем корректировку
                      insert into c_charge_prep
                        (lsk, usl, vol, sch, tp)
                      values
                        (c.lsk, p_usl, c.corr_vol, c.sch, 4);
                      l_lsk_round := c.lsk;
                      exit;
                    end loop;
                    /*                  update nabor t
                      set t.vol = t.vol + p_kub_dist - all_kub_ -
                                      l_nbalans
                    where t.lsk =
                          (select max(lsk)
                             from nabor n
                            where n.vol >= 0.01
                              and n.usl =p_usl
                              and exists (select *
                                     from nabor r, kart k
                                    where n.lsk = r.lsk
                                      and k.lsk=r.lsk
                                      and k.psch not in (8, 9)
                                      and r.fk_vvod = p_id
                                      and r.usl = p_usl--с јрендаторами))
                      and t.usl = p_usl
                      and t.vol >= 0.01 --там где еще положительные объемы есть, куда округл€ть
                      returning t.lsk into l_lsk_round;  */
                  end if;
                  if l_lsk_round is not null then
                    --обновить инфу по ќƒЌ.
                    update c_charge t
                       set t.test_opl = t.test_opl + p_kub_dist - all_kub_ -
                                        l_nbalans
                     where t.lsk = l_lsk_round
                       and t.usl = fk_usl_chld_
                       and t.type = 5;
                  end if;
                
                end if;
              end if;
            elsif dist_tp_ = 2 then
              --доначисление пропорционально потреб. объему
            
              raise_application_error(-20000,
                                      ' ќƒ Ќ≈ »—ѕќЋ№«”≈“—я!');
              /*            update nabor t
                set t.vol_add = t.vol_add + p_kub_dist - all_kub_ -
                                 (select round(sum(n.vol_add), 3)
                                    from nabor n
                                   where n.usl = fk_usl_chld_
                                     and exists
                                   (select *
                                            from nabor r, kart k
                                           where n.lsk = r.lsk
                                             and k.lsk = r.lsk
                                             and k.psch not in (8, 9)
                                             and r.fk_vvod = p_id
                                             and r.usl = p_usl))
              where t.lsk =
                    (select max(lsk)
                       from nabor n
                      where n.vol_add <> 0
                        and n.usl =fk_usl_chld_
                        and exists (select *
                               from nabor r, kart k
                              where n.lsk = r.lsk
                                and k.lsk=r.lsk
                                and k.psch not in (8, 9)
                                and r.fk_vvod = p_id
                                and r.usl = p_usl--с јрендаторами))
                and t.usl = fk_usl_chld_
                and t.vol_add <> 0; */
            end if;
            ---------------------------------------------------
            --------ќ –”√Ћ≈Ќ»≈ ќƒЌ-----------------------------
          end if;
        
          ---------------------------------------------------
          --------»“ќ√» –ј—ѕ–≈ƒ≈Ћ≈Ќ»я ќƒЌ--------------------
          --итоговые выполненные доначислени€
          --по жилым помещени€м
          select nvl(sum(case
                           when k.psch in (1, 2) and fk_calc_tp_ in (3, 17, 38) then
                            0
                           when k.psch in (1, 3) and fk_calc_tp_ in (4, 18, 40) then
                            0
                           when k.psch in (0, 3) and fk_calc_tp_ in (3, 17, 38) then
                            n.test_opl
                           when k.psch in (0, 2) and fk_calc_tp_ in (4, 18, 40) then
                            n.test_opl
                           when k.sch_el in (0) and fk_calc_tp_ in (31) then
                            n.test_opl
                         end),
                     0),
                 nvl(sum(case
                           when k.psch in (1, 2) and fk_calc_tp_ in (3, 17, 38) then
                            n.test_opl
                           when k.psch in (1, 3) and fk_calc_tp_ in (4, 18, 40) then
                            n.test_opl
                           when k.psch in (0, 3) and fk_calc_tp_ in (3, 17, 38) then
                            0
                           when k.psch in (0, 2) and fk_calc_tp_ in (4, 18, 40) then
                            0
                           when k.sch_el in (1) and fk_calc_tp_ in (31) then
                            n.test_opl
                         end),
                     0)
            into rec_cnt_
            from kart k, c_charge n
           where k.lsk = n.lsk
             and k.psch not in (8, 9)
             and n.usl = fk_usl_chld_
             and n.type = 5
             and exists (select *
                    from nabor r
                   where n.lsk = r.lsk
                     and r.fk_vvod = p_id
                     and r.usl = p_usl)
             and k.status <> 9;
          --итоги
          p_kub_nrm_fact := rec_cnt_.vol;
          p_kub_sch_fact := rec_cnt_.vol_add;
          --итоговые выполненные доначислени€
          --по нежилым помещени€м
          select nvl(sum(n.test_opl), 0)
            into rec_cnt_.vol_add
            from kart k, c_charge n
           where k.lsk = n.lsk
             and k.psch not in (8, 9)
             and n.usl = fk_usl_chld_
             and exists (select *
                    from nabor r
                   where n.lsk = r.lsk
                     and r.fk_vvod = p_id
                     and r.usl = p_usl)
             and k.status = 9
             and n.type = 5;
          p_kub_ar_fact := rec_cnt_.vol_add;
          p_kub_fact    := p_kub_nrm_fact + p_kub_sch_fact + p_kub_ar_fact;
        
        elsif dist_tp_ = 0 then
          --–ј—ѕ–≈ƒ≈Ћ≈Ќ»≈ пропорционально объему ( ис) (устаревает)
          raise_application_error(-20000,
                                  ' ќƒ Ќ≈ »—ѕќЋ№«”≈“—я!');
          if p_kub_dist <> 0 then
            --если расход <> 0, то распредел€ем коэфф.
            if use_sch_ = 1 then
              --распределение на долю норматив, счетчик
              update nabor k
                 set k.vol = --доначисление нормативщику
                      round(p_kub_dist / (all_kub_) * nvl(k.kf_kpr, 0) *
                            k.norm,
                            3)
               where k.usl = p_usl
                 and exists (select *
                        from nabor n, kart t
                       where n.lsk = k.lsk
                         and n.lsk = t.lsk
                         and t.psch not in (8, 9)
                         and n.fk_vvod = p_id
                         and n.usl = p_usl);
              update nabor k
                 set k.vol_add = --доначисление счетчику, где счетчик > 0
                      round(p_kub_dist / (all_kub_) *
                            nvl((select decode(tp_, 0, t.mhw, 1, t.mgw, 0)
                                  from kart t
                                 where t.lsk = k.lsk
                                   and nvl(decode(tp_, 0, t.mhw, 1, t.mgw, 0),
                                           0) > 0),
                                0),
                            3)
               where k.usl = p_usl
                 and exists (select *
                        from nabor n, kart t
                       where n.lsk = k.lsk
                         and n.lsk = t.lsk
                         and t.psch not in (8, 9)
                         and n.fk_vvod = p_id
                         and n.usl = p_usl)
                 and exists
               (select *
                        from kart t
                       where t.lsk = k.lsk
                         and nvl(decode(tp_, 0, t.mhw, 1, t.mgw, 0), 0) > 0);
            
              --распределение счетчику, если у него сн€тие ( < 0)
              update nabor k
                 set k.vol_add = --распределение счетчику, где счетчик < 0
                     (select decode(tp_, 0, t.mhw, 1, t.mgw, 0)
                        from kart t
                       where t.lsk = k.lsk)
               where k.usl = p_usl
                 and exists (select *
                        from nabor n, kart t
                       where n.lsk = k.lsk
                         and n.lsk = t.lsk
                         and t.psch not in (8, 9)
                         and n.fk_vvod = p_id
                         and n.usl = p_usl)
                 and exists
               (select *
                        from kart t
                       where t.lsk = k.lsk
                         and nvl(decode(tp_, 0, t.mhw, 1, t.mgw, 0), 0) < 0);
            
              if rec_norm_.kub_norm <> 0 then
                --округление на случайного нормативщика
                update nabor t
                   set t.vol = t.vol + p_kub_dist -
                               (select sum(n.vol + case
                                             when n.vol_add > 0 then
                                              n.vol_add
                                             else
                                              0
                                           end)
                                  from nabor n
                                 where n.fk_vvod = p_id)
                 where t.fk_vvod = p_id
                   and t.lsk = (select max(lsk)
                                  from nabor n
                                 where n.fk_vvod = p_id
                                   and n.vol <> 0)
                   and t.vol <> 0;
              else
                --округление на случайного счетчика > 0
                update nabor t
                   set t.vol_add = t.vol_add + p_kub_dist -
                                   (select sum(n.vol + n.vol_add)
                                      from nabor n
                                     where n.fk_vvod = p_id
                                       and exists
                                     (select *
                                              from kart t
                                             where t.lsk = n.lsk
                                               and nvl(decode(tp_,
                                                              0,
                                                              t.mhw,
                                                              1,
                                                              t.mgw,
                                                              0),
                                                       0) > 0))
                 where t.fk_vvod = p_id
                   and t.lsk = (select max(lsk)
                                  from nabor n
                                 where n.fk_vvod = p_id
                                   and n.vol_add > 0)
                   and t.vol_add > 0;
                null;
              end if;
            
            else
              --распределение только на долю нормативщиков
              if rec_norm_.kub_norm <> 0 and
                 abs(p_kub_dist) > rec_sch_.kub_sch then
                --≈сли дол€ нормативщиков <> 0
                update nabor k
                   set k.vol = --доначисление нормативщику
                        round((p_kub_dist - rec_sch_.kub_sch) /
                              rec_norm_.kub_norm * nvl(k.kf_kpr, 0) * k.norm,
                              3)
                 where k.usl = p_usl
                   and exists (select *
                          from nabor n, kart t
                         where n.lsk = k.lsk
                           and t.psch not in (8, 9)
                           and n.fk_vvod = p_id
                           and n.usl = p_usl);
                --округление на случайного нормативщика
                update nabor t
                   set t.vol = t.vol + p_kub_dist -
                               (rec_sch_.kub_sch +
                               (select sum(n.vol)
                                   from kart k, nabor n
                                  where n.fk_vvod = p_id
                                    and k.lsk = n.lsk
                                    and k.psch not in (8, 9)))
                 where t.fk_vvod = p_id
                   and t.vol <> 0
                   and t.lsk = (select max(k.lsk)
                                  from kart k, nabor n
                                 where n.fk_vvod = p_id
                                   and k.lsk = n.lsk
                                   and k.psch not in (8, 9)
                                   and n.vol <> 0);
              end if;
            end if;
            --итоговые выполненные доначислени€
            select sum(n.vol),
                   sum(case
                         when n.vol_add > 0 then
                          n.vol_add
                         else
                          0
                       end)
              into rec_cnt_
              from kart k, nabor n
             where n.fk_vvod = p_id
               and k.lsk = n.lsk
               and k.psch not in (8, 9)
               and n.usl = p_usl;
            --итоги
            p_kub_nrm_fact := rec_cnt_.vol;
            p_kub_sch_fact := rec_cnt_.vol_add;
            if use_sch_ = 1 then
              p_kub_fact := p_kub_nrm_fact + p_kub_sch_fact;
            else
              p_kub_fact := p_kub_nrm_fact + p_kub_sch_fact +
                            rec_sch_.kub_sch;
            end if;
          end if;
        end if;
      
        ---------------------------------------------------
        --------–ј—ѕ–≈ƒ≈Ћ≈Ќ»≈------------------------------
      
      end if;
    
    elsif fk_calc_tp_ = 1 and dist_tp_ = 0 then
      --устаревает, смотри услугу 31
      --распределение Ёлектроэнергии ћќѕ, пропорционально площади, по дочерней услуге (“—∆)
      select nvl(sum(k.mel), 0) as kub_sch,
             count(*) as cnt,
             nvl(sum(k.kpr - k.kpr_ot), 0) as kpr_sch,
             nvl(sum(k.opl), 0) as opl
        into rec_sch_
        from kart k, nabor n
       where n.fk_vvod = p_id
         and k.sch_el = 1
         and k.lsk = n.lsk
         and k.psch not in (8, 9)
         and n.usl = p_usl;
      p_kub_sch := rec_sch_.kub_sch;
      p_sch_cnt := rec_sch_.cnt;
      p_sch_kpr := rec_sch_.kpr;
    
      select 0 as kub_norm,
             count(*) as cnt, --да, да 0 по нормативу (нужно сделать kpr * норматив) доделать! ред 21.03.12
             nvl(sum(k.kpr - k.kpr_ot), 0) as kpr_norm,
             nvl(sum(k.opl), 0) as opl
        into rec_norm_
        from kart k, nabor n
       where n.fk_vvod = p_id
         and k.sch_el <> 1
         and k.lsk = n.lsk
         and k.psch not in (8, 9)
         and n.usl = p_usl;
      p_kub_norm := rec_norm_.kub_norm;
      p_kpr      := rec_norm_.kpr;
      p_cnt_lsk  := rec_norm_.cnt_lsk;
    
      --суммируем расход по вводу
      all_kub_ := rec_sch_.kub_sch + rec_norm_.kub_norm;
      --суммируем площадь по вводу
      all_opl_ := rec_sch_.opl + rec_norm_.opl;
    
      update nabor k
         set k.vol_add = --доначисление по нормативщику, счетчику небаланс, (+ или -)
              round((select t.opl from kart t where t.lsk = k.lsk) /
                    all_opl_ * (p_kub_dist - all_kub_),
                    3)
       where k.usl = fk_usl_chld_
         and exists (select *
                from nabor n, kart t
               where n.lsk = k.lsk
                 and t.psch not in (8, 9)
                 and n.fk_vvod = p_id
                 and n.usl = p_usl);
    
      --округление на случайного нормативщика/cчетчика
      update nabor t
         set t.vol_add = t.vol_add + p_kub_dist - all_kub_ -
                         (select sum(n.vol_add)
                            from nabor n
                           where n.usl = fk_usl_chld_
                             and exists (select *
                                    from nabor r, kart t
                                   where n.lsk = r.lsk
                                     and r.lsk = t.lsk
                                     and t.psch not in (8, 9)
                                     and r.fk_vvod = p_id
                                     and r.usl = p_usl))
       where t.lsk = (select max(lsk)
                        from nabor n
                       where n.vol_add <> 0
                         and n.usl = fk_usl_chld_
                         and exists (select *
                                from nabor r, kart t
                               where n.lsk = r.lsk
                                 and r.lsk = t.lsk
                                 and t.psch not in (8, 9)
                                 and r.fk_vvod = p_id
                                 and r.usl = p_usl))
         and t.vol_add <> 0;
      --итоговые выполненные доначислени€
      select sum(case
                   when k.sch_el <> 1 then
                    n.vol_add
                   else
                    0
                 end),
             sum(case
                   when k.sch_el = 1 then
                    n.vol_add
                   else
                    0
                 end)
        into rec_cnt_
        from kart k, nabor n
       where k.lsk = n.lsk
         and k.psch not in (8, 9)
         and n.usl = fk_usl_chld_
         and exists (select *
                from nabor r, kart t
               where n.lsk = r.lsk
                 and r.lsk = t.lsk
                 and t.psch not in (8, 9)
                 and r.fk_vvod = p_id
                 and r.usl = p_usl);
      --итоги
      p_kub_nrm_fact := rec_cnt_.vol;
      p_kub_sch_fact := rec_cnt_.vol_add;
      p_kub_fact     := p_kub_nrm_fact + p_kub_sch_fact;
      ---------
      ---------
    elsif fk_calc_tp_ = 1 and dist_tp_ = 1 then
      --начисление по Ёлектр.энерг ( ис)
      select nvl(sum(mel), 0), count(*), nvl(sum(k.kpr - k.kpr_ot), 0)
        into kub_rec_
        from kart k, nabor n
       where k.sch_el in (1)
         and k.lsk = n.lsk
         and k.psch not in (8, 9)
         and n.usl = p_usl
         and case
               when sptarn_ = 0 and nvl(n.koeff, 0) <> 0 then
                1 --определ€ем наличие услуги в л.с.
               when sptarn_ = 1 and nvl(n.norm, 0) <> 0 then
                1
               when sptarn_ = 2 and nvl(n.koeff, 0) <> 0 and
                    nvl(n.norm, 0) <> 0 then
                1
               when sptarn_ = 3 and nvl(n.koeff, 0) <> 0 and
                    nvl(n.norm, 0) <> 0 then
                1
               else
                0
             end = 1
         and n.fk_vvod = p_id;
    
      p_kub_sch := kub_rec_.kub_sch;
      p_sch_cnt := kub_rec_.cnt;
      p_sch_kpr := kub_rec_.kpr_sch;
    
      --колво людей по нормативу
      select count(*), nvl(sum(k.kpr - k.kpr_ot), 0)
        into kpr_rec_
        from kart k, nabor n
       where k.sch_el not in (1)
         and k.lsk = n.lsk
         and n.usl = p_usl
         and k.psch not in (8, 9)
         and case
               when sptarn_ = 0 and nvl(n.koeff, 0) <> 0 then
                1 --определ€ем наличие услуги в л.с.
               when sptarn_ = 1 and nvl(n.norm, 0) <> 0 then
                1
               when sptarn_ = 2 and nvl(n.koeff, 0) <> 0 and
                    nvl(n.norm, 0) <> 0 then
                1
               when sptarn_ = 3 and nvl(n.koeff, 0) <> 0 and
                    nvl(n.norm, 0) <> 0 then
                1
               else
                0
             end = 1
         and n.fk_vvod = p_id;
      p_kpr     := kpr_rec_.kpr;
      p_cnt_lsk := kpr_rec_.cnt;
    
      --ќбновл€ем кол-во квт по карточкам, по нормативу
      if (p_kub_dist - kub_rec_.kub_sch) < 0 then
        -- не реальна€ ситуаци€ ( квт по сч > кубов по дому)
        update kart k
           set k.mel = 0
         where k.sch_el not in (1)
           and exists
         (select *
                  from nabor n
                 where n.lsk = k.lsk
                   and n.usl = p_usl
                   and case
                         when sptarn_ = 0 and nvl(n.koeff, 0) <> 0 then
                          1 --определ€ем наличие услуги в л.с.
                         when sptarn_ = 1 and nvl(n.norm, 0) <> 0 then
                          1
                         when sptarn_ = 2 and nvl(n.koeff, 0) <> 0 and
                              nvl(n.norm, 0) <> 0 then
                          1
                         when sptarn_ = 3 and nvl(n.koeff, 0) <> 0 and
                              nvl(n.norm, 0) <> 0 then
                          1
                         else
                          0
                       end = 1
                   and n.fk_vvod = p_id);
      
        --расход квт по каждому человеку, по этому вводу
        p_kub_man := 0;
      elsif kpr_rec_.kpr > 0 then
        --если есть люди
        update kart k
           set k.mel =
               (p_kub_dist - kub_rec_.kub_sch) / kpr_rec_.kpr
         where k.sch_el not in (1)
           and k.psch not in (8, 9)
           and exists
         (select *
                  from nabor n
                 where n.lsk = k.lsk
                   and n.usl = p_usl
                   and case
                         when sptarn_ = 0 and nvl(n.koeff, 0) <> 0 then
                          1 --определ€ем наличие услуги в л.с.
                         when sptarn_ = 1 and nvl(n.norm, 0) <> 0 then
                          1
                         when sptarn_ = 2 and nvl(n.koeff, 0) <> 0 and
                              nvl(n.norm, 0) <> 0 then
                          1
                         when sptarn_ = 3 and nvl(n.koeff, 0) <> 0 and
                              nvl(n.norm, 0) <> 0 then
                          1
                         else
                          0
                       end = 1
                   and n.fk_vvod = p_id);
        --расход квт по каждому человеку, по этому вводу
        p_kub_man := (p_kub_dist - kub_rec_.kub_sch) / kpr_rec_.kpr;
      elsif kpr_rec_.kpr = 0 then
        --если нет людей
        update kart k
           set k.mel = 0
         where k.sch_el not in (1)
           and exists
         (select *
                  from nabor n
                 where n.lsk = k.lsk
                   and n.usl = p_usl
                   and case
                         when sptarn_ = 0 and nvl(n.koeff, 0) <> 0 then
                          1 --определ€ем наличие услуги в л.с.
                         when sptarn_ = 1 and nvl(n.norm, 0) <> 0 then
                          1
                         when sptarn_ = 2 and nvl(n.koeff, 0) <> 0 and
                              nvl(n.norm, 0) <> 0 then
                          1
                         when sptarn_ = 3 and nvl(n.koeff, 0) <> 0 and
                              nvl(n.norm, 0) <> 0 then
                          1
                         else
                          0
                       end = 1
                   and n.fk_vvod = p_id);
        --расход квт по каждому человеку, по этому вводу
        p_kub_man := 0;
      end if;
    
      select sum(decode(k.sch_el, 1, k.mel, k.mel * k.kpr))
        into p_kub_fact
        from kart k, nabor c
       where c.fk_vvod = p_id
         and c.usl = p_usl
         and k.psch not in (8, 9)
         and k.lsk = c.lsk;
    
      ---------
      ---------
    elsif fk_calc_tp_ = 11 then
      --распределение по услуге – ÷ ∆ ’ (пропорционально площади)
      update nabor n
         set n.koeff = round(p_kub_dist /
                             (select sum(k.opl)
                                from kart k, nabor r
                               where k.lsk = r.lsk
                                 and r.fk_vvod = p_id
                                 and k.psch not in (8, 9)) *
                             (select sum(k.opl)
                                from kart k
                               where k.lsk = n.lsk
                                 and k.psch not in (8, 9)),
                             2)
       where exists (select *
                from kart a, nabor r
               where a.lsk = n.lsk
                 and a.lsk = r.lsk
                 and r.fk_vvod = p_id)
         and n.usl = p_usl;
    
    elsif fk_calc_tp_ = 23 and p_kub_dist is not null then
      --распределение по прочей услуге, расчитываемой как расценка * vol_add, пропорционально площади
      --например, эл.энерг ћќѕ в  ис., в “—∆, эл.эн.ќƒЌ в ѕолыс.
      --здесь же распредел€етс€ услуга ќƒЌ, котора€ не предполагает собой
      --начисление по основной услуге в лицевых счетах
      l_limit_vol := 0;
    
      if l_usl_cd in ('эл.эн.ќƒЌ', 'эл.эн.ћќѕ2') and nvl(p_wo_limit, 0) = 0 then
        begin
          select nvl(round(x.n1 * 2.7, 4), 0)
            into l_limit_vol
            from t_objxpar x, v_house_pars u, c_houses h
           where x.fk_list = u.id
             and x.fk_k_lsk = h.k_lsk_id
             and h.id = p_house_id
             and u.cd = 'area_general_property'
             and not exists
           (select *
                    from t_objxpar x, v_house_pars u, c_houses h
                   where x.fk_list = u.id
                     and x.fk_k_lsk = h.k_lsk_id
                     and h.id = p_house_id
                     and u.cd = 'exist_lift'
                     and nvl(x.n1, 0) = 1
                  
                  );
          l_odn_nrm:=2.7;
        exception
          when no_data_found then
            l_limit_vol := 0;
        end;
        if l_limit_vol = 0 then
          --значит дом с лифтом
          begin
            select nvl(round(x.n1 * 4.1, 4), 0)
              into l_limit_vol
              from t_objxpar x, v_house_pars u, c_houses h
             where x.fk_list = u.id
               and x.fk_k_lsk = h.k_lsk_id
               and h.id = p_house_id
               and u.cd = 'area_general_property'
               and exists
             (select *
                      from t_objxpar x, v_house_pars u, c_houses h
                     where x.fk_list = u.id
                       and x.fk_k_lsk = h.k_lsk_id
                       and h.id = p_house_id
                       and u.cd = 'exist_lift'
                       and nvl(x.n1, 0) = 1
                    );
          l_odn_nrm:=4.1;
          exception
            when no_data_found then
              l_limit_vol := 0;
          end;
        end if;
      
        --провер€ем ограничение ќƒЌ
        if p_kub_dist > l_limit_vol then
          p_kub_dist := l_limit_vol;
        end if;
      end if;
    
      --нулим по вводу-услуге
      update nabor k
         set k.vol = 0, k.vol_add = 0, k.limit = null
       where k.usl = p_usl
         and exists (select *
                from nabor n, kart t
               where n.lsk = k.lsk
                 and n.lsk = t.lsk
                 and n.usl = p_usl
                 and n.fk_vvod = p_id);
      --распредел€ем
      update nabor n
         set n.vol_add = round(p_kub_dist /
                               (select sum(k.opl)
                                  from kart k, nabor r
                                 where k.lsk = r.lsk
                                   and r.fk_vvod = p_id
                                   and k.psch not in (8, 9)) *
                               (select sum(k.opl)
                                  from kart k
                                 where k.lsk = n.lsk
                                   and k.psch not in (8, 9)),
                               2)
       where nvl(n.koeff, 0) <> 0
         and n.fk_vvod = p_id
         and n.usl = p_usl
         and exists (select *
                from kart k
               where k.lsk = n.lsk
                 and k.psch not in (8, 9));
    
      --распределено фактически
      select nvl(sum(c.vol_add), 0)
        into p_kub_fact
        from kart k, nabor c
       where c.fk_vvod = p_id
         and c.usl = p_usl
         and k.psch not in (8, 9)
         and nvl(c.koeff, 0) <> 0
         and k.lsk = c.lsk;
      if abs(p_kub_dist - p_kub_fact) > 2 then
        raise_application_error(-20000,
                                '¬озможно лицевые счета в карточке не прив€заны ко вводу, распределение по id=' || p_id||', разница='||(p_kub_dist - p_kub_fact));
      end if;
    
      --округление
      update nabor t
         set t.vol_add = t.vol_add + p_kub_dist - p_kub_fact
       where t.fk_vvod = p_id
         and t.lsk = (select max(lsk)
                        from nabor n
                       where n.fk_vvod = p_id
                         and n.vol_add <> 0
                         and n.usl = p_usl)
         and t.vol_add <> 0;
    
      --и оп€ть.. распределено фактически
      select sum(c.vol_add)
        into p_kub_fact
        from kart k, nabor c
       where c.fk_vvod = p_id
         and c.usl = p_usl
         and k.psch not in (8, 9)
         and nvl(c.koeff, 0) <> 0
         and k.lsk = c.lsk;
    
    elsif fk_calc_tp_ = 15 then
      --Ёлектроэнерги€ распр (дл€ “—∆), (по лицевым счетам)
      update nabor n
         set n.vol = round(p_kub_dist /
                           (select count(*)
                              from kart k, nabor b, usl u
                             where k.lsk = b.lsk
                               and b.usl = u.usl
                               and b.usl = p_usl
                               and nvl(b.koeff, 0) <> 0
                               and b.fk_vvod = p_id
                               and k.psch not in (8, 9)),
                           5)
       where n.fk_vvod = p_id
         and exists (select *
                from nabor b
               where n.lsk = b.lsk
                 and b.usl = p_usl
                 and b.fk_vvod = p_id
                 and nvl(b.koeff, 0) <> 0)
         and n.usl = p_usl;
    
      begin
        select nvl(round(p_kub_dist / count(*), 2), 0), count(*), null
          into kub_rec_
          from kart k, nabor b, usl u
         where k.lsk = b.lsk
           and b.usl = u.usl
           and b.usl = p_usl
           and nvl(b.koeff, 0) <> 0
           and b.fk_vvod = p_id
           and k.psch not in (8, 9);
      exception
        when zero_divide then
          raise_application_error(-20000,
                                  '¬озможно отсутствует услуга в лицевых счетах, деление на ноль в вводе ID=' || p_id);
        
      end;
    
      select sum(c.vol)
        into p_kub_fact
        from kart k, nabor c
       where c.fk_vvod = p_id
         and c.usl = p_usl
         and k.psch not in (8, 9)
         and nvl(c.koeff, 0) <> 0
         and k.lsk = c.lsk;
    
      p_kub_sch := kub_rec_.kub_sch;
      p_sch_cnt := kub_rec_.cnt;
      p_sch_kpr := kub_rec_.kpr_sch;
    
    elsif fk_calc_tp_ = 14 then
      --начисление по услуге отопление в гигах
      --поправочный коэфф. дл€ перевода расц за гиг в расц за площадь
      --коэфф. един дл€ отоплени€ по норме и свыше
    
      --коэфф по норме
      koeff_ := 1;
      --распредел€ем —“–ќ√ќ по тем Ќ≈ «ј –џ“џћ квартирам, в которых ¬ Ћё„≈Ќј услуга
        --распределить без норматива, г ал пропорционально площади
        update nabor n
           set n.vol = round(round(p_kub_dist /
                                   (select sum(k.opl)
                                      from kart k, nabor b, usl u
                                     where k.lsk = b.lsk
                                       and b.usl = u.usl
                                       and b.usl = p_usl
                                       and b.fk_vvod = p_id
                                       and k.psch not in (8, 9)),
                                   5) * koeff_ *
                             (select k.opl from kart k where k.lsk = n.lsk),
                             5)
         where n.fk_vvod = p_id
           and exists (select *
                  from nabor b
                 where n.lsk = b.lsk
                   and b.usl = p_usl)
           and n.usl = p_usl
           and n.fk_vvod = p_id;
               
      select sum(c.vol)
        into p_kub_fact
        from kart k, nabor c
       where c.fk_vvod = p_id
         and c.usl = p_usl
         and k.psch not in (8, 9)
         and k.lsk = c.lsk;
      /* --ветка странна€ if... не работает видимо ред. 28.04.12
      elsif fk_calc_tp_ = 1 then
        --начисление по Ёлектр.энерг
        select nvl(sum(mel), 0), count(*), nvl(sum(k.kpr - k.kpr_ot), 0)
          into kub_rec_
          from kart k, nabor n
         where k.house_id = p_house_id
           and k.sch_el in (1)
           and k.lsk = n.lsk
           and k.psch not in (8, 9)
           and n.usl = p_usl
           and n.fk_vvod = p_id;
      
        p_kub_sch := kub_rec_.kub_sch;
        p_sch_cnt := kub_rec_.cnt;
        p_sch_kpr := kub_rec_.kpr_sch;
      
        --колво людей по нормативу
        select count(*), nvl(sum(k.kpr - k.kpr_ot), 0)
          into kpr_rec_
          from kart k, nabor n
         where k.house_id = p_house_id
           and k.sch_el not in (1)
           and k.lsk = n.lsk
           and n.usl = p_usl
           and k.psch not in (8, 9)
           and n.fk_vvod = p_id;
        p_kpr     := kpr_rec_.kpr;
        p_cnt_lsk := kpr_rec_.cnt;
      
        --ќбновл€ем кол-во квт по карточкам, по нормативу
        if (p_kub - kub_rec_.kub_sch) < 0 then
          -- не реальна€ ситуаци€ ( квт по сч > кубов по дому)
          update kart k
             set k.mel = 0
           where k.house_id = p_house_id
             and k.sch_el not in (1)
             and exists (select *
                    from nabor n
                   where n.lsk = k.lsk
                     and n.usl = p_usl
                     and n.fk_vvod = p_id);
      
          --расход квт по каждому человеку, по этому вводу
          p_kub_man := 0;
        elsif kpr_rec_.kpr > 0 then
          --если есть люди
          update kart k
             set k.mel =
                  (p_kub - kub_rec_.kub_sch) / kpr_rec_.kpr
           where k.house_id = p_house_id
             and k.sch_el not in (1)
             and k.psch not in (8, 9)
             and exists (select *
                    from nabor n
                   where n.lsk = k.lsk
                     and n.usl = p_usl
                     and n.fk_vvod = p_id);
          --расход квт по каждому человеку, по этому вводу
          p_kub_man := (p_kub - kub_rec_.kub_sch) / kpr_rec_.kpr;
        elsif kpr_rec_.kpr = 0 then
          --если нет людей
          update kart k
             set k.mel = 0
           where k.house_id = p_house_id
             and k.sch_el not in (1)
             and exists (select *
                    from nabor n
                   where n.lsk = k.lsk
                     and n.usl = p_usl
                     and n.fk_vvod = p_id);
          --расход квт по каждому человеку, по этому вводу
          p_kub_man := 0;
        end if;
      
        select sum(decode(k.sch_el, 1, k.mel, k.mel * k.kpr))
          into p_kub_fact
          from kart k, nabor c
         where c.fk_vvod = p_id
           and c.usl = p_usl
           and k.psch not in (8, 9)
           and k.lsk = c.lsk;
      */
    end if;
  
    --обновить вводы выходными параметрами
    --не выполнить случайно обновление по циклу!
  
    update c_vvod t
       set t.kub_nrm_fact = p_kub_nrm_fact,
           t.kub_sch_fact = p_kub_sch_fact,
           t.kub_ar_fact  = p_kub_ar_fact,
           t.kub_ar       = p_kub_ar,
           t.opl_ar       = p_opl_ar,
           t.kub_sch      = p_kub_sch,
           t.sch_cnt      = p_sch_cnt,
           t.sch_kpr      = p_sch_kpr,
           t.kpr          = p_kpr,
           t.cnt_lsk      = p_cnt_lsk,
           t.kub_norm     = p_kub_norm,
           t.kub_fact     = p_kub_fact,
           t.kub_man      = p_kub_man,
           t.kub_dist     = p_kub_dist,
           t.opl_add      = p_opl_add,
           t.nrm = l_odn_nrm
     where t.id = p_id;
  
    if p_gen_part_kpr = 1 then
      --расчет начислени€ (если из триггера)
      l_cnt := c_charges.gen_charges(null, null, null, p_id, 0, 0);
    end if;
    logger.log_(l_time,
                '¬ыполнено: p_vvod.gen_dist: vvod_id=' || p_id);
    
  end;

  procedure gen_clear_odn(p_usl      in c_vvod.usl%type,
                          p_usl_chld in c_vvod.usl%type,
                          p_house    in c_houses.id%type,
                          p_vvod     in c_vvod.id%type) is
  l_time1 date;
  begin
    --почистить информацию по ќƒЌ
    l_time1 := sysdate;
    if p_vvod is not null then
      --удал€ем информацию по распр.ќƒЌ.по информационным запис€м
      delete from c_charge t
       where t.type = 5
         and t.usl = p_usl_chld
         and exists (select *
                from nabor n
               where n.fk_vvod = p_vvod
                 and n.usl = p_usl
                 and n.lsk = t.lsk);
      --удал€ем информацию по корректировкам ќƒЌ
      delete from c_charge_prep t
       where t.usl = p_usl
         and t.tp = 4
         and exists (select *
                from nabor n
               where n.fk_vvod = p_vvod
                 and n.usl = p_usl
                 and n.lsk = t.lsk);
    
      --нулим по вводу-услуге
      update nabor k
         set k.vol = 0, k.vol_add = 0, k.limit = null
       where k.usl = p_usl
         and exists (select *
                from nabor n, kart t
               where n.lsk = k.lsk
                 and n.lsk = t.lsk
                 and n.usl = p_usl
                 and n.fk_vvod = p_vvod);
      --нулим по зависимым услугам
      update nabor k
         set k.vol = 0, k.vol_add = 0, k.limit = null
       where k.usl = p_usl_chld
         and exists (select *
                from nabor n, kart t
               where n.lsk = k.lsk
                 and n.lsk = t.lsk
                 and n.usl = p_usl
                 and n.fk_vvod = p_vvod);
      --почистить нормативы (ограничени€)
      update c_vvod t set t.nrm=null where t.id=p_vvod;           
    elsif p_house is not null then
      --удал€ем информацию по распр.ќƒЌ.по информационным запис€м
      delete from c_charge t
       where t.type = 5
         and t.usl = p_usl_chld
         and exists (select *
                from nabor n, kart k
               where k.house_id = p_house
                 and k.lsk = n.lsk
                 and n.usl = p_usl
                 and n.lsk = t.lsk);
    
      --нулим по вводу-услуге
      update nabor k
         set k.vol = 0, k.vol_add = 0
       where k.usl = p_usl
         and exists (select *
                from nabor n, kart t
               where n.lsk = k.lsk
                 and n.lsk = t.lsk
                 and t.psch not in (8, 9)
                 and n.usl = p_usl
                 and t.house_id = p_house);
      --нулим по зависимым услугам
      update nabor k
         set k.vol = 0, k.vol_add = 0
       where k.usl = p_usl_chld
         and exists (select *
                from nabor n, kart t
               where n.lsk = k.lsk
                 and n.lsk = t.lsk
                 and t.psch not in (8, 9)
                 and n.usl = p_usl
                 and t.house_id = p_house);
      --почистить нормативы (ограничени€)
      update c_vvod t set t.nrm=null where t.house_id=p_house and t.usl=p_usl;           
    end if;
    logger.log_(l_time1,
                '¬ыполнена очистка: p_vvod.gen_clear_odn p_house='||p_house||', p_vvod='||p_vvod);
  
  end;

  procedure gen_dist_wo_vvod_usl(p_vvod in c_vvod.id%type) is
    fk_usl_chld_ usl.usl%type;
    fk_calc_tp_  number;
    sptarn_      number;
    l_kpr        number;
    l_cnt        number;
    tp_          number;
    l_rate       number; --норматив по ќƒЌ
    l_area_prop  number; --площадь общего имущества дома
    l_limit_vol  number; --допустимый лимит ќƒЌ по законодательству (общий)
    l_usl        c_vvod.usl%type; --услуга
    l_house      c_vvod.house_id%type; --id дома
    l_nrm_kpr    number; --кол-во людей по нормативу
    l_sch_kpr    number; --кол-во людей по счетчику
    --начисленные факты
    l_kub_nrm_fact number;
    l_kub_sch_fact number;
    l_kub_fact     number;
    l_opl_add      number;
    l_edt_norm number;
    type rec_cnt is record(
      vol     number,
      vol_add number);
    l_rec_cnt rec_cnt;
    l_odn_nrm number; --ограничение по ќƒЌ (еще называют нормативом)
    l_time1 date;
  begin
    l_time1 := sysdate;
    --распределение ќƒЌ по домам, в которых нет домового ѕ.”.
    --(ќƒЌ по формуле)
  
    --вид расчета услуги
    select nvl(u.fk_calc_tp, 0), u.fk_usl_chld, u.usl, d.house_id, d.edt_norm
      into fk_calc_tp_, fk_usl_chld_, l_usl, l_house, l_edt_norm
      from usl u, c_vvod d
     where u.usl = d.usl
       and d.id = p_vvod;
    select nvl(u.sptarn, 0) into sptarn_ from usl u where u.usl = l_usl;
  
    --установить коэфф по проживающим, по вводу
    c_kart.set_part_kpr_vvod(p_vvod);
  
    if fk_calc_tp_ in (3, 17, 38) then
      tp_ := 0; --х.в.
    elsif fk_calc_tp_ in (4, 18, 40) then
      tp_ := 1; --г.в.
    elsif fk_calc_tp_ in (31) then
      tp_ := 2; --эл.эн.
    end if;
  
    ---ќ„»—“ ј »Ќ‘ќ–ћј÷»» ќƒЌ-------------------------
    gen_clear_odn(p_usl      => l_usl,
                  p_usl_chld => fk_usl_chld_,
                  p_house    => null,
                  p_vvod     => p_vvod);
  
    if tp_ in (0, 1) then
      --х.в. или г.в.
      --кол-во проживающих
      select nvl(sum(e.kpr2), 0) as kpr,
             sum(case
                   when nvl(e.sch, 0) <> 0 then
                    e.kpr2
                   else
                    0
                 end),
             sum(case
                   when nvl(e.sch, 0) = 0 then
                    e.kpr2
                   else
                    0
                 end)
        into l_kpr, l_sch_kpr, l_nrm_kpr
        from kart k, nabor n, c_charge_prep e
       where k.lsk = n.lsk
         and k.lsk = e.lsk
            --    and k.house_id=l_house
         and n.fk_vvod = p_vvod
         and n.usl = e.usl
         and n.usl = l_usl
         and k.psch not in (8, 9)
         and e.tp = 6 --итог без ќƒЌ
         and k.status not in (9) /*без јрендаторов*/
      ;
    
    elsif tp_ = 2 then
      --по эл.эн. - по особенному
      --дом без лифта = площадь общего имущества * 2.7 квт.
      begin
        --площадь общ.имущ., норматив, объем на площадь
        select x.n1, 2.7, nvl(round(x.n1 * 2.7, 4), 0)
          into l_area_prop, l_rate, l_limit_vol
          from t_objxpar x, v_house_pars u, c_houses h
         where x.fk_list = u.id
           and x.fk_k_lsk = h.k_lsk_id
           and h.id = l_house
           and u.cd = 'area_general_property'
           and not exists
         (select *
                  from t_objxpar x, v_house_pars u, c_houses h
                 where x.fk_list = u.id
                   and x.fk_k_lsk = h.k_lsk_id
                   and h.id = l_house
                   and u.cd = 'exist_lift'
                   and nvl(x.n1, 0) = 1
                
                );
         l_odn_nrm:=2.7;       
      exception
        when no_data_found then
          l_limit_vol := 0;
      end;
    
      if l_limit_vol = 0 then
        --значит дом с лифтом
        begin
          --площадь общ.имущ., норматив, объем на площадь
          select x.n1, 4.1, nvl(round(x.n1 * 2.7, 4), 0)
            into l_area_prop, l_rate, l_limit_vol
            from t_objxpar x, v_house_pars u, c_houses h
           where x.fk_list = u.id
             and x.fk_k_lsk = h.k_lsk_id
             and h.id = l_house
             and u.cd = 'area_general_property'
             and exists
           (select *
                    from t_objxpar x, v_house_pars u, c_houses h
                   where x.fk_list = u.id
                     and x.fk_k_lsk = h.k_lsk_id
                     and h.id = l_house
                     and u.cd = 'exist_lift'
                     and nvl(x.n1, 0) = 1
                  
                  );
         l_odn_nrm:=4.1;       
        exception
          when no_data_found then
            l_limit_vol := 0;
        end;
      end if;
      null;
    
    end if;
  
   --отопление г ал, по нормативу, х.в., г.в. 
    if tp_ in (0, 1) and l_kpr <> 0 or tp_ in (2) then
      --если кол-во проживающих <>0, то имеет смысл (дл€ х.в. и г.в., но не дл€ эл.эн.)
      for c in (select sum(k.opl) as opl,
                       case
                         when tp_ in (0, 1) then
                          opl_liter(sum(k.opl) / l_kpr) / 1000 --лимит ќƒЌ по л/с. х.в. и г.в.
                         when tp_ = 2 then
                          null --лимит ќƒЌ по л/с. Ёл.эн.
                       end as vl
                  from kart k, nabor n
                 where k.house_id = l_house
                   and k.lsk=n.lsk 
                   and n.usl=fk_usl_chld_
                   and k.psch not in (8, 9) --без арендаторов
                   and nvl(k.opl, 0) <> 0) loop
        l_opl_add := c.opl;
        update nabor n
           set n.vol_add =
               (select case
                         when tp_ in (0, 1) then
                          round(k.opl * c.vl, 3)
                         when tp_ = 2 then
                          round(l_rate * l_area_prop * k.opl / c.opl, 3) --лимит ќƒЌ по л/с. Ёл.эн.
                       end
                  from kart k
                 where k.lsk = n.lsk)
         where exists (select *
                  from kart t, nabor r
                 where t.lsk = n.lsk
                   and t.lsk = r.lsk
                   and r.fk_vvod = p_vvod
                   and nvl(t.opl, 0) <> 0)
           and n.usl = fk_usl_chld_;
        --добавить инфу по ќƒЌ.
        insert into c_charge
          (lsk, usl, test_opl, type)
          select k.lsk,
                 fk_usl_chld_,
                 case
                   when tp_ in (0, 1) then
                    round(k.opl * c.vl, 3)
                   when tp_ = 2 then
                    round(l_rate * l_area_prop * k.opl / c.opl, 3) --лимит ќƒЌ по л/с. Ёл.эн.
                 end as test_opl,
                 5 as type
            from kart k, nabor n
           where k.lsk = n.lsk
             and n.usl = fk_usl_chld_
             and exists (select *
                    from kart t, nabor r
                   where t.lsk = n.lsk
                     and t.lsk = r.lsk
                     and r.fk_vvod = p_vvod
                     and nvl(t.opl, 0) <> 0);
      
        select nvl(sum(n.vol_add), 0)
          into l_cnt
          from nabor n
         where n.fk_vvod = p_vvod
           and n.usl = l_usl;
        l_odn_nrm:=c.vl*1000;--вернуть в литры
        --округление -- здесь не нужно
      end loop;
    
      --итоговые выполненные доначислени€
      select nvl(sum(case
                           when k.psch in (1, 2) and fk_calc_tp_ in (3, 17, 38) then
                            0
                           when k.psch in (1, 3) and fk_calc_tp_ in (4, 18, 40) then
                            0
                           when k.psch in (0, 3) and fk_calc_tp_ in (3, 17, 38) then
                            n.test_opl
                           when k.psch in (0, 2) and fk_calc_tp_ in (4, 18, 40) then
                            n.test_opl
                           when k.sch_el in (0) and fk_calc_tp_ in (31) then
                            n.test_opl
                         end),
                     0),
                 nvl(sum(case
                           when k.psch in (1, 2) and fk_calc_tp_ in (3, 17, 38) then
                            n.test_opl
                           when k.psch in (1, 3) and fk_calc_tp_ in (4, 18, 40) then
                            n.test_opl
                           when k.psch in (0, 3) and fk_calc_tp_ in (3, 17, 38) then
                            0
                           when k.psch in (0, 2) and fk_calc_tp_ in (4, 18, 40) then
                            0
                           when k.sch_el in (1) and fk_calc_tp_ in (31) then
                            n.test_opl
                         end),
                     0)
        into l_rec_cnt
        from kart k, c_charge n
       where k.lsk = n.lsk
         and k.psch not in (8, 9)
         and n.usl = fk_usl_chld_
         and n.type = 5
         and exists (select *
                from nabor r, kart t
               where n.lsk = r.lsk
                 and r.lsk = t.lsk
                 and t.psch not in (8, 9)
                 and r.fk_vvod = p_vvod
                 and r.usl = l_usl);
      --итоги
      l_kub_nrm_fact := l_rec_cnt.vol;
      l_kub_sch_fact := l_rec_cnt.vol_add;
      l_kub_fact     := l_kub_nrm_fact + l_kub_sch_fact;
    
      update c_vvod t
         set t.kub_nrm_fact = l_kub_nrm_fact,
             t.kub_sch_fact = l_kub_sch_fact,
             t.kub_sch      = null,
             t.sch_cnt      = null,
             t.sch_kpr      = l_sch_kpr,
             t.kpr          = l_nrm_kpr,
             t.cnt_lsk      = null,
             t.kub_norm     = null,
             t.kub_fact     = l_kub_fact,
             t.kub_man      = null,
             t.kub_dist     = null,
             t.opl_add      = l_opl_add,
             t.nrm          = l_odn_nrm
       where t.id = p_vvod;
    end if;
      logger.log_(l_time1,
                '–аспределено: p_vvod.gen_dist_wo_vvod_usl, p_vvod='||p_vvod);

    --убрал коммит
    --commit;
  end;

  --перераспределение объемов по всем домам
  procedure gen_dist_all_houses is
    l_cnt number;
    --i number;
    /*l_job number;
    l_job1 number;
    l_job2 number;
    l_job3 number;
    l_start_row number;
    l_end_row number;*/
    time_  date;
    time1_ date;
  begin
    time_  := sysdate;
    time1_ := sysdate;
    --сперва, на вс€кий случай чистим инфу, там где ¬ќќЅў≈ нет счетчиков (нет записи в c_vvod)
    for c in (select u.usl, u.fk_usl_chld
                from usl u, usl odn
               where u.cd in ('х.вода',
                              'г.вода',
                              'х.в. дл€ гвс',
                              'эл.энерг.2',
                              'эл.эн.ќƒЌ',
                              'отоп.гкал.')
                 and u.fk_usl_chld = odn.usl) loop
      for c2 in (select h.id
                   from c_houses h
                  where nvl(h.psch, 0) = 0 --не закрытые дома
                    and not exists
                  (select * from c_vvod d where d.usl = c.usl)
                  order by h.id) loop
        --почистить
        gen_clear_odn(p_usl      => c.usl,
                      p_usl_chld => c.fk_usl_chld,
                      p_house    => c2.id,
                      p_vvod     => null);
      end loop;
    end loop;
  
    --commit, чтобы ускорить процесс
    commit;
    logger.log_(time1_,
                'p_vvod.gen_dist_all_houses - закончена I - ‘аза:ќчистка там где вообще нет записи во вводе');
    time1_ := sysdate;
  
    --сперва распредел€ем ќƒЌ в домах, где нет ќƒѕ” (или потом, без разницы)
    for c in (select d.id
                from c_vvod d, c_houses h
               where d.house_id = h.id
                 and d.dist_tp in (4,5) --дома без ќƒѕ”
                 and nvl(h.psch, 0) = 0 --не закрытые дома
               order by d.id) loop
      --распределить объем
      gen_dist_wo_vvod_usl(c.id);
    end loop;
  
    logger.log_(time1_,
                'p_vvod.gen_dist_all_houses - закончена II - ‘аза:–аспр в домах, где нет ќƒѕ”');
    time1_ := sysdate;
  
    --перераспределить объемы по домам
    for c in (select distinct d.*
                from c_vvod d, c_houses h
               where d.house_id = h.id
                 and nvl(h.psch, 0) = 0 --не закрытые дома
                 and d.dist_tp not in (4,5,2) --дома с ќƒѕ” и с услугой дл€ распределени€, например ќƒЌ (dist_tp<>2)
              ) 
     loop
      --коэфф по проживающим будет установлен в p_vvod.gen_dist
      p_vvod.gen_dist(p_klsk           => c.fk_k_lsk,
                      p_dist_tp        => c.dist_tp,
                      p_usl            => c.usl,
                      p_use_sch        => c.use_sch,
                      p_old_use_sch    => c.use_sch,
                      p_kub_nrm_fact   => c.kub_nrm_fact,
                      p_kub_sch_fact   => c.kub_sch_fact,
                      p_kub_ar_fact    => c.kub_ar_fact,
                      p_kub_ar         => c.kub_ar,
                      p_opl_ar         => c.opl_ar,
                      p_kub_sch        => c.kub_sch,
                      p_sch_cnt        => c.sch_cnt,
                      p_sch_kpr        => c.sch_kpr,
                      p_kpr            => c.kpr,
                      p_cnt_lsk        => c.cnt_lsk,
                      p_kub_norm       => c.kub_norm,
                      p_kub_fact       => c.kub_fact,
                      p_kub_man        => c.kub_man,
                      p_kub            => c.kub,
                      p_edt_norm       => c.edt_norm,
                      p_kub_dist       => c.kub_dist,
                      p_id             => c.id,
                      p_house_id       => c.house_id,
                      p_opl_add        => c.opl_add,
                      p_old_kub        => c.kub,
                      p_limit_proc     => c.limit_proc,
                      p_old_limit_proc => c.limit_proc,
                      p_gen_part_kpr   => 1,
                      p_wo_limit       => c.wo_limit);
    
      --Ќј„»—Ћ≈Ќ»≈ выполнитс€ в триггере C_VVOD_AU! --??? не нашЄл подтверждени€...
      commit;
    end loop;
    logger.log_(time1_,
                'p_vvod.gen_dist_all_houses - закончена III - ‘аза:–аспр в домах, где есть ќƒѕ”');
    logger.log_(time_,
                'p_vvod.gen_dist_all_houses: ќкончание распределени€');
  
  end;

  procedure gen_test_one_vvod(p_cur_dt  in date,
                              p_vvod_id in c_vvod.id%type) is
    l_cnt number;
    a     number;
  begin
    --проверка распределени€ по одному выбранному вводу
  
    --дата нужна дл€ начислени€
    a := init.set_date(p_cur_dt);
    for c in (select d.* from c_vvod d where d.id = p_vvod_id) loop
      p_vvod.gen_dist(p_klsk           => c.fk_k_lsk,
                      p_dist_tp        => c.dist_tp,
                      p_usl            => c.usl,
                      p_use_sch        => c.use_sch,
                      p_old_use_sch    => c.use_sch,
                      p_kub_nrm_fact   => c.kub_nrm_fact,
                      p_kub_sch_fact   => c.kub_sch_fact,
                      p_kub_ar_fact    => c.kub_ar_fact,
                      p_kub_ar         => c.kub_ar,
                      p_opl_ar         => c.opl_ar,
                      p_kub_sch        => c.kub_sch,
                      p_sch_cnt        => c.sch_cnt,
                      p_sch_kpr        => c.sch_kpr,
                      p_kpr            => c.kpr,
                      p_cnt_lsk        => c.cnt_lsk,
                      p_kub_norm       => c.kub_norm,
                      p_kub_fact       => c.kub_fact,
                      p_kub_man        => c.kub_man,
                      p_kub            => c.kub,
                      p_edt_norm       => c.edt_norm,
                      p_kub_dist       => c.kub_dist,
                      p_id             => c.id,
                      p_house_id       => c.house_id,
                      p_opl_add        => c.opl_add,
                      p_old_kub        => c.kub,
                      p_limit_proc     => c.limit_proc,
                      p_old_limit_proc => c.limit_proc,
                      p_gen_part_kpr   => 1,
                      p_wo_limit       => c.wo_limit);
      commit;
    end loop;
  end;

  procedure del_broken_sch_all is
    a number;
  begin
    --сн€ть признак счетчиков в зависимости от признака исправен/нет
    --по всем услугам
    --(обычно вызываетс€ из итогового формировани€)
    for c in (select u.usl from usl u where u.counter is not null) loop
      del_broken_sch(c.usl);
    end loop;
  end;

  procedure del_broken_sch(p_usl in usl.usl%type) is
    l_counter varchar2(100);
    cursor c is
      select substr(b.lsk, 1, 8) as lsk,
             b.state,
             b.dt1 as dt1,
             case
               when to_char(b.dt1, 'YYYYMM') <> p.period then
                to_date(p.period || '01', 'YYYYMMDD')
               else
                b.dt1
             end as dt2,
             b.psch,
             months_between(to_date(p.period || '01', 'YYYYMMDD'), b.dt1) as cnt_months
        from (select max(t.lsk) as lsk,
                     max(a.cd) keep(dense_rank last order by t.dt1) as state,
                     max(t.dt1) keep(dense_rank last order by t.dt1) as dt1,
                     max(k.psch) keep(dense_rank last order by t.dt1) as psch
                from kart k, c_reg_sch t, u_list a
               where t.fk_state = a.id
                 and k.lsk = t.lsk
                 and (k.psch in (1, 2) and l_counter = 'phw' or
                     (k.psch in (1, 3) and l_counter = 'pgw') or
                     (k.sch_el = 1 and l_counter = 'pel'))
                 and exists (select *
                        from u_list u
                       where u.cd = 'ѕоверка ѕ”'
                         and u.id = t.fk_tp)
                 and t.fk_usl = p_usl
               group by t.lsk, t.fk_usl) b,
             params p
       where b.state = 'Ќеисправен ѕ”';

 --больше 6 мес.не было передано объемов   
  cursor c2 is       
  select k.lsk, k.psch, to_date(p.period || '01', 'YYYYMMDD') as dt2
     from scott.kart k, scott.params p where not exists (
    select t.*
      from scott.t_objxpar t, scott.u_list s, scott.u_listtp tp, scott.params p
     where t.fk_list = s.id
       and t.tp =0
       and s.fk_listtp=tp.id 
       and tp.cd='ѕараметры лиц.счета'
       and t.fk_usl=p_usl
       and s.cd='ins_vol_sch'
       and nvl(t.n1,0)>0 
       and k.psch not in (8,9)
       and t.mg>=to_char(add_months(to_date(p.period || '01', 'YYYYMMDD'),-6),'YYYYMM') --назад на 6 мес€цев
       and t.fk_lsk=k.lsk
    ) 
    and (k.psch in (1, 2) and l_counter = 'phw' or
        (k.psch in (1, 3) and l_counter = 'pgw') or
        (k.sch_el = 1 and l_counter = 'pel'));
       
    l_rec    c%rowtype;
    l_rec2    c2%rowtype;
    l_res    number;
    l_usl_nm varchar2(100);
  begin
    --по среднему, за последний N мес€цев, но не менее чем за последние 3 мес.
    select trim(t.counter), trim(t.nm)
      into l_counter, l_usl_nm
      from usl t
     where t.usl = p_usl;
  
    --ѕеределать все счетчики в норматив, если признаны неисправными
    open c;
    loop
      fetch c
        into l_rec;
      exit when c%notfound;
      if l_rec.cnt_months > 2 then
        --больше чем 2 мес€ца неисправен прибор учета
        if l_counter = 'phw' then
          l_res := utils.set_krt_psch(dat_       => l_rec.dt2,
                                      fk_status_ => case
                                                      when l_rec.psch = 1 then
                                                       3
                                                      when l_rec.psch = 2 then
                                                       0
                                                    end,
                                      lsk_       => l_rec.lsk);
          if l_res <> 1 then
            raise_application_error(-20000,
                                    'ќшибка сн€ти€ прибора учета по услуге: ' ||
                                    l_usl_nm || ', в Ћ/— ' || l_rec.lsk);
          end if;
          logger.log_act(l_rec.lsk,
                         'ќбновление л/с: ' || l_rec.lsk ||
                         ' Ќеисправный счетчик по услуге: ' || l_usl_nm ||
                         ', >= 3 мес€ца, установлен норматив',
                         2);
        elsif l_counter = 'pgw' then
          l_res := utils.set_krt_psch(dat_       => l_rec.dt2,
                                      fk_status_ => case
                                                      when l_rec.psch = 1 then
                                                       2
                                                      when l_rec.psch = 3 then
                                                       0
                                                    end,
                                      lsk_       => l_rec.lsk);
          if l_res <> 1 then
            raise_application_error(-20000,
                                    'ќшибка сн€ти€ прибора учета по услуге: ' ||
                                    l_usl_nm || ', в Ћ/—' || l_rec.lsk);
          end if;
          logger.log_act(l_rec.lsk,
                         'ќбновление л/с: ' || l_rec.lsk ||
                         ' Ќеисправный счетчик по услуге: ' || l_usl_nm ||
                         ', >= 3 мес€ца, установлен норматив',
                         2);
        elsif l_counter = 'pel' then
          update kart k set k.sch_el = 0 where k.lsk = l_rec.lsk;
          logger.log_act(l_rec.lsk,
                         'ќбновление л/с: ' || l_rec.lsk ||
                         ' Ќеисправный счетчик по услуге: ' || l_usl_nm ||
                         ', >= 3 мес€ца, установлен норматив',
                         2);
        end if;
      else
        -- <= 2 мес€ца неисправен прибор учета
        --просто убрать расход, если введЄн (при автоначислении, - начислитс€ по среднему)
        if l_counter = 'phw' then
          update kart k set k.mhw = 0 where k.lsk = l_rec.lsk;
          logger.log_act(l_rec.lsk,
                         'ќбновление л/с: ' || l_rec.lsk ||
                         ' Ќеисправный счетчик по услуге: ' || l_usl_nm ||
                         ', < 3 мес€ца, начислено по среднему',
                         2);
        elsif l_counter = 'pgw' then
          update kart k set k.mgw = 0 where k.lsk = l_rec.lsk;
          logger.log_act(l_rec.lsk,
                         'ќбновление л/с: ' || l_rec.lsk ||
                         ' Ќеисправный счетчик по услуге: ' || l_usl_nm ||
                         ', < 3 мес€ца, начислено по среднему',
                         2);
        elsif l_counter = 'pel' then
          update kart k set k.mel = 0 where k.lsk = l_rec.lsk;
          logger.log_act(l_rec.lsk,
                         'ќбновление л/с: ' || l_rec.lsk ||
                         ' Ќеисправный счетчик по услуге: ' || l_usl_nm ||
                         ', < 3 мес€ца, начислено по среднему',
                         2);
        end if;
      
      end if;
    end loop;
    close c;
    
    
    --ѕеределать все счетчики в норматив, если не было передано показаний по ним
    open c2;
    loop
      fetch c2
        into l_rec2;
      exit when c2%notfound;
        if l_counter = 'phw' then
          l_res := utils.set_krt_psch(dat_       => l_rec2.dt2,
                                      fk_status_ => case
                                                      when l_rec2.psch = 1 then
                                                       3
                                                      when l_rec2.psch = 2 then
                                                       0
                                                    end,
                                      lsk_       => l_rec2.lsk);
          if l_res <> 1 then
            raise_application_error(-20000,
                                    'ќшибка сн€ти€ прибора учета по услуге: ' ||
                                    l_usl_nm || ', в Ћ/— ' || l_rec2.lsk);
          end if;
          logger.log_act(l_rec2.lsk,
                         'ќбновление л/с: ' || l_rec2.lsk ||
                         ' ѕо счетчику не передавали показаний >= 6 мес€цев, по услуге: ' || l_usl_nm ||
                         ' установлен норматив',
                         2);
        elsif l_counter = 'pgw' then
          l_res := utils.set_krt_psch(dat_       => l_rec2.dt2,
                                      fk_status_ => case
                                                      when l_rec2.psch = 1 then
                                                       2
                                                      when l_rec2.psch = 3 then
                                                       0
                                                    end,
                                      lsk_       => l_rec2.lsk);
          if l_res <> 1 then
            raise_application_error(-20000,
                                    'ќшибка сн€ти€ прибора учета по услуге: ' ||
                                    l_usl_nm || ', в Ћ/—' || l_rec2.lsk);
          end if;
          logger.log_act(l_rec2.lsk,
                         'ќбновление л/с: ' || l_rec2.lsk ||
                         ' ѕо счетчику не передавали показаний >= 6 мес€цев, по услуге: ' || l_usl_nm ||
                         ' установлен норматив',
                         2);
        elsif l_counter = 'pel' then
          update kart k set k.sch_el = 0 where k.lsk = l_rec2.lsk;
          logger.log_act(l_rec2.lsk,
                         'ќбновление л/с: ' || l_rec2.lsk ||
                         ' ѕо счетчику не передавали показаний >= 6 мес€цев, по услуге: ' || l_usl_nm ||
                         ' установлен норматив',
                         2);
        end if;
  end loop;
  close c2;
      
  end;

  function gen_auto_chrg_all(p_set in number, p_usl in usl.usl%type)
    return number is
    l_counter usl.counter%type;
    l_mg1     params.period%type;
    l_mg2     params.period%type;
    l_cnt     t_objxpar.n1%type;
    l_tp      t_objxpar.tp%type;
    l_ret     number;
    l_months  spr_params.parn1%type;
    l_usl_nm  varchar2(100);
    l_otop    number; --отопит.период
  begin
    logger.log_(null, 'p_vvod.gen_auto_chrg_all Ќачало');
  
    --установить глобальную переменную - признак автоначислени€ (потом сделать как нить g_tp=3)
    g_tp := 1;
    --сн€ть статусы неисправных счетчиков
    if utils.get_int_param('DEL_BRK_SCH')=1 then
      del_broken_sch(p_usl);
    end if;
    --сн€ть глобальную переменную
    g_tp := 0;
  
    --автоначисление по счетчикам, по услуге
    l_ret := 1;
  
    --узнать отопительный ли сезон?
    --(по последней дате мес€ца) - пока так... ничего умнее не придумал
    select case
             when last_day(to_date(p.period || '01', 'YYYYMMDD')) between
                  utils.get_date_param('MONTH_HEAT1') --обраб.отопит.период
                  and utils.get_date_param('MONTH_HEAT2') then
              1
             else
              0
           end
      into l_otop
      from params p;
  
    --по среднему, за последний N мес€цев, но не менее чем за последние 3 мес.
    select trim(t.counter), trim(t.nm)
      into l_counter, l_usl_nm
      from usl t
     where t.usl = p_usl;
    l_months := utils.get_int_param('AUTOCHRGM');
  
    if p_set = 1 then
      --автоначислить по среднему
      --период, от года назад до прошлого мес€ца
      select to_char(add_months(to_date(p.period || '01', 'YYYYMMDD'),
                                -1 * l_months),
                     'YYYYMM'),
             to_char(add_months(to_date(p.period || '01', 'YYYYMMDD'), -1),
                     'YYYYMM')
        into l_mg1, l_mg2
        from params p;
    
      --сн€ть неисправные счетчики (превратить в нормативы)
      if utils.get_int_param('DEL_BRK_SCH')=1 then  --ѕќ„≈ћ” ƒ¬ј∆ƒџ????
        del_broken_sch(p_usl);
      end if;
    
      --установить глобальную переменную - признак автоначислени€
      g_tp := 1;
    
      for c in (select a.lsk,
                       nvl(sum(case
                                 when a.psch in (1, 2) then
                                  1
                                 else
                                  0
                               end),
                           0) as m_hw, --мес€цев, когда счетчик был установлен
                       nvl(sum(case
                                 when a.psch in (1, 2) then
                                  a.mhw
                                 else
                                  0
                               end),
                           0) as cnt_hw, --объем, когда счетчик был установлен
                       nvl(sum(case
                                 when a.psch in (1, 3) then
                                  1
                                 else
                                  0
                               end),
                           0) as m_gw, --и так далее...
                       nvl(sum(case
                                 when a.psch in (1, 3) then
                                  a.mgw
                                 else
                                  0
                               end),
                           0) as cnt_gw,
                       nvl(sum(case
                                 when a.sch_el in (1) then
                                  1
                                 else
                                  0
                               end),
                           0) as m_el,
                       nvl(sum(case
                                 when a.sch_el in (1) then
                                  a.mel
                                 else
                                  0
                               end),
                           0) as cnt_el
                  from arch_kart a
                 where a.mg between l_mg1 and l_mg2
                   and (l_otop = 0 and l_counter = 'pgw' and not exists --обрабатываем краны из сист.отоплени€ (только дл€ √.¬.!!!)
                        (select *
                           from kart k
                          where k.lsk = a.lsk
                            and k.kran1 = 1) or
                        l_otop = 1 and l_counter = 'pgw' or
                        l_counter <> 'pgw')
                   and exists
                 (select *
                          from kart k
                         where k.k_lsk_id = a.k_lsk_id -- and k.lsk='04002933'
                           and ((k.psch in (1, 2) and l_counter = 'phw' and
                               nvl(k.mhw, 0) = 0) or
                               (k.psch in (1, 3) and l_counter = 'pgw' and
                               nvl(k.mgw, 0) = 0) or
                               (k.sch_el = 1 and l_counter = 'pel') and
                               nvl(k.mel, 0) = 0)
                              
                           and k.psch not in (8, 9))
                 group by a.lsk) loop
        --¬Ќ»ћјЌ»≈!, ѕ≈–≈ѕ»—ј“№ ƒЋя  »—, ≈—Ћ» Ѕ”ƒ”“ »—ѕќЋ№«ќ¬ј“№ распределение по расходу!
        if l_counter = 'phw' then
          --автоначислить по х.в.
          if c.m_hw >= 3 and c.cnt_hw > 0 then
            --не менее 3 мес€цев счетчик
            l_ret := 0;
            update kart k
               set k.phw = nvl(k.phw, 0) + round(c.cnt_hw / c.m_hw, 3)
             where k.lsk = c.lsk;
          end if;
        elsif l_counter = 'pgw' then
          --автоначислить по г.в.
          if c.m_gw >= 3 and c.cnt_gw > 0 then
            --не менее 3 мес€цев счетчик
            l_ret := 0;
            update kart k
               set k.pgw = nvl(k.pgw, 0) + round(c.cnt_gw / c.m_gw, 3)
             where k.lsk = c.lsk;
          end if;
        elsif l_counter = 'pel' then
          --автоначислить по эл.эн.
          if c.m_el >= 3 and c.cnt_el > 0 then
            --не менее 3 мес€цев счетчик
            l_ret := 0;
            update kart k
               set k.pel = nvl(k.pel, 0) + round(c.cnt_el / c.m_el, 3)
             where k.lsk = c.lsk;
          end if;
        end if;
      end loop;
    elsif p_set = 0 then
      --сн€ть автоначисление (отмена) (последнюю итерацию)
      --установить глобальную переменную - признак сн€ти€ автоначислени€
      g_tp := 2;
    
      for c in (select t.fk_lsk, max(t.id) as max_id
                  from t_objxpar t, params p, u_list s, u_listtp tp
                 where t.mg = p.period
                   and tp.id = s.fk_listtp
                   and tp.cd = 'ѕараметры лиц.счета'
                   and s.cd = 'ins_vol_sch'
                   and t.fk_list = s.id
                   and t.fk_usl = p_usl
                   and t.tp in (1, 2) --тип - автоначислено, отмена автоначисл.
                --         and exists (select * from kart k where k.kran1=1 and k.lsk=t.fk_lsk)  включить если нужно отменить по сист. отоплени€
                 group by t.fk_lsk) loop
        select t.tp, nvl(t.n1, 0)
          into l_tp, l_cnt
          from t_objxpar t
         where t.id = c.max_id;
      
        --¬Ќ»ћјЌ»≈!, ѕ≈–≈ѕ»—ј“№ ƒЋя  »—, ≈—Ћ» Ѕ”ƒ”“ »—ѕќЋ№«ќ¬ј“№ распределение по расходу!
        if l_tp = 1 and l_cnt <> 0 then
          l_ret := 0;
          --¬озможность отменить только автоначисление!
          --(Ќо только его, а не другие типы)
          if l_counter = 'phw' then
            --сн€ть автоначисление по х.в.
            update kart k
               set k.phw = nvl(k.phw, 0) - l_cnt
             where k.lsk = c.fk_lsk
               and k.psch in (1, 2);
          elsif l_counter = 'pgw' then
            --сн€ть автоначисление по г.в.
            update kart k
               set k.pgw = nvl(k.pgw, 0) - l_cnt
             where k.lsk = c.fk_lsk
               and k.psch in (1, 3);
          elsif l_counter = 'pel' then
            --сн€ть автоначисление по эл.эн.
            update kart k
               set k.pel = nvl(k.pel, 0) - l_cnt
             where k.lsk = c.fk_lsk
               and k.sch_el in (1);
          end if;
        end if;
      end loop;
    
    end if;
    --сн€ть глобальную переменную - признак автоначислени€
    g_tp := 0;
    commit;
    if p_set = 1 then
      logger.log_(null,
                  'p_vvod.gen_auto_chrg_all ќкончание-автоначислено по среднему');
    elsif p_set = 0 then
      logger.log_(null,
                  'p_vvod.gen_auto_chrg_all ќкончание-—н€тие:автоначислени€ по среднему');
    end if;
    return l_ret;
  end;

  function opl_liter(p_opl_man in number) return number is
  begin
    --таблица дл€ возврата норматива потреблени€ (в литрах) по соотв.площади на человека
    case round(p_opl_man)
      when 1 then
        return 2;
      when 2 then
        return 2;
      when 3 then
        return 2;
      when 4 then
        return 10;
      when 5 then
        return 10;
      when 6 then
        return 10;
      when 7 then
        return 10;
      when 8 then
        return 10;
      when 9 then
        return 10;
      when 10 then
        return 9;
      when 11 then
        return 8.2;
      when 12 then
        return 7.5;
      when 13 then
        return 6.9;
      when 14 then
        return 6.4;
      when 15 then
        return 6.0;
      when 16 then
        return 5.6;
      when 17 then
        return 5.3;
      when 18 then
        return 5.0;
      when 19 then
        return 4.7;
      when 20 then
        return 4.5;
      when 21 then
        return 4.3;
      when 22 then
        return 4.1;
      when 23 then
        return 3.9;
      when 24 then
        return 3.8;
      when 25 then
        return 3.6;
      when 26 then
        return 3.5;
      when 27 then
        return 3.3;
      when 28 then
        return 3.2;
      when 29 then
        return 3.1;
      when 30 then
        return 3.0;
      when 31 then
        return 2.9;
      when 32 then
        return 2.8;
      when 33 then
        return 2.7;
      when 34 then
        return 2.6;
      when 35 then
        return 2.6;
      when 36 then
        return 2.5;
      when 37 then
        return 2.4;
      when 38 then
        return 2.4;
      when 39 then
        return 2.3;
      when 40 then
        return 2.3;
      when 41 then
        return 2.2;
      when 42 then
        return 2.1;
      when 43 then
        return 2.1;
      when 44 then
        return 2;
      when 45 then
        return 2;
      when 46 then
        return 2;
      when 47 then
        return 1.9;
      when 48 then
        return 1.9;
      when 49 then
        return 1.8;
      else
        return 1.8;
    end case;
  end;

  procedure kmp_dist_all_houses is
    l_cnt       number;
    i           number;
    l_job       number;
    l_job1      number;
    l_job2      number;
    l_job3      number;
    l_start_row number;
    l_end_row   number;
    time_       date;
  begin
    time_ := sysdate;
    --запускаем 3 JOB-a которые будут проставл€ть kpr!
    --разделил весьма грубо на 3 части
    i := 1;
    --создать JOB
    while i <= 3 loop
      if i = 1 then
        l_start_row := 1;
        l_end_row   := 1999;
      elsif i = 2 then
        l_start_row := 2000;
        l_end_row   := 4999;
      elsif i = 3 then
        l_start_row := 5000;
        l_end_row   := 999999;
      end if;
    
      dbms_job.submit(job  => l_job,
                      what => '
      declare
       l_a number;
      begin
       for c in (select * from
         (select k.lsk, rownum as rn from kart k
        where k.psch not in (8,9) order by k.lsk) a
            where a.rn between ' || l_start_row ||
                               ' and ' || l_end_row || ')
         loop

--          logger.log_(null, c.lsk);
         c_kart.set_part_kpr(c.lsk);

         commit;
         end loop;
      exception when others
        then
          logger.log_(null, ''ќшибка из JOB: ''||SQLERRM);
          raise;

      end;');
      --    dbms_job.broken(job => l_job, broken => TRUE);
      --    dbms_job.run(job => l_job);
    
      if i = 1 then
        l_job1 := l_job;
      elsif i = 2 then
        l_job2 := l_job;
      elsif i = 3 then
        l_job3 := l_job;
      end if;
      i := i + 1;
    end loop;
  
    commit;
  
    --ожидать выполнени€ JOB
    dbms_lock.sleep(10);
    while true loop
      for c in (select t.*
                  from user_jobs t
                 where t.job in (l_job1, l_job2, l_job3)
                   and t.failures <> 0) loop
        --удалить Job-ы
        for c2 in (select t.*
                     from user_jobs t
                    where t.job in (l_job1, l_job2, l_job3)) loop
          dbms_job.remove(c2.job);
          commit;
        end loop;
        raise_application_error(-20000,
                                'ќшибка #1 во врем€ начислени€ (см.Log)!');
      end loop;
    
      select nvl(count(*), 0)
        into l_cnt
        from dba_jobs_running t
       where t.job in (l_job1, l_job2, l_job3);
      if l_cnt = 0 then
        exit;
      end if;
      dbms_lock.sleep(2);
    end loop;
  
    --  dbms_job.broken(job => l_job1, broken => TRUE);
    --  dbms_job.broken(job => l_job2, broken => TRUE);
    --  dbms_job.broken(job => l_job3, broken => TRUE);
  
  end;
end p_vvod;
/

prompt
prompt Creating package body REP_BILLS
prompt ===============================
prompt
create or replace package body scott.rep_bills is

procedure get_breaks(p_reu in kart.reu%type,
                     p_cnt number,
                     p_mg in params.period%type,
                     p_recset OUT SYS_REFCURSOR) is
begin
--получить разбиение счетов на партии
 if nvl(p_cnt,0) = 0 then
  OPEN p_recset FOR
    select 0 as first_rec, 0 as last_rec, '¬се' as name
      from dual;
 else
  OPEN p_recset FOR
    select 0 as first_rec, 0 as last_rec, '¬се' as name
      from dual
    union all
    select distinct a.fst as first_rec,
     max(k.prn_num) over (partition by a.fst) as last_rec,
     'с ' || a.fst || ' по ' || max(k.prn_num) over (partition by a.fst) as name
     from (select nvl(lag(r.rn,1) over (order by 0),0)+1 as fst,
      r.rn as lst  from
       (select level*p_cnt as rn
      from dual connect by level <= 1000000) r) a,
     arch_kart k
     where k.mg=p_mg and k.reu=p_reu
     and k.prn_num between a.fst and a.lst
     order by first_rec;


/*    select
     s.lvl, s.first_rec, s.last_rec,
     'с ' || s.first_rec || ' по ' || s.last_rec as name
      from (with t as (select count(*) as all_cnt,
                              count(distinct k.lsk) / nvl(p_cnt, 0) as cnt
                         from scott.arch_kart k
                        where k.reu = p_reu
                          and k.mg = p_mg
                          and nvl(k.for_bill, 0) = 1)
             select level as lvl,
                    nvl(lag(level * nvl(p_cnt, 0) + 1, 1) over(order by level),
                         1) as first_rec,
                    case
                      when level * nvl(p_cnt, 0) >= t.all_cnt then
                       t.all_cnt
                      else
                       level * nvl(p_cnt, 0)
                    end as last_rec
               from t
             connect by level < case
                          when t.all_cnt > t.cnt then
                           t.cnt + 1
                          else
                           t.cnt
                        end
              order by level) s
              order by lvl;*/
 end if;
end;

function pipe_bills(lsk_           IN KART.lsk%TYPE,
                         lsk1_          IN KART.lsk%TYPE,
                         var_           IN number,
                         var2_          IN number,
                         kul_           IN KART.kul%TYPE,
                         nd_            IN KART.nd%TYPE,
                         kw_            IN KART.kw%TYPE,
                         mg1_ IN PARAMS.period%TYPE,
                         mg2_ IN PARAMS.period%TYPE)
 return tbl_bills pipelined as
 l_bill_var number; --вариант формировани€ счета
 cur ccur;
 rec_ rec_bills;
 mg_ varchar(6);
 mg3_ varchar(6);
 fname_sch_ VARCHAR2(25);
 sqlstr_ VARCHAR2(200);
 sqlstr2_ VARCHAR2(200);
 sqlstr3_ VARCHAR2(350);
 sqlstr4_ VARCHAR2(500);
 sqlstr5_ VARCHAR2(300);
 sqlstr6_ VARCHAR2(100);
 sqlstr7_ VARCHAR2(650);
 sqlstr8_ VARCHAR2(50);
 sqlstr9_ VARCHAR2(300);
 sqlstr10_ VARCHAR2(300);
 sqlstr11_ VARCHAR2(300);
 sqlstr12_ VARCHAR2(300);
 sqlstr13_ VARCHAR2(2000);
 sqlstr14_ VARCHAR2(800);
 sqlstr15_ VARCHAR2(800);
 l_supress_sal number;

 mg_nolg_ VARCHAR2(6);

-- компилируетс€ неустойчиво на oracle 9.xx
begin
-- logger_tst;
 mg_:=mg1_;
 --на мес€ц вперед
 mg3_:=to_char(add_months(to_date(mg_||'01','YYYYMMDD'),1),'YYYYMM');

 --период отмены льгот
  mg_nolg_:=utils.get_str_param('MG_NOLG');

  --подавл€ть строки с нулевым сальдо в счетах
  l_supress_sal:=utils.get_int_param('BILL_SUPRESS_SAL');
  if l_supress_sal = 1 then
    sqlstr15_:='';
  else
    sqlstr15_:='sum(sl.summa) <> 0 or';
  end if;
loop
  exit when to_number(mg_) > to_number(mg2_);
  --ред. оптимизаци€ под 1 л.с.
  sqlstr_:= 'and l.lsk = '''||lsk1_||'''';
--  sqlstrlsk_:= 'and lsk = '''||lsk1_||'''';
/*    if lsk_ is not null and lsk1_ is not null then
      sqlstr_:= 'AND l.lsk BETWEEN '''||lsk_||''' AND '''||lsk1_||'''';
    else
      if kul_ is not null then
         sqlstr_:= ' and '||'l.kul='''||kul_||'''';
      end if;
      if nd_ is not null then
         sqlstr_:= sqlstr_||' and '||'l.nd='''||nd_||'''';
      end if;
      if kw_ is not null then
         sqlstr_:= sqlstr_||' and '||'l.kw='''||kw_||'''';
      end if;
    end if;*/

   --печатать ли по старому фонду счета?
   if nvl(var2_,0) = 0 then
     sqlstr8_:='and k.psch <> 8';
   else
     sqlstr8_:='';
   end if;

  select o.fk_bill_var into l_bill_var
    from kart k, t_org o
    where k.reu=o.reu
    and k.lsk=lsk1_;
  if l_bill_var is null then
    Raise_application_error(-20000, 'ƒолжен быть заполнен fk_bill_var в справочнике t_org!');
  end if;  

  if nvl(var_,0) in (0,4) then --счЄт, счЄт дл€ ”—«Ќ
   sqlstr2_:='s.usl';
   sqlstr3_:='substr(trim(s.nm),1,28)||'',''||trim(s.ed_izm)';
   if mg_ > 200710 and mg_ >= mg_nolg_ then
     --новые счета
     sqlstr4_:='max(psch) in (8,9) and max(h2.dolg) <> 0 and ((sum(y.summa) <> 0 or
         sum(r.summa) <> 0 or
         sum(x.summa) <> 0 or
         sum(sl.summa) <> 0 or
         sum(nvl(a.summa, 0) - nvl(c.summa, 0) +
             nvl(y.summa, 0)+nvl(r.summa, 0)+nvl(x.summa, 0))  <> 0)
             or max(s.usl)=''003'')
             ';
    else
     sqlstr4_:='max(psch) in (8,9) and max(h2.dolg) <> 0 and ((sum(y.summa) <> 0 or
         sum(r.summa) <> 0 or
         sum(x.summa) <> 0 or
         sum(nvl(a.summa, 0) - nvl(c.summa, 0) +
             nvl(y.summa, 0)+nvl(r.summa, 0)+nvl(x.summa, 0))  <> 0)
             or max(s.usl)=''003'')
             ';
    end if;

   sqlstr5_:='round(sum(e.cena), 2)';
   sqlstr6_:='substr(k.fio, 1, 40)';
   sqlstr7_:='(select nvl(tp.cd,''LSK_TP_MAIN'') as lsk_tp, u.usl, l.*, substr(t.name,1,32) as name_org, t.phone, t.phone2
    from arch_kart l, t_org t, usl u, v_lsk_tp tp
      where l.fk_tp=tp.id(+) and (l.psch in (8,9) or l.psch not in (8,9)) and l.reu=t.reu and l.mg='''||mg_||''' '||sqlstr_||'
      )';
   sqlstr9_:='(select l.lsk, nvl(sum(l.penya),0) as penya
          from a_penya l where l.mg='''||mg_||''' '||sqlstr_||'
          group by l.lsk)';
   sqlstr11_:='(select l.lsk, nvl(sum(l.penya),0) as penya
          from scott.a_penya l where l.mg='''||mg_||''' '||sqlstr_||'
          group by l.lsk)';

--   if mg_ > 200710 and mg_ >= mg_nolg_ then
     sqlstr12_:='(select lsk, sum(summa) AS summa, sum(penya) as penya
                    from a_kwtp_mg l
                   where mg between '''||mg1_||''' and '''||mg2_||''' '||sqlstr_||'
                   group by lsk)';
--   else
--     sqlstr12_:='(select lsk, sum(summa) AS summa, null as penya
--                    from arch_kwtp l
--                   where mg between '''||mg1_||''' and '''||mg2_||''' '||sqlstr_||'
--                   group by lsk)';
--   end if;                
                   
  end if;




--оплата в разные периоды распредел€лась по разным таблицам
if to_number(mg_) > 200803 then
   sqlstr10_:='select l.lsk, sum(l.summa) as prev_pay
          from a_kwtp_mg l where l.mg='''||mg_||''' '||sqlstr_||'
         group by l.lsk';
else
   sqlstr10_:='select l.lsk, sum(l.summa) as prev_pay
          from arch_kwtp l where l.mg='''||mg_||''' '||sqlstr_||'
         group by l.lsk';
end if;

if mg_ >= utils.get_str_param('COLLAPSE_USL') then
/* —ворачивать ли расценку по услуге с.н.+св.н*/

/*sqlstr13_:='select cc2.lsk, cc2.usl, max(cc2.org) as org, sum(cc2.cena) as cena from (
       select aa1.lsk, aa1.org,
         su.id as usl, su.frc_get_price,
         case when nvl(lag(su.id,1) over (order by su.id, su.usl_id),''XXX'')
           <> su.id or su.frc_get_price=1 then aa1.cena
           else 0
           end as cena
           from
          (select cc.lsk,
                 cc.usl,
                 n.org,
                 max(round(cc.test_cena, 2)) as cena
            from a_charge cc, arch_kart l, a_nabor n
           where cc.type = 0
             and cc.lsk=l.lsk and l.mg='''||mg_||''' '||sqlstr_||' and l.psch <> 8
             and cc.mg=l.mg
             and cc.lsk=n.lsk(+)
             and cc.usl=n.usl(+)
             and cc.mg=n.mg(+)
           group by cc.lsk, cc.usl, n.org) aa1, scott.usl_bills su, scott.usl su2
           where aa1.usl=su.usl_id and aa1.usl=su2.usl and su.fk_bill_var='||l_bill_var||'
           and  '''||mg_||''' between su.mg1 and su.mg2
           ) cc2 group by cc2.lsk, cc2.usl'; */ --было до 21.10.2015
           
           
sqlstr13_:='select cc2.lsk, cc2.usl, max(cc2.org) as org, sum(cc2.cena) as cena from (
       select aa1.lsk, aa1.org,/* —ворачивать ли расценку по услуге с.н.+св.н*/
         su.id as usl, su.frc_get_price,
         case when nvl(lag(su2.uslm,1) over (order by su2.uslm, su2.usl),''XXX'')
           <> su2.uslm or su.frc_get_price=1 then aa1.cena
           else 0
           end as cena
           from
          (select cc.lsk,
                 cc.usl,
                 n.org,
                 max(round(cc.test_cena, 2)) as cena
            from a_charge cc, arch_kart l, a_nabor n
           where cc.type = 0
             and cc.lsk=l.lsk and l.mg='''||mg_||''' '||sqlstr_||' and l.psch <> 8
             and cc.mg=l.mg
             and cc.lsk=n.lsk(+)
             and cc.usl=n.usl(+)
             and cc.mg=n.mg(+)
           group by cc.lsk, cc.usl, n.org) aa1, scott.usl_bills su, scott.usl su2
           where aa1.usl=su.usl_id and aa1.usl=su2.usl and su.fk_bill_var='||l_bill_var||'
           and  '''||mg_||''' between su.mg1 and su.mg2
           ) cc2 group by cc2.lsk, cc2.usl';
           
else
  sqlstr13_:='select cc.lsk,
                 cc.usl,
                 n.org,
                 max(round(cc.test_cena, 2)) as cena
            from a_charge cc, arch_kart l, a_nabor n
           where cc.type = 0
             and cc.lsk=l.lsk and l.mg='''||mg_||''' '||sqlstr_||' and l.psch <> 8
             and cc.mg=l.mg
             and cc.lsk=n.lsk(+)
             and cc.usl=n.usl(+)
             and cc.mg=n.mg(+)
           group by cc.lsk, cc.usl, n.org';
end if;

  sqlstr14_:='(select l.lsk, nvl(sum(l.summa),0) as dolg
          from saldo_usl l where l.mg =to_char(add_months(to_date('''||mg_||''', ''YYYYMM''), 1), ''YYYYMM'')
            '||sqlstr_||'
         group by l.lsk)';

if mg_ > 200710 and mg_ < mg_nolg_ then
  OPEN cur FOR
   'select k.mg1, k.mg, k.k_lsk_id, k.lsk, g.name || '' д.'' || ltrim(k.nd, ''0'') || ''-'' || ltrim(k.kw, ''0'') as streetname,
       '||sqlstr6_||' as fio,
       utils.month_name(SUBSTR('''||mg_||''', 5, 2)) || '' '' ||
       SUBSTR('''||mg_||''', 1, 4) || '' г.'' AS monthyear,
       k.status,
       k.psch,
       k.phw,
       k.pgw,
       k.pel,
       k.kul,
       k.opl,
       k.pldop,
       k.kpr,
       k.kpr_ot,
       k.kpr_wr,
       k.kpr_wrp,
       k.name_org,
       k.phone,
       k.phone2,
       k.ki,
       k.subs_inf,
       s.npp,
       '||sqlstr2_||' as usl,
       '||sqlstr3_||' as nm,
       max((select count(distinct tt.id)
        from a_kart_pr tt, a_lg_docs d, a_lg_pr p
        where tt.id=d.c_kart_pr_id and d.id=p.c_lg_docs_id
        and tt.lsk=k.lsk
        and tt.mg=k.mg and tt.mg=d.mg and tt.mg=p.mg and p.spk_id<>1
        and p.type=1 and d.main=1)) as lg_mains,
       max((select max(utils.concatenate(ROWNUM, p.spk_id, '','')) as nm
        from a_kart_pr tt, a_lg_docs d, a_lg_pr p
        where tt.id=d.c_kart_pr_id and d.id=p.c_lg_docs_id
        and tt.lsk=k.lsk
        and tt.mg=k.mg and tt.mg=d.mg and tt.mg=p.mg and p.spk_id<>1
        and p.type=1 and d.main=1)) as lg_ids,
       max(h5.penya) as itg_pen,
       max(h6.summa) as itg_pay,
       max(h6.penya) as itg_pen_pay,
        '||sqlstr5_||' as tarif,
       sum(decode('||sqlstr2_||', ''004'', a.vol, 0)) as pl_svnorm,
       max(a.vol) as vol, /*было max(a.vol) as vol, ред от 29.12.2010*/
       sum(a.summa) as charges,
       sum(f.summa) as privs,
       sum(y.summa) AS changes0,
       null AS ch_proc0,
       sum(r.summa) AS changes1,
       sum(x.summa) AS changes2,
       null as sl,
       sum(c.summa) as subs,
       max(j.summa) AS sub_el,
       sum(nvl(a.summa, 0) - nvl(f.summa, 0) - nvl(c.summa, 0) +
           nvl(y.summa, 0)+nvl(r.summa, 0)+nvl(x.summa, 0)) as itog,
       sum(nvl(a.summa, 0) - nvl(f.summa, 0) - nvl(c.summa, 0)) as itog_uszn,
       f.lgname,
       f.lg_id,
       f.cnt,
       f.lg_koef,
       '''||fname_sch_||''' as fname_sch,
       max(h.prev_chrg) as prev_chrg,
       max(o.prev_pay) as prev_pay,
       max(o.prev_pay) as payment,  --оч странно
       max(h3.penya) as penya,
       max(h3.penya) as monthpenya,
       max(h3.penya) as monthpenya2,
       max(h2.dolg) as dolg,
       null as old_dolg,
       max(nvl(h2.dolg,0)) as itog_dolg,
       max(
       case when h4.sal_in < 0 then
        h4.sal_in
        else
        0 end) as ovrpaymnt,
       max(h4.sal_in) as sal_in,
       k.dolg as dolg2,
       null as org,
       null as bill_brake
  from spul g,
       '||sqlstr7_||' k,
       (select a.lsk, a.usl, sum(a.summa) as summa, sum(a.test_opl) as vol
          from scott.a_charge a, scott.arch_kart l
         where a.type = 1 and a.lsk=l.lsk and l.mg='''||mg_||''' '||sqlstr_||'
         and a.mg=l.mg
         group by a.lsk, a.usl) a,
       (select a.lsk, a.usl, sum(a.summa) as summa
          from scott.a_charge a, scott.arch_kart l
         where type = 2 and a.lsk=l.lsk and l.mg='''||mg_||''' '||sqlstr_||'
         and a.mg=l.mg
         group by a.lsk, a.usl) c,
       ( '||sqlstr13_||') e,
         (select l.lsk, l.usl_id, sum(l.summa) as summa from
          arch_changes l where l.mg='''||mg_||'''
          '||sqlstr_||'
          and l.id=0 and nvl(l.show_bill,0)<>1
          group by l.lsk, l.usl_id) y,
         (select l.lsk, l.usl_id, sum(l.summa) as summa from
          arch_changes l where l.mg='''||mg_||''' and nvl(l.show_bill,0)<>1
          '||sqlstr_||'
          and l.id=1
          group by l.lsk, l.usl_id) r,
         (select l.lsk, l.usl_id, sum(l.summa) as summa from
          arch_changes l where l.mg='''||mg_||''' and nvl(l.show_bill,0)<>1
          '||sqlstr_||'
          and l.id=2
          group by l.lsk, l.usl_id) x,
       (select l.lsk,
               l.usl_id,
               max(sp.id) as lg_id,
               max(sp.name) as lgname,
               max(sk.koef) as lg_koef,
               sum(l.summa) as summa,
               sum(l.cnt_main) as cnt_main,
               sum(l.cnt) as cnt
          from arch_privs l, spk sp, a_spk_usl sk
         where l.mg = sk.mg and l.mg='''||mg_||''' '||sqlstr_||'
           and l.lg_id = sp.id
           and l.lg_id = sk.spk_id
           and l.usl_id = sk.usl_id
         group by l.lsk, l.usl_id) f,
       (select l.lsk, nvl(sum(l.summa),0) as prev_chrg,
          sum(null) as prev_pen
          from saldo_usl l where l.mg = '''||mg_||''' '||sqlstr_||'
         group by l.lsk) h,
       '||sqlstr14_||' h2,
       '||sqlstr9_||' h3,
       '||sqlstr11_||' h5,
       '||sqlstr12_||' h6,
       (select l.lsk, nvl(sum(l.summa),0) as sal_in
          from saldo_usl l where l.mg = '''||mg_||''' '||sqlstr_||'
         group by l.lsk) h4,
       ('||sqlstr10_||') o,
       (select l.lsk, sum(l.summa) as summa
                  from arch_subsidii l
                  where l.usl_id = ''024'' and l.mg='''||mg_||''' '||sqlstr_||'
                  and l.mg=l.mg
                  group by l.lsk) j,
       scott.usl s,
       scott.usl_bills m
 where k.kul = g.id '||sqlstr8_||'
   and k.usl = m.usl_id and k.usl not in (select ex.usl_id from usl_excl ex)
   and m.id = s.usl
   and k.lsk = a.lsk(+)
   and k.usl = a.usl(+)
   and k.lsk = c.lsk(+)
   and k.usl = c.usl(+)
   and k.lsk = e.lsk(+)
   and k.usl = e.usl(+)

   and k.lsk = y.lsk(+)
   and k.usl = y.usl_id(+)
   and k.lsk = r.lsk(+)
   and k.usl = r.usl_id(+)
   and k.lsk = x.lsk(+)
   and k.usl = x.usl_id(+)

   and k.lsk = f.lsk(+)
   and k.usl = f.usl_id(+)
   and k.lsk = h.lsk(+)
   and k.lsk = h2.lsk(+)
   and k.lsk = h3.lsk(+)
   and k.lsk = h4.lsk(+)
   and k.lsk = h5.lsk(+)
   and k.lsk = h6.lsk(+)
   and k.lsk = o.lsk(+)
   and k.lsk = j.lsk(+)
   and k.mg between m.mg1 and m.mg2

  group by k.mg1, k.mg, k.k_lsk_id, k.lsk,
          g.name || '' д.'' || ltrim(k.nd, ''0'') || ''-'' || ltrim(k.kw, ''0''),
          '||sqlstr6_||',
          k.status,
          k.psch,
          k.phw,
          k.pgw,
          k.pel,
          k.kul,
          k.opl,
          k.pldop,
          k.kpr,
          k.kpr_wr,
          k.kpr_wrp,
          k.name_org,
          k.phone,
          k.phone2,
          k.ki,
          k.subs_inf,
          s.npp,
          '||sqlstr2_||',
          '||sqlstr3_||',
          k.kpr_ot,
          k.psch,
          k.gt,
          f.lgname,
          f.lg_id,
          f.cnt,
          f.lg_koef,
          k.dolg
 /* закрытые лицевые - берем */
having '||sqlstr4_||' or
       max(psch) not in (8,9) and (sum(y.summa) <> 0 or
       sum(r.summa) <> 0 or
       sum(x.summa) <> 0 or
       sum(nvl(a.summa, 0) - nvl(c.summa, 0) +
           nvl(y.summa, 0)+nvl(r.summa, 0)+nvl(x.summa, 0))  <> 0)
          order by s.usl
           ';
elsif mg_ > 200710 and mg_ >= mg_nolg_ then
--счета новые, без льгот
--оптимизированные под работу с 1 л.с.
OPEN cur FOR
   'select k.mg1, k.mg, k.k_lsk_id, k.lsk, g.name || '' д.'' || ltrim(k.nd, ''0'') || ''-'' || ltrim(k.kw, ''0'') as streetname,
       '||sqlstr6_||' as fio,
       utils.month_name(SUBSTR('''||mg_||''', 5, 2)) || '' '' ||
       SUBSTR('''||mg_||''', 1, 4) || '' г.'' AS monthyear,
       k.status,
       k.psch,
       k.phw,
       k.pgw,
       k.pel,
       k.kul,
       k.opl,
       k.pldop,
       k.kpr,
       k.kpr_ot,
       k.kpr_wr,
       k.kpr_wrp,
       k.name_org,
       k.phone,
       k.phone2,
       k.ki,
       k.subs_inf,
       s.npp,
       '||sqlstr2_||' as usl,
       '||sqlstr3_||' as nm,
       0 as lg_mains,
       0 as lg_ids,
       max(h5.penya) as itg_pen,
       max(h6.summa) as itg_pay,
       max(h6.penya) as itg_pen_pay,
        '||sqlstr5_||' as tarif,
       sum(decode('||sqlstr2_||', ''004'', a.vol, 0)) as pl_svnorm,
       sum(a.vol) as vol, /*было max(a.vol) as vol, ред от 29.12.2010*/
       sum(a.summa) as charges,
       null as privs,
       sum(y.summa) AS changes0,
       sum(y2.proc) AS ch_proc0,
       sum(r.summa) AS changes1,
       sum(x.summa) AS changes2,
       sum(sl.summa) AS sl, --сальдо исх. ред.01.10.12
       sum(c.summa) as subs,
       0 AS sub_el,
       sum(nvl(a.summa, 0) - nvl(c.summa, 0) +
           nvl(y.summa, 0)+nvl(r.summa, 0)+nvl(x.summa, 0)) as itog,
       sum(nvl(a.summa, 0) - nvl(c.summa, 0)) as itog_uszn,
       null as lgname,
       null as lg_id,
       null as cnt,
       null as lg_koef,
       '''||fname_sch_||''' as fname_sch,
       max(h.prev_chrg) as prev_chrg,
       max(o.prev_pay) as prev_pay,
       max(o.prev_pay) as payment,  --оч странно
       max(h3.penya) as penya,
       max(h3.penya) as monthpenya,
       max(h3.penya) as monthpenya2,
       max(h2.dolg) as dolg,
       null as old_dolg,
       max(nvl(h2.dolg,0)) as itog_dolg,
       max(
       case when h4.sal_in < 0 then
        h4.sal_in
        else
        0 end) as ovrpaymnt,
       max(h4.sal_in) as sal_in,
       k.dolg as dolg2,
       e.org as org,
       s.bill_brake
  from spul g,
       '||sqlstr7_||' k,
       (select l.lsk, u.id as usl, sum(l.summa) as summa, sum(decode(u.is_vol, 1, l.test_opl, 0)) as vol
          from a_charge l, usl_bills u
         where l.type = 1  '||sqlstr_||' and u.fk_bill_var='||l_bill_var||'   
         and l.mg='''||mg_||''' and l.usl=u.usl_id and '''||mg_||''' between u.mg1 and u.mg2
         group by l.lsk, u.id) a,
       (select l.lsk, u.id as usl, sum(l.summa) as summa, sum(decode(u.is_vol, 1, l.test_opl, 0)) as vol
          from a_charge l, usl_bills u
         where l.type = 2  '||sqlstr_||' and u.fk_bill_var='||l_bill_var||'   
         and l.mg='''||mg_||''' and l.usl=u.usl_id and '''||mg_||''' between u.mg1 and u.mg2
         group by l.lsk, u.id) c,
       (select l.lsk, u.id as usl, sum(l.summa) as summa
          from saldo_usl l, arch_kart k2, usl_bills u --сальдо по услугам
         where l.lsk=k2.lsk '||sqlstr_||'
         and l.mg='''||mg_||''' and k2.mg='''||mg_||'''
         and l.usl=u.usl_id and u.fk_bill_var='||l_bill_var||' 
         and '''||mg_||''' between u.mg1 and u.mg2
         group by l.lsk, u.id) sl,
       ('||sqlstr13_||'
         ) e,
         (select l.lsk, l.usl_id , sum(l.summa) as summa from
          arch_changes l where l.mg='''||mg_||''' '||sqlstr_||'
            and l.id=0 and nvl(l.show_bill,0)<>1
            group by l.lsk, l.usl_id) y,
        (select lsk, usl_id,
            case when sum(norm_proc) <> 0 then sum(norm_proc)
                 else sum(sv_proc) end as proc
            from (
            select l.lsk, l.doc_id, b.id as usl_id,
            sum(case when l.proc <> 0 and u.usl_norm=0 then l.proc else 0 end) as norm_proc, --ред.28.06.13
            sum(case when l.proc <> 0 and u.usl_norm=1 then l.proc else 0 end) as sv_proc
            from a_change l, usl_bills b, usl u where
            l.mg='''||mg_||''' '||sqlstr_||' and l.usl=b.usl_id and l.usl=u.usl
            and b.fk_bill_var='||l_bill_var||'
            and l.mg between b.mg1 and b.mg2
            group by l.lsk, l.doc_id, b.id) a
            group by lsk, usl_id) y2,
         (select l.lsk, l.usl_id, sum(l.summa) as summa from
          arch_changes l where l.mg='''||mg_||''' and nvl(l.show_bill,0)<>1 '||sqlstr_||'
          and l.id=1
          group by l.lsk, l.usl_id) r,
         (select l.lsk, l.usl_id, sum(l.summa) as summa from
          arch_changes l where l.mg='''||mg_||''' and nvl(l.show_bill,0)<>1 '||sqlstr_||'
          and l.id=2
          group by l.lsk, l.usl_id) x,
       (select l.lsk, nvl(sum(l.summa),0) as prev_chrg,
          sum(null) as prev_pen
          from saldo_usl l where l.mg = '''||mg_||''' '||sqlstr_||'
         group by l.lsk) h,
       '||sqlstr14_||' h2,
       '||sqlstr9_||' h3,
       '||sqlstr11_||' h5,
       '||sqlstr12_||' h6,
       (select l.lsk, nvl(sum(l.summa),0) as sal_in
          from saldo_usl l where l.mg = '''||mg_||'''  '||sqlstr_||'
         group by l.lsk) h4,
       ('||sqlstr10_||') o,
       scott.usl s,
       scott.usl_bills m,
       (select l.lsk, l.mg1, sum(l.summa) as summa from scott.a_penya l where l.mg = '''||mg_||'''
         '||sqlstr_||'
        group by l.lsk, l.mg1) z
 where
   k.kul = g.id '||sqlstr8_||'
   and k.usl = m.usl_id and k.usl not in (select ex.usl_id from usl_excl ex)
   and m.id = s.usl
   and m.fk_bill_var='||l_bill_var||'

   and k.lsk = a.lsk(+)
   and k.usl = a.usl(+)
   and k.lsk = c.lsk(+)
   and k.usl = c.usl(+)

   and k.lsk = sl.lsk(+)
   and k.usl = sl.usl(+)

   and k.lsk = e.lsk(+)
   and k.usl = e.usl(+)

   and k.lsk=z.lsk(+)
   and k.mg=z.mg1(+)

   and k.lsk = y.lsk(+)
   and k.usl = y.usl_id(+)

   and k.lsk = y2.lsk(+)
   and k.usl = y2.usl_id(+)

   and k.lsk = r.lsk(+)
   and k.usl = r.usl_id(+)
   and k.lsk = x.lsk(+)
   and k.usl = x.usl_id(+)

   and k.lsk = h.lsk(+)
   and k.lsk = h2.lsk(+)
   and k.lsk = h3.lsk(+)
   and k.lsk = h4.lsk(+)
   and k.lsk = h5.lsk(+)
   and k.lsk = h6.lsk(+)
   and k.lsk = o.lsk(+)
   and k.mg between m.mg1 and m.mg2

  group by k.mg1, k.mg, k.k_lsk_id, k.lsk,
          g.name || '' д.'' || ltrim(k.nd, ''0'') || ''-'' || ltrim(k.kw, ''0''),
          '||sqlstr6_||',
          k.status,
          k.psch,
          k.phw,
          k.pgw,
          k.pel,
          k.kul,
          k.opl,
          k.pldop,
          k.kpr,
          k.kpr_wr,
          k.kpr_wrp,
          k.name_org,
          k.phone,
          k.phone2,
          k.ki,
          k.subs_inf,
          s.npp,
          '||sqlstr2_||',
          '||sqlstr3_||',
          k.kpr_ot,
          k.psch,
          k.gt,
          k.dolg,
          e.org,
          s.bill_brake
 /* закрытые лицевые - берем */
   having '||sqlstr4_||' or
       max(psch) not in (8,9) and (sum(y.summa) <> 0 or
       sum(r.summa) <> 0 or
       sum(x.summa) <> 0 or
       '||sqlstr15_||'
       sum(nvl(a.summa, 0) - nvl(c.summa, 0) +
           nvl(y.summa, 0)+nvl(r.summa, 0)+nvl(x.summa, 0))  <> 0)
          order by s.usl
           ';



else
    --—чета старые
  if nvl(var_,0) = 0 then --счета
   sqlstr2_:='case
                  when u.usl in (''011'', ''012'', ''013'', ''014'', ''015'', ''016'') then
               trim(u.nm)||'',м3''
               else
               trim(u.nm)
               end';
   sqlstr7_:='arch_kart';
  else  --справка из архива
   sqlstr2_:='u.nm2';
   sqlstr7_:='(select ll.mg1, l.k_lsk_id, l.lsk, l.nd, l.kw, ll.fio, ll.status, l.psch, l.phw,
               l.pgw, l.pel, l.kul, l.opl,
     l.pldop, l.kpr, l.kpr_ot, l.kpr_wr, l.kpr_wrp, l.ki, l.gt, l.dolg, l.old_dolg, l.ovrpaymnt, l.penya, l.old_pen, l.subs_inf, l.mg
      from scott.arch_kart l, scott.kart ll
          where l.lsk=ll.lsk)';
  end if;
OPEN cur FOR
         'SELECT l.mg1, l.mg, l.k_lsk_id, l.lsk,
               s.name || '' д.'' || LTRIM(l.nd, ''0'') || ''-'' ||
               LTRIM(l.kw, ''0'') AS streetname,
               substr(l.fio, 1, 40) as fio,
               utils.month_name(SUBSTR('''||mg_||''', 5, 2)) || '' '' ||
               SUBSTR('''||mg_||''', 1, 4) || '' г.'' AS monthyear,
               l.status,
               l.psch,
               l.phw,
               l.pgw,
               l.pel,
               l.kul,
               l.opl,
               l.pldop,
               l.kpr,
               l.kpr_ot,
               null as kpr_wr,
               null as kpr_wrp,
               null as name_org,
               null as phone,
               null as phone2,
               l.ki,
               l.subs_inf,
               u.npp,
               bi.id as usl,
               '||sqlstr2_||' as nm,
               null as lg_mains,
               null as lg_ids,
               null as itg_pen,
               null as itg_pay,
               null as itg_pen_pay,
               round(CASE
                 WHEN l.kpr <> 0 and u.uslm in (''002'', ''004'',''009'') THEN --расценка по тек ремонту, отоплению всегда на уровне расценки по соц норме
                 (SELECT pr.summa*decode(u.sptarn, 0, NVL(w.koeff, 0), 1, 1, 2, NVL(w.koeff, 0), 3, NVL(w.koeff, 0))
                     FROM USL um, a_prices pr, spt w
                    WHERE u.USLM = um.USLM
                      AND um.usl_norm = 0 AND u.usl=w.usl_id and w.gtr=l.gt and w.mg=l.mg
                      AND um.USL = pr.USL
                      AND pr.mg = m.mg)
                 WHEN l.kpr = 0 and u.uslm in (''002'', ''004'',''009'') THEN --расценка по тек ремонту, отоплению всегда на уровне расценки по соц норме
                 (SELECT pr.summa*decode(u.sptarn, 0, NVL(w.koeff, 0), 1, 1, 2, NVL(w.koeff, 0), 3, NVL(w.koeff, 0))
                     FROM USL um, a_prices pr, spt w
                    WHERE u.USLM = um.USLM
                      AND um.usl_norm = 1 AND u.usl=w.usl_id and w.gtr=l.gt and w.mg=l.mg
                      AND um.USL = pr.USL
                      AND pr.mg = m.mg)
                 WHEN l.kpr <> 0 and l.psch = 0 and u.uslm in (''006'', ''008'', ''007'') THEN --нет счетчиков
                  (SELECT pr.summa
                     FROM USL um, a_prices pr
                    WHERE u.USLM = um.USLM
                      AND um.usl_norm = 0
                      AND um.USL = pr.USL
                      AND pr.mg = m.mg) * NVL(c.koeff, 0)
                 WHEN l.kpr <> 0 and l.psch = 1 and u.uslm in (''006'', ''008'', ''007'') THEN --счетчики хол.в. и г.в. и канализ.
                  (SELECT pr.summa
                     FROM USL um, a_prices pr
                    WHERE u.USLM = um.USLM
                      AND um.usl_norm = 0
                      AND um.USL = pr.USL
                      AND pr.mg = m.mg)
                 WHEN l.kpr <> 0 and l.psch = 3 and u.uslm in (''006'', ''007'') THEN --счетчики только гор.в. и канализ.
                  (SELECT pr.summa
                     FROM USL um, a_prices pr
                    WHERE u.USLM = um.USLM
                      AND um.usl_norm = 0
                      AND um.USL = pr.USL
                      AND pr.mg = m.mg)
                 WHEN l.kpr <> 0 and l.psch = 2 and u.uslm in (''008'', ''007'') THEN --счетчики только хол.в. и канализ.
                  (SELECT pr.summa --psch специально перепутан
                     FROM USL um, a_prices pr
                    WHERE u.USLM = um.USLM
                      AND um.usl_norm = 0
                      AND um.USL = pr.USL
                      AND pr.mg = m.mg)
                 WHEN l.kpr = 0 THEN
                  m.summa
                 WHEN l.kpr <> 0 THEN --остальные варианты
                  (SELECT pr.summa
                     FROM USL um, a_prices pr
                    WHERE u.USLM = um.USLM
                      AND um.usl_norm = 0
                      AND um.USL = pr.USL
                      AND pr.mg = m.mg)
                 ELSE m.summa
               END, 2) AS tarif,
               null as pl_svnorm,
               null as vol,
               NVL(b.summa_it, 0) AS CHARGES,
               f.summa AS PRIVS,
               g.summa AS changes0,
               null AS ch_proc0,
               h.summa AS changes1,
               k.summa AS changes2,
               null as sl,
               e.summa AS subs,
               j.summa AS sub_el,
               NVL(b.summa_it, 0) + NVL(g.summa, 0) + NVL(h.summa, 0)+
               NVL(k.summa, 0) - NVL(e.summa, 0)- NVL(f.summa, 0)  AS itog,
               NVL(b.summa_it, 0) - NVL(e.summa, 0)- NVL(f.summa, 0) AS itog_uszn,
               f.lgname,
               f.lg_id,
               f.cnt,
               f.lg_koef,
               '''||fname_sch_||''' as fname_sch,
               n.prev_chrg,
               o.prev_pay,
               d.summa AS payment,
               nvl(l.penya,0)+nvl(l.old_pen,0) as penya,
               nvl(l.penya,0)+nvl(l.old_pen,0)-n.prev_pen as monthpenya,
               nvl(z.penya,0) as monthpenya2,
               l.dolg as dolg,
               null as old_dolg,
               l.dolg as itog_dolg,
               null as ovrpayment,
               l.dolg as sal_in,
               null as dolg2,
               null as org,
               null as bill_brake
          FROM '||sqlstr7_||' l,
               SPT c,
               USL u,
               USL_BILLS bi,
               a_prices m,
               (SELECT DISTINCT lsk, usl_id
                  FROM (SELECT lsk, usl_id
                          FROM ARCH_KWTP
                         WHERE mg = '''||mg_||'''
                        UNION ALL
                        SELECT lsk, usl_id
                          FROM ARCH_CHARGES
                         WHERE mg = '''||mg_||'''
                        UNION ALL
                        SELECT lsk, usl_id
                          FROM ARCH_CHANGES
                         WHERE mg = '''||mg_||'''
                        UNION ALL
                        SELECT lsk, usl_id
                          FROM ARCH_SUBSIDII
                         WHERE mg = '''||mg_||'''
                        UNION ALL
                        SELECT lsk, usl_id FROM ARCH_PRIVS WHERE mg = '''||mg_||''')) a,
               ARCH_CHARGES b,
               (select lsk, mg, sum(summa) as summa from arch_kwtp
                 where mg='''||mg_||'''
                 group by lsk, mg) d,
               ARCH_SUBSIDII e,
               (SELECT lsk, SUM(summa) AS summa
                  FROM ARCH_SUBSIDII su
                 WHERE mg = '''||mg_||'''
                   AND su.usl_id = ''024''
                 GROUP BY lsk) j,
               (SELECT ap.lsk,
                       ap.usl_id,
                       MAX(sp.id) AS lg_id,
                       MAX(sp.name) AS lgname,
                       MAX(sk.koef) AS lg_koef,
                       SUM(ap.summa) AS summa,
                       SUM(ap.cnt_main) as cnt_main,
                       SUM(ap.cnt) as cnt
                  FROM ARCH_PRIVS ap, SPK sp, c_spk_usl sk
                 WHERE ap.lg_id = sp.id and ap.lg_id=sk.spk_id and ap.usl_id=sk.usl_id
                   AND mg = '''||mg_||'''
                 GROUP BY ap.lsk, ap.usl_id) f,
               ARCH_CHANGES g,
               ARCH_CHANGES h,
               ARCH_CHANGES k,
               (SELECT lsk, sum(nvl(dolg,0)+nvl(penya,0)) AS prev_chrg,
                  sum(nvl(penya,0)) as prev_pen
                  FROM ARCH_KART
                 WHERE mg = TO_CHAR(ADD_MONTHS(TO_DATE('''||mg_||''', ''YYYYMM''), -1),
                                    ''YYYYMM'')
                 GROUP BY lsk) n,
               (SELECT lsk, SUM(summa) AS prev_pay
                  FROM ARCH_KWTP
                 WHERE mg = '''||mg_||'''
                 GROUP BY lsk) o,
               SPUL s,
               c_penya z
         WHERE l.lsk = a.lsk
           '||sqlstr_||' and l.psch <> 8
           AND l.gt = c.gtr(+)
           AND m.USL = c.usl_id
           AND u.usl <> ''024''
           AND bi.usl_id=u.usl
           and bi.fk_bill_var='||l_bill_var||'
           AND l.mg = '''||mg_||'''

           AND l.lsk = n.lsk(+)
           AND l.lsk = o.lsk(+)
           AND l.kul = s.id
           AND a.usl_id = u.USL
           AND a.usl_id = m.USL
           AND m.mg = '''||mg_||'''
           AND c.mg = '''||mg_||'''
           AND a.lsk = b.lsk(+)
           AND a.usl_id = b.usl_id(+)
           AND b.mg(+) = '''||mg_||'''
           AND a.lsk = d.lsk(+)
         /*  AND a.usl_id = d.usl_id(+) */
           AND d.mg(+) = '''||mg_||'''
           AND a.lsk = e.lsk(+)
           AND a.usl_id = e.usl_id(+)
           AND e.mg(+) = '''||mg_||'''
           AND a.lsk = f.lsk(+)
           AND a.usl_id = f.usl_id(+)
           AND a.lsk = g.lsk(+)
           AND a.usl_id = g.usl_id(+)
           AND g.mg(+) = '''||mg_||'''
           AND g.id(+) = 0
           AND a.lsk = h.lsk(+)
           AND a.usl_id = h.usl_id(+)
           AND h.mg(+) = '''||mg_||'''
           AND h.id(+) = 1
           AND a.lsk = k.lsk(+)
           AND a.usl_id = k.usl_id(+)
           AND k.mg(+) = '''||mg_||'''
           AND k.id(+) = 2
           AND a.lsk = j.lsk(+)
           and l.lsk=z.lsk(+)
           and l.mg=z.mg1(+)
           ORDER BY a.lsk, bi.id';
end if;
 loop
  fetch cur into rec_;
  exit when cur%NOTFOUND;
   pipe row (rec_);

 end loop;
 close cur;
 mg_:=to_char(add_months(to_date(mg_,'YYYYMM'), 1),'YYYYMM');
end loop;

 return;
end;


procedure main(p_sel_obj in number,
               p_reu in kart.reu%type,
               p_kul in kart.kul%type,
               p_nd in kart.nd%type,
               p_kw in kart.kw%type,
               p_lsk in kart.lsk%type,
               p_lsk1 in kart.lsk%type,
               p_firstrec in number,
               p_lastrec in number,
               p_var2 in number,
               p_var3 in number,
               p_cntrec in number,
               p_mg in params.period%type,
               p_rfcur out ccur
  ) is 
begin
open p_rfcur for 
  select /*+ RULE*/ * from (   --если не делать хинт RULE то возникает ошибка в CBO, котора€ преп€тствует выводу записей в датасете...
  select  a.*,
   'ST00012'||'|Name='||a.full_name||'|PersonalAcc='||a.raschet_schet||
   '|BankName='||a.bank||'|BIC='||a.bik||'|CorrespAcc='||a.k_schet
   ||'|Sum='||trim(to_char(a.sal_out*100,9999999999))||'|Purpose= вартплата'
   ||'|PayeeINN='||a.inn||'|lastName='||a.k_fam||'|firstName='||a.k_im
   ||'|middleName='||a.k_ot||'|payerAddress='||a.adr2||'|persAcc='||a.lsk||'|PaymPeriod='||p_mg
   ||'|serviceName=000'
   ||'|category='||decode(a.psch,8,'43301',9,'43301', '43302') as QR
  from (
  select k.lsk, 
         decode(stp.cd,'LSK_TP_ADDIT',k3.kpr,k.kpr) as kpr, 
         decode(stp.cd,'LSK_TP_ADDIT',k3.kpr_wr,k.kpr_wr) as kpr_wr, 
         decode(stp.cd,'LSK_TP_ADDIT',k3.kpr_wrp,k.kpr_wrp) as kpr_wrp, 
         decode(stp.cd,'LSK_TP_ADDIT',k3.kpr_ot,k.kpr_ot) as kpr_ot, 
         t.name as st_name,
         decode(t.cd, 'MUN','Ќаниматель','—обственник') as pers_tp,
         s.name || ', ' || nvl(ltrim(k.nd, '0'), '0') || '-' ||
         nvl(ltrim(k.kw, '0'), '0') as adr,
         o2.name||', ул.'||s.name || ', д. ' || nvl(ltrim(k.nd, '0'), '0') || ', кв.' ||
         nvl(ltrim(k.kw, '0'), '0') as adr2,
        k.phw, k.pgw, k.pel, k2.phw as phw_back, k2.pgw as pgw_back, k2.pel as pel_back,
        k.mel, k.mhw, k.mgw,
        scott.init.get_fio as fio_kass,
        p_mg as mg, scott.utils.month_name(substr(p_mg, 5, 2))||' '||substr(p_mg,1,4)||'г.' as mg_str,
        to_date(p_mg||'01','YYYYMMDD') as dt1,
        to_date(scott.utils.add_months_pr(p_mg, 1)||'01','YYYYMMDD') as dt2,
        k.house_id,
        k.reu, case when stp.cd='LSK_TP_ADDIT' then o.r_sch_addit
                    when b.cnt = 1 then o.raschet_schet2
                    else o.raschet_schet end 
                    as raschet_schet,
        sl.summa as sal_out,
        k.k_fam, k.k_im, k.k_ot, k.fio,
        o.inn, o.k_schet, o.bik, o.bank, o.full_name, o.phone, o.adr as adr_org, k.psch, stp.cd as lsk_tp, stp.npp as lsk_tp_npp, k.prn_num, k.prn_new
    from scott.arch_kart k
      left join scott.arch_kart k2 on k.lsk=k2.lsk and k2.mg=scott.utils.add_months_pr(p_mg, -1) 
      left join scott.spul s on k.kul = s.id 
      left join scott.status t on k.status=t.id
      left join scott.t_org_tp tp on tp.cd='– ÷'
      left join scott.t_org o on tp.id=o.fk_orgtp  
      left join scott.t_org_tp tp2 on tp2.cd='√ород'
      left join scott.t_org o2 on tp2.id=o2.fk_orgtp
      left join scott.v_lsk_tp stp on k.fk_tp=stp.id
      left join scott.arch_kart k3 on k.k_lsk_id=k3.k_lsk_id and k.mg=k3.mg and k.lsk<>k3.lsk and k3.psch not in (8,9)  and stp.cd='LSK_TP_ADDIT'
      left join (select l.lsk, sum(l.summa) as summa --сальдо исход€щее
            from scott.saldo_usl l
           where l.mg=scott.utils.add_months_pr(p_mg, 1)
           group by l.lsk) sl on k.lsk=sl.lsk
      left join (select r.lsk, 1 as cnt from scott.a_nabor r, scott.usl u where r.mg=p_mg
       and r.usl=u.usl and u.cd='усл.банка') b on k.lsk=b.lsk
   where k.mg = p_mg
     /*and  (p_cntrec=0 or p_cntrec<> 0 and */ and nvl(k.for_bill,0)=1 --)
     and ((p_sel_obj = 0 and k.lsk between p_lsk and p_lsk1) or
           p_sel_obj = 1 and
           (p_kul is not null and k.kul = p_kul or p_kul is null) and
           (p_nd is not null and k.nd = p_nd or p_nd is null) and
           (p_kw is not null and k.kw = p_kw or p_kw is null) or
           (p_sel_obj = 2 and k.reu = p_reu)
           )
     and (p_var2 = 1 or p_var2 = 0 and k.psch <> 8)
     and (p_var3 = 0 or p_var3 = 1 and stp.cd='LSK_TP_MAIN')
    order by s.name, scott.utils.f_ord_digit(k.nd), --¬нимание! пор€док точно такой как и в GEN.upd_arch_kart2
         scott.utils.f_ord3(k.nd) desc, 
         scott.utils.f_ord_digit(k.kw),
         scott.utils.f_ord3(k.kw) desc, k.k_lsk_id, stp.npp
  ) a
  ) b 
  where p_cntrec=0 or
  p_cntrec<>0 and b.prn_num between nvl(p_firstrec,0) and nvl(p_lastrec,0);

end;


--справка о задолжности
procedure deb(p_k_lsk_id in number,
              p_lsk in kart.lsk%type,
              p_rfcur out ccur
  ) is 
begin
  if utils.get_int_param('SPR_DEB_VAR') = 1 then
    --новый вариант (дл€ “—∆), здесь по p_lsk
    open p_rfcur for
      select b.summa as charge, c.summa as payment, nvl(b.summa,0) - nvl(c.summa,0) as dolg, 
      nvl(d.penya,0) as penya,
      nvl(d.dolg_pen,0)+nvl(d.penya,0) as itog,
      utils.MONTH_NAME(substr(a.mg,5,2))||' '||substr(a.mg,1,4) as mg, d.days, d.dolg_pen,
       sum(nvl(b.summa,0) - nvl(c.summa,0)) OVER (order by a.mg) as prev_sum,
      e.summa as sal
       from
       scott.long_table a ,
      (select mg, sum(summa) as summa from scott.c_chargepay where period=(select period from scott.params) and
         lsk=p_lsk and type=0 group by mg) b,
      (select mg, sum(summa) as summa from scott.c_chargepay where period=(select period from scott.params) and
         lsk=p_lsk and type=1 group by mg) c,
      (select t.mg, sum(t.dolg) as summa from scott.arch_kart t where
         lsk=p_lsk group by mg) e,

      (select summa as dolg_pen,penya, days, mg1 from scott.c_penya c where lsk=p_lsk) d
      where a.mg=b.mg(+) and a.mg=c.mg(+)
      and a.mg=e.mg(+)
      and a.mg=d.mg1(+)  and (nvl(b.summa,0) <>0 or nvl(c.summa,0) <>0 or nvl(e.summa,0) <>0)
      and d.dolg_pen > 0
      order by a.mg
      ;
  elsif  utils.get_int_param('SPR_DEB_VAR') = 0 then
    --старый вариант, здесь по p_k_lsk_id
    open p_rfcur for 
      select * from (
      select k.lsk, k.psch, s.name||', '||ltrim(k.nd,'0')||', '||ltrim(k.kw,'0') as adr, k.fio, s.name, k.mg,
       substr(k.mg,1,4)||'-'||substr(k.mg,5,2) as mg2,
       scott.utils.MONTH_NAME(substr(k.mg,5,2))||' '||substr(k.mg,1,4)||' г.' as mg_name, 
               b.summa as charge,
               nvl(d.penya,0) as penya,
               case when /*p.period=k.mg and */d.summa <0 then
                  'ѕереплата'
               else 
                  'ƒолг'
               end
      as dolg_name, 
               case when /*p.period=k.mg and */d.summa <0 then
                  d.summa
               else 
                  d.summa
               end as dolg,
               d.days,
               p.period,
        scott.init.get_fio as fio_kass
          from (select k1.psch, k1.lsk, k1.c_lsk_id, k1.k_lsk_id, k1.kul, k1.nd, k1.kw, first_value(k1.fio)
             over (order by decode(psch,8,0,1) desc) as fio, a.mg
                from scott.kart k1, scott.long_table a 
                where k1.k_lsk_id=p_k_lsk_id) k, scott.spul s,  scott.params p,
               (select c.lsk, c.mg, sum(c.summa) as summa
                  from scott.c_chargepay c, scott.kart k2
                 where period = (select period from scott.params)
                   and type = 0 and k2.lsk=c.lsk and  k2.k_lsk_id=p_k_lsk_id
                 group by c.lsk, c.mg) b,
                 scott.c_penya d
         where k.lsk=d.lsk(+) and k.mg=d.mg1(+)  
            and k.lsk=b.lsk(+) and k.mg=b.mg(+)
        and k.kul=s.id
      ) t where t.dolg <> 0 or (t.mg = t.period and t.dolg <>0 and t.psch <> 8)
      order by t.mg;
  end if;
end;

end rep_bills;
/

prompt
prompt Creating package body REP_CHARGES
prompt =================================
prompt
CREATE OR REPLACE PACKAGE BODY SCOTT.rep_charges IS
  PROCEDURE report_xito13(reu_           IN XITO13.reu%TYPE,
                          kul_           IN XITO13.kul%TYPE,
                          nd_            IN XITO13.nd%TYPE,
                          trest_         IN XITO13.trest%TYPE,
                          mg_            IN XITO13.mg%TYPE,
                          mg1_           IN XITO13.mg%TYPE,
                          prep_refcursor IN OUT rep_refcursor) IS
  BEGIN
    IF trest_ IS NOT NULL THEN
      NULL;
      --ѕо трестам
      /*        OPEN prep_refcursor FOR 'select ' || sqlstr3 || ' as name_tr,
      substr(o.name,1,35) as name, substr(u.nm1,1,22) as nm1, round(sum(summa),2) as summa from xxito12 t,
      s_reu_trest s, s_reu_trest d, sprorg o, usl u
      where  t.mg BETWEEN :mg_ AND :mg1_ ' || sqlstr2 || ' and t.org=o.kod
      ' || sqlstr1 || ' and s.trest=:trest_ and t.usl=u.usl
      group by   ' || sqlstr3 || ', o.kod, substr(o.name,1,35), substr(u.nm1,1,22)
      order by   ' || sqlstr3 || ', o.kod, substr(u.nm1,1,22)'
      USING mg_, mg1_, trest_;*/
    ELSIF reu_ IS NOT NULL AND kul_ IS NULL AND nd_ IS NULL THEN
      --ѕо –Ё”
      OPEN prep_refcursor FOR 'select s.name_tr, t.reu, p.name as street, LTRIM(t.ND, ''0'') as nd, u.nm, sum(t.summa) as summa
          FROM XITO13 t, S_REU_TREST s, USL u, SPUL p
          WHERE t.mg BETWEEN :mg_ AND :mg1_ AND t.reu=s.reu AND t.kul=p.id AND t.USL=u.USL
          AND t.reu=:reu_
          GROUP BY s.name_tr, t.reu, p.name, LTRIM(t.ND, ''0''), u.nm'
        USING mg_, mg1_, reu_;
    ELSIF reu_ IS NOT NULL AND kul_ IS NOT NULL AND nd_ IS NOT NULL THEN
      NULL;
      --ѕо адресу
      /*  OPEN prep_refcursor FOR 'select ' || sqlstr3 || ' as name_tr,
      substr(o.name,1,35) as name, substr(u.nm1,1,22) as nm1, round(sum(summa),2) as summa from xxito12 t,
      s_reu_trest s, s_reu_trest d, sprorg o, usl u
      where  t.mg BETWEEN :mg_ AND :mg1_ ' || sqlstr2 || ' and t.org=o.kod
      ' || sqlstr1 || ' and s.reu=:reu_ and t.kul=:kul_ and t.nd=:nd_ and t.usl=u.usl
      group by   ' || sqlstr3 || ', o.kod, substr(o.name,1,35), substr(u.nm1,1,22)
      order by   ' || sqlstr3 || ', o.kod, substr(u.nm1,1,22)'
      USING mg_, mg1_, reu_, kul_, nd_;*/
    ELSE
      NULL;
      --ѕо всем ∆Ёќ
      /*  OPEN prep_refcursor FOR 'select ' || sqlstr3 || ' as name_tr,
      to_char(o.kod)||'' ''||substr(o.name,1,35) as name, u.nm1 as nm1, round(sum(summa),2) as summa from xxito12 t,
      s_reu_trest s, s_reu_trest d, sprorg o, usl u
      where  t.mg BETWEEN :mg_ AND :mg1_ ' || sqlstr2 || ' and t.org=o.kod
      ' || sqlstr1 || ' and t.usl=u.usl
      group by   ' || sqlstr3 || ', to_char(o.kod)||'' ''||substr(o.name,1,35), u.nm1
      order by   ' || sqlstr3 || ', to_char(o.kod)||'' ''||substr(o.name,1,35), u.nm1'
      USING mg_, mg1_;*/
    END IF;
  END report_xito13;
END rep_charges;
/

prompt
prompt Creating package body REP_LISTS
prompt ===============================
prompt
create or replace package body scott.rep_lists is
  procedure report(rep_id_ in number,
                          mg_            in a_charge.mg%type,
                          org_ in number,
                          var_ in number,
                          cnt_ in number,
                          proc_ in number,
                          fname_ in varchar2,
                          prep_refcursor in out rep_refcursor) is
  uslg_ uslg.uslg%type;
  str_ varchar2(15);
  mg1_ params.period%type;
  begin
  --rep_id_ - ID отчета
  if rep_id_=1 then
  --—убсидии по л/с
    open prep_refcursor for
    select * from
    scott.v_kart_subs t where t.mg=mg_
    order by t.lsk;
  elsif rep_id_=2 then
  --—убсидии по л/с по обща
    open prep_refcursor for
      select * from
      scott.v_kart_subs2 t where t.mg=mg_
      order by t.lsk;
  elsif rep_id_=3 then
  --—кидки по домам
    open prep_refcursor for
      select t.* from scott.expkwni t
       where t.mg=mg_
       and exists
      (select * from scott.list_choices_reu l where l.reu=t.reu and l.sel=0);
  elsif rep_id_=4 then
  --—писки по льготникам
    open prep_refcursor for
    select t.* from scott.v_exporter3 t
     where t.mg=mg_;

  elsif rep_id_=5 then
  --«адолжники
    open prep_refcursor for
    select lsk, reu, kul, name, nd, kw, fio, status, opl, cnt_month, dolg, nachisl, penya, v.mg,
     v.payment, v.pay_pen
--    select 1 as lll
    from scott.debits_lsk_month v
     where exists
    (select * from scott.list_choices_reu l where l.reu=v.reu and l.sel=0)
    and v.mg=mg_;

  elsif rep_id_=6 then
  --¬ыгрузка произвольного файла
    open prep_refcursor for
     'select * from scott.'||fname_;

  elsif rep_id_=7 then
  --—писки по льготникам
    open prep_refcursor for
    select u.nm2 as nm, s.name as org_name, t.summa,
        '–Ё”-'||t.reu||' '||substr(l.name,1,17)||','||ltrim(t.nd,'0')||'-'||ltrim(t.kw,'0')||', '||t.lsk as adr,
        initcap(rtrim(a.fio)) ||', '||to_char(a.dat_rog,'DD/MM/YYYY')||', '||trim(d.doc)||', '||decode(t.cnt_main, 0, 'польз.', 'носит.') as fio,
        null as other1,
        rtrim(p.name) as lg_name
       from xito_lg4 t, a_kart_pr a, (select /* „®ѕќѕјЋќ Ќјѕ»—јЋ, –≈јЋ№Ќќ */ c_kart_pr_id, mg, max(doc) as doc
          from a_lg_docs group by c_kart_pr_id, mg) d, usl u, sprorg s, spk p, spul l
       where t.mg=mg_ and t.org=org_
         and t.nomer=a.id and a.id=d.c_kart_pr_id and t.kul=l.id and t.usl = u.usl and t.lg_id=p.id
         and t.org = s.kod  and a.mg=mg_ and d.mg=mg_
          and exists
          (select * from scott.list_choices_reu l where l.reu=t.reu and l.sel=0);

  elsif rep_id_=8 then
  --—писки по начислению
    open prep_refcursor for
    select t.* from scott.expkartw t
       where t.mg=mg_
      and exists
      (select * from scott.list_choices_reu l where l.reu=t.reu and l.sel=0);

  elsif rep_id_=9 then
  --¬ыгрузка оборотки дл€ ”  в DBF
    open prep_refcursor for
    select u.uslm, u.nm1, a.*, b.opl, b.kpr from
    (select * from scott.xitog3 t where t.mg=mg_
      ) a,
    (select reu, kul, nd, sum(opl) as opl, sum(kpr) as kpr
      from scott.arch_kart t where t.mg=mg_ and psch <> 8
      group by reu, kul, nd) b, scott.uslm u
    where a.uslm=u.uslm and a.reu=b.reu(+) and a.kul=b.kul(+) and a.nd=b.nd(+)
    and exists
    (select * from scott.list_choices_reu l where l.reu=a.reu and l.sel=0);

  elsif rep_id_=10 then
  Raise_application_error(-20000, 'не работает отчет, перенесЄн в stat');
  --«адолжники где есть услуга, определенна€ в scott.list_choices_usl
    open prep_refcursor for
    select d.lsk, s.name_reu, trim(d.name) as street_name,
      ltrim(d.nd,'0') as nd, ltrim(d.kw,'0') as kw, d.fio, d.cnt_month, d.dolg, d.dat
      from scott.debits_lsk_month d, scott.s_reu_trest s
      where d.reu=s.reu
       and exists
      (select * from scott.list_choices_reu l where l.reu=d.reu and l.sel=0)
      and exists
      (select * from scott.nabor n, scott.list_choices_usl l, scott.usl u
        where n.lsk=d.lsk and n.usl=u.usl and decode(u.sptarn, 0, n.koeff, 1, n.norm, 2,
        nvl(n.koeff,0)*nvl(n.norm,0)) <> 0 and l.uslm=u.uslm and l.sel=0
        )
      and d.mg=mg_
      and
      ((var_=0 and d.cnt_month > cnt_) or
      (var_=1 and d.dolg > cnt_) )
      order by s.name_reu, d.name, d.nd, d.kw;


  elsif rep_id_ in (11,19,20,22) then
  --ƒолги дл€ —бербанка, ѕочты (дл€  ис)
  open prep_refcursor for
        select * from (
        select k.lsk, substr(trim(k.fio),1,25) as fio,
         substr(l.name||', '||NVL(LTRIM(k.nd,'0'),'0')||'-'||NVL(LTRIM(k.kw,'0'),'0') ,1,32)  as adr,
          1 as type, ' вартплата' as type_name,
         substr(mg_,5,2)||substr(mg_,1,4) as period, nvl(sum(s.summa),0)*proc_ as summa, sum(s.cur_chrg) as cur_chrg, k.psch, tp.cd as tp_cd --(nvl(s.summa,0) > 0 or k.psch <> 8)
         from scott.kart k , scott.v_lsk_tp tp,
          scott.spul l,
           (select lsk, sum(nvl(c.summa,0)+nvl(c.penya,0)) as summa, sum(decode(c.mg1, mg_, c.summa, 0)) as cur_chrg from  --пен€ вместе с 24.10.13
            scott.a_penya c where c.mg=mg_
            group by lsk
           ) s  --ниже - дл€ л.с. с долгами и новых л.с. ( в т.ч. без долгов)
          where k.lsk=s.lsk and k.kul=l.id and k.lsk=s.lsk
          and k.fk_tp=tp.id
          and exists
         (select * from scott.list_choices_reu l where l.reu=k.reu and l.sel=0)
          group by k.lsk, k.psch, substr(trim(k.fio),1,25),
         substr(l.name||', '||NVL(LTRIM(k.nd,'0'),'0')||'-'||NVL(LTRIM(k.kw,'0'),'0') ,1,32),
         tp.cd
         ) a
         where rep_id_=19 and a.tp_cd='LSK_TP_MAIN' and exists (select r.lsk, 1 as cnt
                        from scott.a_nabor r, scott.usl u where r.mg=mg_
                        and r.usl=u.usl and u.cd='усл.банка'
                        and a.lsk=r.lsk and (a.summa > 0 or a.psch <> 8)
                        ) or
               rep_id_=20 and a.tp_cd='LSK_TP_MAIN' and not exists (select r.lsk, 1 as cnt
                        from scott.a_nabor r, scott.usl u where r.mg=mg_
                        and r.usl=u.usl and u.cd='усл.банка'
                        and a.lsk=r.lsk and (a.summa > 0 or a.psch <> 8)
                        ) or
               rep_id_=22 and a.tp_cd='LSK_TP_ADDIT'  --дополнительные счета
               and (a.summa > 0 or a.psch <> 8)
         order by lsk, period, type;
   elsif rep_id_=15 then
   --ƒолги дл€ ”ралсиба
    open prep_refcursor for
     select k.fio||';'||t.name||',#'||k.kul||','||k.nd||','||k.kw||';'||
       k.lsk||';'||to_char(s.summa) as txt, s.summa
        from
       scott.kart k,
       (select lsk, sum(summa) as summa from scott.c_penya group by lsk) s, scott.t_org t, scott.t_org_tp tp
       where k.lsk=s.lsk and nvl(s.summa,0) <> 0
       and t.fk_orgtp=tp.id and tp.cd='√ород'
       and  exists
       (select * from scott.list_choices_reu l where l.reu=k.reu and l.sel=0)
        order by k.kul, k.nd, k.kw;
  elsif rep_id_ in (16,17) then
  --ƒолги дл€ —бербанка, дл€ ѕолыс, разбитые по периодам
  if rep_id_ = 16  then
    str_:='\';
    else
    str_:='корп.';
  end if;
    open prep_refcursor for
      select * from (
      select k.lsk, substr(trim(k.fio),1,25) as fio,
       substr(l.name||', '||NVL(LTRIM( replace(k.nd, '\', str_) ,'0'),'0')||'-'||NVL(LTRIM(k.kw,'0'),'0') ,1,32)  as adr,
        1 as type, ' вартплата' as type_name,
       substr(s.mg,5,2)||substr(s.mg,1,4) as period, sum(s.summa)*100 as summa
       from scott.kart k ,
        scott.spul l,
         (select lsk, mg1 as mg, c.summa as summa from
          scott.c_penya c
         ) s
        where k.lsk=s.lsk and k.kul=l.id and k.lsk=s.lsk
        and exists
       (select * from scott.list_choices_reu l where l.reu=k.reu and l.sel=0)
        group by k.lsk, substr(trim(k.fio),1,25), s.mg,
       substr(l.name||', '||NVL(LTRIM(replace(k.nd, '\', str_),'0'),'0')||'-'||NVL(LTRIM(k.kw,'0'),'0') ,1,32)
       union all
      select k.lsk, substr(trim(k.fio),1,25) as fio,
       substr(l.name||', '||NVL(LTRIM(replace(k.nd, '\', str_),'0'),'0')||'-'||NVL(LTRIM(k.kw,'0'),'0') ,1,32)  as adr,
        2 as type, 'ѕен€' as type_name,
       substr(s.mg,5,2)||substr(s.mg,1,4) as period, sum(s.summa)*100 as summa
       from scott.kart k ,
        scott.spul l,
         (select lsk, mg1 as mg, c.penya as summa from
          scott.c_penya c
         ) s
        where nvl(s.summa,0) <> 0 and k.lsk=s.lsk and k.kul=l.id and k.lsk=s.lsk
        and exists
       (select * from scott.list_choices_reu l where l.reu=k.reu and l.sel=0)
        group by k.lsk, substr(trim(k.fio),1,25), s.mg,
       substr(l.name||', '||NVL(LTRIM(replace(k.nd, '\', str_),'0'),'0')||'-'||NVL(LTRIM(k.kw,'0'),'0') ,1,32))
       order by lsk, period, type;
  elsif rep_id_ in (21) then
  --ƒолги дл€ —бербанка, дл€ ѕолыс, совокупные (Ќ≈ разбитые по периодам, и Ќ≈ разбитые на пеню)
    str_:='корп.';
/*    open prep_refcursor for
      select k.lsk, substr(trim(k.fio),1,25) as fio,
       substr(l.name||', '||NVL(LTRIM( replace(k.nd, '\', str_) ,'0'),'0')||'-'||NVL(LTRIM(k.kw,'0'),'0') ,1,32)  as adr,
        '01' as type, ' вартплата' as type_name, substr(mg_,5,2)||substr(mg_,1,4) as period, 
        decode(s.is_not_only_cur, 1, s.summa*100, 0) as summa --если только текущий период, то поставить ноль
       from scott.kart k ,
        scott.spul l,
         (select c.lsk, max(decode(c.mg1, mg_, 0, 1)) as is_not_only_cur, sum(decode(c.mg1, mg_, 0, nvl(c.summa,0)+nvl(c.penya,0))) as summa from
          scott.c_penya c where c.mg1 <= mg_ --только задолжность (в т.ч. текущий период)
          group by c.lsk) s
        where k.lsk=s.lsk and k.kul=l.id and k.lsk=s.lsk
        and exists
       (select * from scott.list_choices_reu l where l.reu=k.reu and l.sel=0)
       order by k.lsk;*/
    --ѕеределал, в тыс€чный раз   
    open prep_refcursor for
      select k.lsk, substr(trim(k.fio),1,25) as fio,
       substr(l.name||', '||NVL(LTRIM( replace(k.nd, '\', str_) ,'0'),'0')||'-'||NVL(LTRIM(k.kw,'0'),'0') ,1,32)  as adr,
        '01' as type, ' вартплата' as type_name, substr(mg_,5,2)||substr(mg_,1,4) as period, 
        s.summa*100 as summa --если только текущий период, то поставить ноль
       from scott.kart k ,
        scott.spul l,
         (select c.lsk, sum(nvl(c.summa,0)+nvl(c.penya,0)) as summa from
          scott.c_penya c where c.mg1 <= mg_ --задолжность+пен€ (в т.ч. текущий период)
          group by c.lsk) s
        where k.lsk=s.lsk and k.kul=l.id and k.lsk=s.lsk
        and exists
       (select * from scott.list_choices_reu l where l.reu=k.reu and l.sel=0)
       order by k.lsk;
   end if;
  end;



end rep_lists;
/

prompt
prompt Creating package body REP_OPL
prompt =============================
prompt
CREATE OR REPLACE PACKAGE BODY SCOTT.rep_opl IS
  PROCEDURE report_xito10(var_           IN XXITO12.var%TYPE, --¬ариант отчета (самост. не самост.)
                          reptype_       IN NUMBER, --¬ариант формы по отчету
                          det_           IN NUMBER, --ƒополнительна€ расшифровка по предпри€ти€м
                          reu_           IN XXITO12.reu%TYPE,
                          kul_           IN XXITO12.kul%TYPE,
                          nd_            IN XXITO12.nd%TYPE,
                          trest_         IN XXITO12.trest%TYPE,
                          org_           IN NUMBER,
                          dat_           IN XXITO12.dat%TYPE,
                          dat1_          IN XXITO12.dat%TYPE,
                          status_        IN XXITO12.STATUS%TYPE, --ƒетализаци€ по статусу
                          mg_            IN XXITO12.mg%TYPE,
                          mg1_           IN XXITO12.mg%TYPE,
                          period_        IN XXITO12.dopl%TYPE,
                          period1_       IN XXITO12.dopl%TYPE,
                          prep_refcursor IN OUT rep_refcursor) IS
    sqlstr1 VARCHAR2(500);
    sqlstr2 VARCHAR2(500);
    sqlstr3 VARCHAR2(500);
    sqlstr4 VARCHAR2(500);
    sqlstr5 varchar2(2000);
    tables_ VARCHAR2(500);
  BEGIN

    tables_ := '';
    sqlstr4 := '';
    IF status_ = 1 OR status_ = 0 THEN
      --¬ыбрана детализаци€ по статусу
/*      IF var_ = 1 THEN
        --ѕо самосто€тельным
        sqlstr1 := ' and t.var in (1) and t.status=' || TO_CHAR(status_);
      ELSIF var_ = 2 THEN
        --ѕо не самосто€тельным
        sqlstr1 := ' and t.var in (0) and t.status=' || TO_CHAR(status_);
      ELSE
        --ѕо всем
        sqlstr1 := ' and t.var in (0,1) and t.status=' || TO_CHAR(status_);
      END IF;
*/
      IF org_ IS NOT NULL THEN
        --‘ильтр по организации
        sqlstr1 := sqlstr1 || ' and t.org IN (' || org_ || ') ';
      END IF;

      IF reptype_ = 1 THEN
        --‘.2.2.—редства, собранные за ∆Ёќ другими (кроме себ€)
        sqlstr2 := ' and forreu=s.reu and d.trest <> s.trest and t.reu=d.reu m';
        sqlstr3 := ' d.trest, substr(d.name_tr,1,15) ';
--        sqlstr5 := ' and t.reu=r.reu ';
      ELSIF reptype_ = 2 THEN
        --‘.2.3.—редства, собранные ∆Ёќ за других (кроме себ€)
        sqlstr2 := ' and t.reu=s.reu and d.trest <> s.trest and t.forreu=d.reu ';
        sqlstr3 := ' d.trest, substr(d.name_tr,1,15) ';
--        sqlstr5 := ' and t.forreu=r.reu ';
      ELSIF reptype_ = 3 THEN
        --‘.2.4.—редства, собранные ∆Ёќ за других (включа€ себ€) (инкасс)
        sqlstr2 := ' and t.reu=s.reu and t.forreu=d.reu ';
        sqlstr3 := ' d.trest, substr(d.name_tr,1,15) ';
--        sqlstr5 := ' and t.forreu=r.reu ';
      ELSE
        --‘.2.1.ƒл€ оборотной ведомости
        IF reu_ IS NOT NULL OR trest_ IS NOT NULL THEN
          --ѕо –Ё” и по тресту несколько по-другому делаем
          sqlstr2 := ' and forreu=s.reu and t.reu=d.reu ';
          sqlstr3 := ' d.trest, substr(d.name_tr,1,15)';
--          sqlstr5 := ' and t.reu=r.reu ';
        ELSE
          sqlstr2 := ' and t.forreu=s.reu and s.reu=d.reu '; --маленька€ корректировка
          sqlstr3 := ' s.trest, substr(s.name_tr,1,15) ';
--          sqlstr5 := ' and t.reu=r.reu ';
        END IF;
      END IF;

      IF period_ IS NOT NULL AND period1_ IS NOT NULL THEN
        sqlstr2 := sqlstr2 || ' and t.dopl BETWEEN ' || period_ || ' AND ' ||
                   period1_;
      END IF;

      IF det_ = 1 THEN
        tables_ := ', v_org_periods r';
        sqlstr1 := sqlstr1 ||
                   ' and t.org=r.org and t.dopl between r.dat and r.dat1 and t.forreu=r.reu';
        sqlstr4 := sqlstr4 ||
                   'rtrim(to_char(o.kod)||'' ''||substr(o.name,1,35))||r.mg';
      ELSE
        sqlstr4 := sqlstr4 ||
                   'rtrim(to_char(o.kod)||'' ''||substr(o.name,1,35))';
      END IF;

      IF trest_ IS NOT NULL THEN
        --ѕо трестам
        IF dat_ IS NOT NULL AND dat1_ IS NOT NULL THEN
          OPEN prep_refcursor FOR 'select ' || sqlstr3 || ' as name_tr,
          ' || sqlstr4 || ' AS name, SUBSTR(u.nm1,1,22) AS nm1, ROUND(SUM(summa),2) AS summa FROM XXITO12 t,
          S_REU_TREST s, S_REU_TREST d, SPRORG o, USL u' || tables_ || '
          WHERE  t.dat BETWEEN :dat_ AND :dat1_ ' || sqlstr2 || ' AND t.ORG=o.kod
          ' || sqlstr1 || ' AND s.trest=:trest_ AND t.USL=u.USL
          GROUP BY   ' || sqlstr3 || ', ' || sqlstr4 || ', u.nm1
          ORDER BY   ' || sqlstr3 || ', ' || sqlstr4 || ', SUBSTR(u.nm1,1,22)'
            USING dat_, dat1_, trest_;
        ELSIF mg_ IS NOT NULL AND mg1_ IS NOT NULL THEN
          OPEN prep_refcursor FOR 'select ' || sqlstr3 || ' as name_tr,
          ' || sqlstr4 || ' AS name, SUBSTR(u.nm1,1,22) AS nm1, ROUND(SUM(summa),2) AS summa FROM XXITO12 t,
          S_REU_TREST s, S_REU_TREST d, SPRORG o, USL u' || tables_ || '
          WHERE  t.mg BETWEEN :mg_ AND :mg1_ ' || sqlstr2 || ' AND t.ORG=o.kod
          ' || sqlstr1 || ' AND s.trest=:trest_ AND t.USL=u.USL
          GROUP BY   ' || sqlstr3 || ', ' || sqlstr4 || ', u.nm1
          ORDER BY   ' || sqlstr3 || ', ' || sqlstr4 || ', SUBSTR(u.nm1,1,22)'
            USING mg_, mg1_, trest_;
        END IF;
      ELSIF reu_ IS NOT NULL AND kul_ IS NULL AND nd_ IS NULL THEN
        --ѕо –Ё”
        IF dat_ IS NOT NULL AND dat1_ IS NOT NULL THEN
          OPEN prep_refcursor FOR 'select ' || sqlstr3 || ' as name_tr,
          ' || sqlstr4 || ' AS name, SUBSTR(u.nm1,1,22) AS nm1, ROUND(SUM(summa),2) AS summa FROM XXITO12 t,
          S_REU_TREST s, S_REU_TREST d, SPRORG o, USL u' || tables_ || '
          WHERE  t.dat BETWEEN :dat_ AND :dat1_ ' || sqlstr2 || ' AND t.ORG=o.kod
          ' || sqlstr1 || ' AND s.reu=:reu_ AND t.USL=u.USL
          GROUP BY   ' || sqlstr3 || ', ' || sqlstr4 || ', u.nm1
          ORDER BY   ' || sqlstr3 || ', ' || sqlstr4 || ', SUBSTR(u.nm1,1,22)'
            USING dat_, dat1_, reu_;
        ELSIF mg_ IS NOT NULL AND mg1_ IS NOT NULL THEN
          OPEN prep_refcursor FOR 'select ' || sqlstr3 || ' as name_tr,
          ' || sqlstr4 || ' AS name, SUBSTR(u.nm1,1,22) AS nm1, ROUND(SUM(summa),2) AS summa FROM XXITO12 t,
          S_REU_TREST s, S_REU_TREST d, SPRORG o, USL u' || tables_ || '
          WHERE  t.mg BETWEEN :mg_ AND :mg1_ ' || sqlstr2 || ' AND t.ORG=o.kod
          ' || sqlstr1 || ' AND s.reu=:reu_ AND t.USL=u.USL
          GROUP BY   ' || sqlstr3 || ', ' || sqlstr4 || ', u.nm1
          ORDER BY   ' || sqlstr3 || ', ' || sqlstr4 || ', SUBSTR(u.nm1,1,22)'
            USING mg_, mg1_, reu_;
        END IF;
      ELSIF reu_ IS NOT NULL AND kul_ IS NOT NULL AND nd_ IS NOT NULL THEN
        --ѕо адресу
        IF dat_ IS NOT NULL AND dat1_ IS NOT NULL THEN
          OPEN prep_refcursor FOR 'select ' || sqlstr3 || ' as name_tr,
          ' || sqlstr4 || ' AS name, SUBSTR(u.nm1,1,22) AS nm1, ROUND(SUM(summa),2) AS summa FROM XXITO12 t,
          S_REU_TREST s, S_REU_TREST d, SPRORG o, USL u' || tables_ || '
          WHERE  t.dat BETWEEN :dat_ AND :dat1_ ' || sqlstr2 || ' AND t.ORG=o.kod
          ' || sqlstr1 || ' AND s.reu=:reu_ AND t.kul=:kul_ AND t.nd=:nd_ AND t.USL=u.USL
          GROUP BY   ' || sqlstr3 || ', ' || sqlstr4 || ', u.nm1
          ORDER BY   ' || sqlstr3 || ', ' || sqlstr4 || ', SUBSTR(u.nm1,1,22)'
            USING dat_, dat1_, reu_, kul_, nd_;
        ELSIF mg_ IS NOT NULL AND mg1_ IS NOT NULL THEN
          OPEN prep_refcursor FOR 'select ' || sqlstr3 || ' as name_tr,
          ' || sqlstr4 || ' AS name, SUBSTR(u.nm1,1,22) AS nm1, ROUND(SUM(summa),2) AS summa FROM XXITO12 t,
          S_REU_TREST s, S_REU_TREST d, SPRORG o, USL u' || tables_ || '
          WHERE  t.mg BETWEEN :mg_ AND :mg1_ ' || sqlstr2 || ' AND t.ORG=o.kod
          ' || sqlstr1 || ' AND s.reu=:reu_ AND t.kul=:kul_ AND t.nd=:nd_ AND t.USL=u.USL
          GROUP BY   ' || sqlstr3 || ', ' || sqlstr4 || ', u.nm1
          ORDER BY   ' || sqlstr3 || ', ' || sqlstr4 || ', SUBSTR(u.nm1,1,22)'
            USING mg_, mg1_, reu_, kul_, nd_;
        END IF;
      ELSE
        --ѕо всем ∆Ёќ
        IF dat_ IS NOT NULL AND dat1_ IS NOT NULL THEN
          OPEN prep_refcursor FOR 'select ' || sqlstr3 || ' as name_tr,
          ' || sqlstr4 || ' AS name, u.nm1 AS nm1, ROUND(SUM(summa),2) AS summa FROM XXITO12 t,
          S_REU_TREST s, S_REU_TREST d, SPRORG o, USL u' || tables_ || '
          WHERE  t.dat BETWEEN :dat_ AND :dat1_ ' || sqlstr2 || ' AND t.ORG=o.kod
          ' || sqlstr1 || ' AND t.USL=u.USL
          GROUP BY   ' || sqlstr3 || ', ' || sqlstr4 || ', u.nm1
          ORDER BY   ' || sqlstr3 || ', ' || sqlstr4 || ', u.nm1'
            USING dat_, dat1_;
        ELSIF mg_ IS NOT NULL AND mg1_ IS NOT NULL THEN

          OPEN prep_refcursor FOR 'select ' || sqlstr3 || ' as name_tr,
          TO_CHAR(o.kod)||'' ''||' || sqlstr4 || ' AS name, u.nm1 AS nm1, ROUND(SUM(summa),2) AS summa FROM XXITO12 t,
          S_REU_TREST s, S_REU_TREST d, SPRORG o, USL u' || tables_ || '
          WHERE  t.mg BETWEEN :mg_ AND :mg1_ ' || sqlstr2 || ' AND t.ORG=o.kod
          ' || sqlstr1 || ' AND t.USL=u.USL
          GROUP BY   ' || sqlstr3 || ', ' || sqlstr4 || ', u.nm1
          ORDER BY   ' || sqlstr3 || ', ' || sqlstr4 || ', u.nm1'
            USING mg_, mg1_;
        END IF;
      END IF;
    ELSE
      --Ѕез детализации по статусу
/*      IF var_ = 1 THEN
        --ѕо самосто€тельным
        sqlstr1 := ' and t.var in (1) ';
      ELSIF var_ = 2 THEN
        --ѕо не самосто€тельным
        sqlstr1 := ' and t.var in (0) ';
      ELSE
        --ѕо всем
        sqlstr1 := ' and t.var in (0,1) ';
      END IF;
*/
      IF org_ IS NOT NULL THEN
        --‘ильтр по организации
        sqlstr1 := sqlstr1 || ' and t.org IN (TO_NUMBER(' || TO_CHAR(org_) ||
                   ')) ';
      END IF;

      IF reptype_ = 1 THEN
        --‘.2.2.—редства, собранные за ∆Ёќ другими (кроме себ€)
        sqlstr2 := ' and forreu=s.reu and d.trest <> s.trest and t.reu=d.reu ';
        sqlstr3 := ' d.trest, substr(d.name_tr,1,15) ';
--        sqlstr5 := ' and t.forreu=r.reu ';
      ELSIF reptype_ = 2 THEN
        --‘.2.3.—редства, собранные ∆Ёќ за других (кроме себ€)
        sqlstr2 := ' and t.reu=s.reu and d.trest <> s.trest and t.forreu=d.reu ';
        sqlstr3 := ' d.trest, substr(d.name_tr,1,15) ';
--        sqlstr5 := ' and t.forreu=r.reu ';
      ELSIF reptype_ = 3 THEN
        --‘.2.4.—редства, собранные ∆Ёќ за других (включа€ себ€) (инкасс)
        sqlstr2 := ' and t.reu=s.reu and t.forreu=d.reu ';
        sqlstr3 := ' d.trest, substr(d.name_tr,1,15) ';
--        sqlstr5 := ' and t.forreu=r.reu ';
      ELSE
        --‘.2.1.ƒл€ оборотной ведомости
        IF reu_ IS NOT NULL OR trest_ IS NOT NULL THEN
          --ѕо –Ё” и по тресту несколько по-другому делаем
          sqlstr2 := ' and forreu=s.reu and t.reu=d.reu ';
          sqlstr3 := ' d.trest, substr(d.name_tr,1,15) ';
--          sqlstr5 := ' and t.forreu=r.reu ';
        ELSE
          sqlstr2 := ' and t.forreu=s.reu and s.reu=d.reu '; --маленька€ корректировка
          sqlstr3 := ' s.trest, substr(s.name_tr,1,15) ';
--          sqlstr5 := ' and t.forreu=r.reu ';
        END IF;
      END IF;

      IF period_ IS NOT NULL AND period1_ IS NOT NULL THEN
        sqlstr2 := sqlstr2 || ' and t.dopl BETWEEN ' || period_ || ' AND ' ||
                   period1_;
      END IF;

      IF det_ = 1 THEN
        sqlstr1 := sqlstr1 ||
                   ' and o.kod=r.org and t.dopl between r.dat and r.dat1 and t.forreu=r.reu';
        tables_ := ', v_org_periods r';
        sqlstr4 := sqlstr4 ||
                   'rtrim(to_char(o.kod)||'' ''||substr(o.name,1,35))||r.mg';
      ELSE
        sqlstr4 := sqlstr4 ||
                   'rtrim(to_char(o.kod)||'' ''||substr(o.name,1,35))';
      END IF;

      IF trest_ IS NOT NULL THEN
        --ѕо трестам
        IF dat_ IS NOT NULL AND dat1_ IS NOT NULL THEN
          OPEN prep_refcursor FOR 'select ' || sqlstr3 || ' as name_tr,
          ' || sqlstr4 || ' AS name, SUBSTR(u.nm1,1,22) AS nm1, ROUND(SUM(summa),2) AS summa FROM XXITO10 t,
          S_REU_TREST s, S_REU_TREST d, SPRORG o, USL u' || tables_ || '
          WHERE  t.dat BETWEEN :dat_ AND :dat1_ ' || sqlstr2 || ' AND t.ORG=o.kod
          ' || sqlstr1 || ' AND s.trest=:trest_ AND t.USL=u.USL AND t.oborot IN (1)
          GROUP BY   ' || sqlstr3 || ', ' || sqlstr4 || ', u.nm1
          ORDER BY   ' || sqlstr3 || ', ' || sqlstr4 || ', SUBSTR(u.nm1,1,22)'
            USING dat_, dat1_, trest_;
        ELSIF mg_ IS NOT NULL AND mg1_ IS NOT NULL THEN
          OPEN prep_refcursor FOR 'select ' || sqlstr3 || ' as name_tr,
          ' || sqlstr4 || ' AS name, SUBSTR(u.nm1,1,22) AS nm1, ROUND(SUM(summa),2) AS summa FROM XXITO10 t,
          S_REU_TREST s, S_REU_TREST d, SPRORG o, USL u' || tables_ || '
          WHERE  t.mg BETWEEN :mg_ AND :mg1_ ' || sqlstr2 || ' AND t.ORG=o.kod
          ' || sqlstr1 || ' AND s.trest=:trest_ AND t.USL=u.USL AND t.oborot IN (1)
          GROUP BY   ' || sqlstr3 || ', ' || sqlstr4 || ', u.nm1
          ORDER BY   ' || sqlstr3 || ', ' || sqlstr4 || ', SUBSTR(u.nm1,1,22)'
            USING mg_, mg1_, trest_;
        END IF;
      ELSIF reu_ IS NOT NULL AND kul_ IS NULL AND nd_ IS NULL THEN
        --ѕо –Ё”
        IF dat_ IS NOT NULL AND dat1_ IS NOT NULL THEN
          OPEN prep_refcursor FOR 'select ' || sqlstr3 || ' as name_tr,
          ' || sqlstr4 || ' AS name, SUBSTR(u.nm1,1,22) AS nm1, ROUND(SUM(summa),2) AS summa FROM XXITO10 t,
          S_REU_TREST s, S_REU_TREST d, SPRORG o, USL u' || tables_ || '
          WHERE  t.dat BETWEEN :dat_ AND :dat1_ ' || sqlstr2 || ' AND t.ORG=o.kod
          ' || sqlstr1 || ' AND s.reu=:reu_ AND t.USL=u.USL AND t.oborot IN (1)
          GROUP BY   ' || sqlstr3 || ', ' || sqlstr4 || ', u.nm1
          ORDER BY   ' || sqlstr3 || ', ' || sqlstr4 || ', SUBSTR(u.nm1,1,22)'
            USING dat_, dat1_, reu_;
        ELSIF mg_ IS NOT NULL AND mg1_ IS NOT NULL THEN
         sqlstr5 := 'select ' || sqlstr3 || ' as name_tr,
          TO_CHAR(o.kod)||'' ''||' || sqlstr4 || ' AS name, u.nm1 AS nm1, ROUND(SUM(summa),2) AS summa FROM XXITO12 t,
          S_REU_TREST s, S_REU_TREST d, SPRORG o, USL u' || tables_ || '
          WHERE  t.mg BETWEEN :mg_ AND :mg1_ ' || sqlstr2 || ' AND t.ORG=o.kod
          ' || sqlstr1 || ' AND t.USL=u.USL
          GROUP BY   ' || sqlstr3 || ', ' || sqlstr4 || ', u.nm1
          ORDER BY   ' || sqlstr3 || ', ' || sqlstr4 || ', u.nm1';
          OPEN prep_refcursor FOR 'select ' || sqlstr3 || ' as name_tr,
          ' || sqlstr4 || ' AS name, SUBSTR(u.nm1,1,22) AS nm1, ROUND(SUM(summa),2) AS summa FROM XXITO10 t,
          S_REU_TREST s, S_REU_TREST d, SPRORG o, USL u' || tables_ || '
          WHERE  t.mg BETWEEN :mg_ AND :mg1_ ' || sqlstr2 || ' AND t.ORG=o.kod
          ' || sqlstr1 || ' AND s.reu=:reu_ AND t.USL=u.USL AND t.oborot IN (1)
          GROUP BY   ' || sqlstr3 || ', ' || sqlstr4 || ', u.nm1
          ORDER BY   ' || sqlstr3 || ', ' || sqlstr4 || ', SUBSTR(u.nm1,1,22)'
            USING mg_, mg1_, reu_;
        END IF;
      ELSIF reu_ IS NOT NULL AND kul_ IS NOT NULL AND nd_ IS NOT NULL THEN
        --ѕо адресу
        IF dat_ IS NOT NULL AND dat1_ IS NOT NULL THEN
          OPEN prep_refcursor FOR 'select ' || sqlstr3 || ' as name_tr,
          ' || sqlstr4 || ' AS name, SUBSTR(u.nm1,1,22) AS nm1, ROUND(SUM(summa),2) AS summa FROM XXITO12 t,
          S_REU_TREST s, S_REU_TREST d, SPRORG o, USL u' || tables_ || '
          WHERE  t.dat BETWEEN :dat_ AND :dat1_ ' || sqlstr2 || ' AND t.ORG=o.kod
          ' || sqlstr1 || ' AND s.reu=:reu_ AND t.kul=:kul_ AND t.nd=:nd_ AND t.USL=u.USL
          GROUP BY   ' || sqlstr3 || ', ' || sqlstr4 || ', u.nm1
          ORDER BY   ' || sqlstr3 || ', ' || sqlstr4 || ', SUBSTR(u.nm1,1,22)'
            USING dat_, dat1_, reu_, kul_, nd_;
        ELSIF mg_ IS NOT NULL AND mg1_ IS NOT NULL THEN
          OPEN prep_refcursor FOR 'select ' || sqlstr3 || ' as name_tr,
          ' || sqlstr4 || ' AS name, SUBSTR(u.nm1,1,22) AS nm1, ROUND(SUM(summa),2) AS summa FROM XXITO12 t,
          S_REU_TREST s, S_REU_TREST d, SPRORG o, USL u' || tables_ || '
          WHERE  t.mg BETWEEN :mg_ AND :mg1_ ' || sqlstr2 || ' AND t.ORG=o.kod
          ' || sqlstr1 || ' AND s.reu=:reu_ AND t.kul=:kul_ AND t.nd=:nd_ AND t.USL=u.USL
          GROUP BY   ' || sqlstr3 || ', ' || sqlstr4 || ', u.nm1
          ORDER BY   ' || sqlstr3 || ', ' || sqlstr4 || ', SUBSTR(u.nm1,1,22)'
            USING mg_, mg1_, reu_, kul_, nd_;
        END IF;
      ELSE
        --ѕо всем ∆Ёќ
        IF dat_ IS NOT NULL AND dat1_ IS NOT NULL THEN
          OPEN prep_refcursor FOR 'select ' || sqlstr3 || ' as name_tr,
          ' || sqlstr4 || ' AS name, u.nm1 AS nm1, ROUND(SUM(summa),2) AS summa FROM XXITO10 t,
          S_REU_TREST s, S_REU_TREST d, SPRORG o, USL u' || tables_ || '
          WHERE  t.dat BETWEEN :dat_ AND :dat1_ ' || sqlstr2 || ' AND t.ORG=o.kod
          ' || sqlstr1 || ' AND t.USL=u.USL AND t.oborot IN (1)
          GROUP BY   ' || sqlstr3 || ', ' || sqlstr4 || ', u.nm1
          ORDER BY   ' || sqlstr3 || ', ' || sqlstr4 || ', u.nm1'
            USING dat_, dat1_;
        ELSIF mg_ IS NOT NULL AND mg1_ IS NOT NULL THEN
          OPEN prep_refcursor FOR 'select ' || sqlstr3 || ' as name_tr,
          ' || sqlstr4 || ' AS name, u.nm1 AS nm1, ROUND(SUM(summa),2) AS summa FROM XXITO10 t,
          S_REU_TREST s, S_REU_TREST d, SPRORG o, USL u' || tables_ || '
          WHERE  t.mg BETWEEN :mg_ AND :mg1_ ' || sqlstr2 || ' AND t.ORG=o.kod
          ' || sqlstr1 || ' AND t.USL=u.USL AND t.oborot IN (1)
          GROUP BY   ' || sqlstr3 || ', ' || sqlstr4 || ', u.nm1
          ORDER BY   ' || sqlstr3 || ', ' || sqlstr4 || ', u.nm1'
            USING mg_, mg1_;
        END IF;
      END IF;
    END IF;

  END report_xito10;

  PROCEDURE report_xito3(reu_           IN VARCHAR2,
                         trest_         IN VARCHAR2,
                         mg_            IN VARCHAR2,
                         mg1_           IN VARCHAR2,
                         prep_refcursor IN OUT rep_refcursor) IS
  BEGIN
    IF trest_ IS NOT NULL THEN
      OPEN prep_refcursor FOR 'select u.nm1, t.dopl, substr(t.dopl,5,2)||''/''||substr(t.dopl,1,4) as period, substr(t.dopl,1,4)||'' г.'' as year,
         o.name||s.name_tr AS predpr, SUM(summa) AS summa
         FROM XXITO3 t, USL u, ORG o, S_REU_TREST s
         WHERE mg BETWEEN :mg_ AND :mg1_ AND t.USL=u.USL AND t.trest=:trest_ AND o.id=2 AND t.reu=s.reu
         GROUP BY u.nm1, t.dopl, SUBSTR(t.dopl,5,2)||''/''||SUBSTR(t.dopl,1,4), SUBSTR(t.dopl,1,4)||'' г.'', o.name||s.name_tr
         ORDER BY t.dopl, u.nm1'
        USING mg_, mg1_, trest_;
    ELSIF reu_ IS NOT NULL THEN
      OPEN prep_refcursor FOR 'select u.nm1, t.dopl, substr(t.dopl,5,2)||''/''||substr(t.dopl,1,4) as period, substr(t.dopl,1,4)||'' г.'' as year,
         s.name_reu AS predpr,SUM(summa) AS summa
         FROM XXITO3 t, USL u, ORG o, S_REU_TREST s
         WHERE mg BETWEEN :mg_ AND :mg1_ AND t.USL=u.USL AND t.reu=:reu AND o.id=3 AND t.reu=s.reu
         GROUP BY u.nm1, t.dopl, SUBSTR(t.dopl,5,2)||''/''||SUBSTR(t.dopl,1,4), SUBSTR(t.dopl,1,4)||'' г.'', s.name_reu
         ORDER BY t.dopl, u.nm1'
        USING mg_, mg1_, reu_;
    ELSE
      OPEN prep_refcursor FOR 'select u.nm1, t.dopl, substr(t.dopl,5,2)||''/''||substr(t.dopl,1,4) as period, substr(t.dopl,1,4)||'' г.'' as year,
         o.name AS predpr, SUM(summa) AS summa
         FROM XXITO3 t, USL u, ORG o
         WHERE mg BETWEEN :mg_ AND :mg1_ AND t.USL=u.USL AND o.id=1
         GROUP BY u.nm1, t.dopl, SUBSTR(t.dopl,5,2)||''/''||SUBSTR(t.dopl,1,4), SUBSTR(t.dopl,1,4)||'' г.'', o.name
         ORDER BY t.dopl, u.nm1'
        USING mg_, mg1_;
    END IF;
  END report_xito3;

  PROCEDURE report_xito11(oper_          IN VARCHAR2,
                          reu_           IN VARCHAR2,
                          trest_         IN VARCHAR2,
                          org_           IN NUMBER,
                          dat_           IN XITO5.dat%TYPE,
                          dat1_          IN XITO5.dat%TYPE,
                          mg_            IN VARCHAR2,
                          mg1_           IN VARCHAR2,
                          prep_refcursor IN OUT rep_refcursor) IS
    sqlstr_ VARCHAR2(500);
  BEGIN
    -- ‘. 2.4
    IF oper_ = '00' THEN
      --выбраны все операции
      sqlstr_ := 'and :oper_ = ''00'' AND t.oper IN (SELECT oper FROM oper WHERE SUBSTR(oigu,1,1)=''1'')';
    ELSE
      --выбрана конкретна€ операци€
      sqlstr_ := 'and t.oper=:oper_';
    END IF;

    IF org_ IS NOT NULL THEN
      --‘ильтр по организации
      sqlstr_ := sqlstr_ || ' and t.org IN (' || TO_CHAR(org_) || ') ';
    END IF;

    IF trest_ IS NOT NULL THEN
      --ѕо трестам
      IF dat_ IS NOT NULL AND dat1_ IS NOT NULL THEN
        OPEN prep_refcursor FOR 'select /*+ ORDERED */ s.trest, substr(s.name_tr,1,15) as name_tr, t.oper,
          TO_CHAR(o.kod)||'' ''||SUBSTR(o.name,1,20) AS name, SUBSTR(u.nm1,1,20) AS nm1, SUM(summa) FROM XXITO11 t,
          S_REU_TREST s, SPRORG o, USL u
          WHERE  t.dat BETWEEN :dat_ AND :dat1_ AND t.forreu=s.reu AND t.ORG=o.kod
         ' || sqlstr_ || ' AND s.trest=:trest_ AND t.USL=u.USL
          GROUP BY s.trest, SUBSTR(s.name_tr,1,15), t.OPER, TO_CHAR(o.kod)||'' ''||SUBSTR(o.name,1,20), SUBSTR(u.nm1,1,20)'
          USING dat_, dat1_, oper_, trest_;
      ELSIF mg_ IS NOT NULL AND mg1_ IS NOT NULL THEN
        OPEN prep_refcursor FOR 'select /*+ ORDERED */ s.trest, substr(s.name_tr,1,15) as name_tr, t.oper,
          TO_CHAR(o.kod)||'' ''||SUBSTR(o.name,1,20) AS name, SUBSTR(u.nm1,1,20) AS nm1, SUM(summa) FROM XXITO11 t,
          S_REU_TREST s, SPRORG o, USL u
          WHERE  t.mg BETWEEN :mg_ AND :mg1_ AND t.forreu=s.reu AND t.ORG=o.kod
          ' || sqlstr_ || ' AND s.trest=:trest_ AND t.USL=u.USL
          GROUP BY s.trest, SUBSTR(s.name_tr,1,15), t.OPER, TO_CHAR(o.kod)||'' ''||SUBSTR(o.name,1,20), SUBSTR(u.nm1,1,20)'
          USING mg_, mg1_, oper_, trest_;
      END IF;
    ELSIF reu_ IS NOT NULL THEN
      --ѕо –Ё”
      IF dat_ IS NOT NULL AND dat1_ IS NOT NULL THEN
        OPEN prep_refcursor FOR 'select /*+ ORDERED */ s.trest, substr(s.name_tr,1,15) as name_tr, t.oper,
          TO_CHAR(o.kod)||'' ''||SUBSTR(o.name,1,20) AS name, SUBSTR(u.nm1,1,20) AS nm1, SUM(summa) FROM XXITO11 t,
          S_REU_TREST s, SPRORG o, USL u
          WHERE  t.dat BETWEEN :dat_ AND :dat1_ AND t.forreu=s.reu AND t.ORG=o.kod
          ' || sqlstr_ || ' AND s.reu=:reu_ AND t.USL=u.USL
          GROUP BY s.trest, SUBSTR(s.name_tr,1,15), t.OPER, TO_CHAR(o.kod)||'' ''||SUBSTR(o.name,1,20), SUBSTR(u.nm1,1,20)'
          USING dat_, dat1_, oper_, reu_;
      ELSIF mg_ IS NOT NULL AND mg1_ IS NOT NULL THEN
        OPEN prep_refcursor FOR 'select /*+ ORDERED */ s.trest, substr(s.name_tr,1,15) as name_tr, t.oper,
          TO_CHAR(o.kod)||'' ''||SUBSTR(o.name,1,20) AS name, SUBSTR(u.nm1,1,20) AS nm1, SUM(summa) FROM XXITO11 t,
          S_REU_TREST s, SPRORG o, USL u
          WHERE  t.mg BETWEEN :mg_ AND :mg1_ AND t.forreu=s.reu AND t.ORG=o.kod
          ' || sqlstr_ || ' AND s.reu=:reu_ AND t.USL=u.USL
          GROUP BY s.trest, SUBSTR(s.name_tr,1,15), t.OPER, TO_CHAR(o.kod)||'' ''||SUBSTR(o.name,1,20), SUBSTR(u.nm1,1,20)'
          USING mg_, mg1_, oper_, reu_;
      END IF;
    ELSE
      --ѕо всем ∆Ёќ
      IF dat_ IS NOT NULL AND dat1_ IS NOT NULL THEN
        OPEN prep_refcursor FOR 'select /*+ ORDERED */ s.trest, substr(s.name_tr,1,15) as name_tr, t.oper,
          TO_CHAR(o.kod)||'' ''||SUBSTR(o.name,1,20) AS name, SUBSTR(u.nm1,1,20) AS nm1, SUM(summa) FROM XXITO11 t,
          S_REU_TREST s, SPRORG o, USL u
          WHERE  t.dat BETWEEN :dat_ AND :dat1_ AND t.forreu=s.reu AND t.ORG=o.kod
          ' || sqlstr_ || ' AND t.USL=u.USL
          GROUP BY s.trest, SUBSTR(s.name_tr,1,15), t.OPER, TO_CHAR(o.kod)||'' ''||SUBSTR(o.name,1,20), SUBSTR(u.nm1,1,20)
          ORDER BY s.trest'
          USING dat_, dat1_, oper_;
      ELSIF mg_ IS NOT NULL AND mg1_ IS NOT NULL THEN
        OPEN prep_refcursor FOR 'select /*+ ORDERED */ s.trest, substr(s.name_tr,1,15) as name_tr, t.oper,
          TO_CHAR(o.kod)||'' ''||SUBSTR(o.name,1,20) AS name, SUBSTR(u.nm1,1,20) AS nm1, SUM(summa) FROM XXITO11 t,
          S_REU_TREST s, SPRORG o, USL u
          WHERE  t.mg BETWEEN :mg_ AND :mg1_ AND t.forreu=s.reu AND t.ORG=o.kod
          ' || sqlstr_ || ' AND t.USL=u.USL
          GROUP BY s.trest, SUBSTR(s.name_tr,1,15), t.OPER, TO_CHAR(o.kod)||'' ''||SUBSTR(o.name,1,20), SUBSTR(u.nm1,1,20)
          ORDER BY s.trest'
          USING mg_, mg1_, oper_;
      END IF;
    END IF;

  END report_xito11;
  PROCEDURE report_xito5(var_           IN NUMBER,
                         type_          IN NUMBER,
                         reu_           IN VARCHAR2,
                         trest_         IN VARCHAR2,
                         dat_           IN XITO5.dat%TYPE,
                         dat1_          IN XITO5.dat%TYPE,
                         mg_            IN VARCHAR2,
                         mg1_           IN VARCHAR2,
                         prep_refcursor IN OUT rep_refcursor) IS
    --ќтчет по операци€м
    tname_  VARCHAR2(20);
    sqlstr1 VARCHAR2(50);
  BEGIN
/*    IF var_ = 1 THEN
      --ѕо самосто€тельным
      sqlstr1 := ' and t.var in (1)';
    ELSIF var_ = 2 THEN
      --ѕо не самосто€тельным
      sqlstr1 := ' and t.var in (0)';
    ELSE
      --ѕо всем
      sqlstr1 := '';
    END IF;
*/
    IF type_ = 0 THEN
      --ѕо инкассаци€м
      tname_ := 'xito5';
    ELSE
      --ƒл€ оборотной
      tname_ := 'xito5_';
    END IF;

    IF trest_ IS NOT NULL THEN
      --ѕо трестам
      IF dat_ IS NOT NULL AND dat1_ IS NOT NULL THEN
        OPEN prep_refcursor FOR 'SELECT SUM(a.ska) AS ska, SUM(a.pn) AS pn, r.name as nm, s.name_tr as name, a.other, a.nal, a.ink, o.naim
       FROM ' || tname_ || ' a, S_REU_TREST s, OPER o, ORG r, (SELECT DISTINCT reu,var FROM s_reu_trest) t WHERE a.dat BETWEEN :dat_ AND :dat1_ AND s.trest=:trest_
       AND a.reu=s.reu AND a.OPER=o.OPER AND r.id=2 AND s.reu=t.reu ' || sqlstr1 || '
       GROUP BY r.name, s.name_tr, a.other, a.nal, a.ink, o.naim'
          USING dat_, dat1_, trest_;
      ELSIF mg_ IS NOT NULL AND mg1_ IS NOT NULL THEN
        OPEN prep_refcursor FOR 'SELECT SUM(a.ska) AS ska, SUM(a.pn) AS pn, r.name as nm, s.name_tr as name, a.other, a.nal, a.ink, o.naim
       FROM ' || tname_ || ' a, S_REU_TREST s, OPER o, ORG r, (SELECT DISTINCT reu,var FROM s_reu_trest) t WHERE a.mg BETWEEN :mg_ AND :mg1_ AND s.trest=:trest_
       AND a.reu=s.reu AND a.OPER=o.OPER AND r.id=2 AND s.reu=t.reu ' || sqlstr1 || '
       GROUP BY r.name, s.name_tr, a.other, a.nal, a.ink, o.naim'
          USING mg_, mg1_, trest_;
      END IF;
    ELSIF reu_ IS NOT NULL THEN
      --ѕо –Ё”
      IF dat_ IS NOT NULL AND dat1_ IS NOT NULL THEN
        OPEN prep_refcursor FOR 'SELECT SUM(a.ska) AS ska, SUM(a.pn) AS pn, r.name as nm, s.name_reu as name, a.other, a.nal, a.ink, o.naim
       FROM ' || tname_ || ' a, S_REU_TREST s, OPER o, ORG r, (SELECT DISTINCT reu,var FROM s_reu_trest) t WHERE a.dat BETWEEN :dat_ AND :dat1_ AND a.reu=:reu_
       AND a.reu=s.reu AND a.OPER=o.OPER AND r.id=3 AND s.reu=t.reu ' || sqlstr1 || '
       GROUP BY r.name, s.name_reu, a.other, a.nal, a.ink, o.naim'
          USING dat_, dat1_, reu_;
      ELSIF mg_ IS NOT NULL AND mg1_ IS NOT NULL THEN
        OPEN prep_refcursor FOR 'SELECT SUM(a.ska) AS ska, SUM(a.pn) AS pn, r.name as nm, s.name_reu as name, a.other, a.nal, a.ink, o.naim
       FROM ' || tname_ || ' a, S_REU_TREST s, OPER o, ORG r, (SELECT DISTINCT reu,var FROM s_reu_trest) t WHERE a.mg BETWEEN :mg_ AND :mg1_ AND a.reu=:reu_
       AND a.reu=s.reu AND a.OPER=o.OPER AND r.id=3 AND s.reu=t.reu ' || sqlstr1 || '
       GROUP BY r.name, s.name_reu, a.other, a.nal, a.ink, o.naim'
          USING mg_, mg1_, reu_;
      END IF;
    ELSE
      --ѕо всем ∆Ёќ
      IF dat_ IS NOT NULL AND dat1_ IS NOT NULL THEN
        OPEN prep_refcursor FOR 'SELECT SUM(a.ska) AS ska, SUM(a.pn) AS pn, r.name as nm, r1.name as nm1, s.name_tr as name, a.other, a.nal, a.ink, o.naim
       FROM ' || tname_ || ' a, S_REU_TREST s, OPER o, ORG r, ORG r1, (SELECT DISTINCT reu,var FROM s_reu_trest) t WHERE a.dat BETWEEN :dat_ AND :dat1_
       AND a.reu=s.reu AND a.OPER=o.OPER AND r.id=2 AND r1.id=1 AND s.reu=t.reu ' || sqlstr1 || '
       GROUP BY r.name, r1.name, s.trest, s.name_tr, a.other, a.nal, a.ink, o.naim
       ORDER BY s.trest'
          USING dat_, dat1_;
      ELSIF mg_ IS NOT NULL AND mg1_ IS NOT NULL THEN
        OPEN prep_refcursor FOR 'SELECT SUM(a.ska) AS ska, SUM(a.pn) AS pn, r.name as nm, r1.name as nm1, s.name_tr as name, a.other, a.nal, a.ink, o.naim
       FROM ' || tname_ || ' a, S_REU_TREST s, OPER o, ORG r, ORG r1, (SELECT DISTINCT reu,var FROM s_reu_trest) t WHERE a.mg BETWEEN :mg_ AND :mg1_
       AND a.reu=s.reu AND a.OPER=o.OPER AND r.id=2 AND r1.id=1 AND s.reu=t.reu ' || sqlstr1 || '
       GROUP BY r.name, r1.name, s.trest, s.name_tr, a.other, a.nal, a.ink, o.naim
       ORDER BY s.trest'
          USING mg_, mg1_;
      END IF;
    END IF;

  END report_xito5;

  PROCEDURE report_xito5_itog(var_           IN NUMBER,
                              type_          IN NUMBER,
                              dat_           IN XITO5.dat%TYPE,
                              dat1_          IN XITO5.dat%TYPE,
                              mg_            IN VARCHAR2,
                              mg1_           IN VARCHAR2,
                              prep_refcursor IN OUT rep_refcursor) IS
    --ќтчет по операци€м (итоги)
    tname_  VARCHAR2(20);
    sqlstr1 VARCHAR2(50);
  BEGIN
/*    IF var_ = 1 THEN
      --ѕо самосто€тельным
      sqlstr1 := ' and t.var in (1)';
    ELSIF var_ = 2 THEN
      --ѕо не самосто€тельным
      sqlstr1 := ' and t.var in (0)';
    ELSE
      --ѕо всем
      sqlstr1 := '';
    END IF;*/

    IF type_ = 0 THEN
      --ѕо инкассаци€м
      tname_ := 'xito5';
    ELSE
      --ƒл€ оборотной
      tname_ := 'xito5_';
    END IF;

    IF dat_ IS NOT NULL AND dat1_ IS NOT NULL THEN
      OPEN prep_refcursor FOR 'SELECT SUM(a.ska) AS ska, SUM(a.pn) AS pn, a.other, a.nal, a.ink, o.naim
       FROM ' || tname_ || ' a, S_REU_TREST s, (SELECT DISTINCT reu,var FROM s_reu_trest) t, OPER o WHERE a.dat BETWEEN :dat_ AND :dat1_
       AND a.reu=s.reu AND a.OPER=o.OPER AND s.reu=t.reu ' || sqlstr1 || '
       GROUP BY a.other, a.nal, a.ink, o.naim'
        USING dat_, dat1_;
    ELSIF mg_ IS NOT NULL AND mg1_ IS NOT NULL THEN
      OPEN prep_refcursor FOR 'SELECT SUM(a.ska) AS ska, SUM(a.pn) AS pn, a.other, a.nal, a.ink, o.naim
       FROM ' || tname_ || ' a, S_REU_TREST s, (SELECT DISTINCT reu,var FROM s_reu_trest) t, OPER o WHERE a.mg BETWEEN :mg_ AND :mg1_
       AND a.reu=s.reu AND a.OPER=o.OPER AND s.reu=t.reu ' || sqlstr1 || '
       GROUP BY a.other, a.nal, a.ink, o.naim'
        USING mg_, mg1_;
    END IF;

  END report_xito5_itog;
END rep_opl;
/

prompt
prompt Creating package body REP_SALDO
prompt ===============================
prompt
CREATE OR REPLACE PACKAGE BODY SCOTT.rep_saldo IS
  PROCEDURE report_saldo(reu_           IN VARCHAR2,
                         trest_         IN VARCHAR2,
                         uslm_         IN VARCHAR2,
                         mg_            IN VARCHAR2,
                         mg1_           IN VARCHAR2,
                         var_         IN NUMBER,
                         prep_refcursor IN OUT rep_refcursor) IS
    --ќборотка по –Ё”/домам
 sql_ varchar2(200);
  BEGIN
  if uslm_ ='000' then
     sql_:='';
  else
     sql_:=' and u.uslm = '''||uslm_||'''';
  end if;

    IF var_ = 4 THEN
      --по дому
      OPEN prep_refcursor FOR 'select null as predpr, h.name_reu||'' ''||p.name||'', ''||ltrim(h.nd,''0'') as adr, sum(i.indebet) as indebet, sum(i.inkredit) as inkredit,
      sum(o.charges) as charges, sum(o.changes) as changes, sum(o.subsid) as subsid, sum(o.privs) as privs, sum(o.privs_city) as privs_city, sum(o.payment) as payment,
      sum(o.ch_full) as ch_full, sum(o.changes2) as changes2, sum(o.changes+o.changes2) as changesall,
      sum(o.pn) as pn, sum(u.outdebet) as outdebet, sum(u.outkredit) as outkredit
      from
      (select u.*, trim(s.name_reu) as name_reu from t_saldo_reu_kul_nd_st u, s_reu_trest s
      where u.reu=s.reu and exists (select * from list_choices t
      where t.reu=u.reu and u.kul=t.kul and u.nd=t.nd and t.sel = 0)
       '||sql_||') h,
      (select * from xitog3 e where e.mg=:mg_) i,
      (select reu,kul,nd,org,usl,status,sum(charges) as charges,
      sum(changes) as changes, sum(subsid) as subsid, sum(privs) as privs, sum(privs_city) as privs_city,
      sum(ch_full) as ch_full, sum(changes2) as changes2, sum(payment) as payment, sum(pn) as pn from xitog3 t
      where t.mg between :mg_ and :mg1_
      group by reu,kul,nd,org,usl,status) o,
      (select * from xitog3 e where e.mg=:mg1_) u,
      sprorg d, uslm m, org l, spul p
      where h.kul=p.id and
      h.reu=i.reu(+) and h.kul=i.kul(+) and h.nd=i.nd(+) and h.org=i.org(+) and h.usl=i.usl(+) and h.status=i.status(+) and
      h.reu=o.reu(+) and h.kul=o.kul(+) and h.nd=o.nd(+) and h.org=o.org(+) and h.usl=o.usl(+) and h.status=o.status(+) and
      h.reu=u.reu(+) and h.kul=u.kul(+) and h.nd=u.nd(+) and h.org=u.org(+) and h.usl=u.usl(+) and h.status=u.status(+) and
      l.id=3 and h.org=d.kod and h.uslm=m.uslm
      group by h.name_reu||'' ''||p.name||'', ''||ltrim(h.nd,''0'')
      having sum(i.indebet) <>0 or sum(i.inkredit) <>0 or
      sum(o.charges) <>0 or sum(o.changes) <>0 or sum(o.subsid) <>0 or
      sum(o.privs) <>0 or sum(o.privs_city) <>0 or sum(o.payment) <>0 or
      sum(o.pn) <>0 or sum(u.outdebet) <>0 or sum(u.outkredit) <>0
      order by h.name_reu||'' ''||p.name||'', ''||ltrim(h.nd,''0'')'
          USING mg_, mg_, mg1_, mg1_;
    ELSIF var_ = 3 THEN
      --по ∆Ёќ
      OPEN prep_refcursor FOR 'select l.name||h.name_reu as predpr, p.name||'', ''||ltrim(h.nd,''0'') as adr, sum(i.indebet) as indebet, sum(i.inkredit) as inkredit,
      sum(o.charges) as charges, sum(o.changes) as changes, sum(o.subsid) as subsid, sum(o.privs) as privs, sum(o.privs_city) as privs_city, sum(o.payment) as payment,
      sum(o.ch_full) as ch_full, sum(o.changes2) as changes2, sum(o.changes+o.changes2) as changesall,
      sum(o.pn) as pn, sum(u.outdebet) as outdebet, sum(u.outkredit) as outkredit
      from
      (select u.*, trim(s.name_reu) as name_reu from t_saldo_reu_kul_nd_st u, s_reu_trest s
      where u.reu=:reu_ and u.reu=s.reu '||sql_||') h,
      (select * from xitog3 e where e.mg=:mg_) i,
      (select reu,kul,nd,org,usl,status,sum(charges) as charges,
      sum(changes) as changes, sum(subsid) as subsid, sum(privs) as privs, sum(privs_city) as privs_city,
      sum(ch_full) as ch_full, sum(changes2) as changes2, sum(payment) as payment, sum(pn) as pn from xitog3 t
      where t.mg between :mg_ and :mg1_
      group by reu,kul,nd,org,usl,status) o,
      (select * from xitog3 e where e.mg=:mg1_) u,
      sprorg d, uslm m, org l, spul p
      where h.kul=p.id and
      h.reu=i.reu(+) and h.kul=i.kul(+) and h.nd=i.nd(+) and h.org=i.org(+) and h.usl=i.usl(+) and h.status=i.status(+) and
      h.reu=o.reu(+) and h.kul=o.kul(+) and h.nd=o.nd(+) and h.org=o.org(+) and h.usl=o.usl(+) and h.status=o.status(+) and
      h.reu=u.reu(+) and h.kul=u.kul(+) and h.nd=u.nd(+) and h.org=u.org(+) and h.usl=u.usl(+) and h.status=u.status(+) and
      l.id=3 and h.org=d.kod and h.uslm=m.uslm
      group by l.name||h.name_reu, p.name||'', ''||ltrim(h.nd,''0'')
      having sum(i.indebet) <>0 or sum(i.inkredit) <>0 or
      sum(o.charges) <>0 or sum(o.changes) <>0 or sum(o.subsid) <>0 or
      sum(o.privs) <>0 or sum(o.privs_city) <>0 or sum(o.payment) <>0 or
      sum(o.pn) <>0 or sum(u.outdebet) <>0 or sum(u.outkredit) <>0
      order by  l.name||h.name_reu, p.name||'', ''||ltrim(h.nd,''0'')'
          USING reu_, mg_, mg_, mg1_, mg1_;
    ELSIF var_ = 2  THEN
      --по ‘онду
      OPEN prep_refcursor FOR 'select l.name||t.name_tr as predpr, p.name||'', ''||ltrim(h.nd,''0'') as adr, sum(i.indebet) as indebet, sum(i.inkredit) as inkredit,
      sum(o.charges) as charges, sum(o.changes) as changes, sum(o.subsid) as subsid, sum(o.privs) as privs, sum(o.privs_city) as privs_city, sum(o.payment) as payment,
      sum(o.ch_full) as ch_full, sum(o.changes2) as changes2, sum(o.changes+o.changes2) as changesall,
      sum(o.pn) as pn, sum(u.outdebet) as outdebet, sum(u.outkredit) as outkredit
      from
      (select u.* from t_saldo_reu_kul_nd_st u, s_reu_trest s
      where u.reu=s.reu and s.trest=:trest_ '||sql_||') h,
      (select * from xitog3 e where e.mg=:mg_) i,
      (select reu,kul,nd,org,usl,status,sum(charges) as charges,
      sum(changes) as changes, sum(subsid) as subsid, sum(privs) as privs, sum(privs_city) as privs_city,
      sum(ch_full) as ch_full, sum(changes2) as changes2, sum(payment) as payment, sum(pn) as pn from xitog3 t
      where t.mg between :mg_ and :mg1_
      group by reu,kul,nd,org,usl,status) o,
      (select * from xitog3 e where e.mg=:mg1_) u,
      sprorg d, uslm m, org l, spul p, s_reu_trest t
      where h.kul=p.id and h.reu=t.reu and
      h.reu=i.reu(+) and h.kul=i.kul(+) and h.nd=i.nd(+) and h.org=i.org(+) and h.usl=i.usl(+) and h.status=i.status(+) and
      h.reu=o.reu(+) and h.kul=o.kul(+) and h.nd=o.nd(+) and h.org=o.org(+) and h.usl=o.usl(+) and h.status=o.status(+) and
      h.reu=u.reu(+) and h.kul=u.kul(+) and h.nd=u.nd(+) and h.org=u.org(+) and h.usl=u.usl(+) and h.status=u.status(+) and
      l.id=2 and h.org=d.kod and h.uslm=m.uslm
      group by l.name||t.name_tr, p.name||'', ''||ltrim(h.nd,''0'')
      having sum(i.indebet) <>0 or sum(i.inkredit) <>0 or
      sum(o.charges) <>0 or sum(o.changes) <>0 or sum(o.subsid) <>0 or
      sum(o.privs) <>0 or sum(o.privs_city) <>0 or sum(o.payment) <>0 or
      sum(o.pn) <>0 or sum(u.outdebet) <>0 or sum(u.outkredit) <>0
      order by l.name||t.name_tr, p.name||'', ''||ltrim(h.nd,''0'')'
          USING trest_, mg_, mg_, mg1_, mg1_;
    ELSIF var_ = 1 THEN
      --по √ороду
      OPEN prep_refcursor FOR 'select l.name as predpr, p.name||'', ''||ltrim(h.nd,''0'') as adr, sum(i.indebet) as indebet, sum(i.inkredit) as inkredit,
      sum(o.charges) as charges, sum(o.pcharges) as pcharges, sum(o.changes) as changes, sum(o.subsid) as subsid, sum(o.privs) as privs, sum(o.privs_city) as privs_city, sum(o.payment) as payment,
      sum(o.ch_full) as ch_full, sum(o.changes2) as changes2, sum(o.changes+o.changes2) as changesall,
      sum(o.pn) as pn, sum(u.outdebet) as outdebet, sum(u.outkredit) as outkredit
      from
      (select u.* from t_saldo_reu_kul_nd_st u
      where u.uslm is not null '||sql_||') h,
      (select * from xitog3 e where e.mg=:mg_) i,
      (select reu,kul,nd,org,usl,status, sum(charges) as charges, sum(pcharges) as pcharges,
      sum(changes) as changes, sum(subsid) as subsid, sum(privs) as privs, sum(privs_city) as privs_city,
      sum(ch_full) as ch_full, sum(changes2) as changes2, sum(payment) as payment, sum(pn) as pn from xitog3 t
      where t.mg between :mg_ and :mg1_
      group by reu,kul,nd,org,usl,status) o,
      (select * from xitog3 e where e.mg=:mg1_) u,
      sprorg d, uslm m, org l, spul p
      where h.kul=p.id and
      h.reu=i.reu(+) and h.kul=i.kul(+) and h.nd=i.nd(+) and h.org=i.org(+) and h.usl=i.usl(+) and h.status=i.status(+) and
      h.reu=o.reu(+) and h.kul=o.kul(+) and h.nd=o.nd(+) and h.org=o.org(+) and h.usl=o.usl(+) and h.status=o.status(+) and
      h.reu=u.reu(+) and h.kul=u.kul(+) and h.nd=u.nd(+) and h.org=u.org(+) and h.usl=u.usl(+) and h.status=u.status(+) and
      l.id=1 and h.org=d.kod and h.uslm=m.uslm
      group by l.name, p.name||'', ''||ltrim(h.nd,''0'')
      having sum(i.indebet) <>0 or sum(i.inkredit) <>0 or
      sum(o.charges) <>0 or sum(o.changes) <>0 or sum(o.subsid) <>0 or
      sum(o.privs) <>0 or sum(o.privs_city) <>0 or sum(o.payment) <>0 or
      sum(o.pn) <>0 or sum(u.outdebet) <>0 or sum(u.outkredit) <>0
      order by l.name, p.name||'', ''||ltrim(h.nd,''0'')'
          USING mg_, mg_, mg1_, mg1_;
     END IF;
  END report_saldo;

  PROCEDURE report_saldo_org_uslm(reu_           IN VARCHAR2,
                                  trest_         IN VARCHAR2,
                                  mg_            IN VARCHAR2,
                                  mg1_           IN VARCHAR2,
                                  kul_           IN VARCHAR2,
                                  nd_            IN VARCHAR2,
                                  var_           IN NUMBER,
                                  prep_refcursor IN OUT rep_refcursor) IS
    --ќборотка по предпри€ти€м - услугам
  BEGIN
    IF reu_ IS NOT NULL AND kul_ IS NULL AND nd_ IS NULL THEN
    -- ѕо ∆Ёќ
      OPEN prep_refcursor FOR 'select d.npp, l.name||h.name_reu as predpr,null as type, to_char(d.kod)||'' ''||d.name as org, to_char(h.uslm)||'' ''||decode(m.frc_get_price,1,m.nm,m.nm1) as nm1, sum(i.indebet) as indebet, sum(i.inkredit) as inkredit,
      sum(o.charges) as charges, sum(o.changes) as changes, sum(o.subsid) as subsid, sum(o.privs) as privs, sum(o.privs_city) as privs_city, sum(o.payment) as payment,
      sum(o.ch_full) as ch_full, sum(o.changes2) as changes2, sum(o.changes+o.changes2) as changesall,
      sum(o.pn) as pn, sum(u.outdebet) as outdebet, sum(u.outkredit) as outkredit
      from
      (select e.*, s.name_reu from t_saldo_reu_kul_nd_st e, s_reu_trest s
      where e.reu=:reu_ and e.reu=s.reu) h,
      (select * from xitog3 e where e.mg=:mg_) i,
      (select reu,kul,nd,org,usl,status,sum(charges) as charges,
      sum(changes) as changes, sum(subsid) as subsid, sum(privs) as privs, sum(privs_city) as privs_city,
      sum(ch_full) as ch_full, sum(changes2) as changes2, sum(changes+changes2) as changesall,
       sum(payment) as payment, sum(pn) as pn from xitog3 t
      where t.mg between :mg_ and :mg1_
      group by reu,kul,nd,org,usl,status) o,
      (select * from xitog3 e where e.mg=:mg1_) u,
      sprorg d, usl m, org l
      where
      h.reu=i.reu(+) and h.kul=i.kul(+) and h.nd=i.nd(+) and h.org=i.org(+) and h.usl=i.usl(+) and h.status=i.status(+) and
      h.reu=o.reu(+) and h.kul=o.kul(+) and h.nd=o.nd(+) and h.org=o.org(+) and h.usl=o.usl(+) and h.status=o.status(+) and
      h.reu=u.reu(+) and h.kul=u.kul(+) and h.nd=u.nd(+) and h.org=u.org(+) and h.usl=u.usl(+) and h.status=u.status(+) and
      l.id=3 and h.org=d.kod and h.usl=m.usl
      group by d.npp, l.name||h.name_reu, to_char(d.kod)||'' ''||d.name, to_char(h.uslm)||'' ''||decode(m.frc_get_price,1,m.nm,m.nm1)
      having sum(i.indebet) <>0 or sum(i.inkredit) <>0 or
      sum(o.charges) <>0 or sum(o.changes) <>0 or sum(o.subsid) <>0 or
      sum(o.privs) <>0 or sum(o.privs_city) <>0 or sum(o.payment) <>0 or
      sum(o.pn) <>0 or sum(u.outdebet) <>0 or sum(u.outkredit) <>0
      order by d.npp'
        USING reu_, mg_, mg_, mg1_, mg1_;
    ELSIF trest_ IS NOT NULL THEN
    -- ѕо ‘онду
      OPEN prep_refcursor FOR 'select d.npp,l.name||h.name_tr as predpr, null as type, to_char(d.kod)||'' ''||d.name as org, to_char(h.uslm)||'' ''||decode(m.frc_get_price,1,m.nm,m.nm1) as nm1, sum(i.indebet) as indebet, sum(i.inkredit) as inkredit,
      sum(o.charges) as charges, sum(o.changes) as changes, sum(o.subsid) as subsid, sum(o.privs) as privs, sum(o.privs_city) as privs_city, sum(o.payment) as payment,
      sum(o.ch_full) as ch_full, sum(o.changes2) as changes2, sum(o.changes+o.changes2) as changesall,
      sum(o.pn) as pn, sum(u.outdebet) as outdebet, sum(u.outkredit) as outkredit
      from
      (select e.*, s.trest, s.name_tr from t_saldo_reu_kul_nd_st e, s_reu_trest s
        where s.trest=:trest_ and e.reu=s.reu) h,
      (select * from xitog3 e where e.mg=:mg_) i,
      (select reu,kul,nd,org,usl,status,sum(charges) as charges,
      sum(changes) as changes, sum(subsid) as subsid, sum(privs) as privs, sum(privs_city) as privs_city,
      sum(ch_full) as ch_full, sum(changes2) as changes2, sum(payment) as payment, sum(pn) as pn from xitog3 t
      where t.mg between :mg_ and :mg1_
      group by reu,kul,nd,org,usl,status) o,
      (select * from xitog3 e where e.mg=:mg1_) u,
      sprorg d, usl m, org l
      where
      h.reu=i.reu(+) and h.kul=i.kul(+) and h.nd=i.nd(+) and h.org=i.org(+) and h.usl=i.usl(+) and h.status=i.status(+) and
      h.reu=o.reu(+) and h.kul=o.kul(+) and h.nd=o.nd(+) and h.org=o.org(+) and h.usl=o.usl(+) and h.status=o.status(+) and
      h.reu=u.reu(+) and h.kul=u.kul(+) and h.nd=u.nd(+) and h.org=u.org(+) and h.usl=u.usl(+) and h.status=u.status(+) and
      l.id=2 and h.org=d.kod and h.usl=m.usl
      group by d.npp, l.name||h.name_tr, to_char(d.kod)||'' ''||d.name, to_char(h.uslm)||'' ''||decode(m.frc_get_price,1,m.nm,m.nm1)
      having sum(i.indebet) <>0 or sum(i.inkredit) <>0 or
      sum(o.charges) <>0 or sum(o.changes) <>0 or sum(o.subsid) <>0 or
      sum(o.privs) <>0 or sum(o.privs_city) <>0 or sum(o.payment) <>0 or
      sum(o.pn) <>0 or sum(u.outdebet) <>0 or sum(u.outkredit) <>0
      order by d.npp'
        USING trest_, mg_, mg_, mg1_, mg1_;
    ELSIF reu_ IS NULL AND trest_ IS NULL THEN
    -- ѕо √ороду
      OPEN prep_refcursor FOR 'select d.npp, l.name as predpr,null as type, to_char(d.kod)||'' ''||d.name as org, to_char(h.uslm)||'' ''||decode(m.frc_get_price,1,m.nm,m.nm1) as nm1, sum(i.indebet) as indebet, sum(i.inkredit) as inkredit,
      sum(o.charges) as charges, sum(o.changes) as changes, sum(o.subsid) as subsid, sum(o.privs) as privs, sum(o.privs_city) as privs_city, sum(o.payment) as payment,
      sum(o.ch_full) as ch_full, sum(o.changes2) as changes2, sum(o.changes+o.changes2) as changesall,
      sum(o.pn) as pn, sum(u.outdebet) as outdebet, sum(u.outkredit) as outkredit
      from
      (select e.*, s.trest from t_saldo_reu_kul_nd_st e, s_reu_trest s where e.reu=s.reu) h,
      (select * from xitog3 e where e.mg=:mg_) i,
      (select reu,kul,nd,org,usl,status,sum(charges) as charges,
      sum(changes) as changes, sum(subsid) as subsid, sum(privs) as privs, sum(privs_city) as privs_city,
      sum(ch_full) as ch_full, sum(changes2) as changes2, sum(payment) as payment, sum(pn) as pn from xitog3 t
      where t.mg between :mg_ and :mg1_
      group by reu,kul,nd,org,usl,status) o,
      (select * from xitog3 e where e.mg=:mg1_) u,
      sprorg d, usl m, org l
      where
      h.reu=i.reu(+) and h.kul=i.kul(+) and h.nd=i.nd(+) and h.org=i.org(+) and h.usl=i.usl(+) and h.status=i.status(+) and
      h.reu=o.reu(+) and h.kul=o.kul(+) and h.nd=o.nd(+) and h.org=o.org(+) and h.usl=o.usl(+) and h.status=o.status(+) and
      h.reu=u.reu(+) and h.kul=u.kul(+) and h.nd=u.nd(+) and h.org=u.org(+) and h.usl=u.usl(+) and h.status=u.status(+) and
      l.id=1 and h.org=d.kod and h.usl=m.usl
      group by d.npp, l.name, to_char(d.kod)||'' ''||d.name, to_char(h.uslm)||'' ''||decode(m.frc_get_price,1,m.nm,m.nm1)
      having sum(i.indebet) <>0 or sum(i.inkredit) <>0 or
      sum(o.charges) <>0 or sum(o.changes) <>0 or sum(o.subsid) <>0 or
      sum(o.privs) <>0 or sum(o.privs_city) <>0 or sum(o.payment) <>0 or
      sum(o.pn) <>0 or sum(u.outdebet) <>0 or sum(u.outkredit) <>0
      order by d.npp'
        USING mg_, mg_, mg1_, mg1_;
    ELSIF reu_ IS NOT NULL AND kul_ IS NOT NULL AND nd_ IS NOT NULL THEN
    -- ѕо выбранному дому
      OPEN prep_refcursor FOR 'select d.npp, h.name_reu||'' ''||l.name||h.name||'', ''||ltrim(h.nd,''0'') as predpr,
      null as type, to_char(d.kod)||'' ''||d.name as org, to_char(h.uslm)||'' ''||decode(m.frc_get_price,1,m.nm,m.nm1) as nm1,
      sum(i.indebet) as indebet, sum(i.inkredit) as inkredit,
      sum(o.charges) as charges, sum(o.changes) as changes, sum(o.subsid) as subsid, sum(o.privs) as privs, sum(o.privs_city) as privs_city, sum(o.payment) as payment,
      sum(o.ch_full) as ch_full, sum(o.changes2) as changes2, sum(o.changes+o.changes2) as changesall,
      sum(o.pn) as pn, sum(u.outdebet) as outdebet, sum(u.outkredit) as outkredit
      from
      (
      select e.*, trim(t.name_reu) as name_reu, s.name from t_saldo_reu_kul_nd_st e, s_reu_trest t, spul s
      where e.reu=t.reu and exists (select * from list_choices l
      where l.reu=e.reu and l.kul=e.kul and l.nd=e.nd and l.sel=0)
      and e.kul=s.id) h,
      (select * from xitog3 e where e.mg=:mg_) i,
      (select reu,kul,nd,org,usl,status,sum(charges) as charges,
      sum(changes) as changes, sum(subsid) as subsid, sum(privs) as privs, sum(privs_city) as privs_city,
      sum(ch_full) as ch_full, sum(changes2) as changes2, sum(payment) as payment, sum(pn) as pn from xitog3 t
      where t.mg between :mg_ and :mg1_
      group by reu,kul,nd,org,usl,status) o,
      (select * from xitog3 e where e.mg=:mg1_) u,
      sprorg d, usl m, org l
      where
      h.reu=i.reu(+) and h.kul=i.kul(+) and h.nd=i.nd(+) and h.org=i.org(+) and h.usl=i.usl(+) and h.status=i.status(+) and
      h.reu=o.reu(+) and h.kul=o.kul(+) and h.nd=o.nd(+) and h.org=o.org(+) and h.usl=o.usl(+) and h.status=o.status(+) and
      h.reu=u.reu(+) and h.kul=u.kul(+) and h.nd=u.nd(+) and h.org=u.org(+) and h.usl=u.usl(+) and h.status=u.status(+) and
      l.id=4 and h.org=d.kod and h.usl=m.usl
      group by d.npp, h.name_reu||'' ''||l.name||h.name||'', ''||ltrim(h.nd,''0''),
      to_char(d.kod)||'' ''||d.name, to_char(h.uslm)||'' ''||decode(m.frc_get_price,1,m.nm,m.nm1)
      having sum(i.indebet) <>0 or sum(i.inkredit) <>0 or
      sum(o.charges) <>0 or sum(o.changes) <>0 or sum(o.subsid) <>0 or
      sum(o.privs) <>0 or sum(o.privs_city) <>0 or sum(o.payment) <>0 or
      sum(o.pn) <>0 or sum(u.outdebet) <>0 or sum(u.outkredit) <>0
      order by h.name_reu||'' ''||l.name||h.name||'', ''||ltrim(h.nd,''0''), d.npp'
        USING  mg_, mg_, mg1_, mg1_;
  END IF;
  END report_saldo_org_uslm;

  PROCEDURE report_saldo_uslm2(reu_           IN VARCHAR2,
                               trest_         IN VARCHAR2,
                               mg_            IN VARCHAR2,
                               mg1_           IN VARCHAR2,
                               kul_           IN VARCHAR2,
                               nd_            IN VARCHAR2,
                               uch_           IN NUMBER,
                               var_            IN NUMBER,
                               prep_refcursor IN OUT rep_refcursor) IS
    --ќборотка по услугам
  BEGIN
    -- ѕо ∆Ёќ
    IF reu_ IS NOT NULL AND kul_ IS NULL AND nd_ IS NULL THEN
      OPEN prep_refcursor FOR 'select l.name||h.name_reu as predpr, null as type, to_char(h.uslm)||'' ''||decode(m.frc_get_price,1,m.nm,m.nm1) as nm1, sum(i.indebet) as indebet, sum(i.inkredit) as inkredit,
      sum(o.charges) as charges, sum(o.changes) as changes, sum(o.subsid) as subsid, sum(o.privs) as privs, sum(o.privs_city) as privs_city, sum(o.payment) as payment,
      sum(o.ch_full) as ch_full, sum(o.changes2) as changes2, sum(o.changes+o.changes2) as changesall,
      sum(o.pn) as pn, sum(u.outdebet) as outdebet, sum(u.outkredit) as outkredit
      from
      (select e.*, s.name_reu from t_saldo_reu_kul_nd_st e, s_reu_trest s
      where e.reu=:reu_ and e.reu=s.reu) h,
      (select * from xitog3 e where e.mg=:mg_) i,
      (select reu,kul,nd,org,usl,status,sum(charges) as charges,
      sum(changes) as changes, sum(subsid) as subsid, sum(privs) as privs, sum(privs_city) as privs_city,
      sum(ch_full) as ch_full, sum(changes2) as changes2, sum(payment) as payment, sum(pn) as pn from xitog3 t
      where t.mg between :mg_ and :mg1_
      group by reu,kul,nd,org,usl,status) o,
      (select * from xitog3 e where e.mg=:mg1_) u,
      sprorg d, usl m, org l
      where
      h.reu=i.reu(+) and h.kul=i.kul(+) and h.nd=i.nd(+) and h.org=i.org(+) and h.usl=i.usl(+) and h.status=i.status(+) and
      h.reu=o.reu(+) and h.kul=o.kul(+) and h.nd=o.nd(+) and h.org=o.org(+) and h.usl=o.usl(+) and h.status=o.status(+) and
      h.reu=u.reu(+) and h.kul=u.kul(+) and h.nd=u.nd(+) and h.org=u.org(+) and h.usl=u.usl(+) and h.status=u.status(+) and
      l.id=3 and h.org=d.kod and h.usl=m.usl
      group by l.name||h.name_reu, to_char(h.uslm)||'' ''||decode(m.frc_get_price,1,m.nm,m.nm1)
      having sum(i.indebet) <>0 or sum(i.inkredit) <>0 or
      sum(o.charges) <>0 or sum(o.changes) <>0 or sum(o.subsid) <>0 or
      sum(o.privs) <>0 or sum(o.privs_city) <>0 or sum(o.payment) <>0 or
      sum(o.pn) <>0 or sum(u.outdebet) <>0 or sum(u.outkredit) <>0
      order by to_char(h.uslm)||'' ''||decode(m.frc_get_price,1,m.nm,m.nm1)'
        USING reu_, mg_, mg_, mg1_, mg1_;
    ELSIF trest_ IS NOT NULL THEN
    --ѕо ‘онду
      OPEN prep_refcursor FOR 'select l.name||h.name_tr as predpr, null as type, to_char(h.uslm)||'' ''||decode(m.frc_get_price,1,m.nm,m.nm1) as nm1,
      sum(i.indebet) as indebet, sum(i.inkredit) as inkredit,
      sum(o.charges) as charges, sum(o.changes) as changes, sum(o.subsid) as subsid, sum(o.privs) as privs, sum(o.privs_city) as privs_city, sum(o.payment) as payment,
      sum(o.ch_full) as ch_full, sum(o.changes2) as changes2, sum(o.changes+o.changes2) as changesall,
      sum(o.pn) as pn, sum(u.outdebet) as outdebet, sum(u.outkredit) as outkredit
      from
      (select e.*, s.trest, s.name_tr from t_saldo_reu_kul_nd_st e, s_reu_trest s where s.trest=:trest_ and e.reu=s.reu) h,
      (select * from xitog3 e where e.mg=:mg_) i,
      (select reu,kul,nd,org,usl,status,sum(charges) as charges,
      sum(changes) as changes, sum(subsid) as subsid, sum(privs) as privs, sum(privs_city) as privs_city,
      sum(ch_full) as ch_full, sum(changes2) as changes2, sum(payment) as payment, sum(pn) as pn from xitog3 t
      where t.mg between :mg_ and :mg1_
      group by reu,kul,nd,org,usl,status) o,
      (select * from xitog3 e where e.mg=:mg1_) u,
      sprorg d, usl m, org l
      where
      h.reu=i.reu(+) and h.kul=i.kul(+) and h.nd=i.nd(+) and h.org=i.org(+) and h.usl=i.usl(+) and h.status=i.status(+) and
      h.reu=o.reu(+) and h.kul=o.kul(+) and h.nd=o.nd(+) and h.org=o.org(+) and h.usl=o.usl(+) and h.status=o.status(+) and
      h.reu=u.reu(+) and h.kul=u.kul(+) and h.nd=u.nd(+) and h.org=u.org(+) and h.usl=u.usl(+) and h.status=u.status(+) and
      l.id=2 and h.org=d.kod and h.usl=m.usl
      group by l.name||h.name_tr, to_char(h.uslm)||'' ''||decode(m.frc_get_price,1,m.nm,m.nm1)
      having sum(i.indebet) <>0 or sum(i.inkredit) <>0 or
      sum(o.charges) <>0 or sum(o.changes) <>0 or sum(o.subsid) <>0 or
      sum(o.privs) <>0 or sum(o.privs_city) <>0 or sum(o.payment) <>0 or
      sum(o.pn) <>0 or sum(u.outdebet) <>0 or sum(u.outkredit) <>0
      order by to_char(h.uslm)||'' ''||decode(m.frc_get_price,1,m.nm,m.nm1)'
        USING trest_, mg_, mg_, mg1_, mg1_;
    -- ѕо √ороду
    ELSIF reu_ IS NULL AND trest_ IS NULL AND uch_ IS NULL THEN
      OPEN prep_refcursor FOR 'select l.name as predpr, null as type, to_char(h.uslm)||'' ''||decode(m.frc_get_price,1,m.nm,m.nm1) as nm1, sum(i.indebet) as indebet, sum(i.inkredit) as inkredit,
      sum(o.charges) as charges, sum(o.changes) as changes, sum(o.subsid) as subsid, sum(o.privs) as privs, sum(o.privs_city) as privs_city, sum(o.payment) as payment,
      sum(o.ch_full) as ch_full, sum(o.changes2) as changes2, sum(o.changes+o.changes2) as changesall,
      sum(o.pn) as pn, sum(u.outdebet) as outdebet, sum(u.outkredit) as outkredit
      from
      (select e.*, s.trest from t_saldo_reu_kul_nd_st e, s_reu_trest s where e.reu=s.reu) h,
      (select * from xitog3 e where e.mg=:mg_) i,
      (select reu,kul,nd,org,usl,status,sum(charges) as charges,
      sum(changes) as changes, sum(subsid) as subsid, sum(privs) as privs, sum(privs_city) as privs_city,
      sum(ch_full) as ch_full, sum(changes2) as changes2, sum(payment) as payment, sum(pn) as pn from xitog3 t
      where t.mg between :mg_ and :mg1_
      group by reu,kul,nd,org,usl,status) o,
      (select * from xitog3 e where e.mg=:mg1_) u,
      sprorg d, usl m, org l
      where
      h.reu=i.reu(+) and h.kul=i.kul(+) and h.nd=i.nd(+) and h.org=i.org(+) and h.usl=i.usl(+) and h.status=i.status(+) and
      h.reu=o.reu(+) and h.kul=o.kul(+) and h.nd=o.nd(+) and h.org=o.org(+) and h.usl=o.usl(+) and h.status=o.status(+) and
      h.reu=u.reu(+) and h.kul=u.kul(+) and h.nd=u.nd(+) and h.org=u.org(+) and h.usl=u.usl(+) and h.status=u.status(+) and
      l.id=1 and h.org=d.kod and h.usl=m.usl
      group by l.name, to_char(h.uslm)||'' ''||decode(m.frc_get_price,1,m.nm,m.nm1)
      having sum(i.indebet) <>0 or sum(i.inkredit) <>0 or
      sum(o.charges) <>0 or sum(o.changes) <>0 or sum(o.subsid) <>0 or
      sum(o.privs) <>0 or sum(o.privs_city) <>0 or sum(o.payment) <>0 or
      sum(o.pn) <>0 or sum(u.outdebet) <>0 or sum(u.outkredit) <>0
      order by to_char(h.uslm)||'' ''||decode(m.frc_get_price,1,m.nm,m.nm1)'
        USING mg_, mg_, mg1_, mg1_;
    -- ѕо выбранному дому
    ELSIF reu_ IS NOT NULL AND kul_ IS NOT NULL AND nd_ IS NOT NULL THEN
      OPEN prep_refcursor FOR 'select h.name_reu||'', по ''||l.name||h.name||'', ''||ltrim(h.nd,''0'') as predpr, null as type,
      to_char(h.uslm)||'' ''||decode(m.frc_get_price,1,m.nm,m.nm1) as nm1, sum(i.indebet) as indebet, sum(i.inkredit) as inkredit,
      h.reu, h.kul, h.nd,
      sum(o.charges) as charges, sum(o.changes) as changes, sum(o.subsid) as subsid, sum(o.privs) as privs, sum(o.privs_city) as privs_city, sum(o.payment) as payment,
      sum(o.ch_full) as ch_full, sum(o.changes2) as changes2, sum(o.changes+o.changes2) as changesall,
      sum(o.pn) as pn, sum(u.outdebet) as outdebet, sum(u.outkredit) as outkredit
      from (select e.*, trim(t.name_reu) as name_reu, s.name from t_saldo_reu_kul_nd_st e, s_reu_trest t, spul s
      where e.reu=t.reu and exists (select * from list_choices l
      where l.reu=e.reu and l.kul=e.kul and l.nd=e.nd and l.sel=0)
      and e.kul=s.id) h,
      (select * from xitog3 e where e.mg=:mg_) i,
      (select reu,kul,nd,org,usl,status,sum(charges) as charges,
      sum(changes) as changes, sum(subsid) as subsid, sum(privs) as privs, sum(privs_city) as privs_city,
      sum(ch_full) as ch_full, sum(changes2) as changes2, sum(payment) as payment, sum(pn) as pn from xitog3 t
      where t.mg between :mg_ and :mg1_
      group by reu,kul,nd,org,usl,status) o,
      (select * from xitog3 e where e.mg=:mg1_) u,
      sprorg d, usl m, org l
      where
      h.reu=i.reu(+) and h.kul=i.kul(+) and h.nd=i.nd(+) and h.org=i.org(+) and h.usl=i.usl(+) and h.status=i.status(+) and
      h.reu=o.reu(+) and h.kul=o.kul(+) and h.nd=o.nd(+) and h.org=o.org(+) and h.usl=o.usl(+) and h.status=o.status(+) and
      h.reu=u.reu(+) and h.kul=u.kul(+) and h.nd=u.nd(+) and h.org=u.org(+) and h.usl=u.usl(+) and h.status=u.status(+) and
      l.id=4 and h.org=d.kod and h.usl=m.usl
      group by h.name_reu||'', по ''||l.name||h.name||'', ''||ltrim(h.nd,''0''), to_char(h.uslm)||'' ''||decode(m.frc_get_price,1,m.nm,m.nm1), h.reu, h.kul, h.nd
      having sum(i.indebet) <>0 or sum(i.inkredit) <>0 or
      sum(o.charges) <>0 or sum(o.changes) <>0 or sum(o.subsid) <>0 or
      sum(o.privs) <>0 or sum(o.privs_city) <>0 or sum(o.payment) <>0 or
      sum(o.pn) <>0 or sum(u.outdebet) <>0 or sum(u.outkredit) <>0
      order by h.name_reu||'', по ''||l.name||h.name||'', ''||ltrim(h.nd,''0''), to_char(h.uslm)||'' ''||decode(m.frc_get_price,1,m.nm,m.nm1)'
        USING mg_, mg_, mg1_, mg1_;
    END IF;
  END report_saldo_uslm2;

  PROCEDURE report_saldo_org_uslm_itog(type_          IN NUMBER,
                                       reu_           IN VARCHAR2,
                                       trest_         IN VARCHAR2,
                                       uslk_          IN USLK.USLK%TYPE,
                                       mg_            IN VARCHAR2,
                                       mg1_           IN VARCHAR2,
                                       kul_           IN VARCHAR2,
                                       nd_            IN VARCHAR2,
                                       prep_refcursor IN OUT rep_refcursor) IS
    --—носка по отчету сальдо по предпри€ти€м, по услугам
    tname_ VARCHAR2(20);
  BEGIN
    IF type_ = 0 THEN
      tname_ := 'charges';
    ELSE
      tname_ := 'subsid';
    END IF;

    IF reu_ IS NOT NULL AND kul_ IS NULL AND nd_ IS NULL THEN
      OPEN prep_refcursor FOR 'select round(sum(t.' || tname_ || ' * a.summa/b.summa),2) as summa,round(sum(t.' || tname_ || '),2) as summa2, c.name
          FROM XITOG3 t,
          (SELECT p.mg, p.summa FROM PRICES_USLK p
          WHERE p.USLK=:uslk_) a,
          (SELECT p.mg, p.summa FROM PRICES_USLK p
          WHERE p.USLK=''001'') b, USLK c
          WHERE t.mg=a.mg AND t.mg=b.mg
          AND t.mg BETWEEN :mg_ AND :mg1_
          AND t.USLM=''002''
          AND c.USLK=:uslk_ AND t.reu=:reu_
          GROUP BY c.name'
        USING uslk_, mg_, mg1_, uslk_, reu_;
    ELSIF trest_ IS NOT NULL THEN
      OPEN prep_refcursor FOR 'select round(sum(t.' || tname_ || ' * a.summa/b.summa),2) as summa,round(sum(t.' || tname_ || '),2) as summa2, c.name
          FROM XITOG3 t, S_REU_TREST k,
          (SELECT p.mg, p.summa FROM PRICES_USLK p
          WHERE p.USLK=:uslk_) a,
          (SELECT p.mg, p.summa FROM PRICES_USLK p
          WHERE p.USLK=''001'') b, USLK c
          WHERE t.mg=a.mg AND t.mg=b.mg
          AND t.mg BETWEEN :mg_ AND :mg1_
          AND t.USLM=''002''
          AND c.USLK=:uslk_ AND t.reu=k.reu AND k.trest=:trest_
          GROUP BY c.name'
        USING uslk_, mg_, mg1_, uslk_, trest_;
    ELSIF reu_ IS NOT NULL AND kul_ IS NOT NULL AND nd_ IS NOT NULL THEN
      OPEN prep_refcursor FOR 'select round(sum(t.' || tname_ || ' * a.summa/b.summa),2) as summa,round(sum(t.' || tname_ || '),2) as summa2, c.name
          FROM XITOG3 t,
          (SELECT p.mg, p.summa FROM PRICES_USLK p
          WHERE p.USLK=:uslk_) a,
          (SELECT p.mg, p.summa FROM PRICES_USLK p
          WHERE p.USLK=''001'') b, USLK c
          WHERE t.mg=a.mg AND t.mg=b.mg
          AND t.mg BETWEEN :mg_ AND :mg1_
          AND t.USLM=''002''
          AND c.USLK=:uslk_ AND t.reu=:reu_ AND t.kul=:kul_ AND t.nd=:nd_
          GROUP BY c.name'
        USING uslk_, mg_, mg1_, uslk_, reu_, kul_, nd_;
    ELSE
      -- ѕо ћѕ ”≈«∆ ”
      OPEN prep_refcursor FOR 'select round(sum(t.' || tname_ || ' * a.summa/b.summa),2) as summa,round(sum(t.' || tname_ || '),2) as summa2, c.name
          FROM XITOG3 t,
          (SELECT p.mg, p.summa FROM PRICES_USLK p
          WHERE p.USLK=:uslk_) a,
          (SELECT p.mg, p.summa FROM PRICES_USLK p
          WHERE p.USLK=''001'') b, USLK c
          WHERE t.mg=a.mg AND t.mg=b.mg
          AND t.mg BETWEEN :mg_ AND :mg1_
          AND t.USLM=''002''
          AND c.USLK=:uslk_
          GROUP BY c.name'
        USING uslk_, mg_, mg1_, uslk_;
    END IF;
  END report_saldo_org_uslm_itog;

  PROCEDURE report_saldo_org_uslm_itog2(type_          IN NUMBER,
                                        reu_           IN VARCHAR2,
                                        trest_         IN VARCHAR2,
                                        uslk_          IN USLK.USLK%TYPE,
                                        mg_            IN VARCHAR2,
                                        mg1_           IN VARCHAR2,
                                        kul_           IN VARCHAR2,
                                        nd_            IN VARCHAR2,
                                        uch_           IN NUMBER,
                                        prep_refcursor IN OUT rep_refcursor) IS
    --—носка по отчету сальдо по предпри€ти€м, по услугам
    tname_ VARCHAR2(20);
  BEGIN
    IF type_ = 0 THEN
      tname_ := 'charges';
    ELSE
      tname_ := 'subsid';
    END IF;

    IF reu_ IS NOT NULL AND kul_ IS NULL AND nd_ IS NULL AND uch_ IS NULL THEN
      OPEN prep_refcursor FOR 'select round(sum(t.' || tname_ || ' * a.summa/b.summa),2) as summa,round(sum(t.' || tname_ || '),2) as summa2, c.name
          FROM XITOG3 t,
          (SELECT p.mg, p.summa FROM PRICES_USLK p
          WHERE p.USLK=:uslk_) a,
          (SELECT p.mg, p.summa FROM PRICES_USLK p
          WHERE p.USLK=''001'') b, USLK c
          WHERE t.mg=a.mg AND t.mg=b.mg
          AND t.mg BETWEEN :mg_ AND :mg1_
          AND t.USLM=''002''
          AND c.USLK=:uslk_ AND t.reu=:reu_
          GROUP BY c.name'
        USING uslk_, mg_, mg1_, uslk_, reu_;
    ELSIF trest_ IS NOT NULL AND uch_ IS NULL THEN
      OPEN prep_refcursor FOR 'select round(sum(t.' || tname_ || ' * a.summa/b.summa),2) as summa,round(sum(t.' || tname_ || '),2) as summa2, c.name
          FROM XITOG3 t, S_REU_TREST k,
          (SELECT p.mg, p.summa FROM PRICES_USLK p
          WHERE p.USLK=:uslk_) a,
          (SELECT p.mg, p.summa FROM PRICES_USLK p
          WHERE p.USLK=''001'') b, USLK c
          WHERE t.mg=a.mg AND t.mg=b.mg
          AND t.mg BETWEEN :mg_ AND :mg1_
          AND t.USLM=''002''
          AND c.USLK=:uslk_ AND t.reu=k.reu AND k.trest=:trest_
          GROUP BY c.name'
        USING uslk_, mg_, mg1_, uslk_, trest_;
    ELSIF reu_ IS NOT NULL AND kul_ IS NOT NULL AND nd_ IS NOT NULL AND
          uch_ IS NULL THEN
      OPEN prep_refcursor FOR 'select round(sum(t.' || tname_ || ' * a.summa/b.summa),2) as summa,
          ROUND(SUM(t.' || tname_ || '),2) AS summa2, c.name
          FROM XITOG3 t,
          (SELECT p.mg, p.summa FROM PRICES_USLK p
          WHERE p.USLK=:uslk_) a,
          (SELECT p.mg, p.summa FROM PRICES_USLK p
          WHERE p.USLK=''001'') b, USLK c
          WHERE t.mg=a.mg AND t.mg=b.mg
          AND t.mg BETWEEN :mg_ AND :mg1_
          AND t.USLM=''002''
          AND c.USLK=:uslk_ AND
          EXISTS (SELECT * FROM LIST_CHOICES l
               WHERE l.reu=t.reu AND l.kul=t.kul AND l.nd=t.nd AND l.sel=0)
          GROUP BY c.name'
        USING uslk_, mg_, mg1_, uslk_;
    ELSIF reu_ IS NOT NULL AND kul_ IS NOT NULL AND nd_ IS NOT NULL AND
          uch_ IS NOT NULL THEN
      OPEN prep_refcursor FOR 'select round(sum(t.' || tname_ || ' * a.summa/b.summa),2) as summa,
          ROUND(SUM(t.' || tname_ || '),2) AS summa2, c.name
          FROM XITOG3 t, KOOP_UCH k,
          (SELECT p.mg, p.summa FROM PRICES_USLK p
          WHERE p.USLK=:uslk_) a,
          (SELECT p.mg, p.summa FROM PRICES_USLK p
          WHERE p.USLK=''001'') b, USLK c
          WHERE t.mg=a.mg AND t.mg=b.mg
          AND t.mg BETWEEN :mg_ AND :mg1_
          AND t.USLM=''002''
          AND c.USLK=:uslk_ AND t.reu=k.reu AND t.kul=k.kul AND t.nd=k.nd AND
          EXISTS (SELECT * FROM LIST_CHOICES_UCH l
               WHERE l.reu=t.reu AND l.uch=k.uch AND l.sel=0)
          GROUP BY c.name'
        USING uslk_, mg_, mg1_, uslk_;
    ELSE
      -- ѕо ћѕ ”≈«∆ ”
      OPEN prep_refcursor FOR 'select round(sum(t.' || tname_ || ' * a.summa/b.summa),2) as summa,round(sum(t.' || tname_ || '),2) as summa2, c.name
          FROM XITOG3 t,
          (SELECT p.mg, p.summa FROM PRICES_USLK p
          WHERE p.USLK=:uslk_) a,
          (SELECT p.mg, p.summa FROM PRICES_USLK p
          WHERE p.USLK=''001'') b, USLK c
          WHERE t.mg=a.mg AND t.mg=b.mg
          AND t.mg BETWEEN :mg_ AND :mg1_
          AND t.USLM=''002''
          AND c.USLK=:uslk_
          GROUP BY c.name'
        USING uslk_, mg_, mg1_, uslk_;
    END IF;
  END report_saldo_org_uslm_itog2;

  PROCEDURE report_charges_usl(reu_           IN VARCHAR2,
                               trest_         IN VARCHAR2,
                               mg_            IN VARCHAR2,
                               mg1_           IN VARCHAR2,
                               var_           IN NUMBER,
                               type_           IN NUMBER,
                               det_           IN NUMBER,
                               prep_refcursor IN OUT rep_refcursor) IS
    --Ќачисление по услугам
  field_ VARCHAR2(20);
  BEGIN
  IF det_ = 0 THEN --Ѕез детализации
   IF var_ = 3 THEN --ѕо дому
      OPEN prep_refcursor FOR 'select ''–Ё”:''||x.reu||'' ''||s.name||'', ''||LTRIM(x.nd,''0'') as predpr,
             x.USL, SUBSTR(u.nm,1,15) AS nm, SUBSTR(u.nm1,1,15) AS nm1, SUM(x.summa) AS summa
             FROM XITO13 x, USL u, SPUL s
             WHERE x.mg BETWEEN :mg_ AND :mg1_ AND x.USL=u.USL AND x.kul=s.id
             AND EXISTS (SELECT * FROM LIST_CHOICES l
               WHERE l.reu=x.reu AND l.kul=x.kul AND l.nd=x.nd AND l.sel=0)
             GROUP BY ''–Ё”:''||x.reu||'' ''||s.name||'', ''||LTRIM(x.nd,''0''), x.USL, SUBSTR(u.nm,1,15), SUBSTR(u.nm1,1,15)'
        USING mg_, mg1_;
   ELSIF var_ = 2 THEN --ѕо –Ё”
      OPEN prep_refcursor FOR 'select s.name||'', ''||LTRIM(x.nd,''0'') as predpr,
             x.USL, SUBSTR(u.nm,1,15) AS nm, SUBSTR(u.nm1,1,15) AS nm1, SUM(x.summa) AS summa
             FROM XITO13 x, USL u, SPUL s
             WHERE x.reu=:reu_ AND x.mg BETWEEN :mg_ AND :mg1_ AND x.USL=u.USL AND x.kul=s.id
             GROUP BY s.name||'', ''||LTRIM(x.nd,''0''), x.USL, SUBSTR(u.nm,1,15), SUBSTR(u.nm1,1,15)'
        USING reu_, mg_, mg1_;
   ELSIF var_ = 1 THEN --ѕо ∆Ёќ
      OPEN prep_refcursor FOR 'select ''–Ё”:''||x.reu as predpr,
             x.USL, SUBSTR(u.nm,1,15) AS nm, SUBSTR(u.nm1,1,15) AS nm1, SUM(x.summa) AS summa
             FROM XITO13 x, USL u, SPUL s
             WHERE x.trest=:trest_ AND x.mg BETWEEN :mg_ AND :mg1_ AND x.USL=u.USL AND x.kul=s.id
             GROUP BY ''–Ё”:''||x.reu, x.USL, SUBSTR(u.nm,1,15), SUBSTR(u.nm1,1,15)'
        USING trest_, mg_, mg1_;
   ELSIF var_ = 0 THEN --ѕо ћѕ ”≈«∆ ” (все тресты)
      OPEN prep_refcursor FOR 'select ''∆Ёќ:''||t.name_tr as predpr,
             x.USL, SUBSTR(u.nm,1,15) AS nm, SUBSTR(u.nm1,1,15) AS nm1, SUM(x.summa) AS summa
             FROM XITO13 x, USL u, SPUL s, S_REU_TREST t
             WHERE x.mg BETWEEN :mg_ AND :mg1_ AND x.USL=u.USL AND x.kul=s.id
             AND x.trest= t.trest
             GROUP BY ''∆Ёќ:''||t.name_tr, x.USL, SUBSTR(u.nm,1,15), SUBSTR(u.nm1,1,15)'
        USING mg_, mg1_;
   END IF;
  ELSE
   IF type_ = 0 THEN
      field_:='charges';
   ELSIF type_ = 1 THEN
      field_:='changes';
   ELSIF type_ = 2 THEN
      field_:='subsid';
   ELSIF type_ = 3 THEN
      field_:='payment';
   ELSIF type_ = 4 THEN
      field_:='pn';
   END IF;

   IF var_ = 3 THEN --ѕо дому
      OPEN prep_refcursor FOR 'select ''–Ё”:''||x.reu||'' ''||s.name||'', ''||LTRIM(x.nd,''0'') as predpr,
             SUBSTR(u.nm1,1,15) AS nm1, SUM(x.'||field_||') AS summa
             FROM XITOG3 x, USLM u, SPUL s
             WHERE x.mg BETWEEN :mg_ AND :mg1_ AND x.USLM=u.USLM AND x.kul=s.id
             AND EXISTS (SELECT * FROM LIST_CHOICES l
               WHERE l.reu=x.reu AND l.kul=x.kul AND l.nd=x.nd AND l.sel=0)
             GROUP BY ''–Ё”:''||x.reu||'' ''||s.name||'', ''||LTRIM(x.nd,''0''), SUBSTR(u.nm1,1,15)'
        USING mg_, mg1_;
   ELSIF var_ = 2 THEN --ѕо –Ё”
      OPEN prep_refcursor FOR 'select s.name||'', ''||LTRIM(x.nd,''0'') as predpr,
             SUBSTR(u.nm1,1,15) AS nm1, SUM(x.'||field_||') AS summa
             FROM XITOG3 x, USLM u, SPUL s
             WHERE x.reu=:reu_ AND x.mg BETWEEN :mg_ AND :mg1_ AND x.USLM=u.USLM AND x.kul=s.id
             GROUP BY s.name||'', ''||LTRIM(x.nd,''0''), SUBSTR(u.nm1,1,15)'
        USING reu_, mg_, mg1_;
   ELSIF var_ = 1 THEN --ѕо ∆Ёќ
      OPEN prep_refcursor FOR 'select ''–Ё”:''||x.reu as predpr,
             SUBSTR(u.nm1,1,15) AS nm1, SUM(x.'||field_||') AS summa
             FROM XITOG3 x, USLM u, SPUL s
             WHERE x.trest=:trest_ AND x.mg BETWEEN :mg_ AND :mg1_ AND x.USLM=u.USLM AND x.kul=s.id
             GROUP BY ''–Ё”:''||x.reu, SUBSTR(u.nm1,1,15)'
        USING trest_, mg_, mg1_;
   ELSIF var_ = 0 THEN --ѕо ћѕ ”≈«∆ ” (все тресты)
      OPEN prep_refcursor FOR 'select ''∆Ёќ:''||t.name_tr as predpr,
             SUBSTR(u.nm1,1,15) AS nm1, SUM(x.'||field_||') AS summa
             FROM XITOG3 x, USLM u, SPUL s, S_REU_TREST t
             WHERE x.mg BETWEEN :mg_ AND :mg1_ AND x.USLM=u.USLM AND x.kul=s.id
             AND x.trest= t.trest
             GROUP BY ''∆Ёќ:''||t.name_tr, SUBSTR(u.nm1,1,15)'
        USING mg_, mg1_;
   END IF;
  END IF;
  END report_charges_usl;

END rep_saldo;
/

prompt
prompt Creating package body SCRIPTS
prompt =============================
prompt
create or replace package body scott.scripts is

procedure swap_payment
is
  mg_ params.period%type;
  dopl_ params.period%type;
  usl_ usl.usl%type;
  usl_sv_ usl.usl%type;
  last_usl_ usl.usl%type;
  last_org_ sprorg.kod%type;
  summa_ number;
  id_ number;
  dat_ date;

begin
--переброска кредитового сальдо по капремонту
--ѕ–≈ƒ¬ј–»“≈Ћ№Ќќ ¬џѕќЋЌ»“№ ѕќƒ√ќ“ќ¬ ” ј–’»¬ќ¬! (дл€ a_nabor)
select period into mg_ from params;
dat_:=to_date('20110730','YYYYMMDD');
id_:=1;
delete from t_corrects_payments t where t.mg=mg_ and t.id=id_;

usl_:='033';
usl_sv_:='034';
--вариант - снимать по оплате
--проставить в WORK_HOUSES.NEWREU=1  по домам дл€ переноса!!!!
/*for c in (select k.c_lsk_id, t.*, a.org from arch_kwtp t, a_nabor a, kart k
    where k.lsk=t.lsk and t.lsk=a.lsk and k.reu in ('11', '12')
    and (t.mg between '200806' and '200809')
    and exists (select * from work_houses w where
      w.reu=k.reu and w.kul=k.kul and w.nd=k.nd)
    and t.mg=a.mg
    and t.usl_id=a.usl
    and usl_id in (usl_, usl_sv_))*/
--вариант - снимать по сальдо
for c in (select t.* from saldo_usl t,
(select t.lsk,sum(summa) as summa from saldo_usl t, params p where t.mg=p.period
  and t.usl not in (usl_, usl_sv_)
  group by t.lsk) a,
  params p where t.mg=p.period and t.summa<0
  and t.usl in (usl_, usl_sv_)
  and t.lsk=a.lsk(+)
  and exists
  (select * from kart k, work_houses h where h.id=k.house_id
  and k.lsk=t.lsk and h.newreu is not null)
  and (nvl(a.summa,0)=0 or abs(t.summa)/abs(nvl(a.summa,0)) > 0.044)

  ) --высчитанный %
loop
  --снимаем оплату
  summa_:=0;
  last_usl_:=null;
  last_org_:=null;
  insert into t_corrects_payments
    (lsk, usl, org, summa, user_id, dat, mg, dopl, id)
    values
    (c.lsk, c.usl, c.org, c.summa, uid, dat_, mg_, c.mg, id_);

  for s in (select s.usl, s.org,
    round(c.summa*nvl(s.summa,0)/nvl(d.summa,0),2) *-1 as summa
            from saldo_usl s,
             (select sum(summa) as summa from saldo_usl s1
              where s1.lsk=c.lsk and s1.summa>0 and s1.mg=mg_
              and s1.usl not in (usl_, usl_sv_)) d where s.mg=mg_
            and s.usl not in (usl_, usl_sv_) and s.lsk=c.lsk
            and round(c.summa*nvl(s.summa,0)/nvl(d.summa,0),2)<>0
            and s.summa > 0)
  loop
  --распредел€ем оплату по сальдо
  insert into t_corrects_payments
    (lsk, usl, org, summa, user_id, dat, mg, dopl, id)
    values
    (c.lsk, s.usl, s.org, s.summa, uid, dat_, mg_, mg_, id_);

  last_usl_:=s.usl;
  last_org_:=s.org;
  summa_:=summa_+s.summa;
  end loop;

  if c.summa*-1-nvl(summa_,0) <> 0 then
  --остаток на последнюю услугу, на последн орг.
  select org into last_org_ from a_nabor n where
   n.mg=c.mg and n.usl=usl_ and n.lsk=c.lsk;
  insert into t_corrects_payments
    (lsk, usl, org, summa, user_id, dat, mg, dopl, id)
    values --ниже ошибка была? сто€ло вместо last_usl_ - usl_ ред.22.12.2011
    (c.lsk, last_usl_, last_org_, c.summa*-1-nvl(summa_,0), uid, dat_, mg_, c.mg, id_);
  end if;
end loop;
commit;
end;

procedure swap_payment9
is
  mg_ params.period%type;
  dopl_ params.period%type;
  last_usl_ usl.usl%type;
  last_org_ sprorg.kod%type;
  summa_ number;
  id_ number;
  dat_ date;
  tst_ number;

begin
--переброска кредитового сальдо по выбранным организаци€м
--ѕ–≈ƒ¬ј–»“≈Ћ№Ќќ ¬џѕќЋЌ»“№ ѕќƒ√ќ“ќ¬ ” ј–’»¬ќ¬! (дл€ a_nabor)
select period into mg_ from params;
dat_:=to_date('20111222','YYYYMMDD');
id_:=2;
delete from t_corrects_payments t where t.mg=mg_ and t.id=id_;
--вариант - снимать по сальдо
for c in (select t.* from saldo_usl t,
(select t.lsk,sum(summa) as summa from saldo_usl t, params p
where t.mg=p.period
  and t.org not in (2, 23, 27, 41)
  group by t.lsk) a,
  params p where t.mg=p.period and t.summa<0
  and t.org in (2, 23, 27, 41)
  and t.lsk=a.lsk(+)
  and exists
  (select * from kart k where
  k.lsk=t.lsk and k.reu in ('14','15')
/*  and exists
  (select sum(x.summa), x.lsk from saldo_usl x, params p
   where x.mg=p.period and x.lsk=k.lsk
   group by x.lsk
   having abs(sum(x.summa) )>0.05
   )*/
  )
  and nvl(a.summa,0) > 0
  )
loop
  if c.lsk='14040068' then
    null;
  end if;
  --снимаем оплату
  summa_:=0;
  last_usl_:=null;
  last_org_:=null;
  tst_:=0;

  for s in (select s.usl, s.org,
    round(c.summa*nvl(s.summa,0)/nvl(d.summa,0),2) *-1 as summa
            from saldo_usl s,
             (select sum(summa) as summa from saldo_usl s1
              where s1.lsk=c.lsk and s1.summa>0 and s1.mg=mg_
              and s1.org not in (2, 23, 27, 41)) d where s.mg=mg_
            and s.org not in (2, 23, 27, 41) and s.lsk=c.lsk
            and round(c.summa*nvl(s.summa,0)/nvl(d.summa,0),2)<>0
            and s.summa > 0)
  loop
    tst_:=1;
    --распредел€ем оплату по сальдо
    insert into t_corrects_payments
      (lsk, usl, org, summa, user_id, dat, mg, dopl, id)
      values
      (c.lsk, s.usl, s.org, s.summa, uid, dat_, mg_, mg_, id_);

    last_usl_:=s.usl;
    last_org_:=s.org;
    summa_:=summa_+s.summa;
  end loop;

  if tst_ = 1 then
    insert into t_corrects_payments
    (lsk, usl, org, summa, user_id, dat, mg, dopl, id)
    values
    (c.lsk, c.usl, c.org, c.summa, uid, dat_, mg_, c.mg, id_);
  end if;

  if tst_ = 1 and c.summa*-1-nvl(summa_,0) <> 0 then
  --остаток на последнюю услугу, на последн орг.
    begin
      insert into t_corrects_payments
        (lsk, usl, org, summa, user_id, dat, mg, dopl, id)
        values
        (c.lsk, last_usl_, last_org_, c.summa*-1-nvl(summa_,0), uid, dat_, mg_, c.mg, id_);
    exception
      when others then
      Raise_application_error(-20000, c.lsk);
    end;
  end if;
end loop;
commit;
end;
procedure swap_payment7
is
  mg_ params.period%type;
  mg1_ params.period%type;
  dopl_ params.period%type;
  last_usl_ usl.usl%type;
  last_org_ sprorg.kod%type;
  summa_ number;
  id_ number;
  id2_ number;
  id3_ number;
  --тип сальдо дл€ переброски
  sign_ number;

begin
--переброска мелкого кредитового или дебетового сальдо
--ред. от 27.04.2011
--ѕ–≈ƒ¬ј–»“≈Ћ№Ќќ ¬џѕќЋЌ»“№ »“ќ√ќ¬ќ≈! (—альдо, ѕќƒ√ќ“ќ¬ ” ј–’»¬ќ¬! (дл€ a_nabor))
--select period into mg_ from params;
--берем исх сальдо, вместо вход€щего

--!!!!!!тип сальдо дл€ переброски!!!! -1 - кредитовое, 1 - дебетовое
sign_:=1;
select period1, period into mg_, mg1_ from sys.v_params;

id_:=2;
id2_:=3;
id3_:=4;
delete from t_corrects_payments t where t.mg=mg1_ and t.id in (id_, id2_, id3_);

--ћЌ≈ Ќ≈ Ќ–ј¬»“—я  ј  «ƒ≈—№ —ƒ≈ЋјЌќ, ћќ∆≈“ ѕ–ќ»«ќ…“» (» ѕ–ќ»—’ќƒ»“)
--ѕ≈–≈ –≈ƒ»“ќ¬јЌ»≈ ѕќ ”—Ћ”√≈. »—ѕ–ј¬»“№ –≈ƒ. 29.06.2011
--выборка мелкого кредитового (дебетового) сальдо
for c in (select x.lsk, x.summa, x.usl, x.org, x.mg from scott.saldo_usl x where
   x.mg=mg_ and ((sign_ = -1 and x.summa < 0) or (sign_ = 1 and x.summa > 0))
and exists
(select * from (select t.lsk, t.mg
 from scott.saldo_usl t
 where t.mg = mg_ and exists
 (select * from scott.saldo_usl s where s.lsk=t.lsk and
   s.mg=t.mg and ((sign_ = -1 and s.summa < 0) or (sign_ = 1 and s.summa > 0)) )
  group by t.lsk, t.mg
 having sum(decode(sign(summa), (-1*sign_), summa, 0))<>0
 and abs(sum(decode(sign(summa), sign_, summa, 0))/
 sum(decode(sign(summa), (-1*sign_), summa, 0))) between 0.001 and 0.99
 ) a where a.lsk=x.lsk)
order by x.lsk, x.org, x.usl) --высчитанный %
loop
  --снимаем оплату
  summa_:=0;
  last_usl_:=null;
  last_org_:=null;

  for s in (select s.usl, s.org,
    round( c.summa *nvl(s.summa,0)/nvl(d.summa,0),2) as summa
            from (select lsk, usl, org, sum(summa) as summa from (
                  select lsk, usl, org, summa from saldo_usl
                  where mg=mg_
                   union all
                  select lsk, usl, org, summa from t_corrects_payments
                  where mg=mg1_)
                  group by lsk, usl, org)  s,
             (select sum(summa) as summa from saldo_usl s1
              where s1.lsk=c.lsk
               and ((sign_ = -1 and s1.summa > 0) or (sign_ = 1 and s1.summa < 0))
               and s1.mg=mg_
              and s1.usl <> c.usl and s1.org <> c.org) d where
              s.usl <> c.usl and s.org <> c.org and s.lsk=c.lsk
            and round(c.summa*nvl(s.summa,0)/nvl(d.summa,0),2)<>0
            and ((sign_ = -1 and s.summa > 0) or (sign_ = 1 and s.summa < 0)))
  loop
  --распредел€ем оплату по вх сальдо
    insert into t_corrects_payments
      (lsk, usl, org, summa, user_id, dat, mg, dopl, id)
      values
      (c.lsk, s.usl, s.org, -1 * s.summa, uid, trunc(sysdate), mg1_, mg_, id2_);

    last_usl_:=s.usl;
    last_org_:=s.org;
    summa_:=summa_+s.summa*-1;
  end loop;

  if last_usl_ is not null and last_org_ is not null then
  --снимаем оплату
    insert into t_corrects_payments
      (lsk, usl, org, summa, user_id, dat, mg, dopl, id)
      values
      (c.lsk, c.usl, c.org, c.summa, uid, trunc(sysdate), mg1_, c.mg, id_);
  end if;

  if last_usl_ is not null and last_org_ is not null and
      (nvl(summa_,0)+c.summa) <> 0 then
      --остаток на последнюю услугу, на последн орг.
      insert into t_corrects_payments
        (lsk, usl, org, summa, user_id, dat, mg, dopl, id)
        values
        (c.lsk, last_usl_, last_org_, -1*(nvl(summa_,0)+c.summa), uid, trunc(sysdate), mg1_, c.mg, id3_);
   end if;
end loop;
commit;
end;


procedure swap_payment2
is
begin
--перенос оплаты по тульской-23
for c in (select a.lsk, a.summa, a.penya, a.oper, '200911' as dopl,
  trunc(sysdate) as dtek, a.nkvit, trunc(sysdate) as dat_ink,
  sysdate as ts, 0 as nink, '999' as nkom
   from a_kwtp_mg a
  where a.mg in ('200909', '200910', '200911', '200912')
  and exists (select * from kart k where k.reu='40'
   and k.kul='0020' and k.nd='000023'
   and k.lsk=a.lsk))
loop

insert into c_kwtp
  (lsk, summa, penya, oper, dopl, nink, nkom, dtek, nkvit, dat_ink, ts, id, iscorrect)
  values
  (c.lsk, -1*c.summa, -1*c.penya, c.oper, c.dopl, c.nink, c.nkom, c.dtek, c.nkvit,
     c.dat_ink, c.ts, c_kwtp_id.nextval, 3);

insert into c_kwtp_mg
  (lsk, summa, penya, oper, dopl, nink, nkom, dtek, nkvit,
     dat_ink, ts, c_kwtp_id)
  values
  (c.lsk, -1*c.summa, -1*c.penya, c.oper, c.dopl, c.nink, c.nkom, c.dtek, c.nkvit,
     c.dat_ink, c.ts, c_kwtp_id.currval);
end loop;

for c in (select m.lsk, a.summa, a.penya, a.oper, '200911' as dopl,
  trunc(sysdate) as dtek, a.nkvit, trunc(sysdate) as dat_ink,
  sysdate as ts, 0 as nink, '999' as nkom
   from a_kwtp_mg a, kart t, kart m
  where a.lsk=t.lsk and t.k_lsk_id=m.k_lsk_id
   and m.psch <> 8 and a.mg in ('200909', '200910', '200911', '200912')
  and exists (select * from kart k where k.reu='40'
   and k.kul='0020' and k.nd='000023'
   and k.lsk=a.lsk))
loop

insert into c_kwtp
  (lsk, summa, penya, oper, dopl, nink, nkom, dtek, nkvit, dat_ink, ts, id, iscorrect)
  values
  (c.lsk, c.summa, c.penya, c.oper, c.dopl, c.nink, c.nkom, c.dtek, c.nkvit,
     c.dat_ink, c.ts, c_kwtp_id.nextval, 3);

insert into c_kwtp_mg
  (lsk, summa, penya, oper, dopl, nink, nkom, dtek, nkvit,
     dat_ink, ts, c_kwtp_id)
  values
  (c.lsk, c.summa, c.penya, c.oper, c.dopl, c.nink, c.nkom, c.dtek, c.nkvit,
     c.dat_ink, c.ts, c_kwtp_id.currval);
end loop;
commit;

end;

procedure swap_payment3
is
  mg_ params.period%type;
  dopl_ params.period%type;
  reu_ kart.reu%type;
  newreu_ kart.reu%type;
  summa_ number;
  dat_ date;
  old_lsk_ kart.lsk%type;
  last_lsk_ kart.lsk%type;
  last_usl_ usl.usl%type;
  last_org_ sprorg.kod%type;
  last_old_org_ sprorg.kod%type;
begin
--перенос кредитового сальда оплатой
--ред. от 27.04.2010

select period into mg_ from params;
dat_:=to_date('02012010','DDMMYYYY');
delete from t_corrects_payments t where t.mg=mg_ and t.dat=dat_;
mg_:='201001';
dopl_:='201001';

last_lsk_:=null;
for c in (select s.lsk, m.lsk as lsk_new, s.usl, s.org, n.org as org_new, s.summa
     from saldo_usl s ,
     (select lsk, sum(summa) as summa from saldo_usl
      where mg='201002' group by lsk) a,
     (select lsk, sum(summa) as summa from saldo_usl
      where mg='201002' and summa < 0 group by lsk) c,
      kart k,
      nabor n,
      (select lsk,k_lsk_id from kart where psch <> 8) m
    where k.lsk=s.lsk and m.k_lsk_id=k.k_lsk_id and s.lsk=n.lsk(+) and s.usl=n.usl(+)
    and s.mg='201002' and s.summa<0 and s.lsk=a.lsk and s.lsk=c.lsk(+)
    and exists (select * from kart k where k.lsk=s.lsk and k.psch=8)
    and exists
    (select t.lsk,sum(summa) from saldo_usl t where t.mg='201002' and t.lsk=s.lsk
     group by t.lsk
     having sum(summa) < 0)
    order by s.lsk)
loop
  --снимаем оплату
  if nvl(last_lsk_,'') <> c.lsk and nvl(summa_,0) <> 0  then
   --остаток от пред л.с. закинуть
    insert into t_corrects_payments
      (lsk, usl, org, summa, user_id, dat, mg, dopl)
      values
      (last_lsk_, last_usl_, last_old_org_, summa_, uid, dat_, mg_, dopl_);

    insert into t_corrects_payments
      (lsk, usl, org, summa, user_id, dat, mg, dopl)
      values
      (last_lsk_, last_usl_, last_org_, summa_*-1, uid, dat_, mg_, dopl_);
  else
    insert into t_corrects_payments
      (lsk, usl, org, summa, user_id, dat, mg, dopl)
      values
      (c.lsk, c.usl, c.org, c.summa, uid, dat_, mg_, dopl_);
    insert into t_corrects_payments
      (lsk, usl, org, summa, user_id, dat, mg, dopl)
      values
      (c.lsk_new, c.usl, c.org_new, c.summa*-1, uid, dat_, mg_, dopl_);
    last_lsk_:=c.lsk_new;
    last_usl_:=c.usl;
    last_org_:=c.org_new;
    last_old_org_:=c.org;

  end if;
end loop;
commit;
end;


procedure gen_del_add_partitions
is
  mg_ number;
begin
--скрипт удаление не нужных партиций (дл€ уменьшени€ dumpa)
--¬ќ ¬—≈’ “јЅЋ»÷ј’ схемы scott
return;
--убери return;

for c in (select table_name
  from all_tables t where t.partitioned ='YES' and t.owner='SCOTT')
loop
mg_:=200701;
loop
  exit when mg_>200807;
  gen.drop_part(c.table_name, to_char(mg_));
  mg_:=mg_+1;
end loop;
end loop;


end gen_del_add_partitions;

procedure new_usl(usl_ in varchar2)
is
  usl_from_ char(3);
begin
--ввод новой услуги
usl_from_:='003';

delete from prices c where c.usl=usl_;
insert into prices
  (usl, summa, summa2)
  select usl_, summa, summa2 from prices c where c.usl=usl_from_;

delete from nabor c where c.usl=usl_;

insert into nabor
  (lsk, usl, org, koeff, norm)
  select lsk, usl_, org, 0, 0 from nabor n where n.usl=usl_from_;

delete from c_spk_usl c where c.usl_id=usl_;

insert into c_spk_usl
  (spk_id, usl_id, koef, dop_pl, prioritet, charge_part)
  select spk_id, usl_, koef, dop_pl, prioritet, charge_part from
    c_spk_usl s where s.usl_id=usl_from_;

commit;
end;

procedure script_renumber(oldreu_ in kart.reu%type, reu_ in kart.reu%type) is

  lsk1_ kart.lsk%type;
begin
  --скрипт дл€ присоединени€ ”  к существующим ” 
  --к которому присоединитс€
--  oldreu_:='34';
  --из которого присоединитс€
--  reu_:='15';
update kart t set t.polis = null;
update kart t set t.polis =
  lpad((select max(lsk)
   from kart k where k.reu = oldreu_)+rownum,8,'0')
    where t.reu = reu_;
update kart t set t.lsk=t.polis, t.polis=t.lsk
 where t.reu = reu_;
 update c_kart_pr t set t.lsk= (select k.lsk from kart k where k.polis=t.lsk
   and k.reu = reu_)
   where exists (select * from kart k where k.polis=t.lsk
   and k.reu = reu_);
 update saldo_usl t set t.lsk= (select k.lsk from kart k where k.polis=t.lsk
   and k.reu = reu_)
   where exists (select * from kart k where k.polis=t.lsk
   and k.reu = reu_);
 update nabor t set t.lsk= (select k.lsk from kart k where k.polis=t.lsk
   and k.reu = reu_)
   where exists (select * from kart k where k.polis=t.lsk
   and k.reu = reu_);

 update c_charge t set t.lsk= (select k.lsk from kart k where k.polis=t.lsk
   and k.reu = reu_)
    where exists (select * from kart k where k.polis=t.lsk
   and k.reu = reu_);

 update c_chargepay t set t.lsk= (select k.lsk from kart k where k.polis=t.lsk
   and k.reu = reu_)
    where exists (select * from kart k where k.polis=t.lsk
   and k.reu = reu_);

update c_houses t set t.reu =oldreu_
 where t.reu = reu_;
update kart t set t.reu =oldreu_
 where t.reu = reu_;


 commit;
end script_renumber;


procedure create_uk(newreu_ in kart.reu%type, nreu_ in varchar2,
  mg1_ in params.period%type, mg2_ in params.period%type) is
--создание нового ”  по таблице work_houses
--¬ыполн€ть во 2 ю очередь

--¬Ќ»ћјЌ»≈! «ј –џ“»≈ Ћ»÷≈¬џ’ —„≈“ќ¬ ƒ≈Ћј“№ ќ“ƒ≈Ћ№Ќќ, ѕќ—Ћ≈ √ј–јЌ“»–ќ¬јЌЌќ√ќ
--ѕ≈–≈Ќќ—ј Ћ»÷≈¬џ’ ¬ ” !!!
begin

--mg1_:='200901'; --новый период работы лицевого
--mg2_:='999999';  --заключительный период работы лицевого
--newreu_:='29';
--nreu_:='0029';
delete from nabor t where
  exists (select * from kart k where k.lsk=t.lsk and k.reu = newreu_);
delete from kart where reu=newreu_;
delete from c_houses c where c.reu=newreu_;
insert into c_houses
  (id, reu, kul, nd, uch, maxlsk, kw, minlsk, house_type, opl)
  select c_house_id.nextval, newreu_, kul, nd, uch, maxlsk, kw, minlsk, house_type, opl
   from c_houses h where exists
   (select * from work_houses c where c.id=h.id and c.newreu = newreu_);

/*--вводы  --”Ѕ–јЋ ƒќЅј¬Ћ≈Ќ»≈ ¬¬ќƒќ¬... —“ј¬»“№ ¬ –”„Ќ”ё...
update c_vvod k set k.flag=rownum;
--по х.воде
update kart k set k.flag=(select c.flag from c_vvod c where c.type=0 and c.id=k.c_vvod_hw_id);
--по г.воде
update kart k set k.flag1=(select c.flag from c_vvod c where c.type=1 and c.id=k.c_vvod_gw_id);

delete from c_vvod t where
  exists (select * from c_houses c where c.id=t.house_id and c.reu = newreu_);

--по х.воде
insert into c_vvod
  (flag, house_id, id, kub, type, kub_man, kpr, kub_sch, sch_cnt, sch_kpr, cnt_lsk, user_id, usl_032)
  select t.flag, v.id, c_vvod_id.nextval, t.kub, t.type, t.kub_man, t.kpr, t.kub_sch, t.sch_cnt, t.sch_kpr,
    t.cnt_lsk, t.user_id, t.usl_032
   from c_vvod t, c_houses h, c_houses v where
   t.house_id = h.id and h.kul=v.kul and h.nd=v.nd and v.reu=newreu_ and
   t.type=0 and
  exists
   (select * from work_houses c where c.id=t.house_id and c.newreu = newreu_);

--по г.воде
insert into c_vvod
  (flag, house_id, id, kub, type, kub_man, kpr, kub_sch, sch_cnt, sch_kpr, cnt_lsk, user_id, usl_032)
  select t.flag, v.id, c_vvod_id.nextval, t.kub, t.type, t.kub_man, t.kpr, t.kub_sch, t.sch_cnt, t.sch_kpr,
    t.cnt_lsk, t.user_id, t.usl_032
   from c_vvod t, c_houses h, c_houses v where
   t.house_id = h.id and h.kul=v.kul and h.nd=v.nd and v.reu=newreu_ and
   t.type=1 and
  exists
   (select * from work_houses c where c.id=t.house_id and c.newreu = newreu_);

--по 032 услуге
insert into c_vvod
  (house_id, id, kub, type, kub_man, kpr, kub_sch, sch_cnt, sch_kpr, cnt_lsk, user_id, usl_032)
  select v.id, c_vvod_id.nextval, t.kub, t.type, t.kub_man, t.kpr, t.kub_sch, t.sch_cnt, t.sch_kpr,
    t.cnt_lsk, t.user_id, t.usl_032
   from c_vvod t, c_houses h, c_houses v where
   t.house_id = h.id and h.kul=v.kul and h.nd=v.nd and v.reu=newreu_ and
   t.type=2 and
  exists
   (select * from work_houses c where c.id=t.house_id and c.newreu = newreu_);
*/
--лицевые
insert into kart
  (k_lsk_id, c_lsk_id, lsk, flag, flag1, kul, nd, kw, fio, kpr, kpr_wr, kpr_ot, kpr_cem, kpr_s, opl,
  ppl, pldop, ki, psch, psch_dt,  status, kwt,
  lodpl, bekpl, balpl, komn, et,
  kfg, kfot, phw, mhw, pgw, mgw, pel, mel,
  sub_nach, subsidii, sub_data, polis, sch_el,
  reu, text,
  schel_dt, eksub1, eksub2, kran, kran1, el,
   el1, sgku, doppl, subs_cor, subs_cur, house_id, kan_sch, mg1, mg2)
select t.k_lsk_id, t.c_lsk_id, nreu_||lpad(rownum,4,'0') as lsk,
 t.flag, t.flag1, t.kul, t.nd, t.kw, fio, kpr, kpr_wr, kpr_ot,
 kpr_cem, kpr_s, t.opl, ppl, pldop, ki,
 t.psch, psch_dt, status, kwt,
 lodpl, bekpl, balpl, komn, et, kfg, kfot, phw, mhw,
 pgw, mgw, pel, mel, sub_nach, subsidii, sub_data,
 polis, sch_el, newreu_, text,
 schel_dt, eksub1, eksub2, kran, t.kran1, el, el1,
 sgku, doppl, subs_cor, subs_cur,
 c.id as house_id, kan_sch, mg1_, mg2_ from kart t, c_houses c where
  exists (select * from work_houses c where c.id=t.house_id and c.newreu = newreu_)
    and c.reu =newreu_ and t.kul=c.kul and t.nd=c.nd
 order by t.kul, t.nd, t.kw;

--оп€ть вводы))
--по х.воде
--update kart t set t.c_vvod_hw_id=(select id from c_vvod c where c.flag=t.flag and c.house_id=
--  t.house_id)
--  where exists (select * from c_houses c where c.id=t.house_id and c.reu = newreu_);

--по г.воде
--update kart t set t.c_vvod_gw_id=(select id from c_vvod c where c.flag=t.flag1 and c.house_id=
--  t.house_id)
--  where exists (select * from c_houses c where c.id=t.house_id and c.reu = newreu_);

--по 032 услуге
--ID на ввод проставл€ть не нужно (в данной версии)

--выполн€етс€ каскадно
--delete from c_kart_pr t

insert into c_kart_pr
  (id, old_id, lsk, fio, status, dat_rog, pol, dok, dok_c, dok_n, dok_d, dok_v, dat_prop, dat_ub, relat_id)
 select kart_pr_id.nextval, p.id, t.lsk, p.fio, p.status, p.dat_rog, p.pol, p.dok,
   p.dok_c, p.dok_n, p.dok_d, p.dok_v, p.dat_prop, p.dat_ub, p.relat_id
 from c_kart_pr p, kart k, kart t where p.lsk=k.lsk and k.c_lsk_id=t.c_lsk_id and k.lsk <> t.lsk and
  exists (select * from work_houses c where c.id=k.house_id and c.newreu = newreu_);
--выполн€етс€ каскадно
--delete from c_lg_docs t

insert into c_lg_docs
  (id, old_id, c_kart_pr_id, doc, dat_begin, main, dat_end)
 select c_lg_docs_id.nextval, c.id, p.id, c.doc, c.dat_begin, c.main, c.dat_end
 from c_lg_docs c, c_kart_pr p, kart k
  where k.lsk=p.lsk and p.old_id=c.c_kart_pr_id and
  exists (select * from c_houses w where w.id=k.house_id and w.reu = newreu_);

--выполн€етс€ каскадно
--delete from c_lg_pr t

insert into c_lg_pr
  (c_lg_docs_id, spk_id, type)
 select c.id, r.spk_id, r.type
 from c_lg_pr r, c_lg_docs c, c_kart_pr p, kart k
  where k.lsk=p.lsk and p.id=c.c_kart_pr_id and c.old_id=r.c_lg_docs_id and
  exists (select * from c_houses w where w.id=k.house_id and w.reu = newreu_);


insert into nabor
  (lsk, usl, org, koeff, norm)
 select t.lsk, n.usl, n.org, n.koeff, n.norm from nabor n, kart k, kart t
   where n.lsk=k.lsk and k.c_lsk_id=t.c_lsk_id and k.lsk <> t.lsk and t.psch <>8
     and exists (select * from work_houses c where c.id=k.house_id and c.newreu = newreu_);

 commit;

end create_uk;

procedure saldo_c_lsk(newreu_ in kart.reu%type) is
begin
--отделение сальдо от прошлых периодов (создание нового c_lsk_id)
--(дл€ “—∆)

for c in (select k.lsk from kart k where exists
  (select * from c_houses c where c.id=k.house_id and c.reu = newreu_))
loop
  insert into c_lsk (id)
   values (c_lsk_id.nextval);

  update kart t set t.c_lsk_id=c_lsk_id.currval
    where t.lsk=c.lsk;
end loop;
commit;
end;



procedure close_uk(newreu_ in kart.reu%type, mg2_ in params.period%type) is
--закрытие старого фонда 8 -ками.
--ќтменить не возможно!!!
--выполн€ть в 4 ю очередь
begin
-- newreu_:='29';
 --ѕоследний период работы лицевых
-- mg2_:='200812';

 update kart k set k.psch = 8, k.mg2=mg2_ where exists
   (select * from work_houses c where c.id=k.house_id and c.newreu = newreu_);

 commit;
end close_uk;

procedure replace_uk_new(newreu_ in kart.reu%type) is
begin
--дома
 update c_houses h set h.reu=newreu_
  where exists
   (select * from work_houses c where c.id=h.id and c.newreu = newreu_);

 update kart h set h.reu=newreu_
  where exists
   (select * from work_houses c where c.id=h.house_id and c.newreu = newreu_);
 commit;
end;


procedure create_uk_new(newreu_ in kart.reu%type,
  lsk_ in kart.lsk%type,
  type_ in number,
  p_tp_sal in number,
  org_ in nabor.org%type) is
  maxlsk_ number;
  mgchange_ c_change.mgchange%type;
  comment_ c_change_docs.text%type;
  mg_ params.period%type;
  mg_close_ params.period%type;
  period_ params.period%type;
  user_id_ number;
  changes_id_ c_change_docs.id%type;
  cnt_ number;
  l_tp_sal number;
  l_par number;
  l_id number;
begin
--присоединение л/с. к ” 
--основной скрипт переброски фонда из ук в ук
-- при type_ =0, null - org_ - не используетс€
-- при type_ =1 - переноситс€ обычно уже «ј –џ“џ… дом (точнее даже его долги, в другое ” )

 --признак как переносить сальдо
 --0-не переносить, 2 - переносить и дебет и кредит,
 --1-только дебет
 l_tp_sal:=nvl(p_tp_sal,0);

select period into period_ from params p;
select period3 into mg_close_ from sys.v_params;
  for c in (select t.reu, s.name, t.kul, t.nd from c_houses t, spul s
    where nvl(t.psch,0)<>1 and t.kul=s.id
    group by t.reu,s.name,t.kul,t.nd
    having count(*)>1)
  loop
   Raise_application_error(-20000,
     'ќтмена, найдено два открытых дома с одним адресом: REU='||c.reu||', KUL='||c.kul||', ”л='||c.name||', ND='||c.nd);
  end loop;

  if nvl(type_,0) <> 1 then
    for c in (select t.reu, s.name, t.kul, t.nd from c_houses t, spul s
      where nvl(t.psch,0)=1 and t.kul=s.id
        and exists
       (select * from work_houses c where c.id=t.id and c.newreu = newreu_))
    loop
     Raise_application_error(-20000,
       'ќтмена, попытка перенести закрытый дом с адресом: REU='||c.reu||', KUL='||c.kul||', ”л='||c.name||', ND='||c.nd);
    end loop;
  end if;
--установка флага переноса, т.е. записи инсерт€тс€ через скрипт переноса домов
c_charges.scr_flag_:=1;
--¬Ќ»ћјЌ»≈ если type_=1 то перенос€тс€ все дома и закрытые и не закрытые
--использовать этот параметр, только в определенных случа€х (ред.19.09.12)

--дома
if nvl(type_,0) =1  then
insert into c_houses
  (id, reu, kul, nd, uch, maxlsk, kw, minlsk, house_type, opl, psch)
  select c_house_id.nextval, newreu_, kul, nd, uch, maxlsk, kw, minlsk, house_type, opl, 1
   from c_houses h where exists
   (select * from work_houses c where c.id=h.id and c.newreu = newreu_);
else
insert into c_houses
  (id, reu, kul, nd, uch, maxlsk, kw, minlsk, house_type, opl)
  select c_house_id.nextval, newreu_, kul, nd, uch, maxlsk, kw, minlsk, house_type, opl
   from c_houses h where exists
   (select * from work_houses c where c.id=h.id and c.newreu = newreu_);


--перенести необходимые параметры дома
for c in (select h.k_lsk_id from c_houses h
    where exists
   (select * from work_houses c where c.id=h.id and c.newreu = newreu_))
loop
  l_par:=c_obj_par.get_num_param(p_k_lsk_id => c.k_lsk_id,
    p_lsk => null, p_cd => 'area_general_property');
  l_id := c_obj_par.set_num_param(p_k_lsk_id => c.k_lsk_id,
                                     p_lsk => null,
                                     p_cd => 'area_general_property',
                                     p_val => l_par,
                                     p_cdtp => 'house_params');
end loop;


--отмечаем дома закрытым признаком, с которых переносим
 update c_houses t set t.psch=1 where exists
   (select * from work_houses c where c.id=t.id and c.newreu = newreu_);

end if;

--лицевые
  if lsk_ is null then
  --присоединение к ” 
    --проверка
    select max(to_number(t.lsk)) into maxlsk_ from kart t where
    t.reu=newreu_;
    if nvl(maxlsk_,0) = 0 then
     Raise_application_error(-20001,
       'Ќе к чему присоедин€тьс€!');
    end if;
  elsif length(lsk_) <> 8 then
     Raise_application_error(-20001,
       'Ќачальный лицевой счет должен быть равен 8 знакам!');
  else
  --новый ” 
   maxlsk_:=lsk_-1;
  end if;

if l_tp_sal in (1,2)  then
--если требуетс€ перенести 1- дебетовое (или 2-всЄ) сальдо

  --период, которым провести изменени€
  select p.period into mgchange_ from params p;
  --период, сальдо по которому смотрим переплату
  mg_:=mgchange_;
  --комментарий
  comment_:='ѕереброска Cальдо на ” ';
  --”никальный номер переброски
  select changes_id.nextval into changes_id_ from dual;

  select t.id into user_id_ from t_user t where t.cd='SCOTT';

  insert into c_change_docs (id, mgchange, dtek, ts, user_id, text)
  select changes_id_, mgchange_, trunc(sysdate), sysdate, user_id_, comment_
   from dual;
end if;

 for c in (select t.lsk as old_lsk, t.k_lsk_id, t.c_lsk_id,
   t.flag, t.flag1, t.kul, t.nd, t.kw, fio, k_fam, k_im, k_ot, kpr, kpr_wr, kpr_ot,
   kpr_cem, kpr_s, t.opl, ppl, pldop, ki,
   t.psch, psch_dt, status, kwt,
   lodpl, bekpl, balpl, komn, et, kfg, kfot, phw, mhw,
   pgw, mgw, pel, mel, sub_nach, subsidii, sub_data,
   polis,
   sch_el, newreu_ as reu, text,
   schel_dt, eksub1, eksub2, kran, t.kran1, el, el1,
   sgku, doppl, subs_cor, subs_cur,
   x.id as house_id, t.kan_sch, period_ as mg1,
   case when nvl(type_,0)=1 then period_
     else '999999' end as mg2, t.fk_tp
        from kart t,
   c_houses x where case when nvl(type_,0)=1 then 0
   else t.psch end <> 8 and
    exists (select * from work_houses c where c.id=t.house_id and c.newreu = newreu_)
      and x.reu =newreu_ and t.kul=x.kul and t.nd=x.nd and
      case when nvl(type_,0)=1 then 0
         else nvl(x.psch,0) end = 0
    order by t.kul, t.nd, t.kw)
 loop
    --получить новый, уникальный лс
  maxlsk_:=p_houses.find_unq_lsk(newreu_, null);
--    select nvl(count(*),0) into cnt_ from kart k where k.lsk=maxlsk_;
--    exit when cnt_=0;
  insert into c_lsk (id)
   values (c_lsk_id.nextval);

  insert into kart
   (k_lsk_id, c_lsk_id, lsk, flag, flag1, kul, nd, kw, fio, k_fam, k_im, k_ot, kpr, kpr_wr, kpr_ot, kpr_cem, kpr_s, opl,
   ppl, pldop, ki, psch, psch_dt,  status, kwt,
   lodpl, bekpl, balpl, komn,  et,
   kfg, kfot, phw, mhw, pgw, mgw, pel, mel,
   sub_nach, subsidii, sub_data,
   polis,
   reu, text,
    schel_dt, eksub1, eksub2, kran, kran1, el,
    el1, sgku, doppl, subs_cor, subs_cur, house_id, kan_sch, mg1, mg2, fk_tp)
  values
   (c.k_lsk_id, c_lsk_id.currval, lpad(to_char(maxlsk_),8,'0'), c.flag, c.flag1, c.kul, c.nd, c.kw,
   c.fio, c.k_fam, c.k_im, c.k_ot, c.kpr, c.kpr_wr, c.kpr_ot, c.kpr_cem, c.kpr_s, c.opl,
   c.ppl, c.pldop, c.ki, c.psch, c.psch_dt, c. status, c.kwt,
   c.lodpl, c.bekpl, c.balpl, c.komn, c.et,
   c.kfg, c.kfot, c.phw, c.mhw, c.pgw, c.mgw, c.pel, c.mel,
   c.sub_nach, c.subsidii, c.sub_data,
   c.polis,
   newreu_, c.text,
   c.schel_dt, c.eksub1, c.eksub2, c.kran, c.kran1, c.el,
    c.el1, c.sgku, c.doppl, c.subs_cor, c.subs_cur, c.house_id, c.kan_sch, c.mg1, c.mg2, c.fk_tp);

   --переносим действующие статусы счетов в новые счета...
   insert into c_states_sch
     (lsk, fk_status, dt1, dt2)
   select lpad(to_char(maxlsk_),8,'0'), t.fk_status, t.dt1, t.dt2 --to_date(period_||'01','YYYYMMDD'), null
   from c_states_sch t
   where t.lsk=c.old_lsk/* and
   mg_ between nvl(to_char(t.dt1,'YYYYMM'), '190001')
              and nvl(to_char(t.dt2,'YYYYMM'), '290001')*/;

if l_tp_sal in (1,2)  then
--если требуетс€ перенести сальдо
 --снимаем сальдо
 insert into c_change
   (lsk, usl, summa, mgchange, nkom, org, type, dtek, ts, user_id, doc_id)
 select s.lsk, s.usl, -1*s.summa, mgchange_, '999', s.org, 0, d.dtek,
   sysdate, d.user_id, d.id
   from c_change_docs d, saldo_usl s,
   (select m.lsk, sum(summa) as summa from saldo_usl m where m.mg=mg_
     and m.lsk=c.old_lsk
     group by m.lsk
    ) a
    where s.mg=mg_ and s.lsk=a.lsk
    and
    case when l_tp_sal =1 and nvl(a.summa,0) > 0 then 1
      when l_tp_sal =2 then 1
      else 0 end =1
     and
    d.id=changes_id_
    and s.lsk=c.old_lsk;

 --устанавливаем сальдо
 insert into c_change
   (lsk, usl, summa, mgchange, nkom, org, type, dtek, ts, user_id, doc_id, show_bill)
 select lpad(to_char(maxlsk_),8,'0') as lsk, s.usl, s.summa,
   mgchange_, '999', s.org, 0, d.dtek, sysdate, d.user_id, d.id, 1 as show_bill
   from c_change_docs d, saldo_usl s,
   (select m.lsk, sum(summa) as summa from saldo_usl m where m.mg=mg_
     and m.lsk=c.old_lsk
     group by m.lsk
    ) a
    where s.mg=mg_ and s.lsk=a.lsk and
    case when l_tp_sal =1 and nvl(a.summa,0) > 0 then 1
      when l_tp_sal =2 then 1
      else 0 end =1
    and
    d.id=changes_id_
    and s.lsk=c.old_lsk;

end if;

--проживающие
for t in (
  select id, lsk, fio, status, dat_rog, pol, dok, dok_c, dok_n, dok_d, dok_v,
  dat_prop, dat_ub, relat_id, old_id, status_dat, status_chng, k_fam,
  k_im, k_ot, fk_doc_tp, fk_nac, b_place, fk_frm_cntr, fk_frm_regn,
  fk_frm_distr, frm_town, frm_dat, fk_frm_kul, frm_nd, frm_kw, w_place,
  fk_ub, fk_to_cntr, fk_to_regn, fk_to_distr, to_town, fk_to_kul, to_nd,
  to_kw, fk_citiz, fk_milit, fk_milit_regn
    from c_kart_pr p where p.lsk=c.old_lsk)
loop
insert into c_kart_pr
  (id, lsk, fio, status, dat_rog, pol, dok, dok_c, dok_n, dok_d,
  dok_v, dat_prop, dat_ub, relat_id, old_id, status_dat,
  status_chng, k_fam, k_im, k_ot, fk_doc_tp, fk_nac, b_place,
  fk_frm_cntr, fk_frm_regn, fk_frm_distr, frm_town, frm_dat,
  fk_frm_kul, frm_nd, frm_kw, w_place, fk_ub, fk_to_cntr,
  fk_to_regn, fk_to_distr, to_town, fk_to_kul, to_nd, to_kw,
  fk_citiz, fk_milit, fk_milit_regn)
values
  (kart_pr_id.nextval, lpad(to_char(maxlsk_),8,'0'),
  t.fio, t.status, t.dat_rog, t.pol, t.dok, t.dok_c, t.dok_n, t.dok_d, t.dok_v,
  t.dat_prop, t.dat_ub, t.relat_id, t.old_id, t.status_dat, t.status_chng,
  t.k_fam, t.k_im, t.k_ot, t.fk_doc_tp, t.fk_nac, t.b_place,
  t.fk_frm_cntr, t.fk_frm_regn, t.fk_frm_distr, t.frm_town, t.frm_dat,
  t.fk_frm_kul, t.frm_nd, t.frm_kw, t.w_place, t.fk_ub, t.fk_to_cntr,
  t.fk_to_regn, t.fk_to_distr, t.to_town, t.fk_to_kul, t.to_nd, t.to_kw,
  t.fk_citiz, t.fk_milit, t.fk_milit_regn);

  --переносим ¬—≈ статусы проживающего в новые счета...
  insert into c_states_pr
    (fk_status, fk_kart_pr, dt1, dt2, fk_tp)
  select p.fk_status, kart_pr_id.currval, p.dt1, p.dt2, p.fk_tp
  from c_states_pr p
  where p.fk_kart_pr=t.id;

  for d in (select c.id, c.doc, c.dat_begin, c.main, c.dat_end
   from c_lg_docs c
    where c.c_kart_pr_id=t.id)
  loop
  insert into c_lg_docs
    (id, c_kart_pr_id, doc, dat_begin, main, dat_end)
   values
   (c_lg_docs_id.nextval, kart_pr_id.currval, d.doc, d.dat_begin, d.main, d.dat_end);

  insert into c_lg_pr
    (c_lg_docs_id, spk_id, type)
   select c_lg_docs_id.currval, r.spk_id, r.type
   from c_lg_pr r
    where r.c_lg_docs_id=d.id;
  end loop;
end loop;

--тер€етс€ информаци€ по вводам... вручную добавл€ть...
  insert into nabor
    (lsk, usl, org, koeff, norm)
   select lpad(to_char(maxlsk_),8,'0'), n.usl, n.org, n.koeff, n.norm from nabor n
      where n.lsk=c.old_lsk;
 end loop;

if nvl(type_,0)=0 then
 --закрытие старого фонда
 --сохран€ем старые признаки счетчиков

--  зачем флаги эти ставить? update kart k set k.flag = k.psch where exists
--   (select * from work_houses c where c.id=k.house_id and c.newreu = newreu_);

  --устанавливаем период закрыти€
  update kart k set k.mg2=mg_close_ where k.mg1 < mg_ and exists
     (select * from work_houses c where c.id=k.house_id and c.newreu = newreu_);

  --дл€ тех л.с. которые были закрытыми и которые успели побыть открытыми в тек мес€це (бывает такое)
  update kart k set k.mg2=period_ where k.mg1=period_ and k.psch in (8,9) and exists
     (select * from work_houses c where c.id=k.house_id and c.newreu = newreu_);

  --psch в kart проставитс€ здесь, в триггерах
  --удал€ем движение в статусах счета
  delete from c_states_sch k
  where exists
              (select * from kart r,
              work_houses c where c.id=r.house_id and c.newreu = newreu_
              and r.lsk=k.lsk);

   --устанавливаем новый "закрытый" статус счета
   insert into c_states_sch
     (lsk, fk_status, dt1, dt2)
   select k.lsk, 8, to_date(period_||'01','YYYYMMDD'), null
   from kart k
   where exists
   (select * from kart r,
              work_houses c where c.id=r.house_id and c.newreu = newreu_
              and r.lsk=k.lsk);
end if;

commit;

--сн€тие флага переноса
c_charges.scr_flag_:=0;

--пересчет коэфф. прожив и текущего начислени€ по старым и новым л.с.
for c in (select r.lsk from kart r,
              work_houses t where t.kul=r.kul and t.nd=r.nd and t.newreu = newreu_
              )
loop
  cnt_:=c_charges.gen_charges(c.lsk, c.lsk, null, null, 1, 0);
end loop;


end create_uk_new;

procedure clear_tables
is
  mg_ number;
begin
--скрипт удаление не нужных партиций (дл€ уменьшени€ dumpa)
--убери return;
return;

for c in (select table_name
  from all_tables t where t.owner='SCOTT'
   and t.table_name like 'X%')
loop
  execute immediate 'truncate table '||c.table_name;
end loop;
end clear_tables;

procedure clear_tables2
is
  mg_ number;
begin
--скрипт удаление не нужных записей в таблицах
--убери return;
--return;

for c in (select distinct t.mg
  from a_charge t)
loop
  execute immediate 'delete from a_charge a where nvl(a.summa,0)=0 and
    a.mg='||c.mg;
  commit;
end loop;
end clear_tables2;

procedure clear_tables3
is
  mg_ number;
begin
--скрипт удаление не нужных записей в таблицах
--убери return;
return;

for c in (select distinct t.mg
  from a_nabor t)
loop
  execute immediate 'delete from a_nabor a where
  exists (select * from kart k where k.lsk=a.lsk and k.psch=8)
   and
    a.mg='||c.mg;
  commit;
end loop;

end clear_tables3;

procedure saldo_uk_div
is
  mg_ number;
  var_ number;
  count_ INTEGER;
  c_lsk_id_ number;
  TYPE cv_type IS REF CURSOR;
   cv cv_type;
begin
--скрипт на разделение сальдо по ”  11-21
--убери return;
--return;
/*     OPEN cv FOR 'select count(*) from '||c.table_name||' t
      where t.c_lsk_id=0 and t.lsk=''''';
     LOOP
        FETCH cv INTO count_;
        EXIT WHEN cv%NOTFOUND;
     END LOOP;
     CLOSE cv; */
--создаем индексы
for c in (select table_name
  from all_tables t where t.owner='SCOTT' and t.table_name
    not in ('C_PENYA', 'A_PENYA'))
loop
  var_:=0;
  begin
     OPEN cv FOR 'select count(*) from '||c.table_name||' t
      where t.c_lsk_id=0 and t.lsk=''''';
     LOOP
        FETCH cv INTO count_;
        EXIT WHEN cv%NOTFOUND;
     END LOOP;
     CLOSE cv;
  exception
    when others then
  var_:=1;
  end;
  if var_ = 0 then
  begin
    execute immediate 'drop index tmp$$$_'||c.table_name;
  exception
    when others then
  null;
  end;
  begin
    execute immediate 'create index tmp$$$_'||c.table_name||' on '||c.table_name||' (lsk)';
  exception
    when others then
  null;
  end;
  end if;
end loop;

--обрабатываем таблицы
for m in (select lsk from kart k where exists
(select *
  from kart t where t.reu between '11' and '21'
  and t.c_lsk_id=k.c_lsk_id)
  and k.psch = 8)
loop
  select c_lsk_id.nextval into c_lsk_id_ from dual;
  insert into c_lsk(id)
    values (c_lsk_id_);
  for c in (select table_name
    from all_tables t where t.owner='SCOTT' and t.table_name
      not in ('C_PENYA', 'A_PENYA'))
  loop
  --  logger.log_(null, '–азделение id, таблица: '||c.table_name);
    begin
     execute immediate 'update '||c.table_name||' t set t.c_lsk_id = '||c_lsk_id_||'
       where t.lsk='''||m.lsk||'''';
    -- logger.log_(null, '“аблица разделена: '||c.table_name);
    exception
      when others then
      var_:=1;
  --   logger.log_(null, 'ќшибка разделени€ таблицы: '||c.table_name);
    end;

/*    begin
      execute immediate 'update '||c.table_name||' t set t.c_lsk_id = 0
       where t.lsk='''||m.lsk||'';
    exception
      when others then
      rollback;
      logger.log_(null, 'ќшибка разделени€ таблицы: '||c.table_name);
    end;
    rollback;
*/

  end loop;
  commit;
end loop;
  return;

end saldo_uk_div;

procedure swap_payment4(reu_ in varchar2, newreu_ in varchar2) is
begin

delete from c_kwtp_mg t where t.nkom='999';
delete from c_kwtp t where t.nkom='999';

--перенос оплаты с ”  reu_ на ”  newreu_
for c in (select k.lsk, k1.lsk as newlsk, s.summa as summa, s.penya, s.oper,
     s.dopl as DOPL, 999 as nink, '999' as nkom,
     trunc(sysdate) as dtek, s.nkvit, trunc(sysdate) as dat_ink, sysdate as ts
     from c_kwtp_mg s, kart k, kart k1
    where k.reu=reu_ and k.lsk=s.lsk
    and k.k_lsk_id=k1.k_lsk_id
    and k1.psch <> 8 and k1.reu=newreu_
    and (s.summa <> 0 or s.penya <> 0))
loop

insert into c_kwtp
  (lsk, summa, penya, oper, dopl, nink, nkom, dtek, nkvit,
  dat_ink, ts, id, iscorrect)
  values
  (c.lsk, -1*c.summa, -1*c.penya, c.oper, c.dopl, c.nink, c.nkom, c.dtek, c.nkvit,
  c.dat_ink, c.ts, c_kwtp_id.nextval, 1);

insert into c_kwtp
  (lsk, summa, penya, oper, dopl, nink, nkom, dtek, nkvit,
  dat_ink, ts, id, iscorrect)
  values
  (c.newlsk, c.summa, c.penya, c.oper, c.dopl, c.nink, c.nkom, c.dtek, c.nkvit,
  c.dat_ink, c.ts, c_kwtp_id.nextval, 1);

insert into c_kwtp_mg
  (lsk, summa, penya, oper, dopl, nink, nkom, dtek, nkvit,
  dat_ink, ts, c_kwtp_id)
  values
  (c.lsk, -1*c.summa, -1*c.penya, c.oper, c.dopl, c.nink, c.nkom, c.dtek, c.nkvit,
  c.dat_ink, c.ts, c_kwtp_id.currval);

insert into c_kwtp_mg
  (lsk, summa, penya, oper, dopl, nink, nkom, dtek, nkvit,
  dat_ink, ts, c_kwtp_id)
  values
  (c.newlsk, c.summa, c.penya, c.oper, c.dopl, c.nink, c.nkom, c.dtek, c.nkvit,
  c.dat_ink, c.ts, c_kwtp_id.currval);

end loop;
commit;

end swap_payment4;

procedure swap_changes is
  mgchange_ c_change.mgchange%type;
  comment_ c_change_docs.text%type;
  mg_ params.period%type;
  user_id_ number;
  cd_ c_change_docs.text%type;
begin

--период, которым провести изменени€
mgchange_:='201004';
--период, сальдо по которому смотрим переплату
mg_:='201004';
--комментарий
comment_:='ѕереброска кредитового сальдо на ”  ';
--”никальный номер переброски
cd_:='02';

select t.id into user_id_ from t_user t where t.cd='SCOTT';

delete from c_change t where t.user_id=user_id_
 and exists (select * from
 c_change_docs d where d.user_id=user_id_ and d.text=cd_ and d.id=t.doc_id);
delete from c_change_docs t where t.user_id=user_id_ and t.text=cd_;

insert into c_change_docs (id, mgchange, dtek, ts, user_id, text)
select changes_id.nextval, mgchange_, trunc(sysdate), sysdate, user_id_, cd_
 from dual;

--перенос кредитового сальдо с ”  на Ќовый ”  »«ћ≈Ќ≈Ќ»яћ»!!!
for c in (select k.lsk, k1.lsk as newlsk, s2.usl, s2.summa as summa,
     mgchange_ as mgchange
     from (select lsk, sum(summa) as summa from saldo_usl where
      mg=mg_
      group by lsk) s,(select usl, lsk, sum(summa) as summa from saldo_usl where
      mg=mg_
      group by usl, lsk) s2, kart k, kart k1
    where exists
    (select * from work_houses w where w.newreu in ('12') --список новых ”  дл€ переброски
     and w.id=k.house_id)
    and k.lsk=s.lsk
    and k.lsk=s2.lsk
    and k.k_lsk_id=k1.k_lsk_id
    and k1.psch <> 8
    and s.summa < 0)
loop

--по старым л.с.
insert into c_change (lsk, usl, summa, mgchange, type, dtek, ts,
user_id, doc_id)
select c.lsk, c.usl, -1*c.summa as summa,
 c.mgchange, 1, trunc(sysdate), sysdate, user_id_, changes_id.currval
 from dual;

--по новым л.с.
insert into c_change (lsk, usl, summa, mgchange, type, dtek, ts,
user_id, doc_id)
select c.newlsk, c.usl, c.summa as summa,
 c.mgchange, 1, trunc(sysdate), sysdate, user_id_, changes_id.currval
 from dual;

end loop;
commit;

end swap_changes;

procedure swap_payment5 is
  dopl_ c_kwtp_mg.dopl%type;
  mg_ params.period%type;
  user_id_ number;
  dat_ date;
  id_ number;
  fk_doc_ number;
begin

--перенос переплаты (не кредитового сальдо выборочно по услугам!)
-- с ”  на Ќовый ”  ќплатой!!!


--период, которым провести оплату
dopl_:='201202';
--период, сальдо по которому смотрим переплату
mg_:='201202';
--ƒата переброски
dat_:=to_date('01022012','DDMMYYYY');
--ID операции
id_:=1;

select t.id into user_id_ from t_user t where t.cd='SCOTT';

insert into c_change_docs
  (mgchange, dtek, ts, user_id, text)
values
  (dopl_, dat_, sysdate, user_id_, 'ѕеренос переплаты - оплатой')
  returning id into fk_doc_;

delete from t_corrects_payments t where t.mg=mg_ and t.dat=dat_ and t.id=id_;

for c in (select k.lsk, s2.org as old_org, s2.usl as old_usl, n.org, n.usl,
   k1.lsk as newlsk, s2.summa as summa
     from (select lsk, sum(summa) as summa from saldo_usl where
      mg=mg_
      group by lsk) s,(select usl, org, lsk, sum(summa) as summa from saldo_usl where
      mg=mg_
      group by usl, org, lsk) s2, kart k, kart k1, nabor n
    where exists
    (select * from work_houses w where w.newreu in ('01') --список новых ”  дл€ переброски
     and w.id=k.house_id)
    and k.lsk=s.lsk
    and k.lsk=s2.lsk
    and k1.lsk=n.lsk and s2.usl=n.usl
    and k.k_lsk_id=k1.k_lsk_id
    and k1.psch <> 8
    and s.summa < 0)
loop

--по старым л.с.
  insert into t_corrects_payments
    (lsk, usl, org, summa, user_id, dat, mg, dopl, id)
    values
    (c.lsk, c.old_usl, c.old_org, c.summa, user_id_, dat_, mg_, dopl_, id_);

--по новым л.с.
  insert into t_corrects_payments
    (lsk, usl, org, summa, user_id, dat, mg, dopl, id)
    values
    (c.newlsk, c.usl, c.org, -1 * c.summa, user_id_, dat_, mg_, dopl_, id_);

end loop;
commit;

end swap_payment5;

procedure upd_nabor(oldorg_ in number, org_ in number, newreu_ in kart.reu%type) is
begin
--обновление кода предпри€ти€ на новый, после переброски фонда из ”  в ” 
update nabor n set n.org=org_
 where exists (select * from kart k
 where k.lsk=n.lsk and k.reu=newreu_)
 and n.org=oldorg_; --список услуг, по которым обновить
commit;

end;

procedure go_back_month is
  mg_ params.period%type;
begin
--возвращение назад мес€ца из архива (специально дл€ полыс)
--внимание! до выполнени€ отключить все триггеры!!!
mg_:='201005';
update params p set p.period=mg_;
generator.disable_keys(null);

  delete from kart;
  delete from c_kart_pr;
  delete from c_lg_docs;
  delete from c_lg_pr;
  delete from nabor;
  delete from c_kwtp;
  delete from c_kwtp_mg;
  delete from c_change_docs;
  delete from c_change;
  delete from c_vvod;
  delete from c_houses;
  commit;

  insert into kart
    (lsk, kul, nd, kw, fio, kpr, kpr_wr, kpr_ot,
    kpr_cem, kpr_s, opl, ppl, pldop, ki, psch,
    psch_dt, status, kwt, lodpl, bekpl, balpl,
    komn, et, kfg, kfot, phw, mhw,
    pgw, mgw, pel, mel, sub_nach, subsidii,
    sub_data, polis, sch_el, reu, text, schel_dt,
    eksub1, eksub2, kran, kran1, el, el1, sgku,
    doppl, subs_cor, house_id, c_lsk_id,
    mg1, mg2, kan_sch, subs_inf,
    k_lsk_id, dog_num, schel_end, fk_deb_org,
    subs_cur, k_fam, k_im, k_ot, memo, fk_distr,
    law_doc, fk_pasp_org)
    select
    k.lsk, k.kul, k.nd, k.kw, k.fio, k.kpr, k.kpr_wr, k.kpr_ot,
    k.kpr_cem, k.kpr_s, k.opl, k.ppl, k.pldop, k.ki, k.psch,
    k.psch_dt, k.status, k.kwt, k.lodpl, k.bekpl, k.balpl,
    k.komn, k.et, k.kfg, k.kfot, k.phw, k.mhw,
    k.pgw, k.mgw, k.pel, k.mel, k.sub_nach, k.subsidii,
    k.sub_data, k.polis, k.sch_el, k.reu, k.text, k.schel_dt,
    k.eksub1, k.eksub2, k.kran, k.kran1, k.el, k.el1, k.sgku,
    k.doppl, k.subs_cor, k.house_id, k.c_lsk_id,
    k.mg1, k.mg2, k.kan_sch, k.subs_inf,
    k.k_lsk_id, k.dog_num, k.schel_end, k.fk_deb_org,
    k.subs_cur, k.k_fam, k.k_im, k.k_ot, k.memo, k.fk_distr,
    k.law_doc, k.fk_pasp_org
    from arch_kart k where k.mg=mg_;
  commit;


  insert into c_kart_pr
    (id, lsk, fio, status, dat_rog, pol, dok, dok_c, dok_n,
    dok_d, dok_v, dat_prop, dat_ub, relat_id,
    status_dat, status_chng, k_fam, k_im, k_ot,
    fk_doc_tp, fk_nac, b_place, fk_frm_cntr, fk_frm_regn,
    fk_frm_distr, frm_town, frm_dat, fk_frm_kul, frm_nd,
    frm_kw, w_place, fk_ub, fk_to_cntr, fk_to_regn,
    fk_to_distr, to_town, fk_to_kul, to_nd, to_kw,
    fk_citiz, fk_milit, fk_milit_regn)
    select c.id, c.lsk, c.fio, c.status, c.dat_rog, c.pol, c.dok, c.dok_c, c.dok_n,
      c.dok_d, c.dok_v, c.dat_prop, c.dat_ub, c.relat_id,
      c.status_dat, c.status_chng, c.k_fam, c.k_im, c.k_ot,
      c.fk_doc_tp, c.fk_nac, c.b_place, c.fk_frm_cntr, c.fk_frm_regn,
      c.fk_frm_distr, c.frm_town, c.frm_dat, c.fk_frm_kul, c.frm_nd,
      c.frm_kw, c.w_place, c.fk_ub, c.fk_to_cntr, c.fk_to_regn,
      c.fk_to_distr, c.to_town, c.fk_to_kul, c.to_nd, c.to_kw,
      c.fk_citiz, c.fk_milit, c.fk_milit_regn
    from a_kart_pr c where c.mg=mg_;
  commit;

  insert into c_lg_docs
    (id, c_kart_pr_id, doc, dat_begin, dat_end, main)
    select c.id,
           c.c_kart_pr_id,
           c.doc,
           c.dat_begin,
           c.dat_end,
           c.main
      from a_lg_docs c where c.mg=mg_;
  commit;

  insert into c_lg_pr
    (c_lg_docs_id, spk_id, type)
    select c.c_lg_docs_id, c.spk_id, c.type
      from a_lg_pr c where c.mg=mg_;
  commit;

  insert into nabor
    (lsk, usl, org, koeff, norm, fk_vvod,  vol)
    select c.lsk, c.usl, c.org, c.koeff, c.norm,
      c.fk_vvod, c.vol
      from a_nabor c where c.mg=mg_;
  commit;

  insert into c_kwtp
    (lsk,
     summa,
     penya,
     oper,
     dopl,
     nink,
     nkom,
     dtek,
     nkvit,
     dat_ink,
     ts,
     id,
     iscorrect)
    select c.lsk,
           c.summa,
           c.penya,
           c.oper,
           c.dopl,
           c.nink,
           c.nkom,
           c.dtek,
           c.nkvit,
           c.dat_ink,
           c.ts,
           c.id,
           c.iscorrect
      from a_kwtp c where c.mg=mg_;
  commit;

  insert into c_kwtp_mg
    (lsk,
     summa,
     penya,
     oper,
     dopl,
     nink,
     nkom,
     dtek,
     nkvit,
     dat_ink,
     ts,
     c_kwtp_id)
    select c.lsk,
           c.summa,
           c.penya,
           c.oper,
           c.dopl,
           c.nink,
           c.nkom,
           c.dtek,
           c.nkvit,
           c.dat_ink,
           c.ts,
           c.c_kwtp_id
      from a_kwtp_mg c where c.mg=mg_;
  commit;

  insert into c_change
    (lsk,
     usl,
     summa,
     proc,
     mgchange,
     nkom,
     org,
     type,
     dtek,
     ts,
     user_id,
     doc_id,
     cnt_days,
     show_bill)
    select c.lsk,
           c.usl,
           c.summa,
           c.proc,
           c.mgchange,
           c.nkom,
           c.org,
           c.type,
           c.dtek,
           c.ts,
           c.user_id,
           c.doc_id,
           c.cnt_days,
           c.show_bill
      from a_change c where c.mg=mg_;
  commit;

  insert into c_change_docs
    (id, mgchange, dtek, ts, user_id, text)
    select c.id, c.mgchange, c.dtek, c.ts, c.user_id, c.text
      from a_change_docs c
      where c.mg=mg_;
  commit;

  insert into c_houses
    (id, reu, kul, nd, uch, house_type, fk_pasp_org)
    select c.id, c.reu, c.kul, c.nd, c.uch, c.house_type, c.fk_pasp_org
      from a_houses c
      where c.mg=mg_;
  commit;

  insert into c_vvod
    (house_id,
     id,
     kub,
     usl,
     kub_man,
     kpr,
     kub_sch,
     sch_cnt,
     sch_kpr,
     cnt_lsk,
     vvod_num)
    select c.house_id,
           c.id,
           c.kub,
           c.usl,
           c.kub_man,
           c.kpr,
           c.kub_sch,
           c.sch_cnt,
           c.sch_kpr,
           c.cnt_lsk,
           c.vvod_num
      from a_vvod c where c.mg=mg_;
 commit;
 generator.enable_keys(null);
end;

procedure create_killme is
--KILLME
begin
--лицевые
delete from c_kart_pr p where exists
 (select * from kart k where k.lsk=p.lsk and k.psch <> 8 and
    exists (select * from work_houses c where
      c.kul=k.kul and c.nd=k.nd and c.newreu is not null)
    );

 for c in (select k.lsk as new_lsk, t.lsk as old_lsk, t.k_lsk_id, t.c_lsk_id,
   t.flag, t.flag1, t.kul, t.nd, t.kw,
   t.kan_sch, p.period as mg1, '999999' as mg2 from kart t, kart k,
   params p where t.psch = 8 and t.k_lsk_id=k.k_lsk_id and k.psch <> 8 and
    '201004' between t.mg1 and t.mg2 and
    exists (select * from work_houses c where c.id=t.house_id and c.newreu is not null)
    order by t.kul, t.nd, t.kw)
 loop
for t in (select p.id,
   p.fio, p.k_fam, p.k_im, p.k_ot, p.status, p.dat_rog, p.pol, p.dok,
   p.dok_c, p.dok_n, p.dok_d, p.dok_v, p.dat_prop, p.dat_ub, p.relat_id
    from c_kart_pr p where p.lsk=c.old_lsk)
loop
  insert into c_kart_pr
  (id, lsk, fio, k_fam, k_im, k_ot, status, dat_rog, pol, dok, dok_c, dok_n,
   dok_d, dok_v, dat_prop, dat_ub, relat_id)
  values
  (kart_pr_id.nextval, c.new_lsk,
   t.fio, t.k_fam, t.k_im, t.k_ot, t.status, t.dat_rog, t.pol, t.dok, t.dok_c, t.dok_n,
   t.dok_d, t.dok_v, t.dat_prop, t.dat_ub, t.relat_id);

  for d in (select c.id, c.doc, c.dat_begin, c.main, c.dat_end
   from c_lg_docs c
    where c.c_kart_pr_id=t.id)
  loop
  insert into c_lg_docs
    (id, c_kart_pr_id, doc, dat_begin, main, dat_end)
   values
   (c_lg_docs_id.nextval, kart_pr_id.currval, d.doc, d.dat_begin, d.main, d.dat_end);

  insert into c_lg_pr
    (c_lg_docs_id, spk_id, type)
   select c_lg_docs_id.currval, r.spk_id, r.type
   from c_lg_pr r
    where r.c_lg_docs_id=d.id;
  end loop;
end loop;

 end loop;

 commit;

end create_killme;

procedure swap_oborot is
  mgchange_ c_change.mgchange%type;
  comment_ c_change_docs.text%type;
  mg_ params.period%type;
  user_id_ number;
  cd_ c_change_docs.text%type;
  old_org_ number;
  new_org_ number;
  dat_ c_change.dtek%type;
  id_ number;
begin
--ѕереброска оборотов (коррекци€ тем самым сальдо)
--ќплатой и начислением
--по Ўукшина-31 (полыс)

--период, которым провести изменени€
mgchange_:='201005';
--комментарий
comment_:=' оррекци€ сальдо по Ўукшина-31';
--”никальный номер переброски
cd_:='02';
--ƒата переброски
dat_:=to_date('31052010','DDMMYYYY');
--ID операции
id_:=2;
old_org_:=3;
new_org_:=78;


select t.id into user_id_ from t_user t where t.cd='SCOTT';
delete from t_corrects_payments t where t.mg=mg_ and t.dat=dat_ and t.id=id_;

delete from c_change t where t.user_id=user_id_
 and exists (select * from
 c_change_docs d where d.user_id=user_id_ and d.text=cd_ and d.id=t.doc_id);
delete from c_change_docs t where t.user_id=user_id_ and t.text=cd_;

insert into c_change_docs (id, mgchange, dtek, ts, user_id, text)
select changes_id.nextval, mgchange_, dat_, sysdate, user_id_, cd_
 from dual;


for c in (select lsk, usl, sum(charges) as charges,sum(payment) as payment
   from xitog3_lsk t where
  t.mg='201004' and
  exists
  (select * from kart k where k.lsk=t.lsk
  and k.house_id=37525)
  and t.org=3
  group by lsk, usl)
loop

--раз изм
--1-орг
if c.charges is not null then
  insert into c_change (lsk, org, usl, summa, mgchange, type, dtek, ts,
  user_id, doc_id)
  select c.lsk, old_org_, c.usl, -1 * c.charges as summa,
   mgchange_, 1, dat_, sysdate, user_id_, changes_id.currval
   from dual;
  --2-орг
  insert into c_change (lsk, org, usl, summa, mgchange, type, dtek, ts,
  user_id, doc_id)
  select c.lsk, new_org_, c.usl, c.charges as summa,
   mgchange_, 1, dat_, sysdate, user_id_, changes_id.currval
   from dual;
end if;

--оплата
--1-орг
if c.payment is not null then
  insert into t_corrects_payments
    (lsk, usl, org, summa, user_id, dat, mg, dopl, id)
    values
    (c.lsk, c.usl, old_org_, -1 * c.payment, user_id_, dat_, mgchange_, mgchange_, id_);
--оплата
--2-орг
  insert into t_corrects_payments
    (lsk, usl, org, summa, user_id, dat, mg, dopl, id)
    values
    (c.lsk, c.usl, new_org_, c.payment, user_id_, dat_, mgchange_, mgchange_, id_);
end if;
end loop;

commit;
end swap_oborot;

procedure ins_vvod is
 usl_ usl.usl%type;
 id_ c_vvod.id%type;
begin
--добавление вводов по услугам корректировка х.в. и корректировка г.в.
usl_:='055';
for c in (select * from c_houses h where not exists
    (select * from kart k, nabor n, c_vvod c
     where k.lsk=n.lsk and n.fk_vvod=c.id and c.house_id=h.id and c.usl=usl_))
loop
 insert into c_vvod
   (house_id, id, usl, vvod_num)
   values
   (c.id, c_vvod_id.nextval, usl_, 1);
 update nabor n set n.fk_vvod=c_vvod_id.currval
  where n.usl = usl_ and
  exists (select * from kart k where k.lsk=n.lsk and k.house_id=c.id);

end loop;
commit;
end;

procedure create_kart is
maxlsk_ varchar2(8);
nd_ varchar2(6);
house_id_ number;
i number;
begin
--создание базы небольшого “—∆
--отключить предварительно триггеры!!!
/*delete from nabor;
delete from c_lg_pr;
delete from c_lg_docs;
delete from c_kart_pr;
delete from c_kwtp_mg;
delete from c_kwtp;
delete from kart;
commit;

for c in (select * from killme_imp)
loop
 insert into k_lsk (id, v, fk_addrtp)
  values (k_lsk_id.nextval, 1, null);
 insert into c_lsk (id)
  values (c_lsk_id.nextval);

   select lpad(max(lsk)+1,8,'0') into maxlsk_ from
     kart k;
   if maxlsk_ is null then
     maxlsk_:='00000001';
   end if;

if c.house is null then
  nd_:='00010а';
  house_id_:=37386;
else
  nd_:='000038';
  house_id_:=37387;
end if;

 insert into kart k (lsk, sch_el, reu, opl, fio, k_fam, k_im, kul, nd, kw, psch, kpr, kpr_wr,
   kpr_ot, status, kfg, kfot, house_id, k_lsk_id, c_lsk_id, mg1, mg2, fk_pasp_org)
 select maxlsk_, 1, '01', c.opl, c.fio, substr(c.fio,1,instr(c.fio,' ',1)),
 substr(c.fio, instr(c.fio,' ',1), length(trim(c.fio))),
 '0001', lpad(nd_,6,'0'), lpad(to_char(c.n),7,'0'),
    1, nvl(c.kpr,0), 0, 0, 2, 2, 2, house_id_, k_lsk_id.currval, c_lsk_id.currval, p.period, '999999',
    t.id
    from params p, t_org t, t_org_tp tp
    where tp.cd='ѕаспортный стол' and tp.id=t.fk_orgtp;
--содерж
 insert into nabor n (lsk, usl, org, koeff, norm)
  select maxlsk_, u.usl, (select min(kod) from sprorg),
    1, 1
   from usl u
   where u.usl='003';
 insert into nabor n (lsk, usl, org, koeff, norm)
  select maxlsk_, u.usl, (select min(kod) from sprorg),
    1, 1
   from usl u
   where u.usl='004';
--отопл
 insert into nabor n (lsk, usl, org, koeff, norm)
  select maxlsk_, u.usl, (select min(kod) from sprorg),
    1, 1
   from usl u
   where u.usl='007';
 insert into nabor n (lsk, usl, org, koeff, norm)
  select maxlsk_, u.usl, (select min(kod) from sprorg),
    1, 1
   from usl u
   where u.usl='008';
--х.в.
 insert into nabor n (lsk, usl, org, koeff, norm)
  select maxlsk_, u.usl, (select min(kod) from sprorg),
    1, 7.9
   from usl u
   where u.usl='011';
 insert into nabor n (lsk, usl, org, koeff, norm)
  select maxlsk_, u.usl, (select min(kod) from sprorg),
    1, 1
   from usl u
   where u.usl='012';
--г.в.
 insert into nabor n (lsk, usl, org, koeff, norm)
  select maxlsk_, u.usl, (select min(kod) from sprorg),
    1, 3.6
   from usl u
   where u.usl='015';
 insert into nabor n (lsk, usl, org, koeff, norm)
  select maxlsk_, u.usl, (select min(kod) from sprorg),
    1, 1
   from usl u
   where u.usl='016';
--канал
 insert into nabor n (lsk, usl, org, koeff, norm)
  select maxlsk_, u.usl, (select min(kod) from sprorg),
    1, 11.5
   from usl u
   where u.usl='013';
 insert into nabor n (lsk, usl, org, koeff, norm)
  select maxlsk_, u.usl, (select min(kod) from sprorg),
    1, 1
   from usl u
   where u.usl='014';
--Ёл.энерг
 insert into nabor n (lsk, usl, org, koeff, norm)
  select maxlsk_, u.usl, (select min(kod) from sprorg),
    1, 1
   from usl u
   where u.usl='038';
 insert into nabor n (lsk, usl, org, koeff, norm)
  select maxlsk_, u.usl, (select min(kod) from sprorg),
    1, 1
   from usl u
   where u.usl='039';

--Ёл.энерг гараж
 insert into nabor n (lsk, usl, org, koeff, norm)
  select maxlsk_, u.usl, (select min(kod) from sprorg),
    decode(nvl(c.el,0), 0, 0, 1), decode(nvl(c.el,0), 0, 0, c.el)
   from usl u
   where u.usl='060';

-- ап.рем
 insert into nabor n (lsk, usl, org, koeff, norm)
  select maxlsk_, u.usl, (select min(kod) from sprorg),
    1, 1
   from usl u
   where u.usl='033';
 insert into nabor n (lsk, usl, org, koeff, norm)
  select maxlsk_, u.usl, (select min(kod) from sprorg),
    1, 1
   from usl u
   where u.usl='034';
--“Ѕќ
 insert into nabor n (lsk, usl, org, koeff, norm)
  select maxlsk_, u.usl, (select min(kod) from sprorg),
    1, 1
   from usl u
   where u.usl='031';
 insert into nabor n (lsk, usl, org, koeff, norm)
  select maxlsk_, u.usl, (select min(kod) from sprorg),
    1, 1
   from usl u
   where u.usl='046';
--јнтенна
 insert into nabor n (lsk, usl, org, koeff, norm)
  select maxlsk_, u.usl, (select min(kod) from sprorg),
    1, decode(c.anten, 65, 1, 0)
   from usl u
   where u.usl='043';
-- од.замки
 insert into nabor n (lsk, usl, org, koeff, norm)
  select maxlsk_, u.usl, (select min(kod) from sprorg),
    decode(c.kodzam,35,1,0), decode(c.kodzam,35,1,0)
   from usl u
   where u.usl='044';
-- од.замки-2
 insert into nabor n (lsk, usl, org, koeff, norm)
  select maxlsk_, u.usl, (select min(kod) from sprorg),
    decode(c.kodzam,27,1,0), decode(c.kodzam,27,1,0)
   from usl u
   where u.usl='045';

i:=1;
while i<=nvl(c.kpr,0)
loop
--проживающие
insert into c_kart_pr
  (id, lsk, fio, status)
values
  (kart_pr_id.nextval, maxlsk_, null, 1);
--документы льгот
insert into c_lg_docs
  (id, c_kart_pr_id, main)
values
  (c_lg_docs_id.nextval, kart_pr_id.currval, 0);
--льготы
insert into c_lg_pr
  (c_lg_docs_id, spk_id, type)
values
  (c_lg_docs_id.currval, 1, 0);
insert into c_lg_pr
  (c_lg_docs_id, spk_id, type)
values
  (c_lg_docs_id.currval, 1, 1);
  i:=i+1;
end loop;
end loop;*/
commit;
end;


procedure find_table is
 tname_ varchar2(255);
 s1 number;
 s2 number;
 s3 number;
begin
--поиск таблиц с определенными критери€ми

delete from tmp;
--найти все таблицы пользовател€ scott, с пол€ми кода организации
for c in (select * from all_tables s where s.owner ='SCOTT')
loop
  s1:=0;
  s2:=0;
  s3:=0;
  tname_:=c.table_name;
 begin
   execute immediate 'update '||tname_||' t set t.org=1 where rownum=1';
 exception
    when others then
  s1:=1;
 end;

 begin
   execute immediate 'update '||tname_||' t set t.kod=1 where rownum=1';
 exception
    when others then
  s2:=1;
 end;

 begin
   execute immediate 'update '||tname_||' t set t.fk_org=1 where rownum=1';
 exception
    when others then
  s3:=1;
 end;
 if s1 =0 or s2 =0 or s3 =0 then
  insert into tmp(txt2)
  values (tname_);
 end if;
end loop;
commit;
end;

procedure swap_payment8
is
  mg_ params.period%type;
  mg1_ params.period%type;
  dopl_ params.period%type;
  last_usl_ usl.usl%type;
  last_org_ sprorg.kod%type;
  dbsum_ number;
  crsum_ number;
  summa_ number;
  id_ number;
  id2_ number;

begin
--переброска мелкого кредитового или дебетового сальдо
--ред. от 30.08.2011
--ѕ–≈ƒ¬ј–»“≈Ћ№Ќќ ¬џѕќЋЌ»“№ »“ќ√ќ¬ќ≈! (—альдо, ѕќƒ√ќ“ќ¬ ” ј–’»¬ќ¬! (дл€ a_nabor))
--берем исх сальдо

select period1, period into mg_, mg1_ from sys.v_params;

id_:=17;
id2_:=18;
delete from t_corrects_payments t where t.mg=mg1_ and t.id in (id_, id2_);

--¬ыбираем мелкое кредитовое сальдо, где так же превальирует дебетовое сальдо
for c in (select s.lsk, s.org, s.usl, s.summa as crsal,
  a.summa as dbsum from saldo_usl s,
 (select d.lsk, sum(summa) as summa from saldo_usl d where d.mg=mg_
   and d.summa > 0
   group by d.lsk) a
 where s.mg=mg_ and s.lsk=a.lsk(+)
 and
 exists
 (select * from saldo_usl t
  where t.lsk=s.lsk and t.mg=mg_
  and t.summa < 0)
 and
 exists
 (select lsk, sum(summa) from saldo_usl t
  where t.lsk=s.lsk and t.mg=mg_
  group by lsk
  having nvl(sum(summa),0)>0)
 and s.summa < 0 )
loop
dbsum_:=nvl(c.dbsum,0);
crsum_:=nvl(c.crsal,0);

           --находим дебетовое сальдо, на которое надо распределить кредитовое по этому л/c
for d in ( -- с учЄтом уже проведенных корректировок
    select lsk, org, usl, sum(summa) as summa from (
    select s.lsk, s.org, s.usl, s.summa as summa from saldo_usl s
   where s.lsk=c.lsk and s.mg=mg_
    union all
    select s.lsk, s.org, s.usl, -1 * s.summa as summa from t_corrects_payments s
   where s.lsk=c.lsk and s.mg=mg_ and s.id=id_)
    having sum(summa) > 0
    group by lsk, org, usl
    )
loop
  exit when crsum_ >= 0 or dbsum_<=0;
  --распредел€ем оплату по вх сальдо
  if abs(crsum_) <= d.summa then
    --ставим на дебетовое
    insert into t_corrects_payments
      (lsk, usl, org, summa, user_id, dat, mg, dopl, id)
      values
      (d.lsk, d.usl, d.org, -1 * crsum_, uid, trunc(sysdate), mg1_, mg_, id_);
    --снимаем с кредитового
    insert into t_corrects_payments
      (lsk, usl, org, summa, user_id, dat, mg, dopl, id)
      values
      (c.lsk, c.usl, c.org, crsum_, uid, trunc(sysdate), mg1_, mg_, id2_);
    dbsum_:=dbsum_-(-1 * c.crsal);
    crsum_:=crsum_+(-1 * c.crsal);
  else
    --ставим на дебетовое
    insert into t_corrects_payments
      (lsk, usl, org, summa, user_id, dat, mg, dopl, id)
      values
      (d.lsk, d.usl, d.org, d.summa, uid, trunc(sysdate), mg1_, mg_, id_);
    --снимаем с кредитового
    insert into t_corrects_payments
      (lsk, usl, org, summa, user_id, dat, mg, dopl, id)
      values
      (c.lsk, c.usl, c.org, -1 * d.summa, uid, trunc(sysdate), mg1_, mg_, id2_);
    dbsum_:=dbsum_-d.summa;
    crsum_:=crsum_+d.summa;
  end if;
end loop;


end loop;
commit;
end;

procedure set_sal_mg
is
--old_mg_ saldo_usl.mg%type;
begin
--инициализаци€ таблицы дл€ по-сальдо-периодному распределению

--old_mg_:=to_char(add_months(to_date(c.mg||'01','YYYYMMDD'),-1), 'YYYYMM');

execute immediate 'truncate table deb_usl_mg';

insert into deb_usl_mg
  (lsk, usl, org, summa, mg, period)
select t.lsk, t.usl, t.org, sum(t.summa) as summa, '000000' as mg,
  to_char(add_months(to_date(p.period||'01','YYYYMMDD'),-1), 'YYYYMM') as period from
  saldo_usl t, params p where t.mg=p.period
  group by t.lsk, t.usl, t.org, t.mg,
  to_char(add_months(to_date(p.period||'01','YYYYMMDD'),-1), 'YYYYMM'); --вх сальдо текущего периода, в кач-ве свернутой задолженности
                                        --прошлых периодов
commit;
end;

procedure swap_oborot2 is
  mgchange_ c_change.mgchange%type;
  comment_ c_change_docs.text%type;
  mg_ params.period%type;
  user_id_ number;
  cd_ c_change_docs.text%type;
  dat_ c_change.dtek%type;
  changes_id_ number;
begin
--ѕереброска сальдо по “—∆ ( ис)
--c одной орг. на другую
--период, которым провести изменени€
mgchange_:='201209';
--комментарий
comment_:=' оррекци€ сальдо по ” ';
--”никальный номер переброски
cd_:='01';
--ƒата переброски
dat_:=to_date('19092012','DDMMYYYY');
select t.id into user_id_ from t_user t where t.cd='SCOTT';

delete from c_change t where t.user_id=user_id_
 and exists (select * from
 c_change_docs d where d.user_id=user_id_ and d.text=cd_ and d.id=t.doc_id);
delete from c_change_docs t where t.user_id=user_id_ and t.text=cd_;

select changes_id.nextval into changes_id_ from dual;

insert into c_change_docs (id, mgchange, dtek, ts, user_id, text)
select changes_id_, mgchange_, dat_, sysdate, user_id_, cd_
 from dual;

  insert into c_change (lsk, org, usl, summa, mgchange, type, dtek, ts,
  user_id, doc_id)
  select s.lsk, s.org, s.usl, -1 * s.summa as summa,
   mgchange_, 1, dat_, sysdate, user_id_, changes_id_
   from saldo_usl s, kart k, t_org o
    where s.lsk=k.lsk and k.reu=o.reu and o.parent_id=626
    and s.usl in ('035','036') and s.org=51
    and s.mg=mgchange_
    union all
  select s.lsk, 723 as org, s.usl,  s.summa as summa,
   mgchange_, 1, dat_, sysdate, user_id_, changes_id_
   from saldo_usl s, kart k, t_org o
    where s.lsk=k.lsk and k.reu=o.reu and o.parent_id=626
    and s.usl in ('035','036') and s.org=51
    and s.mg=mgchange_;

commit;
end swap_oborot2;
procedure swap_oborot3 is
  mgchange_ c_change.mgchange%type;
  comment_ c_change_docs.text%type;
  mg_ params.period%type;
  user_id_ number;
  cd_ c_change_docs.text%type;
  dat_ c_change.dtek%type;
  changes_id_ number;
begin
--ѕереброска сальдо по ”  (ѕолыс)
--c одной орг. на другую
--период, которым провести изменени€
mgchange_:='201209';
--комментарий
comment_:=' оррекци€ сальдо по ” ';
--”никальный номер переброски
cd_:='01';
--ƒата переброски
dat_:=to_date('19092012','DDMMYYYY');
select t.id into user_id_ from t_user t where t.cd='SCOTT';

delete from c_change t where t.user_id=user_id_
 and exists (select * from
 c_change_docs d where d.user_id=user_id_ and d.text=cd_ and d.id=t.doc_id);
delete from c_change_docs t where t.user_id=user_id_ and t.text=cd_;

select changes_id.nextval into changes_id_ from dual;

insert into c_change_docs (id, mgchange, dtek, ts, user_id, text)
select changes_id_, mgchange_, dat_, sysdate, user_id_, cd_
 from dual;

  insert into c_change (lsk, org, usl, summa, mgchange, type, dtek, ts,
  user_id, doc_id)
  select s.lsk, s.org, s.usl, -1 * s.summa as summa,
   mgchange_, null, dat_, sysdate, user_id_, changes_id_
   from saldo_usl s, kart k, t_org o, work_houses h
    where s.lsk=k.lsk and k.reu=o.reu
    and s.mg=mgchange_ and h.id=k.house_id
    union all
  select s.lsk, s.org, s.usl, s.summa as summa,
   mgchange_, null, dat_, sysdate, user_id_, changes_id_
   from saldo_usl s, kart k, kart k2, t_org o, work_houses h
    where s.lsk=k.lsk and k.reu=o.reu
    and s.mg=mgchange_ and h.id=k.house_id
    and k.k_lsk_id = k2.k_lsk_id
    and k2.psch <>8;


commit;
end swap_oborot3;


procedure close_sal is
l_mg params.period%type;
l_mg1 params.period%type;
l_dt date;
l_id c_change_docs.id%type;
l_cd_tp c_change_docs.cd_tp%type;
begin
--закрытие сальдо ќѕЋј“ќ…, по закрытым лицевым определенного периода
--и определенных ” 
l_mg:= '201301';
l_mg1:= '201212';
l_dt:=to_date('20130113','YYYYMMDD');
l_cd_tp:='PAY_SAL2';

delete from t_corrects_payments t where mg=l_mg
 and exists (select * from c_change_docs d where
  d.cd_tp=l_cd_tp and d.id=t.fk_doc);

delete from c_change_docs t where t.cd_tp=l_cd_tp;

insert into c_change_docs
  (mgchange, dtek, ts, user_id, text, cd_tp)
  values (l_mg, l_dt, sysdate, uid, ' оррекци€ сальдо по закрытым л/c', l_cd_tp)
returning id into l_id;

for c in (
  select t.lsk
     from saldo_usl t where t.mg=l_mg
     and exists (select * from arch_kart k where
     k.mg=l_mg1
     and k.lsk=t.lsk and k.psch in (8,9)
     and exists (select * from s_reu_trest s where s.reu=k.reu
      and s.trest='03')
     )
     group by t.lsk
     having nvl(sum(t.summa),0)= 0
     and nvl(count(*),0) <> 0


 )
loop
  delete from temp_prep;
  insert into temp_prep
  (usl, org, summa, tp_cd)
  select t.usl, t.org, t.summa, 0 as tp_cd
     from saldo_usl t where t.mg=l_mg
     and t.lsk=c.lsk;

  --закрываем суммы сальдо
  c_prep.dist_summa;

--загружаем корректировки c обратным знаком
insert into t_corrects_payments
  (lsk, usl, org, summa, user_id, dat, mg, dopl, fk_doc, var)
  select c.lsk, t.usl, t.org, -1*t.summa, uid, l_dt, l_mg, l_mg, l_id, 0
   from temp_prep t where
     t.tp_cd in (3,4);
  commit;
end loop;

commit;
end;

procedure close_sal2 is
l_mg params.period%type;
l_dt date;
l_id c_change_docs.id%type;
l_cd_tp c_change_docs.cd_tp%type;
l_user_id t_user.id%type;
begin
--закрытие сальдо »«ћ≈Ќ≈Ќ»яћ», по условию
l_mg:= '201307';
l_dt:=to_date('20130725','YYYYMMDD');
l_cd_tp:='PAY_SAL2';
select t.id into l_user_id
 from t_user t where t.cd=user;

delete from c_change_docs t where t.cd_tp=l_cd_tp;

insert into c_change_docs
  (mgchange, dtek, ts, user_id, text, cd_tp)
  values (l_mg, l_dt, sysdate, uid, ' оррекци€ сальдо по закрытым л/c', l_cd_tp)
returning id into l_id;

for c in (
  select t.lsk
     from saldo_usl t where t.mg=l_mg
     and exists (select * from kart k where
       k.lsk=t.lsk and k.psch in (8,9)
--       and k.reu='' and k.kul=''
--       and k.nd in ('','','')
     )
     group by t.lsk
     having nvl(sum(t.summa),0)= 0
     and nvl(count(*),0) <> 0


 )
loop
  delete from temp_prep;
  insert into temp_prep
  (usl, org, summa, tp_cd)
  select t.usl, t.org, t.summa, 0 as tp_cd
     from saldo_usl t where t.mg=l_mg
     and t.lsk=c.lsk;

  --закрываем суммы сальдо
  c_prep.dist_summa;

--загружаем корректировки
insert into c_change
  (lsk, usl, org, summa, mgchange, nkom, type, dtek, ts, user_id,
   doc_id)
  select c.lsk, t.usl, t.org, t.summa, l_mg as mgchange, '999' as nkom, 0 as type,
   l_dt, sysdate, l_user_id, l_id
   from temp_prep t where
     t.tp_cd in (3,4);
  commit;
end loop;

commit;
end;

procedure close_sal3 is
l_mg params.period%type;
l_dt date;
l_id c_change_docs.id%type;
l_cd_tp c_change_docs.cd_tp%type;
l_var number;
begin
--закрытие сальдо ќѕЋј“ќ…, Ќ≈ дл€ корректировки c_deb_usl, а дл€ корректировки saldo_usl
l_mg:= '201408';
l_dt:=to_date('20140821','YYYYMMDD');
l_cd_tp:='PAY_SAL1';
l_var:=12; --12 корректировка не дл€ c_deb_usl (полыс)

delete from t_corrects_payments t where mg=l_mg
 and exists (select * from c_change_docs d where
  d.cd_tp=l_cd_tp and d.id=t.fk_doc);

delete from c_change_docs t where t.cd_tp=l_cd_tp;

insert into c_change_docs
  (mgchange, dtek, ts, user_id, text, cd_tp)
  values (l_mg, l_dt, sysdate, uid, ' оррекци€ сальдо', l_cd_tp)
returning id into l_id;

for c in (
  select distinct t.lsk --найти кредитовое сальдо (вход€щее) при наличии дебетового
     from saldo_usl t where t.mg=l_mg
     and t.summa<0 and exists
     (select * from saldo_usl s where s.mg=t.mg
       and s.lsk=t.lsk
       and s.summa>0)
 )
loop
  delete from temp_prep;
  insert into temp_prep
  (usl, org, summa, tp_cd)
  select t.usl, t.org, t.summa, 0 as tp_cd
     from saldo_usl t where t.mg=l_mg
     and t.lsk=c.lsk;

  --закрываем суммы сальдо
  c_prep.dist_summa;

--загружаем корректировки c обратным знаком
insert into t_corrects_payments
  (lsk, usl, org, summa, user_id, dat, mg, dopl, fk_doc, var)
  select c.lsk, t.usl, t.org, -1*t.summa, uid, l_dt, l_mg, l_mg, l_id, l_var
   from temp_prep t where
     t.tp_cd in (3,4);
  commit;
end loop;

--
--¬ этом периоде еще и свыше с.н. перекинуть на норму (только дл€ полыс)
/*003	004	Cодер/соц.нор.
004	004	Cодер/св.нор
005	006	Ёкспл.лифт./соц.нор.
006	006	Ёкспл.лифт./св.нор
007	008	ќтопление
008	008	ќтопление/св.нор
009	010	—одерж.лифта/соц.нор.
010	010	—одерж.лифта/св.нор
011	012	’олодна€ вода
012	012	’олодн.вода /св.нор
013	014	 анализование
014	014	 анализован /св.нор
015	016	√ор€ча€ вода
016	016	√ор€ча€ вода /св.нор
026	026	ѕлата/найм
031	046	¬ывоз “Ѕќ/соц.нор.
033	034	 ап.ремонт/соц.нор.
034	034	 ап.ремонт/св.нор.
038	039	Ёл.эн.
039	039	Ёл.эн./св.нор
046	046	¬ывоз “Ѕќ/св.нор.
052	052	ќчистка   выгр.€м/соц.нор.
053	053	ќƒЌ-Ёл.эн.
054	054	”тилизаци€
055	055	“екущий ремонт
056		ќтопление, 0 зарег.   */

/*insert into t_corrects_payments
  (lsk, usl, org, summa, user_id, dat, mg, dopl, fk_doc, var)
  select t.lsk, t.usl, t.org, t.summa, uid, l_dt, l_mg, l_mg, l_id, l_var
   from saldo_usl t, usl u where t.usl=u.usl_p and
     t.usl in ('004','006','010','034','046') and t.mg=l_mg
     and t.summa<0
  union all
  select t.lsk, u.usl, t.org, -1*t.summa, uid, l_dt, l_mg, l_mg, l_id, l_var
   from saldo_usl t, usl u where t.usl=u.usl_p and
     t.usl in ('004','006','010','034','046') and t.mg=l_mg
     and t.summa<0;
  */
  commit;
--¬ этом периоде еще и свыше с.н. перекинуть на норму (только дл€ полыс)
--

commit;
end;

--переброска сальдо по выбранной услуге, посредством проводки нулевой суммы (сальдо с кредита перейдЄт на дебет)
--ред 25.11.2014
procedure swap_sal1 is
  l_uslm usl.uslm%type;
  l_mg params.period%type;
  l_dt date;
  l_id number;
  l_oper oper.oper%type;
  l_nkom c_comps.nkom%type;
  l_org number;
begin
select p.period into l_mg from params p;
l_dt:=gdt(17,0,0); --28 числа, текущего, по params периода
l_oper:='99';
l_nkom:='999';
--например капремонт
l_uslm:='023';
l_org:=43;

--удал€етс€ 99 операци€!!!
delete from c_kwtp t where t.oper='99';

for c in (select distinct t.lsk from kart k, saldo_usl t where --k.reu in ('15', '14', '41', '11', '12')
--    and exists (select * from usl u where u.uslm = l_uslm and u.usl=t.usl)
    k.lsk=t.lsk and t.mg=to_char(l_dt, 'YYYYMM')
    and t.org=l_org
    and t.summa<0 --где есть кредитовые суммы 
    )
loop
  
  --установка нулевых сумм, автоматическое перераспределение внутри
  insert into c_kwtp
    (lsk, summa, oper, dopl, nink, nkom, dtek, nkvit, dat_ink, ts, iscorrect)
    values 
    (c.lsk, 0, l_oper, l_mg, 1, l_nkom, l_dt, 1, l_dt, sysdate, 0)
    returning id into l_id;

  insert into c_kwtp_mg
    (lsk, summa, oper, dopl, nink, nkom, dtek, nkvit, dat_ink, ts, c_kwtp_id)
  values
    (c.lsk, 0, l_oper, l_mg, 1, l_nkom, l_dt, 1, l_dt, sysdate, l_id); --is_dist=0 - распределить! (распределитс€ в триггере)

end loop;    

commit;
end;


procedure swap_payment10 is
  dopl_ c_kwtp_mg.dopl%type;
  mg_ params.period%type;
  user_id_ number;
  dat_ date;
  fk_doc_ number;
  p_reu_src kart.reu%type;
  p_reu_dst kart.reu%type;
begin
--перенос всего сальдо
-- с ”  на Ќовый ”  раз изменени€ми

--период, которым провести оплату
dopl_:='201412';
--период, сальдо по которому смотрим
mg_:='201412';
--ƒата переброски
dat_:=to_date('30122014','DDMMYYYY');

--”  источник
p_reu_src:='42';
--”  назначение
p_reu_dst:='65';

select t.id into user_id_ from t_user t where t.cd='SCOTT';

delete from t_corrects_payments t where t.mg=dopl_ 
 and exists (select * from c_change_docs d where d.id=t.fk_doc and
  d.text='ѕеренос сальдо - перерасчетом и оплатой');
delete from c_change t where
  exists (select * from c_change_docs d where d.id=t.doc_id and
  d.text='ѕеренос сальдо - перерасчетом и оплатой');

insert into c_change_docs
  (mgchange, dtek, ts, user_id, text)
values
  (dopl_, dat_, sysdate, user_id_, 'ѕеренос сальдо - перерасчетом и оплатой')
  returning id into fk_doc_;


for c in (select k.lsk, s2.org, s2.usl,
   k1.lsk as newlsk, s2.summa as summa
     from (select usl, org, lsk, sum(summa) as summa from saldo_usl where
      mg=mg_
      group by usl, org, lsk) s2, kart k, kart k1, v_lsk_tp tp
    where 
    k.reu =p_reu_src --источник-”  дл€ переброски
    and k.lsk=s2.lsk
    and k.k_lsk_id=k1.k_lsk_id
    and k1.reu =p_reu_dst  --назначение-”  дл€ переброски
    and k1.psch <> 8
    and tp.cd='LSK_TP_MAIN'
    and k1.fk_tp=tp.id)
loop

--по старым л.с.
  insert into c_change
    (lsk, usl, org, summa, user_id, dtek, mg2, mgchange, doc_id, ts)
    values
    (c.lsk, c.usl, c.org, -1*c.summa, user_id_, dat_, dopl_, dopl_, fk_doc_, sysdate);

--по новым л.с.
  insert into c_change
    (lsk, usl, org, summa, user_id, dtek, mg2, mgchange, doc_id, ts)
    values
    (c.newlsk, c.usl, c.org, c.summa, user_id_, dat_, dopl_, dopl_, fk_doc_, sysdate);

end loop;

for c in (select k.lsk, s2.org as org, s2.usl as usl,
   k1.lsk as newlsk, s2.summa as summa
     from (select t.usl, t.org, t.lsk, sum(t.summa) as summa from c_kwtp_mg m, kwtp_day t
      where to_char(t.dat_ink,'YYYYMM')=dopl_ and m.id=t.kwtp_id
      group by t.usl, t.org, t.lsk) s2, kart k, kart k1, v_lsk_tp tp
    where 
    k.reu =p_reu_src --источник-”  дл€ переброски
    and k.lsk=s2.lsk
    and k.k_lsk_id=k1.k_lsk_id
    and k1.reu =p_reu_dst  --назначение-”  дл€ переброски
    and k1.psch <> 8 
    and tp.cd='LSK_TP_MAIN'
    and k1.fk_tp=tp.id)
loop

--по старым л.с.
  insert into t_corrects_payments
    (lsk, usl, org, summa, user_id, dat, mg, dopl, fk_doc)
    values
    (c.lsk, c.usl, c.org, -1*c.summa, user_id_, dat_, dopl_, dopl_, fk_doc_);

--по новым л.с.
  insert into t_corrects_payments
    (lsk, usl, org, summa, user_id, dat, mg, dopl, fk_doc)
    values
    (c.newlsk, c.usl, c.org, c.summa, user_id_, dat_, dopl_, dopl_, fk_doc_);

end loop;

commit;

end swap_payment10;

--перенос оплаты, начислени€ на другую организацию по определенному л.с. и периоду
--с использованием xitog3_lsk!
--например дл€ переброски домов
procedure swap_sal2 is
l_mg params.period%type;
l_mg1 params.period%type;
l_mg2 params.period%type;
l_dt date;
l_user number;
l_cd_tp c_change_docs.cd_tp%type;
l_fk_doc number;
l_usl usl.usl%type;

--орг. источник - назначение
l_src number;
l_dst number;
begin
  
l_mg1:='201412';
l_mg2:='201504';
l_mg:='201505';

l_dt:=gdt(31,5,15);
l_cd_tp:='SWPSAL';

l_usl:='033';
l_src:=801;
l_dst:=801;


select t.id into l_user
  from t_user t where t.cd='SCOTT';

delete from t_corrects_payments t where t.mg=l_mg 
 and exists (select * from c_change_docs d where d.id=t.fk_doc and
  d.cd_tp=l_cd_tp);
delete from c_change t where
  exists (select * from c_change_docs d where d.id=t.doc_id and
  d.cd_tp=l_cd_tp);

delete from c_change_docs t where t.cd_tp=l_cd_tp;

insert into c_change_docs
  (mgchange, dtek, ts, user_id, cd_tp)
values
  (l_mg, l_dt, sysdate, l_user, l_cd_tp)
  returning id into l_fk_doc;


for c in (select * from kart k where k.house_id in (
    5502, 10321, 4739, 3613, 3956, 10322, 3966, 5968, 5977, 5978, 5980, 3930, 4331, 3753, 3770, 
     3755, 3759, 3765, 3754, 3771, 4300, 4296, 4402, 6761, 6762, 6763, 6764, 5081, 4299, 3774, 
     3766, 4298, 4301, 5083, 4295, 4294, 4401, 5883, 5882, 3937,  10328, 3938, 6923, 6924, 3618, 
     3987, 3984, 4867, 10661, 10345, 6921, 3589, 3614, 3612, 10323, 10324, 3953, 3590, 3609, 3965, 
     5996, 5997, 6922, 3586, 3621, 3611, 3588, 3967, 6005, 6002, 10325, 3595, 3940, 10327, 3941, 
     10326, 3958, 3581, 3615, 3585, 3979, 3968, 3591, 3954, 3606, 3622, 3946, 6361, 6421, 4692,4693,
     4694,4690,4696,4691,4697,3540,4275,3530,4701,3531,3541,3537,7021,3539,10262,10261,
      3796,3808,4276,3535,4272,4266,4262,4244,4245,4703,4247,3536,3542,4722,3456,4248,4706,10201,
      3817,10642,3474,3487,10144,10143,4267,6904,3457,3458,3471,3485,4283,10145,10146,3472,10148,
      10147,3463,3473,3464,4712,3476,4284,4713,3819,3810,3462,3797,3798,4715,4711,4699,4700,4242,
      3799,5141,4717,3543,3538,4716,4263,3466,3811,5501,3483,3465,3481,3822,3800,10142,4249,4708,
      4258,4707,6901,4259,3821,3813,3805,3814,3812,3532,3533,6902,6903,3467,3488,3816,3534,4260,
      3468,4282,4271,10641,3807,10141,3824,6241,3478,3469,4261,4265,10745, 5407, 5413, 5436, 5429, 
      5479, 5437, 4785, 5401, 5467, 5402, 5403, 5404, 5459, 5445, 5431, 5405, 5424, 5460, 5406, 
      5425, 5432, 5446, 5433, 5448, 5409, 5434, 5410, 5411, 5435, 5428, 5458, 5412, 5440, 5420, 
      5415, 5441, 5449, 5450, 5453, 5416, 5456, 5455, 5438, 5417, 5418, 5439, 5480, 5430, 5443, 
      5421, 5422, 5444, 5447, 5427, 5408, 5452, 5454, 5442, 5472, 5414, 4790, 5474, 4792, 4793, 
      4795, 4796, 4798, 4800, 4801, 4802, 5466, 5476, 4812, 5473, 4805, 5465, 5471, 5464, 4809, 
      4810, 5462, 4811, 5463, 5477, 5461, 5423, 5478, 4807, 4814, 4815, 4816, 4819, 6121, 6123, 
      6126, 6128, 6129, 10746, 4788
  )) --<-- здесь определить id домов
  loop
    insert into t_corrects_payments
      (lsk, usl, org, summa, user_id, dat, mg, dopl, fk_doc, var)
       select t.lsk, t.usl, t.org, -1*nvl(t.payment,0), l_user, l_dt, l_mg, t.mg as dopl, l_fk_doc, null as var
            from xitog3_lsk t where t.mg between l_mg1 and l_mg2
            and t.lsk=c.lsk and t.usl=l_usl
            and t.org=l_src ;
    insert into t_corrects_payments
      (lsk, usl, org, summa, user_id, dat, mg, dopl, fk_doc, var)
       select t.lsk, t.usl, l_dst as org, nvl(t.payment,0), l_user, l_dt, l_mg, t.mg as dopl, l_fk_doc, null as var
            from xitog3_lsk t where t.mg between l_mg1 and l_mg2
            and t.lsk=c.lsk and t.usl=l_usl
            and t.org=l_src;

    insert into c_change
      (lsk, usl, org, summa, mgchange, nkom, dtek, ts, user_id, doc_id, mg2)
       select t.lsk, t.usl, t.org, -1*(nvl(t.charges,0)+nvl(t.changes,0)) as summa, t.mg, '999' as nkom,
           l_dt, sysdate, l_user, l_fk_doc, t.mg
            from xitog3_lsk t where t.mg between l_mg1 and l_mg2
            and t.lsk=c.lsk and t.usl=l_usl
            and t.org=l_src;

    insert into c_change
      (lsk, usl, org, summa, mgchange, nkom, dtek, ts, user_id, doc_id, mg2)
       select t.lsk, t.usl, l_dst as org, (nvl(t.charges,0)+nvl(t.changes,0)) as summa, t.mg, '999' as nkom,
           l_dt, sysdate, l_user, l_fk_doc, t.mg
            from xitog3_lsk t where t.mg between l_mg1 and l_mg2
            and t.lsk=c.lsk and t.usl=l_usl
            and t.org=l_src;

  end loop;         

commit;
end;

--перенос оплаты, начислени€ с доп л.с. на доп л.с. другой компании
--с использованием xitog3_lsk!
--дл€ отмены переброски, сделанной в марте
procedure swap_sal3 is
l_mg params.period%type;
l_mg1 params.period%type;
l_mg2 params.period%type;
l_dt date;
l_user number;
l_cd_tp c_change_docs.cd_tp%type;
l_fk_doc number;
l_usl usl.usl%type;

begin
  
l_mg1:='201412';
l_mg2:='201508';
l_mg:='201509';

l_dt:=gdt(30,9,15); --дата проводки
l_cd_tp:='SWPSAL2'; --маркер проводки

l_usl:='033';


select t.id into l_user
  from t_user t where t.cd='SCOTT';

delete from t_corrects_payments t where t.mg=l_mg 
 and exists (select * from c_change_docs d where d.id=t.fk_doc and
  d.cd_tp=l_cd_tp);
delete from c_change t where
  exists (select * from c_change_docs d where d.id=t.doc_id and
  d.cd_tp=l_cd_tp);

delete from c_change_docs t where t.cd_tp=l_cd_tp;

insert into c_change_docs
  (mgchange, dtek, ts, user_id, cd_tp)
values
  (l_mg, l_dt, sysdate, l_user, l_cd_tp)
  returning id into l_fk_doc;

for c in (select k.lsk as lsk_old, k2.lsk as lsk_new
    from kart k, kart k2, v_lsk_tp tp1, v_lsk_tp tp2
    where k.house_id in (
    10981)
    and k.k_lsk_id=k2.k_lsk_id
    and k.psch = 8 and k.fk_tp=tp1.id and tp1.cd='LSK_TP_ADDIT' --с закрытого доп.
    and k2.psch <> 8 and k2.fk_tp=tp2.id and tp2.cd='LSK_TP_ADDIT' --на открытый доп.
  ) --<-- здесь определить id домов
  loop

/*    insert into t_corrects_payments
      (lsk, usl, org, summa, user_id, dat, mg, dopl, fk_doc, var)
       select t.lsk, t.usl, t.org, -1*nvl(t.summa,0), l_user, l_dt, l_mg, t.dopl as dopl, l_fk_doc, null as var
            from a_kwtp_day t where t.mg ='201503'
            and t.lsk in (c.lsk_old, c.lsk_new) and t.usl=l_usl
            and t.oper='99' and t.dtek=gdt(30,3,15);*/

    --оплата в архиве, кроме текущей
    insert into t_corrects_payments
      (lsk, usl, org, summa, user_id, dat, mg, dopl, fk_doc, var)
       select t.lsk, t.usl, t.org, -1*nvl(t.summa,0), l_user, l_dt, l_mg, t.dopl as dopl, l_fk_doc, null as var
            from a_kwtp_day t where t.mg between l_mg1 and l_mg2 and t.mg<>l_mg
            and t.lsk=c.lsk_old and t.usl=l_usl
            and t.oper<>'99';
    insert into t_corrects_payments
      (lsk, usl, org, summa, user_id, dat, mg, dopl, fk_doc, var)
       select c.lsk_new, t.usl, t.org as org, nvl(t.summa,0), l_user, l_dt, l_mg, t.dopl as dopl, l_fk_doc, null as var
            from a_kwtp_day t where t.mg between l_mg1 and l_mg2 and t.mg<>l_mg
            and t.lsk=c.lsk_old and t.usl=l_usl
            and t.oper<>'99';

    --текуща€ оплата        
    insert into t_corrects_payments
      (lsk, usl, org, summa, user_id, dat, mg, dopl, fk_doc, var)
       select t.lsk, t.usl, t.org, -1*nvl(t.summa,0), l_user, l_dt, l_mg, t.dopl as dopl, l_fk_doc, null as var
            from kwtp_day t where t.lsk=c.lsk_old and t.usl=l_usl
            and t.oper<>'99' and to_char(t.dtek,'YYYYMM')=l_mg;
    insert into t_corrects_payments
      (lsk, usl, org, summa, user_id, dat, mg, dopl, fk_doc, var)
       select c.lsk_new, t.usl, t.org as org, nvl(t.summa,0), l_user, l_dt, l_mg, t.dopl as dopl, l_fk_doc, null as var
            from kwtp_day t where t.lsk=c.lsk_old and t.usl=l_usl
            and t.oper<>'99' and to_char(t.dtek,'YYYYMM')=l_mg;

    insert into c_change
      (lsk, usl, org, summa, mgchange, nkom, dtek, ts, user_id, doc_id, mg2)
       select t.lsk, t.usl, t.org, -1*(nvl(t.charges,0)) as summa, t.mg, '999' as nkom,
           l_dt, sysdate, l_user, l_fk_doc, t.mg
            from xitog3_lsk t where t.mg between l_mg1 and l_mg2
            and t.lsk=c.lsk_old and t.usl=l_usl
            ;

    insert into c_change
      (lsk, usl, org, summa, mgchange, nkom, dtek, ts, user_id, doc_id, mg2)
       select c.lsk_new, t.usl, t.org as org, (nvl(t.charges,0)) as summa, t.mg, '999' as nkom,
           l_dt, sysdate, l_user, l_fk_doc, t.mg
            from xitog3_lsk t where t.mg between l_mg1 and l_mg2
            and t.lsk=c.lsk_old and t.usl=l_usl
            ;

  end loop;         

commit;
end;

--переброска сальдо (деб и кредит) перерасчетом
procedure swap_sal4 is
  mgchange_ c_change.mgchange%type;
  comment_ c_change_docs.text%type;
  mg_ params.period%type;
  user_id_ number;
  cd_ c_change_docs.text%type;
  l_id number;
begin

--период, которым провести изменени€
mgchange_:='201504';
--период, сальдо по которому смотрим переплату
mg_:='201504';
--комментарий
comment_:='ѕереброска кред/деб сальдо на ”  ';
--”никальный номер переброски
cd_:='20150430';

select t.id into user_id_ from t_user t where t.cd='SCOTT';
select changes_id.nextval into l_id from dual;

delete from c_change t where t.user_id=user_id_
 and exists (select * from
 c_change_docs d where d.user_id=user_id_ and d.text=cd_ and d.id=t.doc_id);
delete from c_change_docs t where t.user_id=user_id_ and t.text=cd_;

insert into c_change_docs (id, mgchange, dtek, ts, user_id, text)
select l_id as id, mgchange_, trunc(sysdate), sysdate, user_id_, cd_
 from dual;

--перенос сальдо с ”  на Ќовый ”  »«ћ≈Ќ≈Ќ»яћ»!!!
for c in (select k.lsk, k1.lsk as newlsk, s2.usl, s2.summa as summa,
     mgchange_ as mgchange
     from (select lsk, sum(summa) as summa from saldo_usl where
      mg=mg_
      group by lsk) s,(select usl, lsk, sum(summa) as summa from saldo_usl where
      mg=mg_
      group by usl, lsk) s2, kart k, kart k1
    where exists
    (select * from work_houses w where w.newreu in ('17') --список новых ”  дл€ переброски
     and w.id=k.house_id)
    and k.lsk=s.lsk
    and k.lsk=s2.lsk
    and k.k_lsk_id=k1.k_lsk_id
    and k1.psch <> 8
    and s.summa <> 0
    order by k1.lsk)
loop

--по старым л.с.
insert into c_change (lsk, usl, summa, mgchange, type, dtek, ts,
user_id, doc_id)
select c.lsk, c.usl, -1*c.summa as summa,
 c.mgchange, 1, trunc(sysdate), sysdate, user_id_, l_id
 from dual;

--по новым л.с.
insert into c_change (lsk, usl, summa, mgchange, type, dtek, ts,
user_id, doc_id)
select c.newlsk, c.usl, c.summa as summa,
 c.mgchange, 1, trunc(sysdate), sysdate, user_id_, l_id
 from dual;

end loop;
commit;

end swap_sal4;

--переброска сальдо, с распределением дебетового по периодам задолжности
procedure swap_sal_chpay is
 l_mg params.period%type;
 l_mg2 params.period%type;
 l_mg3 params.period%type;
 l_user number;
 l_id number;
 l_cd c_change_docs.text%type;
 l_mgchange c_change_docs.mgchange%type;
 l_dt date;
begin

--ѕ–ќ÷≈ƒ”–ј ¬–≈ћ≈ЌЌќ Ќ≈ »—ѕќЋ№«”≈“—я (передумал примен€ть!)
Raise_application_error(-20000, 'ѕ–ќ÷≈ƒ”–ј ¬–≈ћ≈ЌЌќ Ќ≈ »—ѕќЋ№«”≈“—я');
  l_mg:='201505'; --тек.период
  l_mg2:=utils.add_months_pr(l_mg,-1); --мес€ц назад
  l_mg3:=utils.add_months_pr(l_mg,1); --мес€ц вперед
  l_cd:='swap_sal_chpay';
  l_mgchange:=l_mg;
  l_dt:=to_date('20150531','YYYYMMDD');

  select t.id into l_user from t_user t where t.cd='SCOTT';
  select changes_id.nextval into l_id from dual;

  delete from c_change t where t.user_id=l_user
   and exists (select * from
  c_change_docs d where d.user_id=l_user and d.text=l_cd and d.id=t.doc_id);
   delete from c_change_docs t where t.user_id=l_user and t.text=l_cd;

  insert into c_change_docs (id, mgchange, dtek, ts, user_id, text)
   select l_id as id, l_mgchange, l_dt, sysdate, l_user, l_cd
   from dual;
 
 for c in (select k.lsk as lsk_old, k2.lsk as lsk_new from kart k
    join kart k2 on k.lsk='12012885' and k.k_lsk_id=k2.k_lsk_id and k.reu='12' and k2.reu='86'
      and k2.psch not in (8,9)
    join v_lsk_tp tp on k.fk_tp=k2.fk_tp and k.fk_tp=tp.id and tp.cd='LSK_TP_MAIN'
                  ) 
 loop
    
  delete from temp_prep;
  insert into temp_prep
  (usl, org, summa, tp_cd)
  select t.usl, t.org, -1*t.summa, 0 as tp_cd
     from saldo_usl t where t.mg=l_mg
     and t.lsk=c.lsk_old and t.summa>0; --дебет.сальдо

/*  insert into temp_prep
  (mg, summa, tp_cd)
  select t.mg, sum(decode(t.type,0,t.summa,-1*t.summa)) as summa, 0 as tp_cd
     from c_chargepay t where t.period='201503'
     and t.lsk=c.lsk_old
     group by t.mg
     having sum(decode(t.type,0,t.summa,-1*t.summa))>0;*/

  insert into temp_prep
  (mg, summa, tp_cd)
  select a.mg, sum(summa), a.tp_cd from (
  select t.mg1 as mg, summa, 0 as tp_cd from a_penya t 
   where t.lsk=c.lsk_old
   and t.mg=l_mg--l_mg2
   union all
  select l_mg, -1*t.summa, 0 as tp_cd --убрать кредит сальдо, чтоб перенести потом отдельно
     from saldo_usl t where t.mg=l_mg3
     and t.lsk=c.lsk_old and t.summa<0) a
     group by a.mg, a.tp_cd
     having sum(summa)>0;  

  --закрываем суммы сальдо
  c_prep.dist_summa2;
 
  --по старым л.с. - сн€тие
  insert into c_change (lsk, usl, org, summa, mgchange, type, dtek, ts,
  user_id, doc_id)
  select c.lsk_old, t.usl, t.org, sum(t.summa), t.mg, 1 as type, l_dt,
   sysdate, l_user, l_id from temp_prep t where t.tp_cd in (3,4)
  group by t.mg, t.org, t.usl
  having sum(t.summa)<0; 

  --по новым л.с. - установка
  insert into c_change (lsk, usl, org, summa, mgchange, type, dtek, ts,
  user_id, doc_id)
  select c.lsk_new, t.usl, t.org, -1*sum(t.summa), t.mg, 1 as type, l_dt,
   sysdate, l_user, l_id from temp_prep t where t.tp_cd in (3,4)
  group by t.mg, t.org, t.usl
  having sum(t.summa)<0; 
  
  --кредитовое сальдо - только в текущий период
  
  --по старым л.с. - сн€тие
  insert into c_change (lsk, usl, org, summa, mgchange, type, dtek, ts,
    user_id, doc_id)
  select c.lsk_old, t.usl, t.org, -1*t.summa, l_mg, 1 as type, l_dt,
     sysdate, l_user, l_id 
     from saldo_usl t where t.mg=l_mg3--l_mg
     and t.lsk=c.lsk_old and t.summa<0; --кредит.сальдо
  
  --по новым л.с. - установка
  insert into c_change (lsk, usl, org, summa, mgchange, type, dtek, ts,
    user_id, doc_id)
  select c.lsk_new, t.usl, t.org, t.summa, l_mg, 1 as type, l_dt,
     sysdate, l_user, l_id 
     from saldo_usl t where t.mg=l_mg3--l_mg
     and t.lsk=c.lsk_old and t.summa<0; --кредит.сальдо
 end loop;
 
commit; 
end swap_sal_chpay;


--ѕереброска всего итогового сальдо (исх.на текущий период) на новый ” 
--¬Ќ»ћјЌ»≈! ќб€зательно сформировать оборотку ƒќ
procedure swap_sal_chpay2 is
 l_mg params.period%type;
 l_mg2 params.period%type;
 l_mg3 params.period%type;
 l_user number;
 l_id number;
 l_cd c_change_docs.text%type;
 l_mgchange c_change_docs.mgchange%type;
 l_dt date;
begin
  l_mg:='201505'; --тек.период
  l_mg2:=utils.add_months_pr(l_mg,-1); --мес€ц назад
  l_mg3:=utils.add_months_pr(l_mg,1); --мес€ц вперед
  l_cd:='swap_sal_chpay';
  l_mgchange:=l_mg;
  l_dt:=to_date('20150531','YYYYMMDD');

  select t.id into l_user from t_user t where t.cd='SCOTT';
  select changes_id.nextval into l_id from dual;

  delete from c_change t where t.user_id=l_user
   and exists (select * from
  c_change_docs d where d.user_id=l_user and d.text=l_cd and d.id=t.doc_id);
   delete from c_change_docs t where t.user_id=l_user and t.text=l_cd;

  insert into c_change_docs (id, mgchange, dtek, ts, user_id, text)
   select l_id as id, l_mgchange, l_dt, sysdate, l_user, l_cd
   from dual;
 
 for c in (select k.lsk as lsk_old, k2.lsk as lsk_new from kart k
    join kart k2 on k.k_lsk_id=k2.k_lsk_id and k.reu in ('12','41') and k2.reu in ('86','85')
      and k2.psch not in (8,9)
    join v_lsk_tp tp on k.fk_tp=k2.fk_tp and k.fk_tp=tp.id and tp.cd='LSK_TP_MAIN'
                  ) 
 loop
    
  --по старым л.с. - сн€тие
  insert into c_change (lsk, usl, org, summa, mgchange, type, dtek, ts,
    user_id, doc_id)
  select c.lsk_old, t.usl, t.org, -1*t.summa, l_mg, 1 as type, l_dt,
     sysdate, l_user, l_id 
     from saldo_usl t where t.mg=l_mg3--l_mg
     and t.lsk=c.lsk_old
     and t.usl in ('003','004','035','036','019','047'); 
  
  --по новым л.с. - установка
  insert into c_change (lsk, usl, org, summa, mgchange, type, dtek, ts,
    user_id, doc_id)
  select c.lsk_new, t.usl, t.org, t.summa, l_mg, 1 as type, l_dt,
     sysdate, l_user, l_id 
     from saldo_usl t where t.mg=l_mg3--l_mg
     and t.lsk=c.lsk_old 
     and t.usl in ('003','004','035','036','019','047'); 
 end loop;
 
commit; 
end swap_sal_chpay2;

--ѕереброска всего выборочного итогового сальдо (исх.на текущий период) на новый ”  по определенной услуге!
--¬Ќ»ћјЌ»≈! ќб€зательно сформировать оборотку ƒќ
procedure swap_sal_chpay3 is
 l_mg params.period%type;
 l_mg2 params.period%type;
 l_mg3 params.period%type;
 l_user number;
 l_id number;
 l_cd c_change_docs.text%type;
 l_mgchange c_change_docs.mgchange%type;
 l_dt date;
begin
  l_mg:='201506'; --тек.период
  l_mg2:=utils.add_months_pr(l_mg,-1); --мес€ц назад
  l_mg3:=utils.add_months_pr(l_mg,1); --мес€ц вперед
  l_cd:='swap_sal_chpay2';
  l_mgchange:=l_mg;
  l_dt:=to_date('20150630','YYYYMMDD');

  select t.id into l_user from t_user t where t.cd='SCOTT';
  select changes_id.nextval into l_id from dual;

  delete from c_change t where t.user_id=l_user
   and exists (select * from
  c_change_docs d where d.user_id=l_user and d.text=l_cd and d.id=t.doc_id);
   delete from c_change_docs t where t.user_id=l_user and t.text=l_cd;

  insert into c_change_docs (id, mgchange, dtek, ts, user_id, text)
   select l_id as id, l_mgchange, l_dt, sysdate, l_user, l_cd
   from dual;
 
 for c in (select k.lsk as lsk_old, k2.lsk as lsk_new from kart k
    join kart k2 on k.k_lsk_id=k2.k_lsk_id and k.reu in ('12','41') and k2.reu in ('86','85')
      and k2.psch not in (8,9)
    join v_lsk_tp tp on k.fk_tp=k2.fk_tp and k.fk_tp=tp.id and tp.cd='LSK_TP_MAIN'
    join (select * from saldo_usl s where s.mg=l_mg3 and s.usl='033' and s.summa<0
                 and exists (select s2.lsk, sum(s2.summa) from saldo_usl s2 where s2.lsk=s.lsk and s2.mg=s.mg
                              group by s2.lsk
                              having sum(s2.summa)<0) --если кредитовое сальдо по капрем, а так же кредитовое вообще по всему счету
                                                      --то - перенести
                  ) a on k.lsk=a.lsk)
 loop
    
  --по старым л.с. - сн€тие
  insert into c_change (lsk, usl, org, summa, mgchange, type, dtek, ts,
    user_id, doc_id)
  select c.lsk_old, t.usl, t.org, -1*t.summa, l_mg, 1 as type, l_dt,
     sysdate, l_user, l_id 
     from saldo_usl t where t.mg=l_mg3--l_mg
     and t.lsk=c.lsk_old
     and t.usl in ('033','034');
  
  --по новым л.с. - установка
  insert into c_change (lsk, usl, org, summa, mgchange, type, dtek, ts,
    user_id, doc_id)
  select c.lsk_new, t.usl, t.org, t.summa, l_mg, 1 as type, l_dt,
     sysdate, l_user, l_id 
     from saldo_usl t where t.mg=l_mg3--l_mg
     and t.lsk=c.lsk_old
     and t.usl in ('033','034');
 end loop;
 
commit; 
end swap_sal_chpay3;
end scripts;
/

prompt
prompt Creating package body STAT
prompt ==========================
prompt
CREATE OR REPLACE PACKAGE BODY SCOTT.stat IS
  PROCEDURE rep_stat(reu_           IN VARCHAR2,
                     kul_           IN VARCHAR2,
                     nd_            IN VARCHAR2,
                     trest_         IN VARCHAR2,
                     mg_            IN VARCHAR2,
                     mg1_           IN VARCHAR2,
                     dat_           IN DATE,
                     dat1_          IN DATE,
                     var_           IN NUMBER, --уровень информации
                     det_           IN NUMBER, --детализаци€ информации
                     org_           IN NUMBER,
                     oper_           IN VARCHAR2,
                     сd_            IN VARCHAR2, --CD отчета
                     spk_id_        IN NUMBER,
                     p_house        IN NUMBER,   --ID дома
                     p_out_tp       IN NUMBER,   --тип выгрузки (null- в реф-курсор, 1-в текстовый файл в дир по умолчанию)
                     prep_refcursor IN OUT rep_refcursor) IS

    sqlstr_ VARCHAR2(2000);
    sqlstr2_ VARCHAR2(2000);
    sqlstr3_ VARCHAR2(2000);
    l_sql VARCHAR2(2000); --дл€ хранени€ полного текста запроса
    period_ varchar2(55);
    uslg_ usl.uslg%type;
    mg2_ params.period%type;
    l_mg_next params.period%type;
    dat2_ date;
    dat3_ date;
    n1_   NUMBER;
    n2_   NUMBER;
    kpr1_   NUMBER;
    kpr2_   NUMBER;
    show_sal_ number;
    cur_pay_ number;
    gndr_ number;
    prop_ number;
    show_fond_ number;
    fk_ses_ number;
    l_dt date;
    l_dt1 date;
    l_in_period number;
    l_out_period number;
    l_cur_period params.period%type;
    l_prev_period params.period%type;
    l_cnt number;
    l_sel varchar2(256);
--    TYPE l_cur_type IS REF CURSOR;
--    l_cur sys_refcursor;
/*    TYPE l_rec_type IS RECORD ( fld1 VARCHAR2(100),
                                fld2 VARCHAR2(100),
                                fld3 VARCHAR2(100),
                                fld4 VARCHAR2(100),
                                fld5 VARCHAR2(100),
                                fld6 VARCHAR2(100),
                                fld7 VARCHAR2(100),
                                fld8 VARCHAR2(100),
                                fld9 VARCHAR2(100),
                                fld10 VARCHAR2(100),
                                fld11 VARCHAR2(100),
                                fld12 VARCHAR2(100)
                                  );*/
--    l_rec l_cur%ROWTYPE;
    BEGIN
    select USERENV('sessionid') into fk_ses_ from dual;
    select period into l_cur_period from params;
    --вычислить первую и последнюю даты заданных периодов, дл€ оптимизации запросов.
    if mg_ is not null then
      l_dt:=to_date(mg_||'01','YYYYMMDD');
    end if;
    if mg1_ is not null then
      l_dt1:=last_day(to_date(mg1_||'01','YYYYMMDD'));
    end if;
    --¬ычисл€ем передыдущ мес€ц
    if mg_ is not null then
      l_prev_period := to_char(add_months(to_date(mg_ || '01', 'YYYYMMDD'), -1),
                      'YYYYMM');
    end if;
    --¬ычисл€ем следующий мес€ц
    if mg_ is not null then
      l_mg_next := to_char(add_months(to_date(mg_ || '01', 'YYYYMMDD'), 1),
                      'YYYYMM');
    end if;
    --узнать находитс€ ли заданные даты отчета в текущем периоде
    select case when not l_dt between to_date(p.period||'01','YYYYMMDD')
       and last_day(to_date(p.period||'01','YYYYMMDD'))
       or
       not l_dt1 between to_date(p.period||'01','YYYYMMDD')
         and last_day(to_date(p.period||'01','YYYYMMDD')) then 1
       else 0
       end,
       case when l_dt between to_date(p.period||'01','YYYYMMDD')
       and last_day(to_date(p.period||'01','YYYYMMDD'))
       or
         l_dt1 between to_date(p.period||'01','YYYYMMDD')
         and last_day(to_date(p.period||'01','YYYYMMDD')) then 1
       else 0
       end into l_out_period, l_in_period
     from params p;

    if dat_ is not null and dat1_ is not null then
      sqlstr_ := 's.dat between TO_DATE(''' || TO_CHAR(dat_, 'DDMMYYYY') ||
                 ''',''DDMMYYYY'') and TO_DATE(''' || TO_CHAR(dat1_, 'DDMMYYYY') ||
                 ''',''DDMMYYYY'')';
    --¬есьма извращенно передавать из курсора такой объем статичной информации
      period_:='с '||to_char(dat_,'DD.MM.YYYY')||' по '||to_char(dat1_,'DD.MM.YYYY');
      sqlstr3_ := 'd.dat between TO_DATE(''' || TO_CHAR(dat_, 'DDMMYYYY') ||
                 ''',''DDMMYYYY'') and TO_DATE(''' || TO_CHAR(dat1_, 'DDMMYYYY') ||
                 ''',''DDMMYYYY'')';
      sqlstr2_ := 's.period between ''' || to_char(dat_, 'YYYYMM') || ''' and ''' || to_char(dat_, 'YYYYMM')||'''';
    elsif dat_ is not null and dat1_ is null then
      sqlstr_ := 's.dat = TO_DATE('' ' || TO_CHAR(dat_, 'DDMMYYYY') ||
                 ' '',''DDMMYYYY'')';
    --¬есьма извращенно передавать из курсора такой объем статичной информации
      period_:='с '||to_char(dat_,'DD.MM.YYYY')||' по '||to_char(dat1_,'DD.MM.YYYY');
      sqlstr3_ := 'd.dat between TO_DATE(''' || TO_CHAR(dat_, 'DDMMYYYY') ||
                 ''',''DDMMYYYY'') and TO_DATE(''' || TO_CHAR(dat1_, 'DDMMYYYY') ||
                 ''',''DDMMYYYY'')';
      sqlstr2_ := 's.period between ''' || to_char(dat_, 'YYYYMM') || ''' and ''' || to_char(dat_, 'YYYYMM')||'''';
    else
    --¬есьма извращенно передавать из курсора такой объем статичной информации
      if mg_ = mg1_ then
        period_:=utils.month_name(substr(mg_, 5, 2))||' '||substr(mg_,1,4)||'г.';
      else
        period_:='с '||utils.month_name1(substr(mg_, 5, 2))||' '||substr(mg_,1,4)||'г.'||' по '||utils.month_name(substr(mg1_, 5, 2))||' '||substr(mg_,1,4)||'г.';
      end if;
      sqlstr_ := 's.mg between ''' || mg_ || ''' and ''' || mg1_||'''';
      sqlstr2_ := 's.period between ''' || mg_ || ''' and ''' || mg1_||'''';
      sqlstr3_ := 'd.mg between ''' || mg_ || ''' and ''' || mg1_||'''';
    end if;

    IF сd_ = '22' THEN
    --—татистика по долгам
     IF var_ = 3 THEN
        --ѕо дому
        OPEN prep_refcursor FOR 'select t.trest||'' ''||t.name_tr as predp, d.reu,
     d.reu||d.kul||d.nd||'' ''||k.name||'', ''||NVL(LTRIM(d.nd,''0''),''0'') AS predpr_det,
     LTRIM(d.kw,''0'') AS kw, substr(d.mg, 1, 4)||''-''||substr(d.mg, 5, 2) AS mg, d.summa,d.dat,SUBSTR(''000''||d.kol_month,-3) AS kol_month
     FROM DEBITS_KW d, S_REU_TREST t, SPUL k
     WHERE d.reu=t.reu
     AND d.kul=k.id
     AND d.reu=:reu_
     AND d.kul=:kul_
     AND d.nd=:nd_
     AND  d.dat BETWEEN :dat_ AND :dat1_  ORDER BY d.mg DESC'
           USING reu_, kul_, nd_,dat_,dat1_;
       ELSIF var_ = 2 THEN
        --ѕо –Ё”
        OPEN prep_refcursor FOR 'select t.trest||'' ''||t.name_tr as predp, d.reu,
     d.reu||d.kul||d.nd||'' ''||k.name||'', ''||NVL(LTRIM(d.nd,''0''),''0'') AS predpr_det,
     NULL AS kw, substr(d.mg, 1, 4)||''-''||substr(d.mg, 5, 2) AS mg, summa,d.dat,SUBSTR(''000''||d.kol_month,-3) AS kol_month
     FROM DEBITS_HOUSES d, S_REU_TREST t, SPUL k
     WHERE d.reu=t.reu
     AND d.kul=k.id
     AND t.reu=:reu_
     AND d.dat BETWEEN :dat_ AND :dat1_ ORDER BY d.mg DESC'
           USING reu_,dat_,dat1_;
       ELSIF var_ = 1 THEN
        --ѕо ∆Ёќ
        OPEN prep_refcursor FOR 'select t.trest||'' ''||t.name_tr as predp, d.reu, null as predpr_det,
     NULL AS kw, substr(d.mg, 1, 4)||''-''||substr(d.mg, 5, 2) AS mg, d.summa,d.dat,SUBSTR(''000''||d.kol_month,-3) AS kol_month
     FROM DEBITS_TREST d, S_REU_TREST t
     WHERE d.reu=t.reu
     AND t.trest=:trest_
     AND d.dat BETWEEN :dat_ AND :dat1_ ORDER BY d.mg DESC'
          USING trest_,dat_,dat1_;
      ELSIF var_ = 0 THEN
        --ѕо ћѕ ”≈«∆ ” (все тресты)
        OPEN prep_refcursor FOR 'select t.trest||'' ''||t.name_tr as predp, d.reu, null as predpr_det,
     NULL AS kw,substr(d.mg, 1, 4)||''-''||substr(d.mg, 5, 2) AS mg,summa,d.dat,SUBSTR(''000''||d.kol_month,-3) AS kol_month
     FROM DEBITS_TREST d, S_REU_TREST t
     WHERE d.reu=t.reu
     AND d.dat BETWEEN :dat_ AND :dat1_ ORDER BY d.mg DESC'
     USING dat_,dat1_;
     END IF;

    ELSIF сd_ = '13' THEN
      --—татистика по услугам
   IF det_ = 3 then
     kpr1_:=utils.getS_int_param('REP_RNG_KPR1');
     kpr2_:=utils.getS_int_param('REP_RNG_KPR2');
--Raise_application_error(-20000, kpr1_||'-'||kpr2_);
   --детализаци€ до квартир
        OPEN prep_refcursor FOR 'select s.org, coalesce(r.fk_org_dst,s.org) as fk_org2, u.uslm, s.usl, s.kul,
    t.trest, s.reu, k.name,
    k.name||'', ''||NVL(LTRIM(s.nd,''0''),''0'')||''-''||NVL(LTRIM(kw,''0''),''0'') AS predpr_det,
    utils.f_order(s.nd,6) as ord1, utils.f_order2(s.nd) as ord3, utils.f_order(s.kw,7) as ord2,
    null as fio,
    s.status, s.psch as psch,
    s.sch as sch, s.val_group, s.val_group2,
    s.cnt AS cnt, s.klsk AS klsk, s.kpr AS kpr, decode(s.is_empt,1,''да'',0,''нет'', null) as is_empt, s.kpr_ot AS kpr_ot,
    s.kpr_wr AS kpr_wr, s.cnt_lg AS cnt_lg, s.cnt_subs AS cnt_subs, s.cnt_room, s.uch,
    substr(s.mg, 1, 4)||''-''||substr(s.mg, 5, 2) as mg1,
    u.npp,
    null as name_gr, null as odpu_ex, 0 as odpu_kub, tp.name as lsk_tp, s.opl, s.is_vol
    FROM STATISTICS_LSK s 
         join USL u on s.USL=u.USL 
         join S_REU_TREST t on s.reu=t.reu
         join SPUL k on s.kul=k.id
         join v_lsk_tp tp on s.fk_tp=tp.id
         left join redir_pay r on s.org=r.fk_org_src and s.mg between r.mg1 and r.mg2
         --join t_org o on coalesce(r.fk_org_dst,s.org)=o.id
    WHERE
    exists
       (select * from list_c i, spr_params p where i.fk_ses=:fk_ses_
            and p.id=i.fk_par and p.cd=''REP_USL''
            and i.sel_cd=s.usl
        and i.sel=1)
    and exists
       (select * from list_c i, spr_params p where i.fk_ses=:fk_ses_
            and p.id=i.fk_par and p.cd=''REP_STATUS''
            and i.sel_id=s.status
        and i.sel=1)
    and ((:var_=3 and
           s.reu = :reu_
           and s.kul = :kul_
           and s.nd = :nd_)
          or (:var_=2 and s.reu=:reu_)
          or (:var_=1 and t.trest=:trest_)
          or :var_=0)
    and exists
    (select * from statistics_lsk st, usl ut where st.lsk=s.lsk and st.mg=s.mg and
       st.usl=ut.usl and ut.uslm=u.uslm
       and (:kpr1_ is not null and st.kpr >=:kpr1_ or :kpr1_ is null)
       and (:kpr2_ is not null and st.kpr <=:kpr2_ or :kpr2_ is null)
      )
    AND ' || sqlstr_ || '
    union all
    select null as org, null as fk_org2, ''000'' as uslm, ''000'' as usl, s.kul,
    t.trest, s.reu, k.name,
    k.name||'', ''||NVL(LTRIM(s.nd,''0''),''0'')||''-''||NVL(LTRIM(kw,''0''),''0'') AS predpr_det,
    utils.f_order(s.nd,6) as ord1, utils.f_order2(s.nd) as ord3, utils.f_order(s.kw,7) as ord2,
    s.fio as fio,
    s.status, s.psch as psch,
    s.sch as sch, s.val_group, s.val_group2,
    s.cnt AS cnt, s.klsk AS klsk, s.kpr AS kpr, decode(s.is_empt,1,''да'',0,''нет'', null) as is_empt, s.kpr_ot AS kpr_ot,
    s.kpr_wr AS kpr_wr, s.cnt_lg AS cnt_lg, s.cnt_subs AS cnt_subs, s.cnt_room, s.uch,
    substr(s.mg, 1, 4)||''-''||substr(s.mg, 5, 2) as mg1,
    null as npp,
    null as name_gr, null as odpu_ex, 0 as odpu_kub, tp.name as lsk_tp, s.opl, s.is_vol
    FROM STATISTICS_LSK s, S_REU_TREST t, SPUL k, v_lsk_tp tp
    WHERE s.reu=t.reu and s.fk_tp=tp.id(+)
    AND s.USL is null
    AND s.kul=k.id
    and exists
       (select * from list_c i, spr_params p where i.fk_ses=:fk_ses_
            and p.id=i.fk_par and p.cd=''REP_USL''
            and i.sel_cd=''0'' --¬ключить ли »“ќ√?
        and i.sel=1)
    and exists
       (select * from list_c i, spr_params p where i.fk_ses=:fk_ses_
            and p.id=i.fk_par and p.cd=''REP_STATUS''
            and i.sel_id=s.status
        and i.sel=1)
    and ((:var_=3 and
           s.reu = :reu_
           and s.kul = :kul_
           and s.nd = :nd_)
          or (:var_=2 and s.reu=:reu_)
          or (:var_=1 and t.trest=:trest_)
          or :var_=0)
    --неоднозначность кака€ то... если по услугам то фильтр по кол-ву прожив один, а если по итогам - по другому принципу...
    and (:kpr1_ is not null and s.kpr >=:kpr1_ or :kpr1_ is null)
    and (:kpr2_ is not null and s.kpr <=:kpr2_ or :kpr2_ is null)
    AND ' || sqlstr_||' order by name, ord1, ord3, ord2' --не убирайте пожалста пор€док сортировки и если что сделайте дополнительный селект сверху select * from () order by ord1, ord2
    USING fk_ses_, fk_ses_, var_, reu_, kul_, nd_, var_, reu_, var_, trest_, var_,
     kpr1_, kpr1_, kpr1_, kpr2_, kpr2_, kpr2_,
     fk_ses_, fk_ses_, var_, reu_, kul_, nd_, var_, reu_, var_, trest_, var_,
     kpr1_, kpr1_, kpr1_, kpr2_, kpr2_, kpr2_;
    ELSIF det_ = 2 then
   --детализаци€ до домов
        OPEN prep_refcursor FOR 'select s.org, coalesce(r.fk_org_dst,s.org) as fk_org2, s.uslm, s.usl,
        s.kul,
    t.trest, s.reu, k.name,
    k.name||'', ''||NVL(LTRIM(s.nd,''0''),''0'') AS predpr_det,
    utils.f_order(s.nd,6) as ord1, utils.f_order2(s.nd) as ord3,
    null as fio,
    s.status, s.psch as psch,
    s.sch as sch, s.val_group, s.val_group2,
    s.cnt AS cnt, s.klsk AS klsk, s.kpr AS kpr, decode(s.is_empt,1,''да'',0,''нет'', null) as is_empt, s.kpr_ot AS kpr_ot,
    s.kpr_wr AS kpr_wr, s.cnt_lg AS cnt_lg, s.cnt_subs AS cnt_subs, s.cnt_room, s.uch,
    substr(s.mg, 1, 4)||''-''||substr(s.mg, 5, 2) as mg1,
    s.npp, hl.name as name_gr, nvl(h2.odpu_ex, ''нет'') as odpu_ex,
    h2.odpu_kub, tp.name as lsk_tp, s.opl, s.is_vol
    FROM (select s1.*, u2.uslm, u2.npp, nvl(u2.parent_usl, s1.usl) as parent_usl
           from STATISTICS s1, usl u2
          where s1.usl=u2.usl) s 
          join S_REU_TREST t on s.reu=t.reu
          join SPUL k on s.kul=k.id 
          left join redir_pay r on s.org=r.fk_org_src and s.mg between r.mg1 and r.mg2
--          join t_org o on coalesce(r.fk_org_dst,s.org)=o.id
          left join (select t.reu, t.kul, t.nd, u.name from t_housexlist t, u_list u
           where t.fk_list=u.id) hl on s.reu=hl.reu and s.kul=hl.kul and s.nd=hl.nd
          left join (select  d.kub as odpu_kub, case when d.dist_tp<>4 and nvl(d.kub,0) = 0 then ''есть, нет объема''
                        when d.dist_tp<>4 and nvl(d.kub,0) <> 0 then ''есть''
                        else ''нет'' end as odpu_ex,
                        d.usl, h.mg, h.reu, h.kul, h.nd, d.dist_tp
                        from a_vvod d, a_houses h, t_org o, usl u
                  where h.id=d.house_id and h.mg=d.mg and nvl(h.psch,0)=0
                  and h.fk_other_org=o.id(+) and d.usl=u.usl
                  ) h2 on s.mg=h2.mg and s.reu=h2.reu and s.kul=h2.kul and s.nd=h2.nd and s.parent_usl=h2.usl
          left join v_lsk_tp tp on s.fk_tp=tp.id
    WHERE exists
   (select * from list_c i, spr_params p where i.fk_ses=:fk_ses_
        and p.id=i.fk_par and p.cd=''REP_USL''
        and i.sel_cd=s.usl
        and i.sel=1)
    and exists
       (select * from list_c i, spr_params p where i.fk_ses=:fk_ses_
            and p.id=i.fk_par and p.cd=''REP_STATUS''
            and i.sel_id=s.status
        and i.sel=1)
        and ((:var_=3 and
           s.reu = :reu_
           and s.kul = :kul_
           and s.nd = :nd_) or
         (:var_=2 and s.reu=:reu_)
          or (:var_=1 and t.trest=:trest_)
          or :var_=0)
    AND ' || sqlstr_ || '
    union all
    select null as org, null as fk_org2, ''000'' as uslm, ''000'' as usl, s.kul,
    t.trest, s.reu, k.name,
    k.name||'', ''||NVL(LTRIM(s.nd,''0''),''0'') AS predpr_det,
    utils.f_order(s.nd,6) as ord1, utils.f_order2(s.nd) as ord3,
    null as fio,
    s.status, s.psch as psch,
    s.sch as sch, s.val_group, s.val_group2,
    s.cnt AS cnt, s.klsk AS klsk, s.kpr AS kpr, decode(s.is_empt,1,''да'',0,''нет'', null) as is_empt, s.kpr_ot AS kpr_ot,
    s.kpr_wr AS kpr_wr, s.cnt_lg AS cnt_lg, s.cnt_subs AS cnt_subs, s.cnt_room, s.uch,
    substr(s.mg, 1, 4)||''-''||substr(s.mg, 5, 2) as mg1,
    null as npp, hl.name as name_gr, null as odpu_ex, 0 as odpu_kub, tp.name as lsk_tp, s.opl, s.is_vol
    FROM STATISTICS s, S_REU_TREST t, SPUL k,
        (select t.reu, t.kul, t.nd, u.name from t_housexlist t, u_list u
         where t.fk_list=u.id) hl, v_lsk_tp tp
    WHERE s.reu=t.reu and s.fk_tp=tp.id(+)
    AND s.USL is null
    AND s.kul=k.id
    and exists
       (select * from list_c i, spr_params p where i.fk_ses=:fk_ses_
            and p.id=i.fk_par and p.cd=''REP_USL''
            and i.sel_cd=''0'' --¬ключить ли »“ќ√?
        and i.sel=1)
    and exists
       (select * from list_c i, spr_params p where i.fk_ses=:fk_ses_
            and p.id=i.fk_par and p.cd=''REP_STATUS''
            and i.sel_id=s.status
        and i.sel=1)

    and s.reu=hl.reu(+) and s.kul=hl.kul(+) and s.nd=hl.nd(+)
    and
         ((:var_=3 and
           s.reu = :reu_
           and s.kul = :kul_
           and s.nd = :nd_) or
         (:var_=2 and s.reu=:reu_)
          or (:var_=1 and t.trest=:trest_)
          or :var_=0)
    AND ' || sqlstr_||' order by name, ord1'
          USING fk_ses_, fk_ses_, var_, reu_, kul_, nd_, var_, reu_, var_, trest_, var_,
     fk_ses_, fk_ses_, var_, reu_, kul_, nd_, var_, reu_, var_, trest_, var_;
    ELSIF det_ in (0, 1) THEN
   --детализаци€ до ∆Ёќ
        OPEN prep_refcursor FOR '
    select s.org, coalesce(r.fk_org_dst,s.org) as fk_org2, u.uslm, s.usl,
    t.trest, s.reu, null as name,
    null as predpr_det,
    null as fio,
    s.status, s.psch as psch,
    s.sch as sch, s.val_group, s.val_group2,
    s.cnt AS cnt, s.klsk AS klsk, s.kpr AS kpr, decode(s.is_empt,1,''да'',0,''нет'', null) as is_empt, s.kpr_ot AS kpr_ot,
    s.kpr_wr AS kpr_wr, s.cnt_lg AS cnt_lg, s.cnt_subs AS cnt_subs, s.cnt_room, s.uch,
    substr(s.mg, 1, 4)||''-''||substr(s.mg, 5, 2) as mg1,
    u.npp, null as name_gr, null as odpu_ex, 0 as odpu_kub, tp.name as lsk_tp, s.opl, s.is_vol
    FROM STATISTICS_TREST s 
    join USL u on s.USL=u.USL
    join S_REU_TREST t on s.reu=t.reu
    join v_lsk_tp tp on s.fk_tp=tp.id
    left join redir_pay r on s.org=r.fk_org_src and s.mg between r.mg1 and r.mg2
   -- join t_org o on coalesce(r.fk_org_dst,s.org)=o.id
    WHERE 
    exists
   (select * from list_c i, spr_params p where i.fk_ses=:fk_ses_
        and p.id=i.fk_par and p.cd=''REP_USL''
        and i.sel_cd=s.usl
        and i.sel=1)
    and exists
       (select * from list_c i, spr_params p where i.fk_ses=:fk_ses_
            and p.id=i.fk_par and p.cd=''REP_STATUS''
            and i.sel_id=s.status
        and i.sel=1)

    and
         ((:var_=2 and s.reu=:reu_)
          or (:var_=1 and t.trest=:trest_)
          or :var_=0)
    AND ' || sqlstr_||'
    union all
    select null as org, null as fk_org2, ''000'' as uslm, ''000'' as usl,
    t.trest, s.reu, null as name,
    null as predpr_det,
    null as fio,
    s.status, s.psch as psch,
    s.sch as sch, s.val_group, s.val_group2,
    s.cnt AS cnt, s.klsk AS klsk, s.kpr AS kpr, decode(s.is_empt,1,''да'',0,''нет'', null) as is_empt, s.kpr_ot AS kpr_ot,
    s.kpr_wr AS kpr_wr, s.cnt_lg AS cnt_lg, s.cnt_subs AS cnt_subs, s.cnt_room, s.uch,
    substr(s.mg, 1, 4)||''-''||substr(s.mg, 5, 2) as mg1,
    null as npp, null as name_gr, null as odpu_ex, 0 as odpu_kub, tp.name as lsk_tp, s.opl, s.is_vol
    FROM STATISTICS_TREST s, S_REU_TREST t, v_lsk_tp tp
    WHERE s.reu=t.reu and s.fk_tp=tp.id(+)
    AND s.USL is null
    and exists
   (select * from list_c i, spr_params p where i.fk_ses=:fk_ses_
        and p.id=i.fk_par and p.cd=''REP_USL''
        and i.sel_cd=''0'' --¬ключить ли »“ќ√?
    and i.sel=1)
    and exists
       (select * from list_c i, spr_params p where i.fk_ses=:fk_ses_
            and p.id=i.fk_par and p.cd=''REP_STATUS''
            and i.sel_id=s.status
        and i.sel=1)

    and
         ((:var_=2 and s.reu=:reu_)
          or (:var_=1 and t.trest=:trest_)
          or :var_=0)
    AND ' || sqlstr_||' order by npp'
      USING fk_ses_, fk_ses_,var_, reu_, var_, trest_, var_,
     fk_ses_, fk_ses_,var_, reu_, var_, trest_, var_;
    END IF;

    ELSIF сd_ = '18' THEN
      --—татистика по льготникам
      IF var_ = 3 THEN
        -- по ƒому
        OPEN prep_refcursor FOR 'select t.trest||'' ''||t.name_tr as predp, k.name||'', ''||NVL(LTRIM(s.nd,''0''),''0'') as predpr_det,
       NVL(LTRIM(s.kw,''0''),''0'') AS kw, g.name AS spk_name, DECODE(s.main,1,''Ќоситель'',''ѕользующ'') AS main, u.nm AS usl_name, s.cnt
       FROM STATISTICS_LG_LSK s, S_REU_TREST t, SPUL k, SPRORG p, SPK g, USL u
       WHERE ' || sqlstr_ || ' AND s.reu=t.reu AND s.kul=k.id AND s.ORG=p.kod AND s.spk_id=g.id AND s.USL=u.USL AND
       s.reu=:reu_ AND s.kul=:kul_ AND s.nd=:nd_
       ORDER BY utils.f_order(s.kw,7)'
          USING reu_, kul_, nd_;
      ELSIF var_ = 2 THEN
        -- по –Ё”
        OPEN prep_refcursor FOR 'select t.trest||'' ''||t.name_tr as predp, s.reu,  k.name||'', ''||NVL(LTRIM(s.nd,''0''),''0'') as predpr_det,
       NULL AS kw, g.name AS spk_name, DECODE(s.main,1,''Ќоситель'',''ѕользующ'') AS main, u.nm AS usl_name, s.cnt
       FROM STATISTICS_LG s, S_REU_TREST t, SPUL k, SPRORG p, SPK g, USL u
       WHERE ' || sqlstr_ || ' AND s.reu=t.reu AND s.kul=k.id AND s.ORG=p.kod AND s.spk_id=g.id AND s.USL=u.USL AND
       s.reu=:reu_
       ORDER BY k.name, utils.f_order(s.nd,6)'
          USING reu_;
      ELSIF var_ = 1 THEN
        -- по ∆Ёќ
        open prep_refcursor for 'select t.trest||'' ''||t.name_tr as predp, s.reu, null as predpr_det,
       null as kw, g.name as spk_name, decode(s.main,1,''Ќоситель'',''ѕользующ'') as main, u.nm as usl_name, s.cnt
       from statistics_lg_trest s, s_reu_trest t, sprorg p, spk g, usl u
       where ' || sqlstr_ || ' and s.reu=t.reu and s.org=p.kod and s.spk_id=g.id and s.usl=u.usl and t.trest=:trest_
       order by s.reu'
          using trest_;
          NULL;
      ELSIF var_ = 0 THEN
        -- по ћѕ ”≈«∆ ”
        OPEN prep_refcursor FOR 'select t.trest||'' ''||t.name_tr as predp, s.reu, null as predpr_det,
       NULL AS kw, p.name AS orgname, g.name AS spk_name, DECODE(s.main,1,''Ќоситель'',''ѕользующ'') AS main, u.nm AS usl_name, s.cnt
       FROM STATISTICS_LG_TREST s, S_REU_TREST t, SPRORG p, SPK g, USL u
       WHERE ' || sqlstr_ || ' AND s.reu=t.reu AND s.ORG=p.kod AND s.spk_id=g.id AND s.USL=u.USL
       ORDER BY t.trest';
      END IF;
    ELSIF сd_ = '14' THEN
    show_sal_:=utils.getS_bool_param('REP_SHOW_SAL');
    show_fond_:=utils.getS_list_param('REP_FOND');
      --ќборотка
      IF det_ = 3 then
       kpr1_:=utils.getS_int_param('REP_RNG_KPR1');  --kpr1, kpr2 - используетс€ в других ведомост€х, но неправильно!!!
       kpr2_:=utils.getS_int_param('REP_RNG_KPR2');  --только в оборотке этой - корректно! исправить потом Lev, 29.10.2015
        --детализаци€ до квартир
        OPEN prep_refcursor FOR 'select x.mg,
       substr(x.mg, 1, 4)||''-''||substr(x.mg, 5, 2) as mg1,
       h.lsk,
       h.name_tr as predpr,
       h.name_reu as reu,
       h.adr as predpr_det,
       decode(h.type,0,''ѕрочие'',''ќсновные'') as type,
       decode(h.status, 2, ''ѕриват'', ''ћуницип'') as status,
       to_char(d.kod) || '' '' || d.name as org,
       c.nm,
       m.nm1,
       null as name_gr,
       case when :show_sal_=0 and x.mg > :mg_ and :mg_ <> :mg1_ then 0
        else i.indebet
        end as indebet,
       case when :show_sal_=0 and x.mg > :mg_ and :mg_ <> :mg1_ then 0
        else i.inkredit
        end as inkredit,
       case when :show_sal_=0 and x.mg < :mg1_ and :mg_ <> :mg1_ then 0
        else i.outdebet
        end as outdebet,
       case when :show_sal_=0 and x.mg < :mg1_ and :mg_ <> :mg1_ then 0
        else i.outkredit
        end as outkredit,
       i.charges as charges,
       i.pcharges as pcharges,
       i.changes as changes,
       i.changes2 as changes2,
       nvl(i.changes,0)+nvl(i.changes2,0) as changeall,
       i.subsid as subsid,
       i.privs as privs,
       i.payment as payment,
       i.pn as pn,
       null as odpu_ex,
       h3.other_name,
       null as val_group2
      from (select e.*, k.nd, k.kw, k.status, k.house_id, u.uslm, g.type,
         s.name||'', ''||NVL(LTRIM(k.nd,''0''),''0'')||''-''||NVL(LTRIM(k.kw,''0''),''0'') as adr,
         s.name as street1,
          s.name_reu, s.name_tr
          from t_saldo_lsk2 e, kart k, spul s, sprorg g, s_reu_trest s, usl u
         where e.lsk = k.lsk and k.reu=s.reu
           and e.org = g.kod
           and k.kul = s.id
           and e.usl = u.usl
           and exists
          (select * from list_c i, spr_params p where i.fk_ses=:fk_ses_
              and p.id=i.fk_par and p.cd=''REP_USL2''
              and i.sel_cd=e.usl
              and i.sel=1)
           and (:show_fond_ = 1 and k.psch not in (8,9)
            or :show_fond_ = 2 and k.psch in (8,9)
            or :show_fond_ = 0
            or :show_fond_ is null)
           and
           ((:var_=3 and
           k.reu = :reu_
           and k.kul = :kul_
           and k.nd = :nd_)
          or (:var_=2 and k.reu=:reu_)
          or (:var_=1 and s.trest=:trest_)
          or :var_=0)
           ) h,
        xitog3_lsk i, arch_kart a,
       (select * from period_reports t where id = 14) x,
       (select t.mg, t.id, o.name as other_name from a_houses t, t_org o where t.fk_other_org=o.id(+)) h3,    
       sprorg d, usl c,
       uslm m
    where h.lsk = i.lsk(+)
     and h.org = i.org(+)
     and h.usl = i.usl(+)
     and i.lsk=a.lsk 
     and i.mg=a.mg 
     and a.kpr>=coalesce(:kpr1_, a.kpr)
     and a.kpr<=coalesce(:kpr2_, a.kpr)
     and x.mg = i.mg
     and h.house_id=h3.id
     and x.mg=h3.mg
     and h.org = d.kod
     and h.usl = c.usl
     and h.uslm = m.uslm
     and x.mg between :mg_ and :mg1_
    order by h.street1, utils.f_order(h.nd,6), utils.f_order(h.kw,7)'
        USING show_sal_, mg_, mg_, mg1_, show_sal_, mg_, mg_, mg1_, show_sal_, mg1_, mg_, mg1_, show_sal_,
          mg1_, mg_, mg1_, fk_ses_, 
          show_fond_, show_fond_, show_fond_, show_fond_,
          var_, reu_, kul_, nd_, var_, reu_, var_, trest_, var_, kpr1_, kpr2_, mg_, mg1_;
      ELSIF det_ = 2 THEN
        -- детализаци€ до домов
/*OPEN prep_refcursor FOR 'select x.mg, substr(x.mg, 1, 4)||''-''||substr(x.mg, 5, 2) as mg1,
        null as lsk,
        t.name_tr as predpr, h.name_reu as reu, k.name||'', ''||nvl(ltrim(h.nd,''0''),''0'')  as predpr_det,
        utils.f_order(h.nd,6) as ord1,
        decode(h.type,0,''прочие'',''основные'') as type,
        decode(h.status,2,''ѕриват'',''ћуницип'') as status, to_char(d.kod)||'' ''||d.name as org, c.nm, m.nm1,
        hl.name as name_gr,
       case when :show_sal_=0 and x.mg > :mg_ and :mg_ <> :mg1_ then 0
        else i.indebet
        end as indebet,
       case when :show_sal_=0 and x.mg > :mg_ and :mg_ <> :mg1_ then 0
        else i.inkredit
        end as inkredit,
       case when :show_sal_=0 and x.mg < :mg1_ and :mg_ <> :mg1_ then 0
        else i.outdebet
        end as outdebet,
       case when :show_sal_=0 and x.mg < :mg1_ and :mg_ <> :mg1_ then 0
        else i.outkredit
        end as outkredit,
        i.charges as charges,
        i.pcharges as pcharges,
        i.changes as changes,
        i.changes2 as changes2,
        nvl(i.changes,0)+nvl(i.changes2,0) as changeall,
        i.subsid as subsid,
        i.privs as privs,
        i.payment as payment,
        i.pn as pn,
        h2.odpu_ex,
        h3.other_name,
        null as val_group2
        
        from
        (select e.*, u.type, s.trest, s.name_reu from t_saldo_reu_kul_nd_st e, sprorg u,
        s_reu_trest s where e.org=u.kod and e.reu=s.reu
        and exists
        (select * from list_c i, spr_params p where i.fk_ses=:fk_ses_
          and p.id=i.fk_par and p.cd=''REP_USL2''
          and i.sel_cd=e.usl
          and i.sel=1) and
         ((:var_=3 and
           e.reu = :reu_
           and e.kul = :kul_
           and e.nd = :nd_) or
         (:var_=2 and e.reu=:reu_)
          or (:var_=1 and s.trest=:trest_)
          or :var_=0)) h,
         (select  case when d.dist_tp<>4 and nvl(d.kub,0) = 0 then ''есть, нет объема''
                      when d.dist_tp<>4 and nvl(d.kub,0) <> 0 then ''есть''
                      else ''нет'' end as odpu_ex,
                      u2.usl, h.mg, h.reu, h.kul, h.nd, d.dist_tp
                      from a_vvod d, a_houses h, t_org o, usl u, usl u2
                where h.id=d.house_id and h.mg=d.mg and nvl(h.psch,0)=0
                and h.fk_other_org=o.id(+) and d.usl=u.usl and u.uslm=u2.uslm
                ) h2,
        (select t.mg, t.reu, t.kul, t.nd, o.name as other_name from a_houses t, t_org o where t.fk_other_org=o.id) h3,                 
        xitog3 i,
        (select * from period_reports t where id=14) x,
        sprorg d, usl c, uslm m, org l, s_reu_trest t, spul k,
        (select t.reu, t.kul, t.nd, u.name from t_housexlist t, u_list u
         where t.fk_list=u.id) hl
        where
        h.reu=i.reu(+) and h.kul=i.kul(+) and h.nd=i.nd(+) and h.org=i.org(+) and h.usl=i.usl(+) and h.status=i.status(+) and
        l.id=1 and h.org=d.kod and h.usl=c.usl and h.uslm=m.uslm and h.reu=t.reu and h.kul=k.id
        and x.mg=i.mg
        and x.mg between :mg_ and :mg1_
        and i.reu=h2.reu(+) and i.kul=h2.kul(+) and i.nd=h2.nd(+) and i.usl=h2.usl(+) and i.mg=h2.mg(+)
        and h.reu=hl.reu(+) and h.kul=hl.kul(+) and h.nd=hl.nd(+)
        and i.reu=h3.reu(+) and i.kul=h3.kul(+) and i.nd=h3.nd(+) and i.mg=h3.mg(+)
        order by x.mg, k.name||'', ''||nvl(ltrim(h.nd,''0''),''0''), utils.f_order(h.nd,6)'
        USING show_sal_, mg_, mg_, mg1_, show_sal_, mg_, mg_, mg1_, show_sal_, mg1_, mg_, mg1_, show_sal_,
          mg1_, mg_, mg1_, fk_ses_, var_, reu_, kul_, nd_, var_, reu_, var_, trest_, var_, mg_, mg1_;   */     
        
        OPEN prep_refcursor FOR 'select i.mg, substr(i.mg, 1, 4)||''-''||substr(i.mg, 5, 2) as mg1,
        null as lsk,
        t.name_tr as predpr, h.name_reu as reu, k.name||'', ''||nvl(ltrim(h.nd,''0''),''0'')  as predpr_det,
        utils.f_order(h.nd,6) as ord1,
        decode(h.type,0,''прочие'',''основные'') as type,
        decode(h.status,2,''ѕриват'',''ћуницип'') as status, to_char(d.kod)||'' ''||d.name as org, c.nm, m.nm1,
        hl.name as name_gr,
       case when :show_sal_=0 and i.mg > :mg_ and :mg_ <> :mg1_ then 0
        else i.indebet
        end as indebet,
       case when :show_sal_=0 and i.mg > :mg_ and :mg_ <> :mg1_ then 0
        else i.inkredit
        end as inkredit,
       case when :show_sal_=0 and i.mg < :mg1_ and :mg_ <> :mg1_ then 0
        else i.outdebet
        end as outdebet,
       case when :show_sal_=0 and i.mg < :mg1_ and :mg_ <> :mg1_ then 0
        else i.outkredit
        end as outkredit,
        i.charges as charges,
        i.pcharges as pcharges,
        i.changes as changes,
        i.changes2 as changes2,
        nvl(i.changes,0)+nvl(i.changes2,0) as changeall,
        i.subsid as subsid,
        i.privs as privs,
        i.payment as payment,
        i.pn as pn,
        h2.odpu_ex,
        h3.other_name,
        st.val_group2
        from
        (select e.*, u.type, s.trest, s.name_reu, nvl(u2.parent_usl, e.usl) as parent_usl
         from t_saldo_reu_kul_nd_st e, sprorg u, usl u2,
        s_reu_trest s where e.org=u.kod and e.reu=s.reu and e.usl=u2.usl
        and exists
        (select * from list_c i, spr_params p where i.fk_ses=:fk_ses_
          and p.id=i.fk_par and p.cd=''REP_USL2''
          and i.sel_cd=e.usl
          and i.sel=1) and
         ((:var_=3 and
           e.reu = :reu_
           and e.kul = :kul_
           and e.nd = :nd_) or
         (:var_=2 and e.reu=:reu_)
          or (:var_=1 and s.trest=:trest_)
          or :var_=0)) h 
         join 
         xitog3 i 
         on h.reu=i.reu and h.kul=i.kul and h.nd=i.nd and h.org=i.org and h.usl=i.usl and h.status=i.status
            and i.mg between :mg_ and :mg1_
         left join 
         (select t.mg, t.reu, t.kul, t.nd, o.name as other_name from a_houses t, t_org o where t.fk_other_org=o.id) h3
         on i.reu=h3.reu and i.kul=h3.kul and i.nd=h3.nd and i.mg=h3.mg
         left join 
         (select distinct case when d.dist_tp<>4 and nvl(d.kub,0) = 0 then ''есть, нет объема''
                      when d.dist_tp<>4 and nvl(d.kub,0) <> 0 then ''есть''
                      else ''нет'' end as odpu_ex,
                      d.usl, h.mg, h.reu, h.kul, h.nd
                      from a_vvod d, a_houses h
                where h.id=d.house_id and h.mg=d.mg and nvl(h.psch,0)=0 and d.mg between :mg_ and :mg1_
                ) h2 
         on i.reu=h2.reu and i.kul=h2.kul and i.nd=h2.nd and i.mg=h2.mg and h.parent_usl=h2.usl
        join 
        sprorg d on h.org=d.kod
        join usl c on h.usl=c.usl
        join uslm m on h.uslm=m.uslm
        join org l on l.id=1 
        join s_reu_trest t on h.reu=t.reu 
        join spul k on h.kul=k.id
        left join 
        (select t.reu, t.kul, t.nd, u.name from t_housexlist t, u_list u
         where t.fk_list=u.id) hl 
        on h.reu=hl.reu and h.kul=hl.kul and h.nd=hl.nd
        
        left join  
        (select t.reu, t.kul, t.nd, t.mg, t.usl, max(t.val_group2) as val_group2 from STATISTICS t --подключил стату здесь, чтобы были видны нормативы в оборотке...
        where t.mg between :mg_ and :mg1_
         group by t.reu, t.kul, t.nd, t.mg, t.usl) st
        on i.reu=st.reu and i.kul=st.kul and i.nd=st.nd and i.mg=st.mg and h.parent_usl=st.usl
        
        order by i.mg, k.name||'', ''||nvl(ltrim(h.nd,''0''),''0''), utils.f_order(h.nd,6)'
        USING show_sal_, mg_, mg_, mg1_, show_sal_, mg_, mg_, mg1_, show_sal_, mg1_, mg_, mg1_, show_sal_,
          mg1_, mg_, mg1_, fk_ses_, var_, reu_, kul_, nd_, var_, reu_, var_, trest_, var_, mg_, mg1_, mg_, mg1_, mg_, mg1_; 
      ELSIF det_ in (0, 1) THEN
        -- до ∆Ёќ
        OPEN prep_refcursor FOR 'select x.mg, substr(x.mg, 1, 4)||''-''||substr(x.mg, 5, 2) as mg1,
        null as lsk,
        t.trest||'' ''||t.name_tr as predpr,
        h.name_reu as reu, null as predpr_det, decode(h.type,0,''прочие'',''основные'') as type,
        decode(h.status,2,''ѕриват'',''ћуницип'') as status, to_char(d.kod)||'' ''||d.name as org, c.nm, m.nm1,
        hl.name as name_gr,
       case when :show_sal_=0 and x.mg > :mg_ and :mg_ <> :mg1_ then 0
        else sum(i.indebet)
        end as indebet,
       case when :show_sal_=0 and x.mg > :mg_ and :mg_ <> :mg1_ then 0
        else sum(i.inkredit)
        end as inkredit,
       case when :show_sal_=0 and x.mg < :mg1_ and :mg_ <> :mg1_ then 0
        else sum(i.outdebet)
        end as outdebet,
       case when :show_sal_=0 and x.mg < :mg1_ and :mg_ <> :mg1_ then 0
        else sum(i.outkredit)
        end as outkredit,
        sum(o.charges) as charges,
        sum(o.pcharges) as pcharges,
        sum(o.changes) as changes,
        sum(o.changes2) as changes2,
        sum(nvl(o.changes,0)+nvl(o.changes2,0)) as changeall,
        sum(o.changes) as changes, sum(o.subsid) as subsid, sum(o.privs) as privs, sum(o.payment) as payment,
        sum(o.pn) as pn,
        null as odpu_ex,
        null as other_name,
        null as val_group2
        from
        (select e.*, u.type, s.trest, s.name_reu from t_saldo_reu_kul_nd_st e, sprorg u,
        s_reu_trest s where e.org=u.kod and e.reu=s.reu
        and exists
        (select * from list_c i, spr_params p where i.fk_ses=:fk_ses_
          and p.id=i.fk_par and p.cd=''REP_USL2''
          and i.sel_cd=e.usl
          and i.sel=1)
         and
         ((:var_=2 and e.reu=:reu_)
          or (:var_=1 and s.trest=:trest_)
          or :var_=0)) h,
        xitog3 i,
        (select reu,kul,nd,status,org,usl,mg, sum(charges) as charges, sum(pcharges) as pcharges,
        sum(changes) as changes, sum(changes2) as changes2, sum(subsid) as subsid, sum(privs) as privs,
        sum(payment) as payment, sum(pn) as pn from xitog3 t
        group by reu,kul,nd,status,org,usl,mg) o,
        (select * from xitog3 e) u,
        (select * from period_reports t where id=14) x,
        sprorg d, usl c, uslm m, org l, s_reu_trest t,
        (select t.reu, t.kul, t.nd, u.name from t_housexlist t, u_list u
         where t.fk_list=u.id) hl
        where
        h.reu=i.reu(+) and h.kul=i.kul(+) and h.nd=i.nd(+) and h.org=i.org(+) and h.usl=i.usl(+) and h.status=i.status(+) and
        h.reu=o.reu(+) and h.kul=o.kul(+) and h.nd=o.nd(+) and h.org=o.org(+) and h.usl=o.usl(+) and h.status=o.status(+) and
        h.reu=u.reu(+) and h.kul=u.kul(+) and h.nd=u.nd(+) and h.org=u.org(+) and h.usl=u.usl(+) and h.status=u.status(+) and
        l.id=1 and h.org=d.kod and h.usl=c.usl and h.uslm=m.uslm and h.reu=t.reu
        and x.mg=i.mg and x.mg=o.mg and x.mg=u.mg
        and x.mg between :mg_ and :mg1_
        and h.reu=hl.reu(+) and h.kul=hl.kul(+) and h.nd=hl.nd(+)
        group by hl.name, x.mg, substr(x.mg, 1, 4)||''-''||substr(x.mg, 5, 2), t.trest||'' ''||t.name_tr, h.name_reu, h.status, h.type, to_char(d.kod)||'' ''||d.name, c.nm, m.nm1
        order by x.mg'
        USING show_sal_, mg_, mg_, mg1_, show_sal_, mg_, mg_, mg1_, show_sal_, mg1_, mg_, mg1_, show_sal_,
          mg1_, mg_, mg1_, fk_ses_, var_, reu_, var_, trest_, var_, mg_, mg1_;
      ELSE
        OPEN prep_refcursor FOR 'select null as predpr, null as reu, null as predpr_det, null as type,
          null as lsk,
          NULL AS STATUS, NULL AS ORG, NULL AS nm1, NULL AS name_gr, NULL AS indebet, NULL AS inkredit,
          NULL AS CHARGES, NULL AS PCHARGES, NULL AS CHANGES, NULL AS CHANGES2, NULL AS CHANGEALL, NULL AS subsid, NULL AS PRIVS, NULL AS payment,
          NULL AS pn, NULL AS outdebet, NULL AS outkredit
          FROM dual';
      END IF;
   elsif сd_ = '35' then
     -- ќплата OLAP
     if var_ = 3 then
        --ѕо дому
        open prep_refcursor for 'select null as predp,
     o.oper||'' ''||o.naim as opername, null as reu,
     ''∆Ёќ:''||k.reu||''-''||l.name||'', ''||NVL(LTRIM(k.nd,''0''),''0'')||''-''||NVL(LTRIM(k.kw,''0''),''0'')
     as predpr_det,
     null as kw, s.var, s.dopl,
     substr(s.dopl, 1, 4)||''-''||substr(s.dopl, 5, 2) as dopl_name,
     s.mg, substr(s.mg, 1, 4)||''-''||substr(s.mg, 5, 2) as mg_name,
     s.dat, to_char(r.kod) || '' '' || r.name as org_name, v.name as var_name, u.nm, u.nm1, sum(s.summa) as summa,
     decode(s.cd_tp, 0, ''ѕен€'', ''ќплата'') as cd_tp
     from kart k, xxito14_lsk s, sprorg r, variant_xxito10 v, spul l, oper o, usl u
     where k.lsk=s.lsk and s.usl=u.usl and s.oper=o.oper
      and s.org=r.kod and s.var=v.id and k.kul=l.id
     and k.reu=:reu_ and k.kul=:kul_ and k.nd=:nd_ and '||sqlstr_||'
     group by o.oper||'' ''||o.naim,
       ''∆Ёќ:''||k.reu||''-''||l.name||'', ''||NVL(LTRIM(k.nd,''0''),''0'')||''-''||NVL(LTRIM(k.kw,''0''),''0''),
       s.var, s.dopl,
       substr(s.dopl, 1, 4)||''-''||substr(s.dopl, 5, 2),
       s.mg, substr(s.mg, 1, 4)||''-''||substr(s.mg, 5, 2),
       s.dat, to_char(r.kod) || '' '' || r.name, v.name, u.nm, u.nm1,
     decode(s.cd_tp, 0, ''ѕен€'', ''ќплата'')
      order by s.dopl desc'
      using reu_, kul_, nd_;
       elsif var_ = 2 then
        --ѕо ∆Ёќ
        open prep_refcursor for 'select t.name_tr as predp,
        o.oper||'' ''||o.naim as opername, t.name_reu as reu,
     '' ∆Ёќ:''||s.forreu||''-''||k.name||'', ''||NVL(LTRIM(s.nd,''0''),''0'')
     as predpr_det,
     null as kw, s.var, s.dopl,
     substr(s.dopl, 1, 4)||''-''||substr(s.dopl, 5, 2) as dopl_name,
     s.mg, substr(s.mg, 1, 4)||''-''||substr(s.mg, 5, 2) as mg_name,
     s.dat, to_char(r.kod) || '' '' || r.name org_name, v.name as var_name, u.nm, u.nm1, sum(s.summa) as summa,
     decode(s.cd_tp, 0, ''ѕен€'', ''ќплата'') as cd_tp
     from xxito14 s, s_reu_trest t, sprorg r, variant_xxito10 v, spul k, oper o, usl u
     where s.usl=u.usl and s.oper=o.oper and s.forreu=t.reu and s.forreu=:reu
     and s.org=r.kod and s.var=v.id and s.kul=k.id
     and '||sqlstr_||'
     group by t.name_tr, o.oper||'' ''||o.naim, t.name_reu,
      '' ∆Ёќ:''||s.forreu||''-''||k.name||'', ''||NVL(LTRIM(s.nd,''0''),''0''),
      s.var, s.dopl,
      substr(s.dopl, 1, 4)||''-''||substr(s.dopl, 5, 2),
      s.mg, substr(s.mg, 1, 4)||''-''||substr(s.mg, 5, 2), s.dat,
      to_char(r.kod) || '' '' || r.name, v.name, u.nm, u.nm1,
      decode(s.cd_tp, 0, ''ѕен€'', ''ќплата'')
      order by s.dopl desc'
      using reu_;
       elsif var_ = 1 then
        --ѕо ‘онду
        open prep_refcursor for 'select t.name_tr as predp, o.oper||'' ''||o.naim as opername, t.name_reu as reu,
     null as predpr_det,null as kw, s.var, s.dopl,
     substr(s.dopl, 1, 4)||''-''||substr(s.dopl, 5, 2) as dopl_name,
     s.mg, substr(s.mg, 1, 4)||''-''||substr(s.mg, 5, 2) as mg_name,
     s.dat, to_char(r.kod) || '' '' || r.name org_name, v.name as var_name, u.nm, u.nm1, sum(s.summa) as summa,
     decode(s.cd_tp, 0, ''ѕен€'', ''ќплата'') as cd_tp
     from xxito14 s, s_reu_trest t, sprorg r, variant_xxito10 v, oper o, usl u
     where s.usl=u.usl and s.oper=o.oper and s.forreu=t.reu and t.trest=:trest and s.org=r.kod and s.var=v.id
     and '||sqlstr_||'
     group by t.name_tr, o.oper||'' ''||o.naim, t.name_reu, s.var, s.dopl,
      substr(s.dopl, 1, 4)||''-''||substr(s.dopl, 5, 2),
      s.mg, substr(s.mg, 1, 4)||''-''||substr(s.mg, 5, 2), s.dat,
      to_char(r.kod) || '' '' || r.name, v.name, u.nm, u.nm1,
      decode(s.cd_tp, 0, ''ѕен€'', ''ќплата'')
      order by s.dopl desc'
      using trest_;
      elsif var_ = 0 then
        --по городу
        open prep_refcursor for 'select t.name_tr as predp, o.oper||'' ''||o.naim as opername, t.name_reu as reu,
     null as predpr_det,null as kw, s.var, s.dopl,
     substr(s.dopl, 1, 4)||''-''||substr(s.dopl, 5, 2) as dopl_name,
     s.mg, substr(s.mg, 1, 4)||''-''||substr(s.mg, 5, 2) as mg_name,
     s.dat, to_char(r.kod) || '' '' || r.name org_name, v.name as var_name, u.nm, u.nm1, sum(s.summa) as summa,
     decode(s.cd_tp, 0, ''ѕен€'', ''ќплата'') as cd_tp
     from xxito14 s, s_reu_trest t, sprorg r, variant_xxito10 v, oper o, usl u
     where s.usl=u.usl and s.oper=o.oper and s.forreu=t.reu and s.org=r.kod and s.var=v.id
     and '||sqlstr_||'
     group by t.name_tr, o.oper||'' ''||o.naim, t.name_reu, s.var, s.dopl,
      substr(s.dopl, 1, 4)||''-''||substr(s.dopl, 5, 2),
      s.mg, substr(s.mg, 1, 4)||''-''||substr(s.mg, 5, 2), s.dat,
      to_char(r.kod) || '' '' || r.name, v.name, u.nm, u.nm1,
      decode(s.cd_tp, 0, ''ѕен€'', ''ќплата'')
      order by s.dopl desc';
 end if;
 elsif сd_ = '36' then
     -- —верка инкассаций
     if var_ = 3 then
        --ѕо дому
        raise_application_error(-20001,'Ќе существует уровн€ детализации!');
      elsif var_ = 2 then
        --ѕо –Ё”
        raise_application_error(-20001,'Ќе существует уровн€ детализации!');
      elsif var_ = 1 then
        --ѕо ∆Ёќ
        raise_application_error(-20001,'Ќе существует уровн€ детализации!');
      elsif var_ = 0 then
        --(все тресты)
          open prep_refcursor for
          'select sum(summa) as summa, sum(penya) as penya, opername,
               nink, nkom, dat_ink from (
               select t.summa as summa, t.penya as penya, o.oper||'' ''||o.naim as opername,
               t.nink, t.nkom, t.dat_ink
                 from c_kwtp_mg t, oper o
               where t.oper=o.oper and t.dat_ink between :dt1 and :dt2
               and :l_in_period=1
               union all
               select t.summa as summa, t.penya as penya, o.oper||'' ''||o.naim as opername,
               t.nink, t.nkom, t.dat_ink
                 from a_kwtp_mg t, oper o, params p
               where t.oper=o.oper and t.dat_ink between :dt1 and :dt2
               and :l_out_period=1 and t.mg <> p.period
               union all
               select t.summa as summa, t.penya as penya, o.oper||'' ''||o.naim as opername,
               t.nink, t.nkom, t.dat_ink
                 from c_kwtp_mg t, oper o
               where t.oper=o.oper and t.dat_ink is null
               and :l_in_period=1
               union all
               select t.summa as summa, t.penya as penya, o.oper||'' ''||o.naim as opername,
               t.nink, t.nkom, t.dat_ink
                 from a_kwtp_mg t, oper o, params p
               where t.oper=o.oper and t.dat_ink is null
               and :l_out_period=1 and t.mg <> p.period
               union all
               select t.summa, null as penya, o.oper||'' ''||o.naim as opername, null as nink,
                null as nkom, t.dat as dat_ink
                from t_corrects_payments t, oper o where
                t.mg between :mg and :mg1 and o.oper=''99''
                ) a
               group by a.dat_ink, a.nkom, opername, a.nink
               order by a.dat_ink, a.nkom, opername, a.nink'
               using l_dt, l_dt1, l_in_period, l_dt, l_dt1, l_out_period, l_in_period,
                l_out_period, mg_, mg1_;
      end if;
 elsif сd_ = '37' then
     -- —верка перерасчетов начислени€
     if var_ = 3 then
        --ѕо дому
        raise_application_error(-20001,'Ќе существует уровн€ детализации!');
      elsif var_ = 2 then
        --ѕо –Ё”
        raise_application_error(-20001,'Ќе существует уровн€ детализации!');
      elsif var_ = 1 then
        --ѕо ∆Ёќ
        raise_application_error(-20001,'Ќе существует уровн€ детализации!');
      elsif var_ = 0 then
        --ѕо городу
        open prep_refcursor for
        'select d.id, s.name_reu, u.nm, t.name as type_ch,
           l.name||'', ''||NVL(LTRIM(k.nd,''0''),''0'')||''-''||NVL(LTRIM(k.kw,''0''),''0'') as adr,
           c.mgchange, substr(c.mgchange, 1, 4)||''-''||substr(c.mgchange, 5, 2) as mg1,
           c.dtek, u.name, sum(c.summa) as summa, max(c.proc) as proc
            from kart k, spul l, c_change_docs d, c_change c, s_reu_trest s, t_user u, usl u, c_change_tp t
            where k.lsk=c.lsk and k.kul=l.id and k.reu=s.reu and d.id=c.doc_id and c.type=t.id and d.user_id=u.id and c.usl=u.usl
           group by d.id,
           l.name||'', ''||NVL(LTRIM(k.nd,''0''),''0'')||''-''||NVL(LTRIM(k.kw,''0''),''0''),
           s.name_reu, u.nm, t.name, c.mgchange, c.dtek, u.name
           order by d.id';
      end if;
 elsif сd_ = '54' then
 --«адолжники OLAP
 --:cur_pay_=1 -- с учетом текущей оплаты, 0 - без учета

   cur_pay_:=utils.getS_bool_param('REP_CUR_PAY');
   kpr1_:=utils.getS_int_param('REP_RNG_KPR1');
   kpr2_:=utils.getS_int_param('REP_RNG_KPR2');
   n1_:=utils.getS_list_param('REP_DEB_VAR');
   if n1_=0 then
     n2_:=utils.getS_int_param('REP_DEB_MONTH');
     else
     n2_:=utils.getS_int_param('REP_DEB_SUMMA');
   end if;

   if var_ = 3 then
    --ѕо дому
   open prep_refcursor for
   'select s.lsk, DECODE(k.psch,9,''«акрытые Ћ/—'', 8,''—тарый фонд'', ''ќткрытые Ћ/—'') AS psch,
    t.name_tr, t.name_reu,
    trim(s.name) as street,  ltrim(s.nd,''0'') as nd, ltrim(s.kw,''0'') as kw,
    trim(s.name)||'', ''||ltrim(s.nd,''0'')||''-''||ltrim(s.kw,''0'') as adr, s.fio,
    case when :cur_pay_=1 then s.cnt_month
      else s.cnt_month2 end as cnt_month,
    case when :cur_pay_=1 then s.dolg
      else s.dolg2 end as dolg, g.name as deb_org, s.penya, s.nachisl, s.payment, s.dat,
      a.name as st_name
    from kart k, debits_lsk_month s, s_reu_trest t, t_org g, status a
    where k.lsk=s.lsk and s.status=a.id and s.reu=t.reu and s.reu=:reu and s.kul=:kul and s.nd=:nd and  '||sqlstr_||'
    and s.fk_deb_org=g.id(+)
    and ((:cur_pay_=1 and s.cnt_month > 0) or
    (:cur_pay_=0 and s.cnt_month2 > 0))
    and exists
    (select * from kart k where k.lsk=s.lsk
      and (:kpr1_ is not null and k.kpr >=:kpr1_ or :kpr1_ is null)
    and (:kpr2_ is not null and k.kpr <=:kpr2_ or :kpr2_ is null))
    and
    ((:n1_=0 and s.cnt_month >= :n2_) or
    (:n1_=1 and s.dolg >= :n2_))
    order by s.name, utils.f_order(s.nd,6), utils.f_order(s.kw,7)'
    using cur_pay_, cur_pay_, reu_, kul_, nd_, cur_pay_, cur_pay_,
    kpr1_, kpr1_, kpr1_, kpr2_, kpr2_, kpr2_, n1_, n2_, n1_, n2_;
   elsif var_ = 2 then
    --ѕо ∆Ёќ
   open prep_refcursor for
   'select s.lsk, DECODE(k.psch,9,''«акрытые Ћ/—'', 8,''—тарый фонд'', ''ќткрытые Ћ/—'') AS psch,
    t.name_tr, t.name_reu,
    trim(s.name) as street,  ltrim(s.nd,''0'') as nd, ltrim(s.kw,''0'') as kw,
    trim(s.name)||'', ''||ltrim(s.nd,''0'')||''-''||ltrim(s.kw,''0'') as adr, s.fio,
    case when :cur_pay_=1 then s.cnt_month
      else s.cnt_month2 end as cnt_month,
    case when :cur_pay_=1 then s.dolg
      else s.dolg2 end as dolg, g.name as deb_org, s.penya, s.nachisl, s.payment, s.dat,
    a.name as st_name
    from kart k, debits_lsk_month s, s_reu_trest t, t_org g, status a
    where k.lsk=s.lsk and s.status=a.id and s.reu=t.reu and s.reu=:reu and  '||sqlstr_||'
    and s.fk_deb_org=g.id(+)
    and ((:cur_pay_=1 and s.cnt_month > 0) or
    (:cur_pay_=0 and s.cnt_month2 > 0))
    and exists
    (select * from kart k where k.lsk=s.lsk
      and (:kpr1_ is not null and k.kpr >=:kpr1_ or :kpr1_ is null)
    and (:kpr2_ is not null and k.kpr <=:kpr2_ or :kpr2_ is null))
    and
    ((:n1_=0 and s.cnt_month >= :n2_) or
    (:n1_=1 and s.dolg >= :n2_))
    order by s.name, utils.f_order(s.nd,6), utils.f_order(s.kw,7)'
    using cur_pay_, cur_pay_, reu_, cur_pay_, cur_pay_,
    kpr1_, kpr1_, kpr1_, kpr2_, kpr2_, kpr2_, n1_, n2_, n1_, n2_;
   elsif var_ = 1 then
    --ѕо фонду
   open prep_refcursor for
   'select s.lsk, DECODE(k.psch,9,''«акрытые Ћ/—'', 8,''—тарый фонд'', ''ќткрытые Ћ/—'') AS psch,
    t.name_tr, t.name_reu,
    trim(s.name) as street,  ltrim(s.nd,''0'') as nd, ltrim(s.kw,''0'') as kw,
    trim(s.name)||'', ''||ltrim(s.nd,''0'')||''-''||ltrim(s.kw,''0'') as adr, s.fio,
    case when :cur_pay_=1 then s.cnt_month
      else s.cnt_month2 end as cnt_month,
    case when :cur_pay_=1 then s.dolg
      else s.dolg2 end as dolg, g.name as deb_org, s.penya, s.nachisl, s.payment, s.dat,
    a.name as st_name
    from kart k, debits_lsk_month s, s_reu_trest t, t_org g, status a
    where k.lsk=s.lsk and s.status=a.id and s.reu=t.reu and t.trest=:trest and  '||sqlstr_||'
    and s.fk_deb_org=g.id(+)
    and ((:cur_pay_=1 and s.cnt_month > 0) or
    (:cur_pay_=0 and s.cnt_month2 > 0))
    and exists
    (select * from kart k where k.lsk=s.lsk
      and (:kpr1_ is not null and k.kpr >=:kpr1_ or :kpr1_ is null)
    and (:kpr2_ is not null and k.kpr <=:kpr2_ or :kpr2_ is null))
    and
    ((:n1_=0 and s.cnt_month >= :n2_) or
    (:n1_=1 and s.dolg >= :n2_))
    order by s.name, utils.f_order(s.nd,6), utils.f_order(s.kw,7)'
    using cur_pay_, cur_pay_, trest_, cur_pay_, cur_pay_,
    kpr1_, kpr1_, kpr1_, kpr2_, kpr2_, kpr2_, n1_, n2_, n1_, n2_;
   elsif var_ = 0 then
   --ѕо городу
   open prep_refcursor for
   'select s.lsk, DECODE(k.psch,9,''«акрытые Ћ/—'', 8,''—тарый фонд'', ''ќткрытые Ћ/—'') AS psch,
    t.name_tr, t.name_reu,
    trim(s.name) as street,  ltrim(s.nd,''0'') as nd, ltrim(s.kw,''0'') as kw,
    trim(s.name)||'', ''||ltrim(s.nd,''0'')||''-''||ltrim(s.kw,''0'') as adr, s.fio,
    case when :cur_pay_=1 then s.cnt_month
      else s.cnt_month2 end as cnt_month,
    case when :cur_pay_=1 then s.dolg
      else s.dolg2 end as dolg, g.name as deb_org, s.penya, s.nachisl, s.payment, s.dat,
    a.name as st_name
    from kart k, debits_lsk_month s, s_reu_trest t, t_org g, status a
    where k.lsk=s.lsk and s.status=a.id and s.reu=t.reu and '||sqlstr_||'
    and s.fk_deb_org=g.id(+)
    and ((:cur_pay_=1 and s.cnt_month > 0) or
    (:cur_pay_=0 and s.cnt_month2 > 0))
    and exists
    (select * from kart k where k.lsk=s.lsk
      and (:kpr1_ is not null and k.kpr >=:kpr1_ or :kpr1_ is null)
    and (:kpr2_ is not null and k.kpr <=:kpr2_ or :kpr2_ is null))
    and
    ((:n1_=0 and s.cnt_month >= :n2_) or
    (:n1_=1 and s.dolg >= :n2_))
    order by s.name, utils.f_order(s.nd,6), utils.f_order(s.kw,7)'
    using cur_pay_, cur_pay_, cur_pay_, cur_pay_,
    kpr1_, kpr1_, kpr1_, kpr2_, kpr2_, kpr2_, n1_, n2_, n1_, n2_;
    end if;
 elsif сd_ = '56' then
 --—писки льготников
   if var_ = 3 then
    --ѕо дому
   open prep_refcursor for
   'select substr(s.mg, 1, 4)||''-''||substr(s.mg, 5, 2) as mg, s.lsk,
    initcap(trim(e.name) || '', '' || ltrim(s.nd, ''0'') || ''-'' || ltrim(s.kw, ''0'')) as adr,
       s.opl, s.kpr, c.kpr_cem, c1.kpr_s,
       decode(lag(s.lsk, 1) over (order by s.lsk), s.lsk, 0, c2.cnt) as cnt,
       decode(lag(s.lsk, 1) over (order by s.lsk), s.lsk, 0, c2.cnt_main) as cnt_main,
       p.fio, m.name as lg_name, u.nm2 as usl_name, b.summa, nvl(d.doc, '' '') as doc
  from arch_kart s, spul e, a_kart_pr p, spk m, a_lg_docs d,
       usl u, (select sum(s.summa) as summa, s.lg_doc_id, s.spk_id, s.usl, s.kart_pr_id
                 from a_charge s
                where '||sqlstr_||' and s.spk_id=:spk_id_ and s.type = 4 and s.summa <> 0
                group by s.lg_doc_id, s.spk_id, s.usl, s.kart_pr_id) b,
              (select lsk, sum(kpr_cem) as kpr_cem from
                (select distinct s.lsk, s.kart_pr_id, 1 as kpr_cem
                 from a_charge s, usl m
                where '||sqlstr_||' and s.usl=m.usl and s.spk_id=:spk_id_ and m.usl_type=1
                 and s.type = 4 and s.summa <> 0)
                 group by lsk
                ) c,
              (select lsk, sum(kpr_s) as kpr_s from
                (select distinct s.lsk, s.kart_pr_id, 1 as kpr_s
                 from a_charge s, usl m
                where '||sqlstr_||' and s.usl=m.usl and s.spk_id=:spk_id_ and m.usl_type=0
                 and s.type = 4 and s.summa <> 0)
                 group by lsk
                ) c1,
              (select lsk, count(*) as cnt, sum(cnt_main) as cnt_main from (
                select distinct lsk, kart_pr_id, main as cnt_main from a_charge s
                where '||sqlstr_||' and s.spk_id=:spk_id_
                and s.type=4 and s.summa <> 0  --кол-во носителей льг.
                )
                group by lsk
                ) c2
 where s.lsk = p.lsk and s.reu=:reu_ and s.kul=:kul_ and s.nd=:nd_
   and s.kul = e.id
   and '||sqlstr_||'
   and s.lsk = c.lsk(+)
   and s.lsk = c1.lsk(+)
   and s.lsk = c2.lsk(+)
   and p.mg=s.mg
   and d.mg=s.mg
   and b.spk_id=m.id
   and p.id = b.kart_pr_id
   and b.usl = u.usl
   and d.id=b.lg_doc_id
   order by s.lsk, p.id'
    using spk_id_, spk_id_, spk_id_, spk_id_, reu_, kul_, nd_;
   elsif var_ = 2 then
    --ѕо ∆Ёќ
   open prep_refcursor for
   'select substr(s.mg, 1, 4)||''-''||substr(s.mg, 5, 2) as mg, s.lsk,
    initcap(trim(e.name) || '', '' || ltrim(s.nd, ''0'') || ''-'' || ltrim(s.kw, ''0'')) as adr,
       s.opl, s.kpr, c.kpr_cem, c1.kpr_s,
       decode(lag(s.lsk, 1) over (order by s.lsk), s.lsk, 0, c2.cnt) as cnt,
       decode(lag(s.lsk, 1) over (order by s.lsk), s.lsk, 0, c2.cnt_main) as cnt_main,
       p.fio, m.name as lg_name, u.nm2 as usl_name, b.summa, nvl(d.doc, '' '') as doc
  from arch_kart s, spul e, a_kart_pr p, spk m, a_lg_docs d,
       usl u, (select sum(s.summa) as summa, s.lg_doc_id, s.spk_id, s.usl, s.kart_pr_id
                 from a_charge s
                where '||sqlstr_||' and s.spk_id=:spk_id_ and s.type = 4 and s.summa <> 0
                group by s.lg_doc_id, s.spk_id, s.usl, s.kart_pr_id) b,
              (select lsk, sum(kpr_cem) as kpr_cem from
                (select distinct s.lsk, s.kart_pr_id, 1 as kpr_cem
                 from a_charge s, usl m
                where '||sqlstr_||' and s.usl=m.usl and s.spk_id=:spk_id_ and m.usl_type=1
                 and s.type = 4 and s.summa <> 0)
                 group by lsk
                ) c,
              (select lsk, sum(kpr_s) as kpr_s from
                (select distinct s.lsk, s.kart_pr_id, 1 as kpr_s
                 from a_charge s, usl m
                where '||sqlstr_||' and s.usl=m.usl and s.spk_id=:spk_id_ and m.usl_type=0
                 and s.type = 4 and s.summa <> 0)
                 group by lsk
                ) c1,
              (select lsk, count(*) as cnt, sum(cnt_main) as cnt_main from (
                select distinct lsk, kart_pr_id, main as cnt_main from a_charge s
                where '||sqlstr_||' and s.spk_id=:spk_id_
                and s.type=4 and s.summa <> 0  --кол-во носителей льг.
                )
                group by lsk
                ) c2
 where s.lsk = p.lsk and s.reu=:reu_
   and s.kul = e.id
   and '||sqlstr_||'
   and s.lsk = c.lsk(+)
   and s.lsk = c1.lsk(+)
   and s.lsk = c2.lsk(+)
   and p.mg=s.mg
   and d.mg=s.mg
   and b.spk_id=m.id
   and p.id = b.kart_pr_id
   and b.usl = u.usl
   and d.id=b.lg_doc_id
   order by s.lsk, p.id'
   using spk_id_, spk_id_, spk_id_, spk_id_, reu_;
   elsif var_ = 1 then
    --ѕо фонду
   open prep_refcursor for
   'select substr(s.mg, 1, 4)||''-''||substr(s.mg, 5, 2) as mg, s.lsk,
    initcap(trim(e.name) || '', '' || ltrim(s.nd, ''0'') || ''-'' || ltrim(s.kw, ''0'')) as adr,
       s.opl, s.kpr, c.kpr_cem, c1.kpr_s,
       decode(lag(s.lsk, 1) over (order by s.lsk), s.lsk, 0, c2.cnt) as cnt,
       decode(lag(s.lsk, 1) over (order by s.lsk), s.lsk, 0, c2.cnt_main) as cnt_main,
       p.fio, m.name as lg_name, u.nm2 as usl_name, b.summa, nvl(d.doc, '' '') as doc
  from arch_kart s, spul e, a_kart_pr p, spk m, a_lg_docs d, s_reu_trest t,
       usl u, (select sum(s.summa) as summa, s.lg_doc_id, s.spk_id, s.usl, s.kart_pr_id
                 from a_charge s
                where '||sqlstr_||' and s.spk_id=:spk_id_ and s.type = 4 and s.summa <> 0
                group by s.lg_doc_id, s.spk_id, s.usl, s.kart_pr_id) b,
              (select lsk, sum(kpr_cem) as kpr_cem from
                (select distinct s.lsk, s.kart_pr_id, 1 as kpr_cem
                 from a_charge s, usl m
                where '||sqlstr_||' and s.usl=m.usl and s.spk_id=:spk_id_ and m.usl_type=1
                 and s.type = 4 and s.summa <> 0)
                 group by lsk
                ) c,
              (select lsk, sum(kpr_s) as kpr_s from
                (select distinct s.lsk, s.kart_pr_id, 1 as kpr_s
                 from a_charge s, usl m
                where '||sqlstr_||' and s.usl=m.usl and s.spk_id=:spk_id_ and m.usl_type=0
                 and s.type = 4 and s.summa <> 0)
                 group by lsk
                ) c1,
              (select lsk, count(*) as cnt, sum(cnt_main) as cnt_main from (
                select distinct lsk, kart_pr_id, main as cnt_main from a_charge s
                where '||sqlstr_||' and s.spk_id=:spk_id_
                and s.type=4 and s.summa <> 0  --кол-во носителей льг.
                )
                group by lsk
                ) c2
 where s.lsk = p.lsk and t.trest=:trest_
   and s.kul = e.id
   and '||sqlstr_||'
   and s.lsk = c.lsk(+)
   and s.lsk = c1.lsk(+)
   and s.lsk = c2.lsk(+)
   and p.mg=s.mg
   and d.mg=s.mg
   and b.spk_id=m.id
   and p.id = b.kart_pr_id
   and b.usl = u.usl
   and d.id=b.lg_doc_id
   order by s.lsk, p.id'
   using spk_id_, spk_id_, spk_id_, spk_id_, trest_;
   elsif var_ = 0 then
   --ѕо городу
   open prep_refcursor for
   'select substr(s.mg, 1, 4)||''-''||substr(s.mg, 5, 2) as mg, s.lsk,
    initcap(trim(e.name) || '', '' || ltrim(s.nd, ''0'') || ''-'' || ltrim(s.kw, ''0'')) as adr,
       s.opl, s.kpr, c.kpr_cem, c1.kpr_s,
       decode(lag(s.lsk, 1) over (order by s.lsk), s.lsk, 0, c2.cnt) as cnt,
       decode(lag(s.lsk, 1) over (order by s.lsk), s.lsk, 0, c2.cnt_main) as cnt_main,
       p.fio, m.name as lg_name, u.nm2 as usl_name, b.summa, nvl(d.doc, '' '') as doc
  from arch_kart s, spul e, a_kart_pr p, spk m, a_lg_docs d,
       usl u, (select sum(s.summa) as summa, s.lg_doc_id, s.spk_id, s.usl, s.kart_pr_id
                 from a_charge s --суммы возмещ по льготам
                where '||sqlstr_||' and s.spk_id=:spk_id_ and s.type = 4 and s.summa <> 0
                group by s.lg_doc_id, s.spk_id, s.usl, s.kart_pr_id) b,
              (select lsk, sum(kpr_cem) as kpr_cem from
                (select distinct s.lsk, s.kart_pr_id, 1 as kpr_cem
                 from a_charge s, usl m --кол-во польз. льг. по жилью
                where '||sqlstr_||' and s.usl=m.usl and s.spk_id=:spk_id_ and m.usl_type=1
                 and s.type = 4 and s.summa <> 0)
                 group by lsk
                ) c,
              (select lsk, sum(kpr_s) as kpr_s from
                (select distinct s.lsk, s.kart_pr_id, 1 as kpr_s
                 from a_charge s, usl m --кол-во польз. льг. по комун.усл.
                where '||sqlstr_||' and s.usl=m.usl and s.spk_id=:spk_id_ and m.usl_type=0
                 and s.type = 4 and s.summa <> 0)
                 group by lsk
                ) c1,
              (select lsk, count(*) as cnt, sum(cnt_main) as cnt_main from (
                select distinct lsk, kart_pr_id, main as cnt_main from a_charge s
                where '||sqlstr_||' and s.spk_id=:spk_id_
                and s.type=4 and s.summa <> 0  --кол-во носителей льг.
                )
                group by lsk
                ) c2
 where s.lsk = p.lsk
   and s.kul = e.id
   and '||sqlstr_||'
   and s.lsk = c.lsk(+)
   and s.lsk = c1.lsk(+)
   and s.lsk = c2.lsk(+)
   and p.mg=s.mg
   and d.mg=s.mg
   and b.spk_id=m.id
   and p.id = b.kart_pr_id
   and b.usl = u.usl
   and d.id=b.lg_doc_id
   order by s.lsk, p.id'
   using spk_id_, spk_id_, spk_id_, spk_id_;
   end if;

 elsif сd_ = 57 then
 --—писок по объЄмным показател€м
   if var_ = 3 then
    --ѕо дому
    OPEN prep_refcursor FOR '
select t.trest||'' ''||t.name_reu as predp,
    k.name||'', ''||NVL(LTRIM(s.nd,''0''),''0'') AS predpr_det,
    LTRIM(s.kw,''0'') AS kw,
    TRIM(u.nm)||DECODE(u.ed_izm,NULL,'''','' (''||TRIM(u.ed_izm)||'')'') AS nm,
    TRIM(u.nm1)||DECODE(u.ed_izm,NULL,'''','' (''||TRIM(u.ed_izm)||'')'') AS nm1,
    p.name AS orgname, m.name AS STATUS, DECODE(s.psch,1,''«акрытые Ћ/—'', 2,''—тарый фонд'', ''ќткрытые Ћ/—'') AS psch,
    DECODE(s.sch,1,''—четчик'',''Ќорматив'') AS sch, s.val_group2 as val_group,
    sum(s.cnt) AS cnt, sum(s.klsk) AS klsk, sum(s.kpr) AS kpr, sum(s.kpr_ot) AS kpr_ot,
    sum(s.kpr_wr) AS kpr_wr, sum(s.cnt_lg) AS cnt_lg, sum(s.cnt_subs) AS cnt_subs, s.uch,
    substr(s.mg, 1, 4)||''-''||substr(s.mg, 5, 2) as mg1,
    to_number(translate(upper(s.nd),
    translate(upper(s.nd),''0123456789'','' ''), '' '')) as nd1,
    to_number(translate(upper(s.kw),
    translate(upper(s.kw),''0123456789'','' ''), '' '')) as kw1
    FROM STATISTICS_LSK s, USL u, S_REU_TREST t, SPRORG p, STATUS m, SPUL k
    WHERE s.reu=t.reu and s.psch not in (8,9)
    AND s.USL=u.USL
    AND s.ORG=p.kod
    and u.uslm in
     (''004'',''006'',''007'',''008'')
    AND s.kul=k.id
    AND s.STATUS=m.id
    AND s.reu=:reu_ and s.kul=:kul_ and s.nd=:nd_
    AND ' || sqlstr_||'
    group by u.npp, t.trest||'' ''||t.name_reu,
    k.name||'', ''||NVL(LTRIM(s.nd,''0''),''0''),
    LTRIM(s.kw,''0''),
    TRIM(u.nm)||DECODE(u.ed_izm,NULL,'''','' (''||TRIM(u.ed_izm)||'')''),
    TRIM(u.nm1)||DECODE(u.ed_izm,NULL,'''','' (''||TRIM(u.ed_izm)||'')''),
    p.name, m.name, DECODE(s.psch,1,''«акрытые Ћ/—'', 2,''—тарый фонд'', ''ќткрытые Ћ/—''),
    DECODE(s.sch,1,''—четчик'',''Ќорматив''), s.val_group2, s.uch,
    substr(s.mg, 1, 4)||''-''||substr(s.mg, 5, 2), k.name,
    to_number(translate(upper(s.nd),
    translate(upper(s.nd),''0123456789'','' ''), '' '')),
    to_number(translate(upper(s.kw),
    translate(upper(s.kw),''0123456789'','' ''), '' ''))
    order by u.npp, k.name, to_number(translate(upper(s.nd),
    translate(upper(s.nd),''0123456789'','' ''), '' '')),
    to_number(translate(upper(s.kw),
    translate(upper(s.kw),''0123456789'','' ''), '' ''))'
   using reu_, kul_, nd_;
   elsif var_ = 2 then
    --ѕо ∆Ёќ
    OPEN prep_refcursor FOR '
select t.trest||'' ''||t.name_reu as predp,
    k.name||'', ''||NVL(LTRIM(s.nd,''0''),''0'') AS predpr_det,
    LTRIM(s.kw,''0'') AS kw,
    TRIM(u.nm)||DECODE(u.ed_izm,NULL,'''','' (''||TRIM(u.ed_izm)||'')'') AS nm,
    TRIM(u.nm1)||DECODE(u.ed_izm,NULL,'''','' (''||TRIM(u.ed_izm)||'')'') AS nm1,
    p.name AS orgname, m.name AS STATUS, DECODE(s.psch,1,''«акрытые Ћ/—'', 2,''—тарый фонд'', ''ќткрытые Ћ/—'') AS psch,
    DECODE(s.sch,1,''—четчик'',''Ќорматив'') AS sch, s.val_group2 as val_group,
    sum(s.cnt) AS cnt, sum(s.klsk) AS klsk, sum(s.kpr) AS kpr, sum(s.kpr_ot) AS kpr_ot,
    sum(s.kpr_wr) AS kpr_wr, sum(s.cnt_lg) AS cnt_lg, sum(s.cnt_subs) AS cnt_subs, s.uch,
    substr(s.mg, 1, 4)||''-''||substr(s.mg, 5, 2) as mg1,
    to_number(translate(upper(s.nd),
    translate(upper(s.nd),''0123456789'','' ''), '' '')) as nd1,
    to_number(translate(upper(s.kw),
    translate(upper(s.kw),''0123456789'','' ''), '' '')) as kw1
    FROM STATISTICS_LSK s, USL u, S_REU_TREST t, SPRORG p, STATUS m, SPUL k
    WHERE s.reu=t.reu and s.psch not in (8,9)
    AND s.USL=u.USL
    AND s.ORG=p.kod
    and u.uslm in
     (''004'',''006'',''007'',''008'')
    AND s.kul=k.id
    AND s.STATUS=m.id
    AND s.reu=:reu_
    AND ' || sqlstr_||'
    group by u.npp, t.trest||'' ''||t.name_reu,
    k.name||'', ''||NVL(LTRIM(s.nd,''0''),''0''),
    LTRIM(s.kw,''0''),
    TRIM(u.nm)||DECODE(u.ed_izm,NULL,'''','' (''||TRIM(u.ed_izm)||'')''),
    TRIM(u.nm1)||DECODE(u.ed_izm,NULL,'''','' (''||TRIM(u.ed_izm)||'')''),
    p.name, m.name, DECODE(s.psch,1,''«акрытые Ћ/—'', 2,''—тарый фонд'', ''ќткрытые Ћ/—''),
    DECODE(s.sch,1,''—четчик'',''Ќорматив''), s.val_group2, s.uch,
    substr(s.mg, 1, 4)||''-''||substr(s.mg, 5, 2), k.name,
    to_number(translate(upper(s.nd),
    translate(upper(s.nd),''0123456789'','' ''), '' '')),
    to_number(translate(upper(s.kw),
    translate(upper(s.kw),''0123456789'','' ''), '' ''))
    order by u.npp, k.name, to_number(translate(upper(s.nd),
    translate(upper(s.nd),''0123456789'','' ''), '' '')),
    to_number(translate(upper(s.kw),
    translate(upper(s.kw),''0123456789'','' ''), '' ''))'
   using reu_;
   elsif var_ = 1 then
    --ѕо фонду
    OPEN prep_refcursor FOR '
 select t.trest||'' ''||t.name_reu as predp,
    k.name||'', ''||NVL(LTRIM(s.nd,''0''),''0'') AS predpr_det,
    LTRIM(s.kw,''0'') AS kw,
    TRIM(u.nm)||DECODE(u.ed_izm,NULL,'''','' (''||TRIM(u.ed_izm)||'')'') AS nm,
    TRIM(u.nm1)||DECODE(u.ed_izm,NULL,'''','' (''||TRIM(u.ed_izm)||'')'') AS nm1,
    p.name AS orgname, m.name AS STATUS, DECODE(s.psch,1,''«акрытые Ћ/—'', 2,''—тарый фонд'', ''ќткрытые Ћ/—'') AS psch,
    DECODE(s.sch,1,''—четчик'',''Ќорматив'') AS sch, s.val_group2 as val_group,
    sum(s.cnt) AS cnt, sum(s.klsk) AS klsk, sum(s.kpr) AS kpr, sum(s.kpr_ot) AS kpr_ot,
    sum(s.kpr_wr) AS kpr_wr, sum(s.cnt_lg) AS cnt_lg, sum(s.cnt_subs) AS cnt_subs, s.uch,
    substr(s.mg, 1, 4)||''-''||substr(s.mg, 5, 2) as mg1,
    to_number(translate(upper(s.nd),
    translate(upper(s.nd),''0123456789'','' ''), '' '')) as nd1,
    to_number(translate(upper(s.kw),
    translate(upper(s.kw),''0123456789'','' ''), '' '')) as kw1
    FROM STATISTICS_LSK s, USL u, S_REU_TREST t, SPRORG p, STATUS m, SPUL k
    WHERE s.reu=t.reu and s.psch not in (8,9)
    AND s.USL=u.USL
    AND s.ORG=p.kod
    and u.uslm in
     (''004'',''006'',''007'',''008'')
    AND s.kul=k.id
    AND s.STATUS=m.id
    AND t.trest=:trest_
    AND ' || sqlstr_||'
    group by u.npp, t.trest||'' ''||t.name_reu,
    k.name||'', ''||NVL(LTRIM(s.nd,''0''),''0''),
    LTRIM(s.kw,''0''),
    TRIM(u.nm)||DECODE(u.ed_izm,NULL,'''','' (''||TRIM(u.ed_izm)||'')''),
    TRIM(u.nm1)||DECODE(u.ed_izm,NULL,'''','' (''||TRIM(u.ed_izm)||'')''),
    p.name, m.name, DECODE(s.psch,1,''«акрытые Ћ/—'', 2,''—тарый фонд'', ''ќткрытые Ћ/—''),
    DECODE(s.sch,1,''—четчик'',''Ќорматив''), s.val_group2, s.uch,
    substr(s.mg, 1, 4)||''-''||substr(s.mg, 5, 2), k.name,
    to_number(translate(upper(s.nd),
    translate(upper(s.nd),''0123456789'','' ''), '' '')),
    to_number(translate(upper(s.kw),
    translate(upper(s.kw),''0123456789'','' ''), '' ''))
    order by u.npp, k.name, to_number(translate(upper(s.nd),
    translate(upper(s.nd),''0123456789'','' ''), '' '')),
    to_number(translate(upper(s.kw),
    translate(upper(s.kw),''0123456789'','' ''), '' ''))'
   using trest_;
   elsif var_ = 0 then
   --ѕо городу
    OPEN prep_refcursor FOR '
   select t.trest||'' ''||t.name_reu as predp,
    k.name||'', ''||NVL(LTRIM(s.nd,''0''),''0'') AS predpr_det,
    LTRIM(s.kw,''0'') AS kw,
    TRIM(u.nm)||DECODE(u.ed_izm,NULL,'''','' (''||TRIM(u.ed_izm)||'')'') AS nm,
    TRIM(u.nm1)||DECODE(u.ed_izm,NULL,'''','' (''||TRIM(u.ed_izm)||'')'') AS nm1,
    p.name AS orgname, m.name AS STATUS, DECODE(s.psch,1,''«акрытые Ћ/—'', 2,''—тарый фонд'', ''ќткрытые Ћ/—'') AS psch,
    DECODE(s.sch,1,''—четчик'',''Ќорматив'') AS sch, s.val_group2 as val_group,
    sum(s.cnt) AS cnt, sum(s.klsk) AS klsk, sum(s.kpr) AS kpr, sum(s.kpr_ot) AS kpr_ot,
    sum(s.kpr_wr) AS kpr_wr, sum(s.cnt_lg) AS cnt_lg, sum(s.cnt_subs) AS cnt_subs, s.uch,
    substr(s.mg, 1, 4)||''-''||substr(s.mg, 5, 2) as mg1,
    to_number(translate(upper(s.nd),
    translate(upper(s.nd),''0123456789'','' ''), '' '')) as nd1,
    to_number(translate(upper(s.kw),
    translate(upper(s.kw),''0123456789'','' ''), '' '')) as kw1
    FROM STATISTICS_LSK s, USL u, S_REU_TREST t, SPRORG p, STATUS m, SPUL k
    WHERE s.reu=t.reu and s.psch not in (8,9)
    AND s.USL=u.USL
    AND s.ORG=p.kod
    and u.uslm in
     (''004'',''006'',''007'',''008'')
    AND s.kul=k.id
    AND s.STATUS=m.id
    AND ' || sqlstr_||'
    group by u.npp, t.trest||'' ''||t.name_reu,
    k.name||'', ''||NVL(LTRIM(s.nd,''0''),''0''),
    LTRIM(s.kw,''0''),
    TRIM(u.nm)||DECODE(u.ed_izm,NULL,'''','' (''||TRIM(u.ed_izm)||'')''),
    TRIM(u.nm1)||DECODE(u.ed_izm,NULL,'''','' (''||TRIM(u.ed_izm)||'')''),
    p.name, m.name, DECODE(s.psch,1,''«акрытые Ћ/—'', 2,''—тарый фонд'', ''ќткрытые Ћ/—''),
    DECODE(s.sch,1,''—четчик'',''Ќорматив''), s.val_group2, s.uch,
    substr(s.mg, 1, 4)||''-''||substr(s.mg, 5, 2), k.name,
    to_number(translate(upper(s.nd),
    translate(upper(s.nd),''0123456789'','' ''), '' '')),
    to_number(translate(upper(s.kw),
    translate(upper(s.kw),''0123456789'','' ''), '' ''))
    order by u.npp, k.name, to_number(translate(upper(s.nd),
    translate(upper(s.nd),''0123456789'','' ''), '' '')),
    to_number(translate(upper(s.kw),
    translate(upper(s.kw),''0123456789'','' ''), '' ''))';
   end if;
 elsif сd_ = 58 then
 --—писок квартиросъемщиков, имеющих счетчики учета воды
   if var_ = 3 then
    --ѕо дому
    OPEN prep_refcursor FOR '
      select s.lsk, k.name||'', ''||NVL(LTRIM(s.nd,''0''),''0'')||''-''||NVL(LTRIM(s.kw,''0''),''0'') as adr,
             case when s.psch in (1,2) then s.phw
               else null end as phw,
             case when s.psch in (1,3) then s.pgw
               else null end as pgw,
             case when s.sch_el in (1) then s.pel
               else null end as pel
        from arch_kart s, s_reu_trest t, spul k
       where s.reu = t.reu
         and s.reu=:reu_ and s.kul=:kul_ and s.nd=:nd_
         and s.psch not in (8, 9, 0)
         and s.kul = k.id
         and (nvl(s.phw,0) <> 0 or nvl(s.pgw,0) <> 0 or nvl(s.pel,0) <> 0)
         and ' || sqlstr_||'
       order by k.name, utils.f_order(s.nd,6), utils.f_order2(s.nd), utils.f_order(s.kw,7)'
   using reu_, kul_, nd_;
   elsif var_ = 2 then
    --ѕо ∆Ёќ
    OPEN prep_refcursor FOR '
      select s.lsk, k.name||'', ''||NVL(LTRIM(s.nd,''0''),''0'')||''-''||NVL(LTRIM(s.kw,''0''),''0'') as adr,
             case when s.psch in (1,2) then s.phw
               else null end as phw,
             case when s.psch in (1,3) then s.pgw
               else null end as pgw,
             case when s.sch_el in (1) then s.pel
               else null end as pel
        from arch_kart s, s_reu_trest t, spul k
       where s.reu = t.reu
         and s.reu =:reu_
         and s.psch not in (8, 9, 0)
         and s.kul = k.id
         and (nvl(s.phw,0) <> 0 or nvl(s.pgw,0) <> 0 or nvl(s.pel,0) <> 0)
         and ' || sqlstr_||'
       order by k.name, utils.f_order(s.nd,6), utils.f_order2(s.nd), utils.f_order(s.kw,7)'
   using reu_;
   elsif var_ = 1 then
    --ѕо фонду
    OPEN prep_refcursor FOR '
      select s.lsk, k.name||'', ''||NVL(LTRIM(s.nd,''0''),''0'')||''-''||NVL(LTRIM(s.kw,''0''),''0'') as adr,
             case when s.psch in (1,2) then s.phw
               else null end as phw,
             case when s.psch in (1,3) then s.pgw
               else null end as pgw,
             case when s.sch_el in (1) then s.pel
               else null end as pel
        from arch_kart s, s_reu_trest t, spul k
       where s.reu = t.reu
         and t.trest =:trest_
         and s.psch not in (8, 9, 0)
         and s.kul = k.id
         and (nvl(s.phw,0) <> 0 or nvl(s.pgw,0) <> 0 or nvl(s.pel,0) <> 0)
         and ' || sqlstr_||'
       order by k.name, utils.f_order(s.nd,6), utils.f_order2(s.nd), utils.f_order(s.kw,7)'
   using trest_;
   elsif var_ = 0 then
   --ѕо городу
    OPEN prep_refcursor FOR '
      select s.lsk, k.name||'', ''||NVL(LTRIM(s.nd,''0''),''0'')||''-''||NVL(LTRIM(s.kw,''0''),''0'') as adr,
             case when s.psch in (1,2) then s.phw
               else null end as phw,
             case when s.psch in (1,3) then s.pgw
               else null end as pgw,
             case when s.sch_el in (1) then s.pel
               else null end as pel
        from arch_kart s, s_reu_trest t, spul k
       where s.reu = t.reu
         and s.psch not in (8, 9, 0)
         and s.kul = k.id
         and (nvl(s.phw,0) <> 0 or nvl(s.pgw,0) <> 0 or nvl(s.pel,0) <> 0)
         and ' || sqlstr_||'
       order by k.name, utils.f_order(s.nd,6), utils.f_order2(s.nd), utils.f_order(s.kw,7)';
   end if;
 elsif сd_ = '59' then
 --ќплата дл€ Ё+
 OPEN prep_refcursor FOR 'select u.nm as name_usl, substr(s.mg, 1, 4)||''-''||substr(s.mg, 5, 2) as mg1, t.name_tr,
   r.name as name_org,
   decode(t.ink, 0, ''самост'', 1, ''не самост'') as name_status, sum(s.summa) as summa
  from rmt_xxito15 s, rmt_s_reu_trest t, rmt_usl u, rmt_sprorg r
  where s.usl in (''020'',''021'') and s.forreu=t.reu and ' || sqlstr_||'
   and s.org=r.kod and s.priznak=1 and s.usl = u.usl
  group by u.nm, substr(s.mg, 1, 4)||''-''||substr(s.mg, 5, 2), r.name,
   t.name_tr, decode(t.ink, 0, ''самост'', 1, ''не самост'')
  order by substr(s.mg, 1, 4)||''-''||substr(s.mg, 5, 2),
   decode(t.ink, 0, ''самост'', 1, ''не самост''), r.name';

 elsif сd_ = '60' then
 --—татистика по ѕрограммам - ѕакетам пользовател€
   if det_ = 3 then
      --ѕо дому
     open prep_refcursor for 'select t.trest||'' ''||t.name_tr as predp,
     k.name||'', ''||nvl(ltrim(r.nd,''0''),''0'')||''-''||ltrim(r.kw,''0'') as predpr_det,
      i.name as tarif_name, u.nm,
     substr(s.mg, 1, 4)||''-''||substr(s.mg, 5, 2) as mg
      from kart r, a_nabor_progs s, spr_tarif i, s_reu_trest t, spul k, usl u
         where r.kul=k.id and r.reu=t.reu and r.lsk=s.lsk and s.usl=u.usl
         and s.fk_tarif=i.id
         and r.reu=:reu_ and r.kul=:kul_ and r.nd=:nd_ and ' || sqlstr_
     using reu_, kul_, nd_;
       elsif det_ = 2 then
        --ѕо ∆Ёќ
        open prep_refcursor for 'select t.reu||'' ''||t.name_reu as predp,
     k.name||'', ''||nvl(ltrim(r.nd,''0''),''0'') as predpr_det,
     i.name as tarif_name, u.nm,
     substr(s.mg, 1, 4)||''-''||substr(s.mg, 5, 2) as mg
      from kart r, a_nabor_progs s, spr_tarif i, s_reu_trest t, spul k, usl u
         where r.kul=k.id and r.reu=t.reu and r.lsk=s.lsk and s.usl=u.usl
         and s.fk_tarif=i.id
         and r.reu=:reu_ and ' || sqlstr_
     using reu_;
       elsif det_ = 1 then
        --ѕо ‘онду
        open prep_refcursor for 'select t.trest||'' ''||t.name_tr as predp,
     k.name||'', ''||nvl(ltrim(r.nd,''0''),''0'') as predpr_det,
     i.name as tarif_name, u.nm,
     substr(s.mg, 1, 4)||''-''||substr(s.mg, 5, 2) as mg
      from kart r, a_nabor_progs s, spr_tarif i, s_reu_trest t, spul k, usl u
         where r.kul=k.id and r.reu=t.reu and r.lsk=s.lsk and s.usl=u.usl
         and s.fk_tarif=i.id
         and t.trest=:trest_ and ' || sqlstr_
     using trest_;
      elsif det_ = 0 then
        --ѕо √ороду
        open prep_refcursor for 'select t.trest||'' ''||t.name_tr as predp,
     k.name||'', ''||nvl(ltrim(r.nd,''0''),''0'') as predpr_det,
     i.name as tarif_name, u.nm,
     substr(s.mg, 1, 4)||''-''||substr(s.mg, 5, 2) as mg
      from kart r, a_nabor_progs s, spr_tarif i, s_reu_trest t, spul k, usl u
         where r.kul=k.id and r.reu=t.reu and r.lsk=s.lsk and s.usl=u.usl
         and s.fk_tarif=i.id
         and ' || sqlstr_;
     end if;
 elsif сd_ = '61' then
 --ќплата по ‘ 2.4.

    if oper_ is null then
      --не выбрана операци€
      sqlstr_ := sqlstr_ || ' and :oper_ is null';
    elsif oper_ is not null then
      --выбрана операци€
      sqlstr_ := sqlstr_ || ' and s.oper=:oper_';
    end if;

/*    if org_ is null then
      --не выбрана организаци€
      sqlstr_ := sqlstr_ || ' and :org_ is null';
    elsif org_ is not null then
      --выбрана организаци€
      sqlstr_ := sqlstr_ || ' and s.org in (:org_)';
    end if;*/

    if var_ = 2 then
    --по –Ё”
        OPEN prep_refcursor FOR 'select ''' ||period_ || ''' as period, s.trest, substr(t.name_tr, 1, 15) as name_tr, s.oper,
               to_char(o.kod) || '' '' || substr(o.name, 1, 20) as name,
               substr(u.nm1, 1, 20) as nm1, sum(summa) as summa,
               decode(s.cd_tp, 0, ''ѕен€'', ''ќплата'') as cd_tp
         from xxito14 s, s_reu_trest t, sprorg o, usl u
           where s.forreu = t.reu
             and s.org = o.kod

            and exists
           (select * from list_c i, spr_params p where i.fk_ses=:fk_ses_
                and p.id=i.fk_par and p.cd=''REP_USL2'' 
                and i.sel_cd=s.usl
            and i.sel=1)
            and exists
           (select * from list_c i, spr_params p where i.fk_ses=:fk_ses_
                and p.id=i.fk_par and p.cd=''REP_ORG2'' 
                and i.sel_id=s.org
            and i.sel=1)
             
             and s.forreu = :reu_
             and s.usl = u.usl and '||sqlstr_||'
           group by s.trest, substr(t.name_tr, 1, 15), s.oper,
          to_char(o.kod) || '' '' || substr(o.name, 1, 20),
          substr(u.nm1, 1, 20),
          decode(s.cd_tp, 0, ''ѕен€'', ''ќплата'')'
          USING fk_ses_, fk_ses_, reu_, oper_;
    elsif var_ = 1 then
    --по ∆Ёќ
        OPEN prep_refcursor FOR 'select ''' ||period_ || ''' as period, s.trest, substr(t.name_tr, 1, 15) as name_tr, s.oper,
               to_char(o.kod) || '' '' || substr(o.name, 1, 20) as name,
               substr(u.nm1, 1, 20) as nm1, sum(summa) as summa,
               decode(s.cd_tp, 0, ''ѕен€'', ''ќплата'') as cd_tp
         from xxito14 s, s_reu_trest t, sprorg o, usl u
           where s.forreu = t.reu
             and s.org = o.kod

            and exists
           (select * from list_c i, spr_params p where i.fk_ses=:fk_ses_
                and p.id=i.fk_par and p.cd=''REP_USL2'' 
                and i.sel_cd=s.usl
            and i.sel=1)
            and exists
           (select * from list_c i, spr_params p where i.fk_ses=:fk_ses_
                and p.id=i.fk_par and p.cd=''REP_ORG2'' 
                and i.sel_id=s.org
            and i.sel=1)

             and s.trest = :trest_
             and s.usl = u.usl and '||sqlstr_||'
           group by s.trest, substr(t.name_tr, 1, 15), s.oper,
          to_char(o.kod) || '' '' || substr(o.name, 1, 20),
          substr(u.nm1, 1, 20),
          decode(s.cd_tp, 0, ''ѕен€'', ''ќплата'')'
          USING fk_ses_, fk_ses_, trest_, oper_;
    elsif var_ = 0 then
    --по √ороду
        OPEN prep_refcursor FOR 'select ''' ||period_ || ''' as period, s.trest, substr(t.name_tr, 1, 15) as name_tr, s.oper,
               to_char(o.kod) || '' '' || substr(o.name, 1, 20) as name,
               substr(u.nm1, 1, 20) as nm1, sum(summa) as summa,
               decode(s.cd_tp, 0, ''ѕен€'', ''ќплата'') as cd_tp
         from xxito14 s, s_reu_trest t, sprorg o, usl u
           where s.forreu = t.reu
             and s.org = o.kod

            and exists
           (select * from list_c i, spr_params p where i.fk_ses=:fk_ses_
                and p.id=i.fk_par and p.cd=''REP_USL2'' 
                and i.sel_cd=s.usl
            and i.sel=1)
            and exists
           (select * from list_c i, spr_params p where i.fk_ses=:fk_ses_
                and p.id=i.fk_par and p.cd=''REP_ORG2'' 
                and i.sel_id=s.org
            and i.sel=1)

             and s.usl = u.usl and '||sqlstr_||'
           group by s.trest, substr(t.name_tr, 1, 15), s.oper,
          to_char(o.kod) || '' '' || substr(o.name, 1, 20),
          substr(u.nm1, 1, 20),
          decode(s.cd_tp, 0, ''ѕен€'', ''ќплата'')'
          USING fk_ses_, fk_ses_, oper_;
    end if;

 elsif сd_ in  ('62','63') then
 --список-оборотка дл€ субсидировани€ “—∆
    if сd_='62' then
      uslg_:='001';
    elsif сd_='63' then
      uslg_:='002';
    end if;
    --список дл€ “—∆
    open prep_refcursor for
    'select l.name||'', ''||NVL(LTRIM(s.nd,''0''),''0'') as adr,
    ltrim(s.kw,''0'') as kw,
    s.komn, s.opl, b.opl_n, b.opl_sv, s.fio, s.kpr, b.summa_n, b.summa_sv,
     decode(s.psch, 1, gw.gw_n, 3, gw.gw_n, 0) as gw_sch_n,
     decode(s.psch, 1, gw.gw_sv, 3, gw.gw_sv, 0) as gw_sch_sv,
     decode(s.psch, 0, gw.gw_n, 2, gw.gw_n, 0) as gw_n,
     decode(s.psch, 0, gw.gw_sv, 2, gw.gw_sv, 0) as gw_sv,
     decode(s.psch, 0, gw.summa_n, 2, gw.summa_n, 0) as gw_n_summa_n,
     decode(s.psch, 0, gw.summa_sv, 2, gw.summa_sv, 0) as gw_n_summa_sv,
     decode(s.psch, 1, gw.summa_n, 3, gw.summa_n, 0) as gw_sch_summa_n,
     decode(s.psch, 1, gw.summa_sv, 3, gw.summa_sv, 0) as gw_sch_summa_sv,
     decode(s.psch, 0, gw2.cnt, 2, gw2.cnt, 0) as gw_n_corr,
     decode(s.psch, 1, gw2.cnt, 3, gw2.cnt, 0) as gw_sch_corr,
     decode(s.psch, 0, gw2.summa, 2, gw2.summa, 0) as gw_n_corr_summa,
     decode(s.psch, 1, gw2.summa, 3, gw2.summa, 0) as gw_sch_corr_summa,
     d.chng,
    c.name, c.adr as org_adr, c.inn, c.kpp, c.head_name,
    upper(utils.MONTH_NAME(substr(s.mg,5,2)))||'' ''||substr(s.mg,1,4)||''г.'' as mg_name,
    upper(s.nm) as nm
    from (select s.*, u.uslg, u.nm from arch_kart s, uslg u  where '||sqlstr_||'
     and exists
      (select * from a_charge a, usl u where a.usl=u.usl and
        u.uslg in (:uslg_) and a.type = 1 and a.summa <> 0
        and a.lsk=s.lsk and a.mg=s.mg
      )
    and s.reu=:reu_ and u.uslg=:uslg_
     and s.psch not in (8,9)
     and s.status not in (7)--убрал нежилые по просьбе “—∆  лЄн, ред.09.01.13
     ) s, t_org c, params p, spul l,
    (select s.lsk, u.uslg,
     sum(decode(u.usl_norm, 0, decode(s.type, 1, s.summa, 0))) as summa_n,
     sum(decode(u.usl_norm, 1, decode(s.type, 1, s.summa, 0))) as summa_sv,
     sum(decode(u.usl_norm, 0, decode(s.type, 1, s.test_opl, 0), 0)) as opl_n,
     sum(decode(u.usl_norm, 1, decode(s.type, 1, s.test_opl, 0), 0)) as opl_sv
      from (
      select s.lsk, s.usl, s.type, s.test_opl, s.summa from a_charge s, usl u where '||sqlstr_||' and s.usl=u.usl and
      u.uslg=:uslg_ and s.type in (1, 2, 4)
      ) s, usl u
      where s.usl=u.usl
     group by s.lsk, u.uslg) b,
      (select s.lsk, u.uslg, sum(s.summa) as chng from a_change s, usl u where '||sqlstr_||' and s.usl=u.usl and
       u.uslg=:uslg_
       group by s.lsk, u.uslg) d,
    (select s.lsk,
     sum(decode(u.usl_norm, 0, decode(s.type, 1, s.summa, 0))) as summa_n,
     sum(decode(u.usl_norm, 1, decode(s.type, 1, s.summa, 0))) as summa_sv,
     sum(decode(u.usl_norm, 0, decode(s.type, 1, s.test_opl, 0), 0)) as gw_n,
     sum(decode(u.usl_norm, 1, decode(s.type, 1, s.test_opl, 0), 0)) as gw_sv
      from (
      select s.lsk, s.usl, s.type, s.test_opl, s.summa from a_charge s, usl u where '||sqlstr_||' and s.usl=u.usl and
      u.cd in (''г.вода'', ''г.вода/св.нор'') and s.type in (1, 2, 4)
      ) s, usl u
      where s.usl=u.usl
     group by s.lsk) gw,
    (select s.lsk,
      sum(s.cnt) as cnt,
      sum(s.summa) as summa
      from (
      select s.lsk, s.usl, s.test_opl as cnt, s.summa from a_charge s, usl u where '||sqlstr_||' and s.usl=u.usl and
      u.cd in (''г.вода.ќƒЌ'') and s.type in (1)
      ) s
     group by s.lsk) gw2
    where s.lsk = b.lsk(+) and s.kul=l.id and s.lsk=gw.lsk(+) and s.uslg=b.uslg(+)
     and s.lsk = d.lsk(+) and s.uslg=d.uslg(+)
     and s.reu=c.reu and s.lsk=gw2.lsk(+)
    order by l.name, s.nd, s.kw'
    using uslg_, reu_, uslg_, uslg_, uslg_;
 elsif сd_ in  ('64') then
 dat2_:=utils.getS_date_param('REP_DT_BR1');
 dat3_:=utils.getS_date_param('REP_DT_BR2');
 gndr_:=utils.getS_list_param('REP_GENDER');
 --ќтчет по проживающим, дл€ паспортного стола
    --список дл€ “—∆
    if var_ = 3 then
    --по –Ё”
    open prep_refcursor for
      select
      l.name||', '||NVL(LTRIM(s.nd,'0'),'0')||'-'||NVL(LTRIM(s.kw,'0'),'0') as adr,
      p.fio, p.dat_rog
      from arch_kart s, a_kart_pr p, spul l
      where s.mg=mg_ and s.lsk=p.lsk and s.kul=l.id and s.mg=p.mg
      and s.reu=reu_ and s.kul=kul_ and s.nd=nd_ and p.dat_rog between dat2_ and dat3_
      and s.psch<>8 and ((gndr_ <> 2 and p.pol=gndr_) or gndr_ = 2)
      order by l.name, utils.f_order(s.nd,6), utils.f_order(s.kw,7);
    elsif var_ = 2 then
    --по –Ё”
    open prep_refcursor for
      select
      l.name||', '||NVL(LTRIM(s.nd,'0'),'0')||'-'||NVL(LTRIM(s.kw,'0'),'0') as adr,
      p.fio, p.dat_rog
      from arch_kart s, a_kart_pr p, spul l
      where s.mg=mg_ and s.lsk=p.lsk and s.kul=l.id and s.mg=p.mg
      and s.reu=reu_ and p.dat_rog between dat2_ and dat3_
      and s.psch<>8 and ((gndr_ <> 2 and p.pol=gndr_) or gndr_ = 2)
      order by l.name, utils.f_order(s.nd,6), utils.f_order(s.kw,7);
    elsif var_ = 1 then
    --по ∆Ёќ
    open prep_refcursor for
      select
      l.name||', '||NVL(LTRIM(s.nd,'0'),'0')||'-'||NVL(LTRIM(s.kw,'0'),'0') as adr,
      p.fio, p.dat_rog
      from arch_kart s, a_kart_pr p, spul l, s_reu_trest t
      where s.mg=mg_ and s.lsk=p.lsk and s.kul=l.id and s.mg=p.mg
      and s.reu=t.reu and t.trest=trest_ and p.dat_rog between dat2_ and dat3_
      and s.psch<>8 and ((gndr_ <> 2 and p.pol=gndr_) or gndr_ = 2)
      order by l.name, utils.f_order(s.nd,6), utils.f_order(s.kw,7);
    elsif var_ = 0 then
    --по √ороду
    open prep_refcursor for
      select
      l.name||', '||NVL(LTRIM(s.nd,'0'),'0')||'-'||NVL(LTRIM(s.kw,'0'),'0') as adr,
      p.fio, p.dat_rog
      from arch_kart s, a_kart_pr p, spul l
      where s.mg=mg_ and s.lsk=p.lsk and s.kul=l.id and s.mg=p.mg
      and p.dat_rog between dat2_ and dat3_
      and s.psch<>8 and ((gndr_ <> 2 and p.pol=gndr_) or gndr_ = 2)
      order by l.name, utils.f_order(s.nd,6), utils.f_order(s.kw,7);
    end if;
 elsif сd_ in  ('65') then
 --ќтчет дл€ сверки распределени€ оплаты
    --список дл€ “—∆
    if var_ in (1,2,3) then
      raise_application_error(-20001,'Ќе существует уровн€ детализации!');
    elsif var_ = 0 then
      if dat1_ is not null and dat2_ is not null then
        mg2_:=mg_;
      else
        select period into mg2_ from params p;
      end if;
      --по √ороду
      open prep_refcursor for
        'select s.fk_distr, decode(s.fk_distr,0,''деб.сальдо'',1,''кред.сальдо'',2,''тек.начисл.'',3,''на одну усл.'',4,
         ''ошибочн.оплата'') as type_distr, o.name as name_tr,
         u.nm as name_usl, o2.name as name_org,
         b.pay as pay_itg, s.pay, t.deb,
         decode(s.fk_distr, 0, decode(nvl(a.deb,0), 0, 0, round(t.deb/a.deb,2)*100), decode(nvl(d.chrg,0), 0, 0, round(r.chrg/d.chrg,2)*100)) as deb_proc, s.sum_distr,
         round(s.pay/b.pay,2)*100 as pay_proc, r.chrg, d.chrg as chrg1,
         decode(nvl(d.chrg,0), 0, 0, round(r.chrg/d.chrg,2)) as chrg_proc
         from
        (select s.forreu as reu, s.fk_distr, s.usl, s.org, sum(s.summa) as pay, sum(s.sum_distr) as sum_distr
         from xxito14 s where '||sqlstr_||' and s.oper <> ''99'' --кроме корректировок
         group by s.forreu, s.fk_distr, s.usl, s.org) s,
         (select c.reu, c.usl, c.org, sum(c.indebet) as deb
         from xitog3 c where mg='''||mg2_||'''
         group by c.reu, c.usl, c.org) t,
         (select c.reu, c.usl, c.org, sum(c.charges) as chrg --текущее начисление
         from xitog3 c where mg='''||mg2_||'''
         group by c.reu, c.usl, c.org) r,
         (select c.reu, sum(c.charges) as chrg --текущее начисление итогом по –Ё”
         from xitog3 c where mg='''||mg2_||'''
         group by c.reu) d,
        (select reu, sum(c.indebet) as deb
         from xitog3 c where mg='''||mg2_||'''
        group by reu) a,
        (select s.forreu as reu, s.fk_distr, sum(s.summa) as pay
         from xxito14 s where '||sqlstr_||' and s.oper <> ''99'' --кроме корректировок
        group by s.forreu, s.fk_distr) b,
         usl u, t_org o, t_org o2
        where s.reu=t.reu(+) and s.usl=t.usl(+) and s.org=t.org(+) and
         s.reu=r.reu(+) and s.usl=r.usl(+) and s.org=r.org(+) and s.reu=d.reu(+) and
         s.reu=a.reu(+) and s.reu=b.reu and s.fk_distr=b.fk_distr and s.usl=u.usl and s.org=o2.id
         and s.reu=o.reu
        order by s.fk_distr, o.name, u.nm, o2.name';
--0 -по дебетовому сальдо
--1 -по кредитовому сальдо
--2 -только дл€ платежей где где отношение деб.сальдо/платеж < 1 (по текущему начислению + дебет сальдо вх)
--3 -как в Ё+ (вс€ оплата на одну услугу)
--4 -неудачное распределение (не найдено ни в сальдо ни в начислении как распредел€ть оплату)
--5 -корректировки оплаты
 end if;
 elsif сd_ in  ('66') then
  --–еестры по задолжникам, по тарифам, дл€ ƒениса (Ё+)
  --¬ыполн€ть после итогового формировани€ (чтоб вошла вс€ текуща€ оплата)
  --¬ычисл€ем следующий мес€ц
    mg2_ := to_char(add_months(to_date(mg_ || '01', 'YYYYMMDD'), 1),
                   'YYYYMM');
    open prep_refcursor for
    select k.lsk, substr(trim(k.fio),1,25) as fio,
       substr(l.name||', '||NVL(LTRIM(k.nd,'0'),'0')||'-'||NVL(LTRIM(k.kw,'0'),'0') ,1,32)  as adr,
        1 as type, u.nm as type_name, f.name as tarif_name,
       mg2_ as period, nvl(s.summa,0) as summa
       from kart k , nabor n, saldo_usl s,
        spul l, usl u, spr_tarif f
        where k.lsk=s.lsk and k.lsk=n.lsk and n.usl=u.usl and n.fk_tarif=f.id
         and k.kul=l.id and k.lsk=s.lsk and s.mg=mg2_
        and s.usl=u.usl and u.cd='каб.тел.' and f.cdtp='»Ќ“'
        order by f.name;

 elsif сd_ in  ('67') then
  --ƒолги дл€ —бербанка-2 (дл€ кабельного)
  --¬ыполн€ть после итогового формировани€ (чтоб вошла вс€ текуща€ оплата)
  --¬ычисл€ем следующий мес€ц
    mg2_ := to_char(add_months(to_date(mg_ || '01', 'YYYYMMDD'), 1),
                   'YYYYMM');
--дл€ —бера
    open prep_refcursor for
      select k.lsk,
      '' as fio,
       substr(l.name||', '||NVL(LTRIM(k.nd,'0'),'0')||'-'||NVL(LTRIM(k.kw,'0'),'0') ,1,32)  as adr,
        1 as type, s.nm as type_name,
       mg_ as period, null as empty_field, nvl(sum(s.summa),0)*100 as summa
       from kart k,
        (select t.*, u.nm from saldo_usl t, usl u where
         t.mg=mg2_ and t.usl=u.usl and u.cd in ('каб.тел.', 'антен.д.нач.','антен.нач.')) s
        , spul l --лицевые по которым есть сальдо
        where k.psch not in (8,9) and k.lsk=s.lsk and k.kul=l.id
        group by k.lsk, substr(trim(k.fio),1,25), s.nm,
        substr(l.name||', '||NVL(LTRIM(k.nd,'0'),'0')||'-'||NVL(LTRIM(k.kw,'0'),'0') ,1,32)
        union all
      select k.lsk,
      '' as fio,
       substr(l.name||', '||NVL(LTRIM(k.nd,'0'),'0')||'-'||NVL(LTRIM(k.kw,'0'),'0') ,1,32)  as adr,
        1 as type, u.nm as type_name,
       mg_ as period, null as empty_field, 0 as summa
       from kart k, nabor n, spul l, usl u --лицевые по которым нет сальдо
        where k.psch not in (8,9) and k.lsk=n.lsk and k.kul=l.id
        and nvl(decode(u.sptarn, 0, nvl(n.koeff,0), 1, nvl(n.norm,0), 2,
               nvl(n.koeff,0) * nvl(n.norm,0), 3, nvl(n.koeff,0) * nvl(n.norm,0)), 0) <> 0
        and n.usl=u.usl and u.cd in ('каб.тел.', 'антен.д.нач.','антен.нач.')
        and not exists
        (select t.*, u.nm from saldo_usl t, usl u where
         t.mg=mg2_ and t.usl=u.usl and u.cd in ('каб.тел.', 'антен.д.нач.','антен.нач.')
         and t.lsk=k.lsk
         )
        group by k.lsk, substr(trim(k.fio),1,25), u.nm,
        substr(l.name||', '||NVL(LTRIM(k.nd,'0'),'0')||'-'||NVL(LTRIM(k.kw,'0'),'0') ,1,32);
--       having sum(summa) > 0; ред 03.10.2011
 elsif сd_ in  ('68') then
    open prep_refcursor for
      select 'USL' as tp_cd, null as lsk, t.usl as s1, t.nm as s2, null as s3, null as n1
        from usl t
        union all
      select 'ORG' as tp_cd, null as lsk, t.cd as s1, t.name as s2, null as s3, null as n1
        from t_org t
        union all
      select 'STREET' as tp_cd, null as lsk, t.id as s1, t.name as s2, null as s3, null as n1
        from spul t
        union all
      select 'ADR' as tp_cd, t.lsk, t.kul as s1, t.nd as s2, t.kw as s3, null as n1
        from kart t
        union all
      select 'VOL' as tp_cd, n.lsk, n.usl as s1, o.cd as s2, null as s3,
                     round(nvl(decode(u.sptarn, 0, nvl(n.koeff,0), 1, nvl(n.norm,0), 2,
                     nvl(n.koeff,0) * nvl(n.norm,0), 3, nvl(n.koeff,0) * nvl(n.norm,0)), 0), 8) as n1
        from nabor n, t_org o, usl u
        where n.org=o.id and n.usl=u.usl
        and round(nvl(decode(u.sptarn, 0, nvl(n.koeff,0), 1, nvl(n.norm,0), 2,
                     nvl(n.koeff,0) * nvl(n.norm,0), 3, nvl(n.koeff,0) * nvl(n.norm,0)), 0), 8) <> 0
                      and u.usl in ('045', '046');
 elsif сd_ in  ('69') then
  --«адолжники FR, вне зависимости от организатора задолжника

  --(не смог сделать по другому, так как в одной квартире могут быть разные орг. а задолжность
  --по членам семьи - не делитс€)
   kpr1_:=utils.getS_int_param('REP_RNG_KPR1');
   kpr2_:=utils.getS_int_param('REP_RNG_KPR2');

   n1_:=utils.getS_list_param('REP_DEB_VAR');
   if n1_=0 then
     n2_:=utils.getS_int_param('REP_DEB_MONTH');
     else
     n2_:=utils.getS_int_param('REP_DEB_SUMMA');
   end if;

    if var_ = 3 then
    --по ƒому
    open prep_refcursor for
    'select s.lsk, t.name_reu, trim(s.name) as street_name,
      ltrim(s.nd,''0'') as nd, ltrim(s.kw,''0'') as kw, s.fio, s.cnt_month, s.dolg, s.penya,
      case when s.dat is null and s.mg is not null then last_day(to_date(s.mg||''01'',''YYYYMMDD''))
           else s.dat
           end as dat
      from debits_lsk_month s, s_reu_trest t
      where s.reu=t.reu
      and ' || sqlstr_ || '
      and s.reu=:reu_ AND s.kul=:kul_ AND s.nd=:nd_
      and exists
      (select * from kart k where k.lsk=s.lsk
      and (:kpr1_ is not null and k.kpr >=:kpr1_ or :kpr1_ is null)
      and (:kpr2_ is not null and k.kpr <=:kpr2_ or :kpr2_ is null))
      and
      ((:n1_=0 and s.cnt_month >= :n2_) or
      (:n1_=1 and s.dolg >= :n2_))
      order by t.name_reu, s.name, s.nd, s.kw'
      using reu_, kul_, nd_,
    kpr1_, kpr1_, kpr1_, kpr2_, kpr2_, kpr2_, n1_, n2_, n1_, n2_;

    elsif var_ = 2 then
    --по –Ё”
    open prep_refcursor for
    'select s.lsk, t.name_reu, trim(s.name) as street_name,
      ltrim(s.nd,''0'') as nd, ltrim(s.kw,''0'') as kw, s.fio, s.cnt_month, s.dolg, s.penya,
      case when s.dat is null and s.mg is not null then last_day(to_date(s.mg||''01'',''YYYYMMDD''))
           else s.dat
           end as dat
      from debits_lsk_month s, s_reu_trest t
      where s.reu=t.reu
      and ' || sqlstr_ || '
      and s.reu=:reu_
      and exists
      (select * from kart k where k.lsk=s.lsk
      and (:kpr1_ is not null and k.kpr >=:kpr1_ or :kpr1_ is null)
      and (:kpr2_ is not null and k.kpr <=:kpr2_ or :kpr2_ is null))
      and
      ((:n1_=0 and s.cnt_month >= :n2_) or
      (:n1_=1 and s.dolg >= :n2_))
      order by t.name_reu, s.name, s.nd, s.kw'
      using reu_,
    kpr1_, kpr1_, kpr1_, kpr2_, kpr2_, kpr2_, n1_, n2_, n1_, n2_;

    elsif var_ = 1 then
    --по ∆Ёќ
    open prep_refcursor for
    'select s.lsk, t.name_reu, trim(s.name) as street_name,
      ltrim(s.nd,''0'') as nd, ltrim(s.kw,''0'') as kw, s.fio, s.cnt_month, s.dolg, s.penya,
      case when s.dat is null and s.mg is not null then last_day(to_date(s.mg||''01'',''YYYYMMDD''))
           else s.dat
           end as dat
      from debits_lsk_month s, s_reu_trest t
      where s.reu=t.reu
      and ' || sqlstr_ || '
      and s.reu=:trest_
      and exists
      (select * from kart k where k.lsk=s.lsk
      and (:kpr1_ is not null and k.kpr >=:kpr1_ or :kpr1_ is null)
      and (:kpr2_ is not null and k.kpr <=:kpr2_ or :kpr2_ is null))
      and
      ((:n1_=0 and s.cnt_month >= :n2_) or
      (:n1_=1 and s.dolg >= :n2_))
      order by t.name_reu, s.name, s.nd, s.kw'
      using trest_,
    kpr1_, kpr1_, kpr1_, kpr2_, kpr2_, kpr2_, n1_, n2_, n1_, n2_;

    elsif var_ = 0 then
    --по √ороду
    open prep_refcursor for
    'select s.lsk, t.name_reu, trim(s.name) as street_name,
      ltrim(s.nd,''0'') as nd, ltrim(s.kw,''0'') as kw, s.fio, s.cnt_month, s.dolg, s.penya,
      case when s.dat is null and s.mg is not null then last_day(to_date(s.mg||''01'',''YYYYMMDD''))
           else s.dat
           end as dat
      from debits_lsk_month s, s_reu_trest t
      where s.reu=t.reu
      and ' || sqlstr_ || '
      and exists
      (select * from kart k where k.lsk=s.lsk
      and (:kpr1_ is not null and k.kpr >=:kpr1_ or :kpr1_ is null)
      and (:kpr2_ is not null and k.kpr <=:kpr2_ or :kpr2_ is null))
      and
      ((:n1_=0 and s.cnt_month >= :n2_) or
      (:n1_=1 and s.dolg >= :n2_))
      order by t.name_reu, s.name, s.nd, s.kw'
      using kpr1_, kpr1_, kpr1_, kpr2_, kpr2_, kpr2_, n1_, n2_, n1_, n2_;

    end if;

 elsif сd_ in  ('73','74') then
 dat2_:=nvl(utils.getS_date_param('REP_DT_PROP1'),to_date('19000101','YYYYMMDD'));
 dat3_:=nvl(utils.getS_date_param('REP_DT_PROP2'),to_date('29000101','YYYYMMDD'));
 prop_:=nvl(utils.getS_list_param('REP_PROP_VAR'),0);
 --ќтчет по прописанным/выписанным, дл€ паспортного стола
    --список дл€ “—∆
    if var_ = 3 then
    --по ƒому
    open prep_refcursor for
      select
      l.name||', '||NVL(LTRIM(s.nd,'0'),'0')||'-'||NVL(LTRIM(s.kw,'0'),'0') as adr,
      p.fio, r.name as rel, p.dat_prop as dt1, p.dat_ub as dt2
      from arch_kart s, a_kart_pr p, spul l, relations r
      where s.mg=mg_ and s.lsk=p.lsk and s.kul=l.id and s.mg=p.mg and p.relat_id=r.id
      and s.reu=reu_ and s.kul=kul_ and s.nd=nd_
      and decode(prop_,0,p.dat_prop, p.dat_ub) between dat2_ and dat3_
      and s.psch<>8
      order by l.name, utils.f_order(s.nd,6), utils.f_order(s.kw,7);
    elsif var_ = 2 then
    --по –Ё”
    open prep_refcursor for
      select
      l.name||', '||NVL(LTRIM(s.nd,'0'),'0')||'-'||NVL(LTRIM(s.kw,'0'),'0') as adr,
      p.fio, r.name as rel, p.dat_prop as dt1, p.dat_ub as dt2
      from arch_kart s, a_kart_pr p, spul l, relations r
      where s.mg=mg_ and s.lsk=p.lsk and s.kul=l.id and s.mg=p.mg and p.relat_id=r.id
      and s.reu=reu_ and decode(prop_,0,p.dat_prop, p.dat_ub) between dat2_ and dat3_
      and s.psch<>8
      order by l.name, utils.f_order(s.nd,6), utils.f_order(s.kw,7);
    elsif var_ = 1 then
    --по ∆Ёќ
    open prep_refcursor for
      select
      l.name||', '||NVL(LTRIM(s.nd,'0'),'0')||'-'||NVL(LTRIM(s.kw,'0'),'0') as adr,
      p.fio, r.name as rel, p.dat_prop as dt1, p.dat_ub as dt2
      from arch_kart s, a_kart_pr p, spul l, relations r, s_reu_trest t
      where s.mg=mg_ and s.lsk=p.lsk and s.kul=l.id and s.mg=p.mg and p.relat_id=r.id
      and s.reu=t.reu and t.trest=trest_ and decode(prop_,0,p.dat_prop, p.dat_ub) between dat2_ and dat3_
      and s.psch<>8
      order by l.name, utils.f_order(s.nd,6), utils.f_order(s.kw,7);
    elsif var_ = 0 then
    --по √ороду
    open prep_refcursor for
      select
      l.name||', '||NVL(LTRIM(s.nd,'0'),'0')||'-'||NVL(LTRIM(s.kw,'0'),'0') as adr,
      p.fio, r.name as rel, p.dat_prop as dt1, p.dat_ub as dt2
      from arch_kart s, a_kart_pr p, spul l, relations r
      where s.mg=mg_ and s.lsk=p.lsk and s.kul=l.id and s.mg=p.mg and p.relat_id=r.id
      and decode(prop_,0,p.dat_prop, p.dat_ub) between dat2_ and dat3_
      and s.psch<>8
      order by l.name, utils.f_order(s.nd,6), utils.f_order(s.kw,7);
    end if;
 elsif сd_ in  ('75') then
  --ƒолги дл€ ” , “—∆ (дл€ кабельного)
  --¬ыполн€ть после итогового формировани€ (чтоб вошла вс€ текуща€ оплата)
  --¬ычисл€ем следующий мес€ц
    mg2_ := to_char(add_months(to_date(mg_ || '01', 'YYYYMMDD'), 1),
                   'YYYYMM');
--дл€ “—∆
    open prep_refcursor for
      select k.lsk,
       l.cd_kladr, l.name, k.nd, k.kw,
       s.nm as type_name,
       mg_ as period, nvl(sum(s.summa),0)*100 as summa
       from scott.kart k ,
        (select t.*, u.nm from scott.saldo_usl t, scott.usl u where
         t.mg=mg2_ and t.usl=u.usl and u.cd in ('каб.тел.', 'антен.д.нач.','антен.нач.')) s
        , scott.spul l
        where k.psch not in (8,9) and k.lsk=s.lsk and k.kul=l.id
        group by k.lsk, substr(trim(k.fio),1,25), s.nm,
        l.name, l.cd_kladr, k.nd, k.kw
     union all
      select k.lsk,
       l.cd_kladr, l.name, k.nd, k.kw,
       u.nm as type_name,
       mg_ as period, 0 as summa
       from kart k, nabor n, spul l, usl u --лицевые по которым нет сальдо
        where k.psch not in (8,9) and k.lsk=n.lsk and k.kul=l.id
        and nvl(decode(u.sptarn, 0, nvl(n.koeff,0), 1, nvl(n.norm,0), 2,
               nvl(n.koeff,0) * nvl(n.norm,0), 3, nvl(n.koeff,0) * nvl(n.norm,0)), 0) <> 0
        and n.usl=u.usl and u.cd in ('каб.тел.', 'антен.д.нач.','антен.нач.')
        and not exists
        (select t.*, u.nm from saldo_usl t, usl u where
         t.mg=mg2_ and t.usl=u.usl and u.cd in ('каб.тел.', 'антен.д.нач.','антен.нач.')
         and t.lsk=k.lsk
         )
        group by k.lsk, substr(trim(k.fio),1,25), u.nm,
        l.name, l.cd_kladr, k.nd, k.kw;
 elsif сd_ in  ('77') then
  --ƒолги дл€ прочих банков (от “—∆)
  --¬ыполн€ть после итогового формировани€ (чтоб вошла вс€ текуща€ оплата)
  --¬ычисл€ем следующий мес€ц
    mg2_ := to_char(add_months(to_date(mg_ || '01', 'YYYYMMDD'), 1),
                   'YYYYMM');
    if var_ = 3 then
    --по ƒому
    open prep_refcursor for
     select k.fio||';'||t.name||','||l.name||','||ltrim(k.nd,'0')||','||ltrim(k.kw,'0')||';'||k.lsk||';'||to_char(sum(s.summa),'999990.99') as txt,
           sum(s.summa) as srv_sum --служебное поле, дл€ подсчЄта итоговой суммы по файлу
           from kart k, saldo_usl s, usl u, spul l, t_org t, t_org_tp tp
            where k.lsk=s.lsk(+) and k.kul=l.id and s.mg=mg2_
            and s.usl=u.usl and t.fk_orgtp=tp.id and tp.cd='√ород'
            and k.reu=reu_ and k.kul=kul_ and k.nd=nd_
            group by k.fio, t.name, l.name, k.nd, k.kw, k.lsk
            order by l.name, k.nd, k.kw;
    elsif var_ = 2 then
    --по ” 
    open prep_refcursor for
     select k.fio||';'||t.name||','||l.name||','||ltrim(k.nd,'0')||','||ltrim(k.kw,'0')||';'||k.lsk||';'||to_char(sum(s.summa),'999990.99') as txt,
           sum(s.summa) as srv_sum --служебное поле, дл€ подсчЄта итоговой суммы по файлу
           from kart k, saldo_usl s, usl u, spul l, t_org t, t_org_tp tp
            where k.lsk=s.lsk(+) and k.kul=l.id and s.mg=mg2_
            and s.usl=u.usl and t.fk_orgtp=tp.id and tp.cd='√ород'
            and k.reu=reu_
            group by k.fio, t.name, l.name, k.nd, k.kw, k.lsk
            order by l.name, k.nd, k.kw;
    elsif var_ = 1 then
    --по ‘онду
    open prep_refcursor for
     select k.fio||';'||t.name||','||l.name||','||ltrim(k.nd,'0')||','||ltrim(k.kw,'0')||';'||k.lsk||';'||to_char(sum(s.summa),'999990.99') as txt,
           sum(s.summa) as srv_sum --служебное поле, дл€ подсчЄта итоговой суммы по файлу
           from kart k, saldo_usl s, usl u, spul l, t_org t, t_org_tp tp
            where k.lsk=s.lsk(+) and k.kul=l.id and s.mg=mg2_
            and s.usl=u.usl and t.fk_orgtp=tp.id and tp.cd='√ород'
            and exists (select * from s_reu_trest r where r.reu=k.reu and r.trest=trest_)
            group by k.fio, t.name, l.name, k.nd, k.kw, k.lsk
            order by l.name, k.nd, k.kw;
    elsif var_ = 0 then
    --по √ороду
    open prep_refcursor for
     select k.fio||';'||t.name||','||l.name||','||ltrim(k.nd,'0')||','||ltrim(k.kw,'0')||';'||k.lsk||';'||to_char(sum(s.summa),'999990.99') as txt,
           sum(s.summa) as srv_sum --служебное поле, дл€ подсчЄта итоговой суммы по файлу
           from kart k, saldo_usl s, usl u, spul l, t_org t, t_org_tp tp
            where k.lsk=s.lsk(+) and k.kul=l.id and s.mg=mg2_
            and s.usl=u.usl and t.fk_orgtp=tp.id and tp.cd='√ород'
            group by k.fio, t.name, l.name, k.nd, k.kw, k.lsk
            order by l.name, k.nd, k.kw;
    end if;
 elsif сd_ in  ('78') then
 --форма дл€ контрол€ тарифов
--det_ - вариант (0-только по основным лс., 1 - только по дополнит лс.)
 l_sel:=utils.getScd_list_param('REP_TP_SCH_SEL');
--Raise_application_error(-20000, show_fond_);
 if l_cur_period=mg_ then
 --текущий период
    if var_ = 3 then
    --по ƒому
    open prep_refcursor for
     select distinct null as btn, k.house_id, u.usl, u.npp, u.nm, t.org, g.id, g.id||' '||g.name as name, m.id||' '||m.name as name2,
       t.koeff, t.norm, u.sptarn
       from kart k, nabor t, usl u, t_org g, t_org m, v_lsk_tp tp
        where k.lsk=t.lsk and t.usl=u.usl
        and t.org=g.id and g.fk_org2=m.id
        and k.house_id=p_house
        and k.fk_tp=tp.id
        and tp.cd=l_sel
       order by u.npp, g.id, t.koeff, t.norm;
    elsif var_ = 2 then
    --по ” 
    open prep_refcursor for
     select distinct null as btn, null as house_id, u.usl, u.npp, u.nm, t.org, g.id, g.id||' '||g.name as name, m.id||' '||m.name as name2,
       t.koeff, t.norm, u.sptarn
       from kart k, nabor t, usl u, t_org g, t_org m, v_lsk_tp tp
        where k.lsk=t.lsk and t.usl=u.usl
        and t.org=g.id and g.fk_org2=m.id
        and k.reu = reu_
        and k.fk_tp=tp.id
        and tp.cd=l_sel
       order by u.npp, g.id, t.koeff, t.norm;
    elsif var_ = 1 then
    --по ‘онду
    open prep_refcursor for
     select distinct null as btn, null as house_id, u.usl, u.npp, u.nm, t.org, g.id, g.id||' '||g.name as name, m.id||' '||m.name as name2,
       t.koeff, t.norm, u.sptarn
       from kart k, nabor t, usl u, t_org g, t_org m, v_lsk_tp tp
        where k.lsk=t.lsk and t.usl=u.usl
        and t.org=g.id and g.fk_org2=m.id
        and k.fk_tp=tp.id
        and exists (select * from s_reu_trest r where r.reu=k.reu and r.trest=trest_)
        and tp.cd=l_sel
       order by u.npp, g.id, t.koeff, t.norm;
    elsif var_ = 0 then
    --по √ороду
    open prep_refcursor for
     select distinct null as btn, null as house_id, u.usl, u.npp, u.nm, t.org, g.id, g.id||' '||g.name as name, m.id||' '||m.name as name2,
       t.koeff, t.norm, u.sptarn
       from kart k, nabor t, usl u, t_org g, t_org m, v_lsk_tp tp
        where k.lsk=t.lsk and t.usl=u.usl
        and t.org=g.id and g.fk_org2=m.id
        and k.fk_tp=tp.id
        and tp.cd=l_sel
       order by u.npp, g.id, t.koeff, t.norm;
    end if;
   else
   --прошлый период
    if var_ = 3 then
    --по ƒому
    open prep_refcursor for
     select distinct null as btn, k.house_id, u.usl, u.npp, u.nm, t.org, g.id, g.id||' '||g.name as name, m.id||' '||m.name as name2,
       t.koeff, t.norm, u.sptarn
       from arch_kart k, a_nabor t, usl u, t_org g, t_org m, v_lsk_tp tp
        where k.lsk=t.lsk and t.usl=u.usl
        and t.org=g.id and g.fk_org2=m.id
        and k.house_id=p_house
        and k.mg=mg_ and k.mg=t.mg
        and k.fk_tp=tp.id
        and tp.cd=l_sel
       order by u.npp, g.id, t.koeff, t.norm;
    elsif var_ = 2 then
    --по ” 
    open prep_refcursor for
     select distinct null as btn, null as house_id, u.usl, u.npp, u.nm, t.org, g.id, g.id||' '||g.name as name, m.id||' '||m.name as name2,
       t.koeff, t.norm, u.sptarn
       from arch_kart k, a_nabor t, usl u, t_org g, t_org m, v_lsk_tp tp
        where k.lsk=t.lsk and t.usl=u.usl
        and t.org=g.id and g.fk_org2=m.id
        and k.reu = reu_
        and k.mg=mg_ and k.mg=t.mg
        and k.fk_tp=tp.id
        and tp.cd=l_sel
       order by u.npp, g.id, t.koeff, t.norm;
    elsif var_ = 1 then
    --по ‘онду
    open prep_refcursor for
     select distinct null as btn, null as house_id, u.usl, u.npp, u.nm, t.org, g.id, g.id||' '||g.name as name, m.id||' '||m.name as name2,
       t.koeff, t.norm, u.sptarn
       from arch_kart k, a_nabor t, usl u, t_org g, t_org m, v_lsk_tp tp
        where k.lsk=t.lsk and t.usl=u.usl
        and t.org=g.id and g.fk_org2=m.id
        and exists (select * from s_reu_trest r where r.reu=k.reu and r.trest=trest_)
        and k.mg=mg_ and k.mg=t.mg
        and k.fk_tp=tp.id
        and tp.cd=l_sel
       order by u.npp, g.id, t.koeff, t.norm;
    elsif var_ = 0 then
    --по √ороду
    open prep_refcursor for
     select distinct null as btn, null as house_id, u.usl, u.npp, u.nm, t.org, g.id, g.id||' '||g.name as name, m.id||' '||m.name as name2,
       t.koeff, t.norm, u.sptarn
       from arch_kart k, a_nabor t, usl u, t_org g, t_org m, v_lsk_tp tp
        where k.lsk=t.lsk and t.usl=u.usl
        and t.org=g.id and g.fk_org2=m.id
        and k.mg=mg_ and k.mg=t.mg
        and k.fk_tp=tp.id
        and tp.cd=l_sel
       order by u.npp, g.id, t.koeff, t.norm;
    end if;
   end if;

 elsif сd_ in  ('79') then
 --отчет (дл€ ѕолыс) по льготникам, дл€ ”—«Ќ
     if var_ = 3 then
        --ѕо дому
        raise_application_error(-20001,'Ќе существует уровн€ детализации!');
      elsif var_ = 2 then
        --ѕо –Ё”
        raise_application_error(-20001,'Ќе существует уровн€ детализации!');
      elsif var_ = 1 then
        --ѕо ∆Ёќ
        raise_application_error(-20001,'Ќе существует уровн€ детализации!');
      elsif var_ = 0 then
        --(все тресты)
          open prep_refcursor for
          'select k.lsk, k.mg, s.name||'', ''||NVL(LTRIM(k.nd,''0''),''0'')||''-''||NVL(LTRIM(k.kw,''0''),''0'') as adr,
           k.opl, decode(k.status,1,''-'',''+'') as status,
           a.summa1,
           a.summa2,
           a.summa3,
           a.summa4,
           a.summa5,
           a.summa6,
           a.summa7,
           a.summa8,
           a.norm1, a.norm2, a.norm3, a.tp1, 
           a.limit1, a.limit2, a.limit3
           from arch_kart k, spul s,
           (select n.lsk,
               max(decode(t.usl,''003'',t.test_cena,''004'',t.test_cena,0)) as summa1, --тек.содержание
               max(decode(t.usl,''005'',t.test_cena,0))+
               max(decode(t.usl,''006'',t.test_cena,0))+
               max(decode(t.usl,''009'',t.test_cena,0))+
               max(decode(t.usl,''010'',t.test_cena,0)) as summa2, --лифт
               max(decode(t.usl,''031'',t.test_cena,''046'',t.summa,0)) as summa3,  --тбо
               max(decode(t.usl,''052'',t.test_cena,0)) as summa4,  --ассенизаци€
               max(decode(t.usl,''054'',t.test_cena,0)) as summa5,  --утилизаци€
               max(decode(t.usl,''033'',t.test_cena,''034'',test_cena,0)) as summa6, --расценка кап.рем.
               max(decode(t.usl,''026'',test_cena,0)) as summa7, --расценка найм.
               max(decode(t.usl,''055'',t.test_cena,0)) as summa8, --текущий ремонт
               max(decode(n.usl,''011'',n.norm,0)) as norm1,  --норматив хвс
               max(decode(n.usl,''015'',n.norm,0)) as norm2,  --норматив гвс
               max(decode(n.usl,''013'',n.norm,0)) as norm3,  --норматив водоотвед
               case when nvl(max(decode(t.usl,''007'',t.summa,''008'',t.summa,0)),0) <> 0 then ''+''
                 else ''-'' end as tp1, --признак наличи€ отоплени€
               max(decode(n.usl,''011'',d.nrm,0)) as limit1,  --ограничение ќƒЌ хвс
               max(decode(n.usl,''015'',d.nrm,0)) as limit2,  --ограничение ќƒЌ гвс
               max(decode(n.usl,''053'',d.nrm,0)) as limit3  --ограничение ќƒЌ Ёл.эн.
               from a_charge t, a_nabor n, a_vvod d
               where n.mg=:mg_ and t.mg(+)=n.mg and n.mg=d.mg(+)
               and t.usl(+)=n.usl and t.lsk(+)=n.lsk
               and t.type(+)=1
               and n.fk_vvod=d.id(+)
             group by n.lsk) a
           where k.kul=s.id and k.lsk=a.lsk(+)
           and k.mg=:mg_ and k.psch not in (8,9)
           order by s.name, utils.f_order(k.nd,6), utils.f_order2(k.nd), utils.f_order(k.kw,7), k.lsk'
           using mg_, mg_;
      end if;
 elsif сd_ = '80' then
 --«адолжники OLAP-2 - верси€ дл€ тех, кто использует c_deb_usl (полыс.)

--   cur_pay_:=utils.getS_bool_param('REP_CUR_PAY');
   kpr1_:=utils.getS_int_param('REP_RNG_KPR1');
   kpr2_:=utils.getS_int_param('REP_RNG_KPR2');
   n1_:=utils.getS_list_param('REP_DEB_VAR');
   if n1_=0 then
     n2_:=utils.getS_int_param('REP_DEB_MONTH');
     else
     n2_:=utils.getS_int_param('REP_DEB_SUMMA');
   end if;

   if var_ = 3 then
    --ѕо дому
   open prep_refcursor for
   'select s.lsk,
       s.org,
       o.name as name_org,
       u.nm,
       u.nm1,
       decode(k.psch,
              9,
              ''«акрытые Ћ/—'',
              8,
              ''—тарый фонд'',
              ''ќткрытые Ћ/—'') as psch,
       r.name_tr,
       r.name_reu,
       l.name as street,
       ltrim(k.nd, ''0'') as nd,
       ltrim(k.kw, ''0'') as kw,
       k.nd, k.kw,
       decode(:det_, 3, trim(l.name) || '', '' || ltrim(k.nd, ''0'') || ''-'' || ltrim(k.kw, ''0''),
               trim(l.name) || '', '' || ltrim(k.nd, ''0'')) --показать информацию по квартирам или по домам
        as adr,
       k.fio,
       sum(s.summa) as dolg,
       t.cnt_month as cnt
  from kart k, c_deb_usl s, (select d.lsk, d.cnt_month
          from debits_lsk_month d where '||sqlstr3_||') t, t_org o, spul l, s_reu_trest r, usl u
 where s.summa > 0
   and s.usl=u.usl and s.mg<=:l_prev_period
   and exists (select *
          from debits_lsk_month d
         where d.k_lsk_id=k.k_lsk_id and '||sqlstr3_||' --вз€ть текущий период
            and
            ((:n1_=0 and d.cnt_month >= :n2_) or
            (:n1_=1 and d.dolg >= :n2_))
           )
   and (:kpr1_ is not null and k.kpr >=:kpr1_ or :kpr1_ is null)
   and (:kpr2_ is not null and k.kpr <=:kpr2_ or :kpr2_ is null)
   and s.org = o.id
   and k.lsk = s.lsk
   and k.lsk = t.lsk
   and k.kul = l.id
   and k.reu = r.reu and k.reu=:reu and k.kul=:kul and k.nd=:nd and '||sqlstr2_||'
 group by s.lsk,
          s.org,
          o.name,
          u.nm,
          u.nm1,
          decode(k.psch,
                 9,
                 ''«акрытые Ћ/—'',
                 8,
                 ''—тарый фонд'',
                 ''ќткрытые Ћ/—''),
          r.name_tr,
          r.name_reu,
          l.name,
          ltrim(k.nd, ''0''),
          ltrim(k.kw, ''0''),
          k.nd, k.kw,
          trim(l.name) || '', '' || ltrim(k.nd, ''0'') || ''-'' ||
          ltrim(k.kw, ''0''),
          k.fio,
          t.cnt_month
 order by trim(l.name), utils.f_order(k.nd, 6), utils.f_order(k.kw, 7)'
    using det_, l_prev_period, kpr1_, n1_, n2_, n1_, n2_, kpr1_, kpr1_, kpr2_, kpr2_, kpr2_,
    reu_, kul_, nd_;
 elsif var_ = 2 then
    --ѕо ∆Ёќ
   open prep_refcursor for
   'select s.lsk,
       s.org,
       o.name as name_org,
       u.nm,
       u.nm1,
       decode(k.psch,
              9,
              ''«акрытые Ћ/—'',
              8,
              ''—тарый фонд'',
              ''ќткрытые Ћ/—'') as psch,
       r.name_tr,
       r.name_reu,
       l.name as street,
       ltrim(k.nd, ''0'') as nd,
       ltrim(k.kw, ''0'') as kw,
       k.nd, k.kw,
       decode(:det_, 3, trim(l.name) || '', '' || ltrim(k.nd, ''0'') || ''-'' || ltrim(k.kw, ''0''),
               trim(l.name) || '', '' || ltrim(k.nd, ''0'')) --показать информацию по квартирам или по домам
       as adr,
       k.fio,
       sum(s.summa) as dolg,
       t.cnt_month as cnt
  from kart k, c_deb_usl s, (select d.lsk, d.cnt_month
          from debits_lsk_month d where '||sqlstr3_||') t, t_org o, spul l, s_reu_trest r, usl u
 where s.summa > 0
   and s.usl=u.usl
   and s.mg<=:l_prev_period
   and exists (select *
          from debits_lsk_month d
         where d.k_lsk_id=k.k_lsk_id and '||sqlstr3_||'
            and
            ((:n1_=0 and d.cnt_month >= :n2_) or
            (:n1_=1 and d.dolg >= :n2_))
           )
   and (:kpr1_ is not null and k.kpr >=:kpr1_ or :kpr1_ is null)
   and (:kpr2_ is not null and k.kpr <=:kpr2_ or :kpr2_ is null)
   and s.org = o.id
   and k.lsk = s.lsk
   and k.lsk = t.lsk
   and k.kul = l.id
   and k.reu = r.reu and r.reu=:reu and '||sqlstr2_||'
 group by s.lsk,
          s.org,
          o.name,
          u.nm,
          u.nm1,
          decode(k.psch,
                 9,
                 ''«акрытые Ћ/—'',
                 8,
                 ''—тарый фонд'',
                 ''ќткрытые Ћ/—''),
          r.name_tr,
          r.name_reu,
          l.name,
          ltrim(k.nd, ''0''),
          ltrim(k.kw, ''0''),
          k.nd, k.kw,
          trim(l.name) || '', '' || ltrim(k.nd, ''0'') || ''-'' ||
          ltrim(k.kw, ''0''),
          k.fio,
          t.cnt_month
 order by trim(l.name), utils.f_order(k.nd, 6), utils.f_order(k.kw, 7)'
    using det_, l_prev_period, n1_, n2_, n1_, n2_, kpr1_, kpr1_, kpr1_, kpr2_, kpr2_, kpr2_, reu_;
 elsif var_ = 1 then
    --ѕо фонду
   open prep_refcursor for
   'select s.lsk,
       s.org,
       o.name as name_org,
       u.nm,
       u.nm1,
       decode(k.psch,
              9,
              ''«акрытые Ћ/—'',
              8,
              ''—тарый фонд'',
              ''ќткрытые Ћ/—'') as psch,
       r.name_tr,
       r.name_reu,
       l.name as street,
       ltrim(k.nd, ''0'') as nd,
       ltrim(k.kw, ''0'') as kw,
       k.nd, k.kw,
       decode(:det_, 3, trim(l.name) || '', '' || ltrim(k.nd, ''0'') || ''-'' || ltrim(k.kw, ''0''),
               trim(l.name) || '', '' || ltrim(k.nd, ''0'')) --показать информацию по квартирам или по домам
       as adr,
       k.fio,
       sum(s.summa) as dolg,
       t.cnt_month as cnt
  from kart k, c_deb_usl s, (select d.lsk, d.cnt_month
          from debits_lsk_month d where '||sqlstr3_||') t, t_org o, spul l, s_reu_trest r, usl u
 where s.summa > 0
   and s.usl=u.usl
   and s.mg<=:l_prev_period
   and exists (select *
          from debits_lsk_month d
         where d.k_lsk_id=k.k_lsk_id and '||sqlstr3_||'
            and
            ((:n1_=0 and d.cnt_month >= :n2_) or
            (:n1_=1 and d.dolg >= :n2_))
           )
   and (:kpr1_ is not null and k.kpr >=:kpr1_ or :kpr1_ is null)
   and (:kpr2_ is not null and k.kpr <=:kpr2_ or :kpr2_ is null)
   and s.org = o.id
   and k.lsk = s.lsk
   and k.lsk = t.lsk
   and k.kul = l.id
   and k.reu = r.reu and r.trest=:trest and '||sqlstr2_||'
 group by s.lsk,
          s.org,
          u.nm,
          u.nm1,
          decode(k.psch,
                 9,
                 ''«акрытые Ћ/—'',
                 8,
                 ''—тарый фонд'',
                 ''ќткрытые Ћ/—''),
          r.name_tr,
          r.name_reu,
          l.name,
          ltrim(k.nd, ''0''),
          ltrim(k.kw, ''0''),
          k.nd, k.kw,
          trim(l.name) || '', '' || ltrim(k.nd, ''0'') || ''-'' ||
          ltrim(k.kw, ''0''),
          k.fio,
          t.cnt_month
 order by trim(l.name), utils.f_order(k.nd, 6), utils.f_order(k.kw, 7)'
    using det_, l_prev_period, n1_, n2_, n1_, n2_, kpr1_, kpr1_, kpr1_, kpr2_, kpr2_, kpr2_, trest_;
   elsif var_ = 0 then
   --ѕо городу
   open prep_refcursor for
   'select s.lsk,
       s.org,
       o.name as name_org,
       u.nm,
       u.nm1,
       decode(k.psch,
              9,
              ''«акрытые Ћ/—'',
              8,
              ''—тарый фонд'',
              ''ќткрытые Ћ/—'') as psch,
       r.name_tr,
       r.name_reu,
       l.name as street,
       ltrim(k.nd, ''0'') as nd,
       ltrim(k.kw, ''0'') as kw,
       k.nd, k.kw,
       decode(:det_, 3, trim(l.name) || '', '' || ltrim(k.nd, ''0'') || ''-'' || ltrim(k.kw, ''0''),
               trim(l.name) || '', '' || ltrim(k.nd, ''0'')) --показать информацию по квартирам или по домам
       as adr,
       k.fio,
       sum(s.summa) as dolg,
       t.cnt_month as cnt  from kart k, c_deb_usl s, (select d.lsk, d.cnt_month
          from debits_lsk_month d where '||sqlstr3_||') t, t_org o, spul l, s_reu_trest r, usl u
 where s.summa > 0
   and s.usl=u.usl and s.mg<=:l_prev_period
   and exists (select *
          from debits_lsk_month d
         where d.k_lsk_id=k.k_lsk_id and '||sqlstr3_||'
            and
            ((:n1_=0 and d.cnt_month >= :n2_) or
            (:n1_=1 and d.dolg >= :n2_))
           )
   and (:kpr1_ is not null and k.kpr >=:kpr1_ or :kpr1_ is null)
   and (:kpr2_ is not null and k.kpr <=:kpr2_ or :kpr2_ is null)
   and s.org = o.id
   and k.lsk = s.lsk
   and k.lsk = t.lsk
   and k.kul = l.id
   and k.reu = r.reu and '||sqlstr2_||'
 group by s.lsk,
          s.org,
          u.nm,
          u.nm1,
          o.name,
          decode(k.psch,
                 9,
                 ''«акрытые Ћ/—'',
                 8,
                 ''—тарый фонд'',
                 ''ќткрытые Ћ/—''),
          r.name_tr,
          r.name_reu,
          l.name,
          ltrim(k.nd, ''0''),
          ltrim(k.kw, ''0''),
          k.nd, k.kw,
          trim(l.name) || '', '' || ltrim(k.nd, ''0'') || ''-'' ||
          ltrim(k.kw, ''0''),
          k.fio,
          t.cnt_month
 order by trim(l.name), utils.f_order(k.nd, 6), utils.f_order(k.kw, 7)'
    using det_, l_prev_period, n1_, n2_, n1_, n2_, kpr1_, kpr1_, kpr1_, kpr2_, kpr2_, kpr2_;
    end if;

 elsif сd_ = '81' then
 --ќтчет дл€ Ё+ (дл€ ƒениса)
   l_sql:='select k.lsk, k.lsk_ext as lsk2, sp.name, ltrim(k.nd, ''0'') as nd,
      ltrim(k.kw, ''0'') as kw, t.cdtp, p.cena, -1*nvl(s.summa,0)/*-nvl(a.summa,0)*/ as summa from kart k,
      nabor n, spr_tarif t, spr_tarif_prices p, spul sp,
      (select s.lsk, sum(summa) as summa from saldo_usl s where s.usl=''042''
       and s.mg='||l_mg_next||'
       group by s.lsk) s,
      (select t.lsk, sum(t.summa) as summa from c_charge t where t.usl=''042''
       and t.type=1
       group by t.lsk) a
       where k.lsk=n.lsk and k.lsk=s.lsk(+)and k.lsk=a.lsk(+) and t.cdtp=''»Ќ“''
      and t.id=p.fk_tarif and '||mg_||'
      between p.mg1 and p.mg2
      and n.fk_tarif=t.id
      and sp.id=k.kul
      and nvl(n.norm,0) <> 0
      and nvl(n.koeff,0) <> 0
      order by sp.name, utils.f_order(k.nd,6), utils.f_order(k.kw,6)';
   if nvl(p_out_tp,0) =1 then
   if utils.set_base_state_gen(1) = 0 then
     --если выполнили ЅЋќ »–ќ¬ ” формировани€,
     --в противном случае выгрузить пустой отчет
     --установить состо€ние базы - не выполнено итоговое формирование
     init.set_state(0);
     --выполнить формирование сальдо
     gen.gen_saldo(null);
     --выгрузить в файл,в директорию по умолчанию
     SQLTofile(l_sql, 'LOAD_FILE_DIR', 'OUT'||to_char(trunc(sysdate),'YYYYMMDD')||'.txt',
       'OUT'||to_char(trunc(sysdate),'YYYYMMDD')||'.txt', ';');
     --снимаем ЅЋќ »–ќ¬ ”
     l_cnt:=utils.set_base_state_gen(0);
   else
     --пустой отчет
     SQLTofile('select null as lsk from dual', 'LOAD_FILE_DIR', 'OUT'||to_char(trunc(sysdate),'YYYYMMDD')||'.txt',
       'OUT'||to_char(trunc(sysdate),'YYYYMMDD')||'.txt', ';');
   end if;

   else
   --отправить как реф-курсор
     open prep_refcursor for l_sql/*
       using l_mg_next, mg_, mg_, mg_*/;
    end if;

 elsif сd_ in  ('82') then
  --«адолжники FR, в зависимости от организатора задолжника - дл€ ѕолыс.
  --переделал, что можно вывести по нескольким орг.
   kpr1_:=utils.getS_int_param('REP_RNG_KPR1');
   kpr2_:=utils.getS_int_param('REP_RNG_KPR2');

   n1_:=utils.getS_list_param('REP_DEB_VAR');
   if n1_=0 then
     n2_:=utils.getS_int_param('REP_DEB_MONTH');
     else
     n2_:=utils.getS_int_param('REP_DEB_SUMMA');
   end if;

    if var_ = 3 then
    --по ƒому
    open prep_refcursor for
    'select o.name as name_deb_org, s.lsk, t.name_reu, trim(s.name) as street_name,
      ltrim(s.nd,''0'') as nd, ltrim(s.kw,''0'') as kw, pr.fio, s.cnt_month, s.dolg, s.penya,
      case when s.dat is null and s.mg is not null then to_date(s.mg||''01'',''YYYYMMDD'')
           else s.dat
           end as dat
      from debits_lsk_month s, s_reu_trest t, t_org o, c_kart_pr pr
      where s.reu=t.reu
      and ' || sqlstr_ || '
      and s.reu=:reu_ AND s.kul=:kul_ AND s.nd=:nd_
      and exists
      (select * from kart k where k.lsk=s.lsk
      and (:kpr1_ is not null and k.kpr >=:kpr1_ or :kpr1_ is null)
      and (:kpr2_ is not null and k.kpr <=:kpr2_ or :kpr2_ is null))
      and
      ((:n1_=0 and s.cnt_month >= :n2_) or
      (:n1_=1 and s.dolg >= :n2_))
      and exists
      (select * from c_kart_pr r, list_c i, spr_params p where i.fk_ses=:fk_ses_
            and p.id=i.fk_par and p.cd=''REP_ORG''
            and r.fk_deb_org=i.sel_id
            and s.lsk=r.lsk
            and i.sel_id=o.id
            and r.id=pr.id
            and r.status<>4
            and i.sel=1)
      order by o.name, t.name_reu, s.name, s.nd, s.kw'
      using reu_, kul_, nd_,
    kpr1_, kpr1_, kpr1_, kpr2_, kpr2_, kpr2_, n1_, n2_, n1_, n2_, fk_ses_;

    elsif var_ = 2 then
    --по –Ё”
    open prep_refcursor for
    'select o.name as name_deb_org, s.lsk, t.name_reu, trim(s.name) as street_name,
      ltrim(s.nd,''0'') as nd, ltrim(s.kw,''0'') as kw, pr.fio, s.cnt_month, s.dolg, s.penya,
      case when s.dat is null and s.mg is not null then to_date(s.mg||''01'',''YYYYMMDD'')
           else s.dat
           end as dat
      from debits_lsk_month s, s_reu_trest t, t_org o, c_kart_pr pr
      where s.reu=t.reu
      and ' || sqlstr_ || '
      and s.reu=:reu_
      and exists
      (select * from kart k where k.lsk=s.lsk
      and (:kpr1_ is not null and k.kpr >=:kpr1_ or :kpr1_ is null)
      and (:kpr2_ is not null and k.kpr <=:kpr2_ or :kpr2_ is null))
      and
      ((:n1_=0 and s.cnt_month >= :n2_) or
      (:n1_=1 and s.dolg >= :n2_))
      and exists
      (select * from c_kart_pr r, list_c i, spr_params p where i.fk_ses=:fk_ses_
            and p.id=i.fk_par and p.cd=''REP_ORG''
            and r.fk_deb_org=i.sel_id
            and s.lsk=r.lsk
            and i.sel_id=o.id
            and r.id=pr.id
            and r.status<>4
            and i.sel=1)
      order by o.name, t.name_reu, s.name, s.nd, s.kw'
      using reu_,
    kpr1_, kpr1_, kpr1_, kpr2_, kpr2_, kpr2_, n1_, n2_, n1_, n2_, fk_ses_;

    elsif var_ = 1 then
    --по ∆Ёќ
    open prep_refcursor for
    'select o.name as name_deb_org, s.lsk, t.name_reu, trim(s.name) as street_name,
      ltrim(s.nd,''0'') as nd, ltrim(s.kw,''0'') as kw, pr.fio, s.cnt_month, s.dolg, s.penya,
      case when s.dat is null and s.mg is not null then to_date(s.mg||''01'',''YYYYMMDD'')
           else s.dat
           end as dat
      from debits_lsk_month s, s_reu_trest t, t_org o, c_kart_pr pr
      where s.reu=t.reu
      and ' || sqlstr_ || '
      and s.reu=:trest_
      and exists
      (select * from kart k where k.lsk=s.lsk
      and (:kpr1_ is not null and k.kpr >=:kpr1_ or :kpr1_ is null)
      and (:kpr2_ is not null and k.kpr <=:kpr2_ or :kpr2_ is null))
      and
      ((:n1_=0 and s.cnt_month >= :n2_) or
      (:n1_=1 and s.dolg >= :n2_))
      and exists
      (select * from c_kart_pr r, list_c i, spr_params p where i.fk_ses=:fk_ses_
            and p.id=i.fk_par and p.cd=''REP_ORG''
            and r.fk_deb_org=i.sel_id
            and s.lsk=r.lsk
            and i.sel_id=o.id
            and r.id=pr.id
            and r.status<>4
            and i.sel=1)
      order by o.name, t.name_reu, s.name, s.nd, s.kw'
      using trest_,
    kpr1_, kpr1_, kpr1_, kpr2_, kpr2_, kpr2_, n1_, n2_, n1_, n2_, fk_ses_;

    elsif var_ = 0 then
    --по √ороду
    open prep_refcursor for
    'select o.name as name_deb_org, s.lsk, t.name_reu, trim(s.name) as street_name,
      ltrim(s.nd,''0'') as nd, ltrim(s.kw,''0'') as kw, pr.fio, s.cnt_month, s.dolg, s.penya,
      case when s.dat is null and s.mg is not null then to_date(s.mg||''01'',''YYYYMMDD'')
           else s.dat
           end as dat
      from debits_lsk_month s, s_reu_trest t, t_org o, c_kart_pr pr
      where s.reu=t.reu
      and ' || sqlstr_ || '
      and exists
      (select * from kart k where k.lsk=s.lsk
      and (:kpr1_ is not null and k.kpr >=:kpr1_ or :kpr1_ is null)
      and (:kpr2_ is not null and k.kpr <=:kpr2_ or :kpr2_ is null))
      and
      ((:n1_=0 and s.cnt_month >= :n2_) or
      (:n1_=1 and s.dolg >= :n2_))
      and exists
      (select * from c_kart_pr r, list_c i, spr_params p where i.fk_ses=:fk_ses_
            and p.id=i.fk_par and p.cd=''REP_ORG''
            and r.fk_deb_org=i.sel_id
            and s.lsk=r.lsk
            and i.sel_id=o.id
            and r.id=pr.id
            and r.status<>4
            and i.sel=1)
      order by o.name, t.name_reu, s.name, s.nd, s.kw'
      using kpr1_, kpr1_, kpr1_, kpr2_, kpr2_, kpr2_, n1_, n2_, n1_, n2_, fk_ses_;
   end if;
 elsif сd_ in  ('83') then
    --отчЄт дл€ администрации по тарифам, объемам, нормативам и прочее...
    --имеет дочерний датасет в rep_detail
    if var_ = 3 then
    --по ƒому
     open prep_refcursor for
       'select s.lsk, st.name as name_st, s.kpr,
         sp.name||'', ''||NVL(LTRIM(s.nd,''0''),''0'')||''-''||NVL(LTRIM(s.kw,''0''),''0'') as adr,
         s.mg
        from arch_kart s, spul sp, status st where s.mg=:p_mg
        and not exists (select * from a_nabor n, usl u where n.lsk=s.lsk and n.usl=u.usl and u.cd=''гараж'') --не гаражи
        and s.reu=:reu_ and s.kul=:kul_ and s.nd=:nd_
        and s.kul=sp.id
        and s.status=st.id
        order by s.lsk  --order by sp.name, f_ord_digit(s.nd), f_ord3(s.nd), f_ord_digit(s.kw)'
        using mg_, reu_, kul_, nd_;
    elsif var_ = 2 then
    --по –Ё”
     open prep_refcursor for
       'select s.lsk, st.name as name_st, s.kpr,
         sp.name||'', ''||NVL(LTRIM(s.nd,''0''),''0'')||''-''||NVL(LTRIM(s.kw,''0''),''0'') as adr,
         s.mg
        from arch_kart s, spul sp, status st where s.mg=:p_mg
        and not exists (select * from a_nabor n, usl u where n.lsk=s.lsk and n.usl=u.usl and u.cd=''гараж'' and n.koeff<>0) --не гаражи
        and s.reu=:reu_
        and s.kul=sp.id
        and s.status=st.id
        order by s.lsk  -- order by sp.name, utils.f_ord_digit(s.nd), utils.f_ord3(s.nd), utils.f_ord_digit(s.kw)'
        using mg_, reu_;
    elsif var_ = 1 then
    --по ∆Ёќ
     open prep_refcursor for
       'select s.lsk, st.name as name_st, s.kpr,
         sp.name||'', ''||NVL(LTRIM(s.nd,''0''),''0'')||''-''||NVL(LTRIM(s.kw,''0''),''0'') as adr,
         s.mg
        from arch_kart s, spul sp, status st, s_reu_trest t where s.mg=:p_mg
        and not exists (select * from a_nabor n, usl u where n.lsk=s.lsk and n.usl=u.usl and u.cd=''гараж'' and n.koeff<>0) --не гаражи
        and s.reu=t.reu
        and t.trest=:trest_
        and s.kul=sp.id
        and s.status=st.id
        order by s.lsk --order by sp.name, utils.f_ord_digit(s.nd), utils.f_ord3(s.nd), utils.f_ord_digit(s.kw)'
        using mg_, trest_;
    elsif var_ = 0 then
    --по √ороду
     open prep_refcursor for
       'select s.lsk, st.name as name_st, s.kpr,
         sp.name||'', ''||NVL(LTRIM(s.nd,''0''),''0'')||''-''||NVL(LTRIM(s.kw,''0''),''0'') as adr,
         s.mg
        from arch_kart s, spul sp, status st where s.mg=:p_mg
        and not exists (select * from a_nabor n, usl u where n.lsk=s.lsk and n.usl=u.usl and u.cd=''гараж'' and n.koeff<>0) --не гаражи
        and s.kul=sp.id
        and s.status=st.id
        order by s.lsk --order by sp.name, utils.f_ord_digit(s.nd), utils.f_ord3(s.nd), utils.f_ord_digit(s.kw)'
        using mg_;
   end if;

 elsif сd_ in  ('84') then
 --Ќовый список-оборотка дл€ субсидировани€ “—∆
    if var_ = 2 then
    --по ” 
    open prep_refcursor for
    'select l.name||'', ''||NVL(LTRIM(s.nd,''0''),''0'') as adr,
     ltrim(s.kw,''0'') as kw,
     s.komn, s.opl, s.fio,
     e.opl_n, e.opl_sv, e.opl_empt,
     nvl(e.opl_n,0)+nvl(e.opl_sv,0)+nvl(e.opl_empt,0) as opl_itg,
     e.summa_n, e.summa_sv, e.summa_empt,
     nvl(e.summa_n,0)+nvl(e.summa_sv,0)+nvl(e.summa_empt,0)+nvl(d.chng,0) as summa_itg,

     nvl(gw.summa_sch_n,0)+ nvl(gw.summa_norm_n,0) as gw_summa_norm,
     gw.summa_sch_sv as gw_summa_sch_sv,
     gw.summa_sch_empt as gw_summa_sch_empt,

     nvl(gw.summa_sch_n,0)+ nvl(gw.summa_norm_n,0)+
     nvl(gw.summa_sch_sv,0)+
     nvl(gw.summa_sch_empt,0)+nvl(gw2.summa,0) as gw_summa_itg,

     gw.vol_sch_n as gw_sch_n,
     gw.vol_sch_sv as gw_sch_sv,
     gw.vol_sch_empt as gw_sch_empt,

     gw.vol_norm_n as gw_vol_norm,
     gw2.vol_sch as odn_vol_sch,
     gw2.vol_norm as odn_vol_norm,

     nvl(gw.vol_sch_n,0)+
     nvl(gw.vol_sch_sv,0)+
     nvl(gw.vol_sch_empt,0)+
     nvl(gw2.vol_sch,0)+
     nvl(gw2.vol_norm,0) as gw_vol_itg,

     gw2.summa as odn_summa,
     gw3.kpr_sch,
     gw3.kpr_norm,
     nvl(gw3.kpr_sch,0)+nvl(gw3.kpr_norm,0) as kpr_itg,
     d.chng,
     c.name, c.adr as org_adr, c.inn, c.kpp, c.head_name,
    upper(utils.MONTH_NAME(substr(s.mg,5,2)))||'' ''||substr(s.mg,1,4)||''г.'' as mg_name
--    ,
--    upper(s.nm) as nm
    from (select s.* from arch_kart s, s_reu_trest e where '||sqlstr_||'
     and exists --ключевой запрос
      (select * from a_charge a, usl u where a.usl=u.usl and
        u.cd in (''отоп'', ''отоп/св.нор'', ''отоп/0 зарег.'') and a.type = 1 and a.summa <> 0
        and a.lsk=s.lsk and a.mg=s.mg
      )
     and e.reu=:reu
     and s.reu=e.reu
     and s.psch not in (8,9)
     and s.status not in (7)--убрал нежилые по просьбе “—∆  лЄн, ред.09.01.13
     ) s, t_org c, params p, spul l,
    (select s.lsk, u.uslg,
     sum(case when u.usl_norm = 0 and s.kpr <> 0 then s.summa else 0 end) as summa_n,
     sum(case when u.usl_norm = 1 and s.kpr <> 0 then s.summa else 0 end) as summa_sv,
     sum(case when s.kpr = 0 then s.summa else 0 end) as summa_empt,
     sum(case when u.usl_norm = 0 and s.kpr <> 0 then s.test_opl else 0 end) as opl_n,
     sum(case when u.usl_norm = 1 and s.kpr <> 0 then s.test_opl else 0 end) as opl_sv,
     sum(case when s.kpr = 0 then s.test_opl else 0 end) as opl_empt
       from a_charge s, usl u where '||sqlstr_||' and s.usl=u.usl and
      u.cd in (''отоп'', ''отоп/св.нор'', ''отоп/0 зарег.'') and s.type=1 --отопление (начисление чистое, объЄмы)
     group by s.lsk, u.uslg) e,
      (select s.lsk, u.uslg, sum(s.summa) as chng from a_change s, usl u where '||sqlstr_||' and s.usl=u.usl and
       u.cd in (''отоп'', ''отоп/св.нор'', ''отоп/0 зарег.'') --перерасчЄты по отоплению
       group by s.lsk, u.uslg) d,
    (select s.lsk,
     sum(case when s.sch <> 0 and u.usl_norm = 0 and nvl(s.kpr,0) <> 0 then s.summa else 0 end) as summa_sch_n,
     sum(case when s.sch <> 0 and u.usl_norm = 1 and nvl(s.kpr,0) <> 0 then s.summa else 0 end) as summa_sch_sv,
     sum(case when s.sch <> 0 and nvl(s.kpr,0) = 0 then s.summa else 0 end) as summa_sch_empt,
     sum(case when s.sch <> 0 and u.usl_norm = 0 and nvl(s.kpr,0) <> 0 then s.test_opl else 0 end) as vol_sch_n,
     sum(case when s.sch <> 0 and u.usl_norm = 1 and nvl(s.kpr,0) <> 0 then s.test_opl else 0 end) as vol_sch_sv,
     sum(case when s.sch <> 0 and nvl(s.kpr,0) = 0 then s.test_opl else 0 end) as vol_sch_empt,
     sum(case when s.sch = 0 and u.usl_norm = 0 then s.summa else 0 end) as summa_norm_n,

     sum(case when s.sch = 0 and u.usl_norm = 0 then s.test_opl else 0 end) as vol_norm_n
       from a_charge s, usl u where '||sqlstr_||' and s.usl=u.usl and
      u.cd in (''г.вода'', ''г.вода/св.нор'', ''г.вода/0 зарег.'') and s.type=1 --г.вода (начисление чистое, объЄмы)
     group by s.lsk
     ) gw,
    (select s.lsk,
     sum(case when s.sch <> 0 then s.kpr else 0 end) as kpr_sch,
     sum(case when s.sch = 0 then s.kpr else 0 end) as kpr_norm
       from a_charge_prep s, usl u where '||sqlstr_||' and s.usl=u.usl and
      u.cd in (''г.вода'') and s.tp=1 --г.вода (кол-во прожив по сч/нормативу)
     group by s.lsk
     ) gw3,
    (select s.lsk,
     sum(s.summa) as summa,
     sum(case when s.sch <> 0 and u.usl_norm = 0 and s.kpr <> 0 then s.test_opl else 0 end) as vol_sch,
     sum(case when s.sch = 0 and u.usl_norm = 0 then s.test_opl else 0 end) as vol_norm
       from a_charge s, usl u where '||sqlstr_||' and s.usl=u.usl and
      u.cd in (''г.вода.ќƒЌ'') and s.type=1 --г.вода ќƒЌ (начисление чистое, объЄмы)
     group by s.lsk
     ) gw2
    where s.lsk = e.lsk(+)
     and s.kul=l.id
     and s.lsk=gw.lsk(+)
     and s.lsk=gw2.lsk(+)
     and s.lsk=gw3.lsk(+)
     and s.lsk = d.lsk(+)
     and s.reu=c.reu
    order by l.name, s.nd, s.kw
    '
    using reu_;
    end if;
elsif сd_ in  ('85') then
 --—правка по начислению квартплаты по отоплению (дл€ кис.)

    if var_ = 2 then
    --по ” 
    open prep_refcursor for
    'select
     c.name as name_uk,
     nvl(r.name2, r2.name2) as name_org,
     nvl(r.name, r2.name) as name_kot,

     sum(nvl(e.opl,0)+nvl(e2.opl,0)) as opl_itg,

     sum(e.opl) as opl,
     sum(e.opl_empt) as opl_empt,

     sum(e2.opl) as opl_sch,
     sum(e2.opl_empt) as opl_empt_sch,
     sum(e2.vol) as vol_sch,
     sum(e2.vol_empt) as vol_empt_sch,

     sum(nvl(e.summa,0)+nvl(e2.summa,0)+nvl(d.summa,0)+nvl(d2.summa,0)) as summa_itg,
     sum(nvl(e.summa,0)+nvl(d.summa,0)) as summa,
     sum(e.summa_empt) as summa_empt,
     sum(d.summa) as chng,
     sum(nvl(e2.summa,0)+nvl(d2.summa,0)) as summa_sch,
     sum(e2.summa_empt) as summa_sch_empt,
     sum(d.summa) as chng_sch,
     c.head_name,
     upper(utils.MONTH_NAME(substr(s.mg,5,2)))||'' ''||substr(s.mg,1,4)||''г.'' as mg_name
    from (select s.* from arch_kart s, s_reu_trest e where '||sqlstr_||' and exists --ключевой запрос
      (select * from a_charge a, usl u where a.usl=u.usl and
        u.cd in (''отоп'', ''отоп/0 зарег.'') and a.type = 1 and a.summa <> 0
        and a.lsk=s.lsk and a.mg=s.mg
      )
     and e.reu=:reu
     and s.reu=e.reu
     and s.psch not in (8,9)
     and s.status not in (7)--убрал нежилые --
     ) s, t_org c, params p,
    (select s.lsk,
     sum(s.summa) as summa,
     sum(case when s.kpr = 0 then s.summa else 0 end) as summa_empt,
     sum(s.test_opl) as opl,
     sum(case when s.kpr = 0 then s.test_opl else 0 end) as opl_empt
       from a_charge s, usl u where '||sqlstr_||' and s.usl=u.usl and
      u.cd in (''отоп'', ''отоп/0 зарег.'') and s.type=1 --отопление (начисление чистое, объЄмы)
     group by s.lsk) e,
    (select s.lsk,
     sum(s.summa) as summa,
     sum(case when s.kpr = 0 then s.summa else 0 end) as summa_empt,
     sum(s.opl) as opl,
     sum(case when s.kpr = 0 then s.opl else 0 end) as opl_empt,
     sum(s.test_opl) as vol,
     sum(case when s.kpr = 0 then s.test_opl else 0 end) as vol_empt
       from a_charge s, usl u where '||sqlstr_||' and s.usl=u.usl and
      u.cd in (''отоп.гкал.'', ''отоп.гкал./0 зарег.'') and s.type=1 --отопление г ал.(начисление чистое, объЄмы)
     group by s.lsk) e2,
      (select s.lsk, sum(s.summa) as summa from a_change s, usl u where '||sqlstr_||' and s.usl=u.usl and
       u.cd in (''отоп'', ''отоп/0 зарег.'') --перерасчЄты по отоплению
       group by s.lsk) d,
      (select s.lsk, sum(s.summa) as summa from a_change s, usl u where '||sqlstr_||' and s.usl=u.usl and
       u.cd in (''отоп.гкал.'', ''отоп.гкал./0 зарег.'') --перерасчЄты по отоплению (г ал)
       group by s.lsk) d2,
       (select n.lsk, o.name, o2.name as name2 from nabor n,
         t_org o, t_org o2, usl u where n.org=o.id and n.usl=u.usl and
         u.cd in (''отоп'') --организации, котельные (здесь по одной услуге иначе - удвоитс€)
         and n.org=o.id and o.fk_org2=o2.id(+)) r,
       (select n.lsk, o.name, o2.name as name2 from nabor n,
         t_org o, t_org o2, usl u where n.org=o.id and n.usl=u.usl and
         u.cd in (''отоп.гкал.'') --организации, котельные (здесь по одной услуге иначе - удвоитс€)
         and n.org=o.id and o.fk_org2=o2.id(+)) r2
    where s.lsk = e.lsk(+)
     and s.lsk = e2.lsk(+)
     and s.lsk = d.lsk(+)
     and s.lsk = d2.lsk(+)
     and s.lsk = r.lsk(+)
     and s.lsk = r2.lsk(+)
     and s.reu=c.reu
     group by
     c.name, nvl(r.name2, r2.name2), nvl(r.name, r2.name),
     c.head_name,
     upper(utils.MONTH_NAME(substr(s.mg,5,2)))||'' ''||substr(s.mg,1,4)||''г.''
     order by
     c.name, nvl(r.name2, r2.name2), nvl(r.name, r2.name)
    '
    using reu_;
    end if;

elsif сd_ in  ('86') then
    if var_ = 2 then
    --по ” 
    open prep_refcursor for
    'select
     c.name as name_uk,
     nvl(r.name2, r2.name2) as name_org,
     nvl(r.name, r2.name) as name_kot,

     sum(nvl(s.opl,0)) as opl_itg,
     sum(case when s.status not in (7) then s.opl else 0 end) as opl,
     sum(case when s.status in (7) then s.opl else 0 end) as opl_ur,

     sum(e.vol) as vol_itg,
     sum(case when f.kub is null then e.vol end) as vol_nrm,
     sum(case when f.kub is null then e.vol_wo_odn end) as vol_wo_odn_nrm,
     sum(case when f.kub is null then e.vol_odn end) as vol_odn_nrm,
     sum(case when f.kub is null then e.vol_empt end) as vol_empt_nrm,
     sum(case when f.kub is null then e.vol_odn_empt end) as vol_odn_empt_nrm,

     sum(case when f.kub is not null then e.vol end) as vol_odpu,
     sum(case when f.kub is not null then e.vol_wo_odn end) as vol_wo_odn_odpu,
     sum(case when f.kub is not null then e.vol_odn end) as vol_odn_odpu,
     sum(case when f.kub is not null then e.vol_empt end) as vol_empt_odpu,
     sum(case when f.kub is not null then e.vol_odn_empt end) as vol_odn_empt_odpu,

     sum(e.summa) as summa_itg,
     sum(case when f.kub is null then e.summa end) as summa_nrm,
     sum(case when f.kub is null then e.summa_wo_odn end) as summa_wo_odn_nrm,
     sum(case when f.kub is null then e.summa_odn end) as summa_odn_nrm,
     sum(case when f.kub is null then e.summa_empt end) as summa_empt_nrm,
     sum(case when f.kub is null then e.summa_odn_empt end) as summa_odn_empt_nrm,
     sum(case when f.kub is null then e.summa_chng end) as summa_chng_nrm,
     sum(case when f.kub is null then e.summa_chng_empt end) as summa_chng_empt_nrm,

     sum(case when f.kub is not null then e.summa end) as summa_odpu,
     sum(case when f.kub is not null then e.summa_wo_odn end) as summa_wo_odn_odpu,
     sum(case when f.kub is not null then e.summa_odn end) as summa_odn_odpu,
     sum(case when f.kub is not null then e.summa_empt end) as summa_empt_odpu,
     sum(case when f.kub is not null then e.summa_odn_empt end) as summa_odn_empt_odpu,
     sum(case when f.kub is not null then e.summa_chng end) as summa_chng_odpu,
     sum(case when f.kub is not null then e.summa_chng_empt end) as summa_chng_empt_odpu,
     c.head_name,
     upper(utils.MONTH_NAME(substr(s.mg,5,2)))||'' ''||substr(s.mg,1,4)||''г.'' as mg_name
    from (select s.* from arch_kart s, s_reu_trest e where '||sqlstr_||' and exists --ключевой запрос
      (select * from a_charge a, usl u where a.usl=u.usl and
        u.cd in (''г.вода'', ''г.вода/0 зарег.'') and a.type = 1 and a.summa <> 0
        and a.lsk=s.lsk and a.mg=s.mg
      )
     and e.reu=:reu
     and s.reu=e.reu
     and s.psch not in (8,9)
     and s.status not in (7)--убрал нежилые
     ) s, t_org c, params p,
    (select a.lsk,
     sum(a.test_opl) as vol, --объем всего
     sum(case when a.cd in (''г.вода'', ''г.вода/0 зарег.'') then a.test_opl else 0 end) as vol_wo_odn, --объем общий без ќƒЌ
     sum(case when a.cd in (''г.вода.ќƒЌ'', ''√.в. ќƒЌ, 0 зарег'') then a.test_opl else 0 end) as vol_odn, --объем ќƒЌ
     sum(case when a.cd in (''г.вода/0 зарег.'') then a.test_opl else 0 end) as vol_empt, --объем по пустым кв.
     sum(case when a.cd in (''√.в. ќƒЌ, 0 зарег'') then a.test_opl else 0 end) as vol_odn_empt, --объем ќƒЌ по пустым кв.
     sum(a.summa) as summa, --начисление всего
     sum(case when a.cd in (''г.вода'', ''г.вода/0 зарег.'') then a.summa else 0 end) as summa_wo_odn, --начисление общее без ќƒЌ
     sum(case when a.cd in (''г.вода.ќƒЌ'', ''√.в. ќƒЌ, 0 зарег'') then a.summa else 0 end) as summa_odn, --начисление ќƒЌ
     sum(case when a.cd in (''г.вода/0 зарег.'') then a.summa else 0 end) as summa_empt, --начисление по пустым кв.
     sum(case when a.cd in (''√.в. ќƒЌ, 0 зарег'') then a.summa else 0 end) as summa_odn_empt, --начисление ќƒЌ по пустым кв.
     sum(a.summa_chng) as summa_chng,
     sum(a.summa_chng_empt) as summa_chng_empt
       from
       (select s.lsk, s.summa, null as summa_chng, null as summa_chng_empt, s.test_opl, u.cd
         from a_charge s, usl u where '||sqlstr_||' and s.usl=u.usl and
         u.cd in (''г.вода'', ''г.вода/0 зарег.'', ''г.вода.ќƒЌ'', ''√.в. ќƒЌ, 0 зарег'') and s.type=1 --г.в.
        union all
        select s.lsk, s.summa, s.summa as summa_chng,
          case when u.cd in (''г.вода/0 зарег.'') then s.summa else 0 end as summa_chng_empt, null as test_opl, u.cd
         from a_change s, usl u where '||sqlstr_||' and s.usl=u.usl and
         u.cd in (''г.вода'', ''г.вода/0 зарег.'', ''г.вода.ќƒЌ'', ''√.в. ќƒЌ, 0 зарег'')) a--г.в. в т.ч. перерасчеты
     group by a.lsk
     ) e,
     (select n.lsk, s.kub from a_nabor n, a_vvod s, usl u where '||sqlstr_||' and s.usl=u.usl and
         u.cd in (''г.вода'')
         and n.mg=s.mg
         and n.usl=s.usl
         and n.fk_vvod=s.id
         ) f,
      (select s.lsk, sum(s.summa) as summa from a_change s, usl u where '||sqlstr_||' and s.usl=u.usl and
       u.cd in (''отоп'', ''отоп/0 зарег.'') --перерасчЄты по отоплению
       group by s.lsk) d,
      (select s.lsk, sum(s.summa) as summa from a_change s, usl u where '||sqlstr_||' and s.usl=u.usl and
       u.cd in (''отоп.гкал.'', ''отоп.гкал./0 зарег.'') --перерасчЄты по отоплению (г ал)
       group by s.lsk) d2,
       (select n.lsk, o.name, o2.name as name2 from nabor n,
         t_org o, t_org o2, usl u where n.org=o.id and n.usl=u.usl and
         u.cd in (''отоп'') --организации, котельные (здесь по одной услуге иначе - удвоитс€)
         and n.org=o.id and o.fk_org2=o2.id(+)) r,
       (select n.lsk, o.name, o2.name as name2 from nabor n,
         t_org o, t_org o2, usl u where n.org=o.id and n.usl=u.usl and
         u.cd in (''отоп.гкал.'') --организации, котельные (здесь по одной услуге иначе - удвоитс€)
         and n.org=o.id and o.fk_org2=o2.id(+)) r2
    where s.lsk = e.lsk(+)
     and s.lsk = f.lsk(+)
     and s.lsk = d.lsk(+)
     and s.lsk = d2.lsk(+)
     and s.lsk = r.lsk(+)
     and s.lsk = r2.lsk(+)
     and s.reu=c.reu
     group by
     c.name, nvl(r.name2, r2.name2), nvl(r.name, r2.name),
     c.head_name,
     upper(utils.MONTH_NAME(substr(s.mg,5,2)))||'' ''||substr(s.mg,1,4)||''г.''
     order by
     c.name, nvl(r.name2, r2.name2), nvl(r.name, r2.name)'
    using reu_;
    end if;

elsif сd_ in  ('88') then
 --–еестр дл€ фонда  апремонта

    if var_ = 0 then
    --по √ороду
        if mg_ in ('201508','201509') then --август, сент€брь мес€ц пока так...
          open prep_refcursor for
          'select scott.utils.month_name(substr(t.mg, 5, 2)) as mon,
                 substr(t.mg, 1, 4) as year, t.lsk as ls, o.name as np, s.name as ul,
                 ltrim(k.nd, ''0'') as dom, ltrim(k.kw, ''0'') as kv, d.name_kp as st,
                 d.tp as naz, k.k_fam as sur, k.k_im as nam, k.k_ot as mid,
                 g.name as lg,
                  --сведени€ о льготах
                 k.opl as pl, nvl(t.indebet, 0) + nvl(t.inkredit, 0) as sn,
                  --сальдо начальное
                 null as pensn,
                  --проценты в сальдо уплаченной пени (нет такого у нас, не ведЄм сальдо по пене)
                 nvl(t.charges, 0) + nvl(t.pcharges, 0) + nvl(t2.pcharges, 0) as bil, --только дл€ сент€бр€ 2015 г. сделал пеню+ по тек содерж
                  --начислено, в т.ч. пен€
                 t.pcharges + nvl(t2.pcharges, 0) as penbil,
                  --начисленна€ пен€
                 nvl(t.payment, 0) + nvl(t.pn, 0) as pay,
                  --платеж, в т.ч. пен€
                 t.pn as penpay,
                  --оплаченна€ пен€
                 nvl(t.outdebet, 0) + nvl(t.outkredit, 0) as sk,
                  --сальдо конечное
                 null as pensk --проценты в сальдо уплаченной пени (нет такого у нас, не ведЄм сальдо по пене)
            from scott.arch_kart k
            left join scott.xitog3_lsk t on k.lsk = t.lsk and k.mg = t.mg and k.mg = :mg
            left join scott.xitog3_lsk t2 on k.lsk = t2.lsk and k.mg = t2.mg and t2.usl in (''003'')
            join scott.t_org o2 on t.org = o2.id and o2.cd = ''‘онд  апремонта ћ ƒ''
            join scott.t_org_tp tp on tp.cd = ''√ород''
            join scott.t_org o on o.fk_orgtp = tp.id
            join scott.spul s on k.kul = s.id
            join scott.status d on k.status = d.id
            join scott.usl u on t.usl = u.usl and u.cd in (''кап.'')
            left join (select p.lsk, max(p.fk_spk) as fk_spk
                         from scott.a_charge_prep p
                        where p.mg = :mg
                          and p.tp = 9
                        group by p.lsk) sl on k.lsk = sl.lsk
            left join scott.spk sp on sl.fk_spk = sp.id
            left join scott.spk_gr g on sp.gr_id = g.id
           order by scott.utils.f_ord_digit(k.nd), scott.utils.f_ord3(k.nd),
                    scott.utils.f_ord_digit(k.kw), scott.utils.f_ord3(k.kw)
          '
         using mg_, mg_;
    else
          open prep_refcursor for
          'select scott.utils.month_name(substr(t.mg, 5, 2)) as mon,
                 substr(t.mg, 1, 4) as year, t.lsk as ls, o.name as np, s.name as ul,
                 ltrim(k.nd, ''0'') as dom, ltrim(k.kw, ''0'') as kv, d.name_kp as st,
                 d.tp as naz, k.k_fam as sur, k.k_im as nam, k.k_ot as mid,
                  --сведени€ о льготах
                 g.name as lg,
                   --площадь
                 k.opl as pl, 
                  --сальдо начальное
                 nvl(t.indebet, 0) + nvl(t.inkredit, 0) as sn,
                  --проценты в сальдо начисленной пени (нет такого у нас, не ведЄм сальдо по пене)
                 null as pensn,
                  --начислено, в т.ч. пен€
                 nvl(t.charges, 0) + nvl(t.pcharges, 0) as bil,
                  --начисленна€ пен€
                 t.pcharges as penbil,
                  --платеж, в т.ч. пен€
                 nvl(t.payment, 0) + nvl(t.pn, 0) as pay,
                  --оплаченна€ пен€
                 t.pn as penpay,
                  --сальдо конечное
                 nvl(t.outdebet, 0) + nvl(t.outkredit, 0) as sk,
                  --проценты в сальдо уплаченной пени (нет такого у нас, не ведЄм сальдо по пене)
                 null as pensk
            from scott.arch_kart k
            left join scott.xitog3_lsk t on k.lsk = t.lsk and k.mg = t.mg and k.mg = :mg
            join scott.t_org o2 on t.org = o2.id and o2.cd = ''‘онд  апремонта ћ ƒ''
            join scott.t_org_tp tp on tp.cd = ''√ород''
            join scott.t_org o on o.fk_orgtp = tp.id
            join scott.spul s on k.kul = s.id
            join scott.status d on k.status = d.id
            join scott.usl u on t.usl = u.usl and u.cd in (''кап.'')
            left join (select p.lsk, max(p.fk_spk) as fk_spk
                         from scott.a_charge_prep p
                        where p.mg = :mg
                          and p.tp = 9
                        group by p.lsk) sl on k.lsk = sl.lsk
            left join scott.spk sp on sl.fk_spk = sp.id
            left join scott.spk_gr g on sp.gr_id = g.id
           order by scott.utils.f_ord_digit(k.nd), scott.utils.f_ord3(k.nd),
                    scott.utils.f_ord_digit(k.kw), scott.utils.f_ord3(k.kw)
          '
         using mg_, mg_;   
         end if;
    end if;

 elsif сd_ in  ('89') then
    if var_ = 3 then
    --по ƒому
      OPEN prep_refcursor FOR 'select d.npp, h.name_reu||'' ''||l.name||h.name||'', ''||ltrim(h.nd,''0'') as predpr,
      null as type, to_char(d.kod)||'' ''||d.name as org, to_char(h.uslm)||'' ''||decode(m.frc_get_price,1,m.nm,m.nm1) as nm1,
      sum(i.indebet) as indebet, sum(i.inkredit) as inkredit,
      sum(o.charges) as charges, sum(o.changes) as changes, sum(o.subsid) as subsid, sum(o.privs) as privs, sum(o.privs_city) as privs_city, sum(o.payment) as payment,
      sum(o.ch_full) as ch_full, sum(o.changes2) as changes2, sum(o.changes+o.changes2) as changesall,
      sum(o.pn) as pn, sum(u.outdebet) as outdebet, sum(u.outkredit) as outkredit
      from
      (
      select e.reu, e.kul, e.nd, e.status, e.org, e.usl, e.uslm, 
             trim(t.name_reu) as name_reu, s.name from t_saldo_reu_kul_nd_st e, s_reu_trest t, spul s
      where e.reu=t.reu and e.reu=:reu_ and e.kul=:kul_ and e.nd=:nd_
            and exists
           (select * from list_c i, spr_params p where i.fk_ses=:fk_ses_
                and p.id=i.fk_par and p.cd=''REP_USL2'' 
                and i.sel_cd=e.usl
            and i.sel=1)
            and exists
           (select * from list_c i, spr_params p where i.fk_ses=:fk_ses_
                and p.id=i.fk_par and p.cd=''REP_ORG2'' 
                and i.sel_id=e.org
            and i.sel=1)
      and e.kul=s.id) h,
      (select * from xitog3 e where e.mg=:mg_) i,
      (select reu,kul,nd,org,usl,status,sum(charges) as charges,
      sum(changes) as changes, sum(subsid) as subsid, sum(privs) as privs, sum(privs_city) as privs_city,
      sum(ch_full) as ch_full, sum(changes2) as changes2, sum(payment) as payment, sum(pn) as pn from xitog3 t
      where t.mg between :mg_ and :mg1_
      group by reu,kul,nd,org,usl,status) o,
      (select * from xitog3 e where e.mg=:mg1_) u,
      sprorg d, usl m, org l
      where
      h.reu=i.reu(+) and h.kul=i.kul(+) and h.nd=i.nd(+) and h.org=i.org(+) and h.usl=i.usl(+) and h.status=i.status(+) and
      h.reu=o.reu(+) and h.kul=o.kul(+) and h.nd=o.nd(+) and h.org=o.org(+) and h.usl=o.usl(+) and h.status=o.status(+) and
      h.reu=u.reu(+) and h.kul=u.kul(+) and h.nd=u.nd(+) and h.org=u.org(+) and h.usl=u.usl(+) and h.status=u.status(+) and
      l.id=4 and h.org=d.kod and h.usl=m.usl
      group by d.npp, h.name_reu||'' ''||l.name||h.name||'', ''||ltrim(h.nd,''0''),
      to_char(d.kod)||'' ''||d.name, to_char(h.uslm)||'' ''||decode(m.frc_get_price,1,m.nm,m.nm1)
      having sum(i.indebet) <>0 or sum(i.inkredit) <>0 or
      sum(o.charges) <>0 or sum(o.changes) <>0 or sum(o.subsid) <>0 or
      sum(o.privs) <>0 or sum(o.privs_city) <>0 or sum(o.payment) <>0 or
      sum(o.pn) <>0 or sum(u.outdebet) <>0 or sum(u.outkredit) <>0
      order by h.name_reu||'' ''||l.name||h.name||'', ''||ltrim(h.nd,''0''), d.npp'
        USING reu_, kul_, nd_, fk_ses_, fk_ses_, mg_, mg_, mg1_, mg1_;
    elsif var_ = 2 then
    --по –Ё”
      OPEN prep_refcursor FOR 'select d.npp, l.name||h.name_reu as predpr,null as type, to_char(d.kod)||'' ''||d.name as org, to_char(h.uslm)||'' ''||decode(m.frc_get_price,1,m.nm,m.nm1) as nm1, sum(i.indebet) as indebet, sum(i.inkredit) as inkredit,
      sum(o.charges) as charges, sum(o.changes) as changes, sum(o.subsid) as subsid, sum(o.privs) as privs, sum(o.privs_city) as privs_city, sum(o.payment) as payment,
      sum(o.ch_full) as ch_full, sum(o.changes2) as changes2, sum(o.changes+o.changes2) as changesall,
      sum(o.pn) as pn, sum(u.outdebet) as outdebet, sum(u.outkredit) as outkredit
      from
      (select e.*, s.name_reu from t_saldo_reu_kul_nd_st e, s_reu_trest s
      where e.reu=:reu_ and e.reu=s.reu
          and exists
           (select * from list_c i, spr_params p where i.fk_ses=:fk_ses_
                and p.id=i.fk_par and p.cd=''REP_USL2''
                and i.sel_cd=e.usl
            and i.sel=1)
            and exists
           (select * from list_c i, spr_params p where i.fk_ses=:fk_ses_
                and p.id=i.fk_par and p.cd=''REP_ORG2'' 
                and i.sel_id=e.org
            and i.sel=1)
      ) h,
      (select * from xitog3 e where e.mg=:mg_) i,
      (select reu,kul,nd,org,usl,status,sum(charges) as charges,
      sum(changes) as changes, sum(subsid) as subsid, sum(privs) as privs, sum(privs_city) as privs_city,
      sum(ch_full) as ch_full, sum(changes2) as changes2, sum(changes+changes2) as changesall,
       sum(payment) as payment, sum(pn) as pn from xitog3 t
      where t.mg between :mg_ and :mg1_
      group by reu,kul,nd,org,usl,status) o,
      (select * from xitog3 e where e.mg=:mg1_) u,
      sprorg d, usl m, org l
      where
      h.reu=i.reu(+) and h.kul=i.kul(+) and h.nd=i.nd(+) and h.org=i.org(+) and h.usl=i.usl(+) and h.status=i.status(+) and
      h.reu=o.reu(+) and h.kul=o.kul(+) and h.nd=o.nd(+) and h.org=o.org(+) and h.usl=o.usl(+) and h.status=o.status(+) and
      h.reu=u.reu(+) and h.kul=u.kul(+) and h.nd=u.nd(+) and h.org=u.org(+) and h.usl=u.usl(+) and h.status=u.status(+) and
      l.id=3 and h.org=d.kod and h.usl=m.usl
      group by d.npp, l.name||h.name_reu, to_char(d.kod)||'' ''||d.name, to_char(h.uslm)||'' ''||decode(m.frc_get_price,1,m.nm,m.nm1)
      having sum(i.indebet) <>0 or sum(i.inkredit) <>0 or
      sum(o.charges) <>0 or sum(o.changes) <>0 or sum(o.subsid) <>0 or
      sum(o.privs) <>0 or sum(o.privs_city) <>0 or sum(o.payment) <>0 or
      sum(o.pn) <>0 or sum(u.outdebet) <>0 or sum(u.outkredit) <>0
      order by d.npp'
        USING reu_, fk_ses_, fk_ses_, mg_, mg_, mg1_, mg1_;
    elsif var_ = 1 then
    --по ∆Ёќ
      OPEN prep_refcursor FOR 'select d.npp,l.name||h.name_tr as predpr, null as type, to_char(d.kod)||'' ''||d.name as org, to_char(h.uslm)||'' ''||decode(m.frc_get_price,1,m.nm,m.nm1) as nm1, sum(i.indebet) as indebet, sum(i.inkredit) as inkredit,
      sum(o.charges) as charges, sum(o.changes) as changes, sum(o.subsid) as subsid, sum(o.privs) as privs, sum(o.privs_city) as privs_city, sum(o.payment) as payment,
      sum(o.ch_full) as ch_full, sum(o.changes2) as changes2, sum(o.changes+o.changes2) as changesall,
      sum(o.pn) as pn, sum(u.outdebet) as outdebet, sum(u.outkredit) as outkredit
      from
      (select e.*, s.trest, s.name_tr from t_saldo_reu_kul_nd_st e, s_reu_trest s
        where s.trest=:trest_ and e.reu=s.reu
          and exists
           (select * from list_c i, spr_params p where i.fk_ses=:fk_ses_
                and p.id=i.fk_par and p.cd=''REP_USL2''
                and i.sel_cd=e.usl
            and i.sel=1)
            and exists
           (select * from list_c i, spr_params p where i.fk_ses=:fk_ses_
                and p.id=i.fk_par and p.cd=''REP_ORG2'' 
                and i.sel_id=e.org
            and i.sel=1)
        ) h,
      (select * from xitog3 e where e.mg=:mg_) i,
      (select reu,kul,nd,org,usl,status,sum(charges) as charges,
      sum(changes) as changes, sum(subsid) as subsid, sum(privs) as privs, sum(privs_city) as privs_city,
      sum(ch_full) as ch_full, sum(changes2) as changes2, sum(payment) as payment, sum(pn) as pn from xitog3 t
      where t.mg between :mg_ and :mg1_
      group by reu,kul,nd,org,usl,status) o,
      (select * from xitog3 e where e.mg=:mg1_) u,
      sprorg d, usl m, org l
      where
      h.reu=i.reu(+) and h.kul=i.kul(+) and h.nd=i.nd(+) and h.org=i.org(+) and h.usl=i.usl(+) and h.status=i.status(+) and
      h.reu=o.reu(+) and h.kul=o.kul(+) and h.nd=o.nd(+) and h.org=o.org(+) and h.usl=o.usl(+) and h.status=o.status(+) and
      h.reu=u.reu(+) and h.kul=u.kul(+) and h.nd=u.nd(+) and h.org=u.org(+) and h.usl=u.usl(+) and h.status=u.status(+) and
      l.id=2 and h.org=d.kod and h.usl=m.usl
      group by d.npp, l.name||h.name_tr, to_char(d.kod)||'' ''||d.name, to_char(h.uslm)||'' ''||decode(m.frc_get_price,1,m.nm,m.nm1)
      having sum(i.indebet) <>0 or sum(i.inkredit) <>0 or
      sum(o.charges) <>0 or sum(o.changes) <>0 or sum(o.subsid) <>0 or
      sum(o.privs) <>0 or sum(o.privs_city) <>0 or sum(o.payment) <>0 or
      sum(o.pn) <>0 or sum(u.outdebet) <>0 or sum(u.outkredit) <>0
      order by d.npp'
        USING trest_, fk_ses_, fk_ses_, mg_, mg_, mg1_, mg1_;
    elsif var_ = 0 then
    --по √ороду
      OPEN prep_refcursor FOR 'select d.npp, l.name as predpr,null as type, to_char(d.kod)||'' ''||d.name as org, to_char(h.uslm)||'' ''||decode(m.frc_get_price,1,m.nm,m.nm1) as nm1, sum(i.indebet) as indebet, sum(i.inkredit) as inkredit,
      sum(o.charges) as charges, sum(o.changes) as changes, sum(o.subsid) as subsid, sum(o.privs) as privs, sum(o.privs_city) as privs_city, sum(o.payment) as payment,
      sum(o.ch_full) as ch_full, sum(o.changes2) as changes2, sum(o.changes+o.changes2) as changesall,
      sum(o.pn) as pn, sum(u.outdebet) as outdebet, sum(u.outkredit) as outkredit
      from
      (select e.*, s.trest from t_saldo_reu_kul_nd_st e, s_reu_trest s where e.reu=s.reu
          and exists
           (select * from list_c i, spr_params p where i.fk_ses=:fk_ses_
                and p.id=i.fk_par and p.cd=''REP_USL2''
                and i.sel_cd=e.usl
            and i.sel=1)
            and exists
           (select * from list_c i, spr_params p where i.fk_ses=:fk_ses_
                and p.id=i.fk_par and p.cd=''REP_ORG2'' 
                and i.sel_id=e.org
            and i.sel=1)
      ) h,
      (select * from xitog3 e where e.mg=:mg_) i,
      (select reu,kul,nd,org,usl,status,sum(charges) as charges,
      sum(changes) as changes, sum(subsid) as subsid, sum(privs) as privs, sum(privs_city) as privs_city,
      sum(ch_full) as ch_full, sum(changes2) as changes2, sum(payment) as payment, sum(pn) as pn from xitog3 t
      where t.mg between :mg_ and :mg1_
      group by reu,kul,nd,org,usl,status) o,
      (select * from xitog3 e where e.mg=:mg1_) u,
      sprorg d, usl m, org l
      where
      h.reu=i.reu(+) and h.kul=i.kul(+) and h.nd=i.nd(+) and h.org=i.org(+) and h.usl=i.usl(+) and h.status=i.status(+) and
      h.reu=o.reu(+) and h.kul=o.kul(+) and h.nd=o.nd(+) and h.org=o.org(+) and h.usl=o.usl(+) and h.status=o.status(+) and
      h.reu=u.reu(+) and h.kul=u.kul(+) and h.nd=u.nd(+) and h.org=u.org(+) and h.usl=u.usl(+) and h.status=u.status(+) and
      l.id=1 and h.org=d.kod and h.usl=m.usl
      group by d.npp, l.name, to_char(d.kod)||'' ''||d.name, to_char(h.uslm)||'' ''||decode(m.frc_get_price,1,m.nm,m.nm1)
      having sum(i.indebet) <>0 or sum(i.inkredit) <>0 or
      sum(o.charges) <>0 or sum(o.changes) <>0 or sum(o.subsid) <>0 or
      sum(o.privs) <>0 or sum(o.privs_city) <>0 or sum(o.payment) <>0 or
      sum(o.pn) <>0 or sum(u.outdebet) <>0 or sum(u.outkredit) <>0
      order by d.npp'
        USING fk_ses_, fk_ses_, mg_, mg_, mg1_, mg1_;
  end if;      
  elsif сd_ in ('90') then
  --ќборотна€ ведомость по домам
    IF var_ = 3 THEN
      --по дому
      OPEN prep_refcursor FOR 'select null as predpr, h.name_reu||'' ''||p.name||'', ''||ltrim(h.nd,''0'') as adr, sum(i.indebet) as indebet, sum(i.inkredit) as inkredit,
      sum(o.charges) as charges, sum(o.changes) as changes, sum(o.subsid) as subsid, sum(o.privs) as privs, sum(o.privs_city) as privs_city, sum(o.payment) as payment,
      sum(o.ch_full) as ch_full, sum(o.changes2) as changes2, sum(o.changes+o.changes2) as changesall,
      sum(o.pn) as pn, sum(u.outdebet) as outdebet, sum(u.outkredit) as outkredit
      from
      (
      select e.*, trim(t.name_reu) as name_reu, s.name from t_saldo_reu_kul_nd_st e, s_reu_trest t, spul s
      where e.reu=t.reu and e.reu=:reu_ and e.kul=:kul_ and e.nd=:nd_
            and exists
           (select * from list_c i, spr_params p where i.fk_ses=:fk_ses_
                and p.id=i.fk_par and p.cd=''REP_USL2'' 
                and i.sel_cd=e.usl
            and i.sel=1)
            and exists
           (select * from list_c i, spr_params p where i.fk_ses=:fk_ses_
                and p.id=i.fk_par and p.cd=''REP_ORG2'' 
                and i.sel_id=e.org
            and i.sel=1)
      and e.kul=s.id) h,
      (select * from xitog3 e where e.mg=:mg_) i,
      (select reu,kul,nd,org,usl,status,sum(charges) as charges,
      sum(changes) as changes, sum(subsid) as subsid, sum(privs) as privs, sum(privs_city) as privs_city,
      sum(ch_full) as ch_full, sum(changes2) as changes2, sum(payment) as payment, sum(pn) as pn from xitog3 t
      where t.mg between :mg_ and :mg1_
      group by reu,kul,nd,org,usl,status) o,
      (select * from xitog3 e where e.mg=:mg1_) u,
      sprorg d, uslm m, org l, spul p
      where h.kul=p.id and
      h.reu=i.reu(+) and h.kul=i.kul(+) and h.nd=i.nd(+) and h.org=i.org(+) and h.usl=i.usl(+) and h.status=i.status(+) and
      h.reu=o.reu(+) and h.kul=o.kul(+) and h.nd=o.nd(+) and h.org=o.org(+) and h.usl=o.usl(+) and h.status=o.status(+) and
      h.reu=u.reu(+) and h.kul=u.kul(+) and h.nd=u.nd(+) and h.org=u.org(+) and h.usl=u.usl(+) and h.status=u.status(+) and
      l.id=3 and h.org=d.kod and h.uslm=m.uslm
      group by h.name_reu||'' ''||p.name||'', ''||ltrim(h.nd,''0'')
      having sum(i.indebet) <>0 or sum(i.inkredit) <>0 or
      sum(o.charges) <>0 or sum(o.changes) <>0 or sum(o.subsid) <>0 or
      sum(o.privs) <>0 or sum(o.privs_city) <>0 or sum(o.payment) <>0 or
      sum(o.pn) <>0 or sum(u.outdebet) <>0 or sum(u.outkredit) <>0
      order by h.name_reu||'' ''||p.name||'', ''||ltrim(h.nd,''0'')'
          USING reu_, kul_, nd_, fk_ses_, fk_ses_, mg_, mg_, mg1_, mg1_;
    ELSIF var_ = 2 THEN
      --по ∆Ёќ
      OPEN prep_refcursor FOR 'select l.name||h.name_reu as predpr, p.name||'', ''||ltrim(h.nd,''0'') as adr, sum(i.indebet) as indebet, sum(i.inkredit) as inkredit,
      sum(o.charges) as charges, sum(o.changes) as changes, sum(o.subsid) as subsid, sum(o.privs) as privs, sum(o.privs_city) as privs_city, sum(o.payment) as payment,
      sum(o.ch_full) as ch_full, sum(o.changes2) as changes2, sum(o.changes+o.changes2) as changesall,
      sum(o.pn) as pn, sum(u.outdebet) as outdebet, sum(u.outkredit) as outkredit
      from
      (select u.*, trim(s.name_reu) as name_reu from t_saldo_reu_kul_nd_st u, s_reu_trest s
      where u.reu=:reu_ and u.reu=s.reu
            and exists
           (select * from list_c i, spr_params p where i.fk_ses=:fk_ses_
                and p.id=i.fk_par and p.cd=''REP_USL2'' 
                and i.sel_cd=u.usl
            and i.sel=1)
            and exists
           (select * from list_c i, spr_params p where i.fk_ses=:fk_ses_
                and p.id=i.fk_par and p.cd=''REP_ORG2'' 
                and i.sel_id=u.org
            and i.sel=1)
      ) h,
      (select * from xitog3 e where e.mg=:mg_) i,
      (select reu,kul,nd,org,usl,status,sum(charges) as charges,
      sum(changes) as changes, sum(subsid) as subsid, sum(privs) as privs, sum(privs_city) as privs_city,
      sum(ch_full) as ch_full, sum(changes2) as changes2, sum(payment) as payment, sum(pn) as pn from xitog3 t
      where t.mg between :mg_ and :mg1_
      group by reu,kul,nd,org,usl,status) o,
      (select * from xitog3 e where e.mg=:mg1_) u,
      sprorg d, uslm m, org l, spul p
      where h.kul=p.id and
      h.reu=i.reu(+) and h.kul=i.kul(+) and h.nd=i.nd(+) and h.org=i.org(+) and h.usl=i.usl(+) and h.status=i.status(+) and
      h.reu=o.reu(+) and h.kul=o.kul(+) and h.nd=o.nd(+) and h.org=o.org(+) and h.usl=o.usl(+) and h.status=o.status(+) and
      h.reu=u.reu(+) and h.kul=u.kul(+) and h.nd=u.nd(+) and h.org=u.org(+) and h.usl=u.usl(+) and h.status=u.status(+) and
      l.id=3 and h.org=d.kod and h.uslm=m.uslm
      group by l.name||h.name_reu, p.name||'', ''||ltrim(h.nd,''0'')
      having sum(i.indebet) <>0 or sum(i.inkredit) <>0 or
      sum(o.charges) <>0 or sum(o.changes) <>0 or sum(o.subsid) <>0 or
      sum(o.privs) <>0 or sum(o.privs_city) <>0 or sum(o.payment) <>0 or
      sum(o.pn) <>0 or sum(u.outdebet) <>0 or sum(u.outkredit) <>0
      order by  l.name||h.name_reu, p.name||'', ''||ltrim(h.nd,''0'')'
          USING reu_, fk_ses_, fk_ses_, mg_, mg_, mg1_, mg1_;
    ELSIF var_ = 1  THEN
      --по ‘онду
      OPEN prep_refcursor FOR 'select l.name||t.name_tr as predpr, p.name||'', ''||ltrim(h.nd,''0'') as adr, sum(i.indebet) as indebet, sum(i.inkredit) as inkredit,
      sum(o.charges) as charges, sum(o.changes) as changes, sum(o.subsid) as subsid, sum(o.privs) as privs, sum(o.privs_city) as privs_city, sum(o.payment) as payment,
      sum(o.ch_full) as ch_full, sum(o.changes2) as changes2, sum(o.changes+o.changes2) as changesall,
      sum(o.pn) as pn, sum(u.outdebet) as outdebet, sum(u.outkredit) as outkredit
      from
      (select u.* from t_saldo_reu_kul_nd_st u, s_reu_trest s
      where u.reu=s.reu and s.trest=:trest_
            and exists
           (select * from list_c i, spr_params p where i.fk_ses=:fk_ses_
                and p.id=i.fk_par and p.cd=''REP_USL2'' 
                and i.sel_cd=u.usl
            and i.sel=1)
            and exists
           (select * from list_c i, spr_params p where i.fk_ses=:fk_ses_
                and p.id=i.fk_par and p.cd=''REP_ORG2'' 
                and i.sel_id=u.org
            and i.sel=1)
       ) h,
      (select * from xitog3 e where e.mg=:mg_) i,
      (select reu,kul,nd,org,usl,status,sum(charges) as charges,
      sum(changes) as changes, sum(subsid) as subsid, sum(privs) as privs, sum(privs_city) as privs_city,
      sum(ch_full) as ch_full, sum(changes2) as changes2, sum(payment) as payment, sum(pn) as pn from xitog3 t
      where t.mg between :mg_ and :mg1_
      group by reu,kul,nd,org,usl,status) o,
      (select * from xitog3 e where e.mg=:mg1_) u,
      sprorg d, uslm m, org l, spul p, s_reu_trest t
      where h.kul=p.id and h.reu=t.reu and
      h.reu=i.reu(+) and h.kul=i.kul(+) and h.nd=i.nd(+) and h.org=i.org(+) and h.usl=i.usl(+) and h.status=i.status(+) and
      h.reu=o.reu(+) and h.kul=o.kul(+) and h.nd=o.nd(+) and h.org=o.org(+) and h.usl=o.usl(+) and h.status=o.status(+) and
      h.reu=u.reu(+) and h.kul=u.kul(+) and h.nd=u.nd(+) and h.org=u.org(+) and h.usl=u.usl(+) and h.status=u.status(+) and
      l.id=2 and h.org=d.kod and h.uslm=m.uslm
      group by l.name||t.name_tr, p.name||'', ''||ltrim(h.nd,''0'')
      having sum(i.indebet) <>0 or sum(i.inkredit) <>0 or
      sum(o.charges) <>0 or sum(o.changes) <>0 or sum(o.subsid) <>0 or
      sum(o.privs) <>0 or sum(o.privs_city) <>0 or sum(o.payment) <>0 or
      sum(o.pn) <>0 or sum(u.outdebet) <>0 or sum(u.outkredit) <>0
      order by l.name||t.name_tr, p.name||'', ''||ltrim(h.nd,''0'')'
          USING trest_, fk_ses_, fk_ses_, mg_, mg_, mg1_, mg1_;
    ELSIF var_ = 0 THEN
      --по √ороду
      OPEN prep_refcursor FOR 'select l.name as predpr, p.name||'', ''||ltrim(h.nd,''0'') as adr, sum(i.indebet) as indebet, sum(i.inkredit) as inkredit,
      sum(o.charges) as charges, sum(o.pcharges) as pcharges, sum(o.changes) as changes, sum(o.subsid) as subsid, sum(o.privs) as privs, sum(o.privs_city) as privs_city, sum(o.payment) as payment,
      sum(o.ch_full) as ch_full, sum(o.changes2) as changes2, sum(o.changes+o.changes2) as changesall,
      sum(o.pn) as pn, sum(u.outdebet) as outdebet, sum(u.outkredit) as outkredit
      from
      (select u.* from t_saldo_reu_kul_nd_st u
      where u.uslm is not null 
            and exists
           (select * from list_c i, spr_params p where i.fk_ses=:fk_ses_
                and p.id=i.fk_par and p.cd=''REP_USL2'' 
                and i.sel_cd=u.usl
            and i.sel=1)
            and exists
           (select * from list_c i, spr_params p where i.fk_ses=:fk_ses_
                and p.id=i.fk_par and p.cd=''REP_ORG2'' 
                and i.sel_id=u.org
            and i.sel=1)
      ) h,
      (select * from xitog3 e where e.mg=:mg_) i,
      (select reu,kul,nd,org,usl,status, sum(charges) as charges, sum(pcharges) as pcharges,
      sum(changes) as changes, sum(subsid) as subsid, sum(privs) as privs, sum(privs_city) as privs_city,
      sum(ch_full) as ch_full, sum(changes2) as changes2, sum(payment) as payment, sum(pn) as pn from xitog3 t
      where t.mg between :mg_ and :mg1_
      group by reu,kul,nd,org,usl,status) o,
      (select * from xitog3 e where e.mg=:mg1_) u,
      sprorg d, uslm m, org l, spul p
      where h.kul=p.id and
      h.reu=i.reu(+) and h.kul=i.kul(+) and h.nd=i.nd(+) and h.org=i.org(+) and h.usl=i.usl(+) and h.status=i.status(+) and
      h.reu=o.reu(+) and h.kul=o.kul(+) and h.nd=o.nd(+) and h.org=o.org(+) and h.usl=o.usl(+) and h.status=o.status(+) and
      h.reu=u.reu(+) and h.kul=u.kul(+) and h.nd=u.nd(+) and h.org=u.org(+) and h.usl=u.usl(+) and h.status=u.status(+) and
      l.id=1 and h.org=d.kod and h.uslm=m.uslm
      group by l.name, p.name||'', ''||ltrim(h.nd,''0'')
      having sum(i.indebet) <>0 or sum(i.inkredit) <>0 or
      sum(o.charges) <>0 or sum(o.changes) <>0 or sum(o.subsid) <>0 or
      sum(o.privs) <>0 or sum(o.privs_city) <>0 or sum(o.payment) <>0 or
      sum(o.pn) <>0 or sum(u.outdebet) <>0 or sum(u.outkredit) <>0
      order by l.name, p.name||'', ''||ltrim(h.nd,''0'')'
          USING fk_ses_, fk_ses_, mg_, mg_, mg1_, mg1_;
     END IF;
 elsif сd_ in ('91') then
    --реестр пользующихс€ льготой по капремонту >=70 лет “ќЋ№ ќ ƒЋя ѕќЋџ—, “ј   ј  ” Ќ»’ Ќ≈“ ƒќѕ —„≈“ќ¬, - –јЅќ“ј≈“ ѕќ ƒ–”√ќћ”
    OPEN prep_refcursor FOR 'select scott.utils.month_name(substr(k.mg, 5, 2)) as mon,
                 substr(k.mg, 1, 4) as year, k.lsk as ls, s.name as ul, ltrim(k.nd,''0'') as dom, ltrim(k.kw,''0'') as kv,
     a.name as st, k.opl, k.k_fam as sur, k.k_im as nam, k.k_ot as mid, k.kpr, t.dat_rog
     from arch_kart k, a_kart_pr t, spul s, status a
    where k.psch not in (8,9)
      and k.lsk=t.lsk and k.mg=t.mg and k.mg=:mg
      and k.kul=s.id and k.status=a.id and a.cd=''PRV''
      and exists (select min(p.id) from a_kart_pr p, relations r where
       months_between(to_date(p.mg||''01'',''YYYYMMDD''), p.dat_rog) /12 >= 70
       and p.dat_rog is not null
       and p.id=t.id and p.mg=:mg
       and p.relat_id=r.id and r.cd in ('' вартиросъемщик'', ''—обственник'')
       and p.status=1
       having min(p.id)=t.id
       )
     and exists (select * from a_charge_prep a 
       where a.lsk=k.lsk and a.tp=9 and a.mg=:mg) --только льготники
      order by k.reu, s.name, ltrim(k.nd,''0''), ltrim(k.kw,''0'')'
      using mg_, mg_, mg_;
      
 elsif сd_ in ('92') then
    --реестр дл€ ”—«Ќ,-длинный, бессмысленный и беспощадный
    OPEN prep_refcursor FOR 'select c.name as org1, c.reu, s.kul, null as st_code, 
     c2.name as nasp, l.name as nylic,
     scott.utils.f_ord_digit(s.nd) as ndom,
     scott.utils.f_ord3(s.nd) as nkorp,
     ltrim(s.kw,''0'') as nkw,
     null as nkomn, 
     s.lsk as lchet,
     s.kpr,
     s.kpr_wr,
     s.kpr_ot,
     s.opl,
     s.opl as pl_ot,
     ''—одержание и ремонт жилого помещени€'' as gu1,
     c1.tf1 as tf_ng1,
     c1.tf2 as tf_svg1,
     e2.summa_itg as sum_g1,
     '' апитальный ремонт'' as gu2,
     c2.tf1 as tf_ng2,
     c2.tf2 as tf_svg2,
     e3.summa_itg as sum_g2,
     ''Ќайм коммерческий'' as gu3,
     null as tf_ng3,
     null as tf_svg3,
     null as sum_g3,
     ''Ќайм помещени€'' as gu4,
     c4.tf1 as tf_ng4,
     null as tf_svg4,
     e4.summa_itg as sum_g4,
     ''Ёлектроснабжение в домах со стационарными эл.плит.'' as gku1,
     s.lsk as lchet1,
     ''квт.'' as edizm1,
     c5.tf1 as tf_n1,
     c5.tf2 as tf_sv1,
     e5.test_opl as fakt1,
     case when s.kpr = 1 THEN
          130
        when s.kpr IN (2, 3) THEN
          100
        when s.kpr = 4 THEN
          87.5
        when s.kpr = 5 THEN
          80
        when s.kpr >= 6 THEN
          75 END as norm1,
     e5.summa_itg as sum_f1,
     ''Ёлектроснабжение, ќƒЌ'' as gku2,
     s.lsk as lchet2,
     ''квт.'' as edizm2,
     e6.nrm as norm2,
     c6.tf1 as tf_n2,
     null as tf_sv2,
     e6.summa_itg as sum_f2,
     null as gku3,
     null as lchet3,
     null as ed_izm3,
     null as tf_n3,
     null as tf_sv3,
     null as norm3,
     null as fakt3,
     null as sum_f3,
     ''’¬—'' as gku4,
     s.lsk as lchet4,
     ''м3'' as edizm4,
     c7.tf1 as tf_n4,
     c7.tf2 as tf_sv4,
     e7.norm as norm4,
     e7.test_opl as fakt4,
     e7.summa_itg as sum_f4,
     ''’олодна€ вода, ќƒЌ'' as gku5,
     s.lsk as lchet5,
     ''м3'' as edizm5,
     c8.tf1 as tf_n5,
     c8.tf2 as tf_sv5,
     e8.nrm as norm5,
     e8.summa_itg as sum_f5,
     ''√¬—'' as gku6,
     s.lsk as lchet6,
     ''м3'' as edizm6,
     c9.tf1 as tf_n6,
     c9.tf2 as tf_sv6,
     e9.norm as norm6,
     e9.test_opl as fakt6,
     e9.summa_itg as sum_f6,
     ''√ор€ча€ вода, ќƒЌ'' as gku7,
     s.lsk as lchet7,
     ''м3'' as edizm7,
     c10.tf1 as tf_n7,
     c10.tf2 as tf_sv7,
     e10.nrm as norm7,
     e10.summa_itg as sum_f7,
     '' анализаци€'' as gku8,
     s.lsk as lchet8,
     ''м3'' as edizm8,
     e11.test_opl as fakt8,
     c11.tf1 as tf_n8,
     c11.tf2 as tf_sv8,
     e11.norm as norm8,
     e11.summa_itg as sum_f8,
     ''ќтопление'' as gku9,
     s.lsk as lchet9,
     ''м2'' as edizm9,
     c12.tf1 as tf_n9,
     c12.tf2 as tf_sv9,
     case when s.kpr = 1 THEN
          33
        when s.kpr IN (2) THEN
          21
        when s.kpr >= 3 THEN
          18 END as norm9,
     e12.summa_itg as sum_f9,
     ''√аз в баллонах'' as gku10,
     null as lchet10,
     null as edizm10,
     null as fakt10,
     null as sum_f10
    from (select s.* from kart k, arch_kart s, s_reu_trest e where s.mg=:mg_
     and k.lsk=s.lsk
     and k.sel1=1
     /*and e.reu=''01''
     and s.lsk=''00000001''*/
     and s.reu=e.reu
     and s.psch not in (8,9) --только открытые
     and s.status not in (7)--убрал нежилые
     ) s join t_org c on s.reu=c.reu
         join t_org c2 on 1=1
         join t_org_tp tp on c2.fk_orgtp=tp.id and tp.cd=''√ород''
         join params p on p.period=p.period
         join spul l on s.kul=l.id
         left join 
    (select s.lsk, 
     sum(s.summa) as summa_itg
       from a_charge s, usl u 
        where s.mg=:mg_ and s.usl=u.usl and
       u.cd in (''т/сод'', ''т/сод/св.нор'', ''лифт'', ''лифт/св.нор'', ''дерат.'', ''дерат/св.нор'', ''мус.площ.'', ''мус.площ./св.нор'',
       ''выв.мус.'', ''выв.мус./св.нор'')
       and s.type=1 --текущее содержание, вместе с под-услугами
     group by s.lsk) e2 on s.lsk = e2.lsk
         left join 
    (select s.lsk,
     sum(s.summa) as summa_itg
       from a_charge s, usl u where s.mg=:mg_ and s.usl=u.usl and
      u.cd in (''кап.'', ''кап/св.нор'') and s.type=1 --капремонт
     group by s.lsk) e3 on s.lsk = e3.lsk
         left join 
    (select s.lsk,
     sum(s.summa) as summa_itg
       from a_charge s, usl u where s.mg=:mg_ and s.usl=u.usl and
      u.cd in (''найм'') and s.type=1 --найм
     group by s.lsk) e4 on s.lsk = e4.lsk
         left join 
    (select s.lsk,
     sum(s.test_opl) as test_opl,
     sum(s.summa) as summa_itg
       from a_charge s, usl u where s.mg=:mg_ and s.usl=u.usl and
      u.cd in (''эл.энерг.2'',''эл.эн.2/св.нор'') and s.type=1 --эл.энерг
     group by s.lsk) e5 on s.lsk = e5.lsk
         left join 
    (select s.lsk,
     sum(s.test_opl) as test_opl,
     sum(s.summa) as summa_itg,
     max(d.nrm) as nrm
       from a_charge s
       join a_nabor n on s.lsk=n.lsk and s.mg=n.mg and 
       s.mg=:mg_
       join a_vvod d on n.fk_vvod=d.id and n.usl=d.usl
       and n.mg=d.mg
       join usl u2 on n.usl=u2.usl and u2.cd in (''эл.энерг.2'')
       join usl u on s.usl=u.usl and u.cd in (''эл.эн.ќƒЌ'') and s.type=1 --эл.энерг
     group by s.lsk) e6 on s.lsk = e6.lsk
         left join 
    (select s.lsk,
     sum(s.test_opl) as test_opl,
     sum(s.summa) as summa_itg,
     max(n.norm) as norm
       from a_charge s, a_nabor n, usl u where 
       s.mg=:mg_ and s.usl=u.usl and s.lsk=n.lsk and s.mg=n.mg
       and s.usl=n.usl and
       u.cd in (''х.вода'', ''х.вода/св.нор'') and s.type=1
     group by s.lsk) e7 on s.lsk = e7.lsk
         left join 
    (select s.lsk,
     sum(s.test_opl) as test_opl,
     sum(s.summa) as summa_itg,
     max(d.nrm) as nrm
       from a_charge s
       join a_nabor n on s.lsk=n.lsk and s.mg=n.mg and 
       s.mg=:mg_
       join a_vvod d on n.fk_vvod=d.id and n.usl=d.usl
       and n.mg=d.mg
       join usl u2 on n.usl=u2.usl and u2.cd in (''х.вода'')
       join usl u on s.usl=u.usl and u.cd in (''х.вода.ќƒЌ'') and s.type=1
     group by s.lsk) e8 on s.lsk = e8.lsk
         left join 
    (select s.lsk,
     sum(s.test_opl) as test_opl,
     sum(s.summa) as summa_itg,
     max(n.norm) as norm
       from a_charge s, a_nabor n, usl u where 
       s.mg=:mg_ and s.usl=u.usl and s.lsk=n.lsk and s.mg=n.mg
       and s.usl=n.usl and
       u.cd in (''г.вода'', ''г.вода/св.нор'') and s.type=1
     group by s.lsk) e9 on s.lsk = e9.lsk
         left join 
    (select s.lsk,
     sum(s.test_opl) as test_opl,
     sum(s.summa) as summa_itg,
     max(d.nrm) as nrm
       from a_charge s
       join a_nabor n on s.lsk=n.lsk and s.mg=n.mg and 
       s.mg=:mg_
       join a_vvod d on n.fk_vvod=d.id and n.usl=d.usl
       and n.mg=d.mg
       join usl u2 on n.usl=u2.usl and u2.cd in (''г.вода'')
       join usl u on s.usl=u.usl and u.cd in (''г.вода.ќƒЌ'') and s.type=1 --эл.энерг
     group by s.lsk) e10 on s.lsk = e10.lsk
         left join 
    (select s.lsk,
     sum(s.test_opl) as test_opl,
     sum(s.summa) as summa_itg,
     max(n.norm) as norm
       from a_charge s, a_nabor n, usl u where 
       s.mg=:mg_ and s.usl=u.usl and s.lsk=n.lsk and s.mg=n.mg
       and s.usl=n.usl and
       u.cd in (''канализ'', ''канализ/св.нор'') and s.type=1
     group by s.lsk) e11 on s.lsk = e11.lsk
         left join 
    (select s.lsk,
     sum(s.test_opl) as test_opl,
     sum(s.summa) as summa_itg,
     null as norm
       from a_charge s, a_nabor n, usl u where 
       s.mg=:mg_ and s.usl=u.usl and s.lsk=n.lsk and s.mg=n.mg 
       and s.usl=n.usl and
       u.cd in (''отоп'', ''отоп/св.нор'') and s.type=1
     group by s.lsk) e12 on s.lsk = e12.lsk

     left join
     (select n.lsk, round(sum(case when u.usl_norm = 0 then 
        case when n.koeff is not null and u.sptarn in (0,2,3) then n.koeff else 1 end * r.summa else 0 end),2) as tf1,
             round(sum(case when u.usl_norm = 1 then 
        case when n.koeff is not null and u.sptarn in (0,2,3) then n.koeff else 1 end * r.summa else 0 end),2) as tf2
       from 
         a_nabor n join usl u on n.usl=u.usl 
         join a_prices r on n.usl=r.usl and n.mg=r.mg
      where n.mg=:mg_ 
      and u.cd in (''т/сод'', ''т/сод/св.нор'', ''лифт'', ''лифт/св.нор'', ''дерат.'', ''дерат/св.нор'', ''мус.площ.'', ''мус.площ./св.нор'',
             ''выв.мус.'', ''выв.мус./св.нор'')
      group by n.lsk       
       ) c1
       on s.lsk=c1.lsk
     left join
     (select n.lsk, round(sum(case when u.usl_norm = 0 then 
        case when n.koeff is not null and u.sptarn in (0,2,3) then n.koeff else 1 end * r.summa else 0 end),2) as tf1,
             round(sum(case when u.usl_norm = 1 then 
        case when n.koeff is not null and u.sptarn in (0,2,3) then n.koeff else 1 end * r.summa else 0 end),2) as tf2
       from 
         a_nabor n join usl u on n.usl=u.usl 
         join a_prices r on n.usl=r.usl and n.mg=r.mg
      where n.mg=:mg_ 
      and u.cd in (''кап.'', ''кап/св.нор'')
      group by n.lsk       
       ) c2
       on s.lsk=c2.lsk
       
       
     left join
     (select n.lsk, round(sum(case when u.usl_norm = 0 then 
        case when n.koeff is not null and u.sptarn in (0,2,3) then n.koeff else 1 end * r.summa else 0 end),2) as tf1,
             round(sum(case when u.usl_norm = 1 then 
        case when n.koeff is not null and u.sptarn in (0,2,3) then n.koeff else 1 end * r.summa else 0 end),2) as tf2
       from 
         a_nabor n join usl u on n.usl=u.usl 
         join a_prices r on n.usl=r.usl and n.mg=r.mg
      where n.mg=:mg_ 
      and u.cd in (''найм'')
      group by n.lsk       
       ) c4
       on s.lsk=c4.lsk
     left join
     (select n.lsk, round(sum(case when u.usl_norm = 0 then 
        case when n.koeff is not null and u.sptarn in (0,2,3) then n.koeff else 1 end * r.summa else 0 end),2) as tf1,
             round(sum(case when u.usl_norm = 1 then 
        case when n.koeff is not null and u.sptarn in (0,2,3) then n.koeff else 1 end * r.summa else 0 end),2) as tf2
       from 
         a_nabor n join usl u on n.usl=u.usl 
         join a_prices r on n.usl=r.usl and n.mg=r.mg
      where n.mg=:mg_ 
      and u.cd in (''эл.энерг.2'',''эл.эн.2/св.нор'')
      group by n.lsk       
       ) c5
       on s.lsk=c5.lsk
       
     left join
     (select n.lsk, round(sum(case when u.usl_norm = 0 then 
        case when n.koeff is not null and u.sptarn in (0,2,3) then n.koeff else 1 end * r.summa else 0 end),2) as tf1,
             round(sum(case when u.usl_norm = 1 then 
        case when n.koeff is not null and u.sptarn in (0,2,3) then n.koeff else 1 end * r.summa else 0 end),2) as tf2
       from 
         a_nabor n join usl u on n.usl=u.usl 
         join a_prices r on n.usl=r.usl and n.mg=r.mg
      where n.mg=:mg_ 
      and u.cd in (''эл.эн.ќƒЌ'')
      group by n.lsk       
       ) c6
       on s.lsk=c6.lsk
       
     left join
     (select n.lsk, round(sum(case when u.usl_norm = 0 then 
        case when n.koeff is not null and u.sptarn in (0,2,3) then n.koeff else 1 end * r.summa else 0 end),2) as tf1,
             round(sum(case when u.usl_norm = 1 then 
        case when n.koeff is not null and u.sptarn in (0,2,3) then n.koeff else 1 end * r.summa else 0 end),2) as tf2
       from 
         a_nabor n join usl u on n.usl=u.usl 
         join a_prices r on n.usl=r.usl and n.mg=r.mg
      where n.mg=:mg_ 
      and u.cd in (''х.вода'', ''х.вода/св.нор'')
      group by n.lsk       
       ) c7
       on s.lsk=c7.lsk       
       
     left join
     (select n.lsk, round(sum(case when u.usl_norm = 0 then 
        case when n.koeff is not null and u.sptarn in (0,2,3) then n.koeff else 1 end * r.summa else 0 end),2) as tf1,
             round(sum(case when u.usl_norm = 1 then 
        case when n.koeff is not null and u.sptarn in (0,2,3) then n.koeff else 1 end * r.summa else 0 end),2) as tf2
       from 
         a_nabor n join usl u on n.usl=u.usl 
         join a_prices r on n.usl=r.usl and n.mg=r.mg
      where n.mg=:mg_ 
      and u.cd in (''х.вода.ќƒЌ'')
      group by n.lsk       
       ) c8
       on s.lsk=c8.lsk       

     left join
     (select n.lsk, round(sum(case when u.usl_norm = 0 then 
        case when n.koeff is not null and u.sptarn in (0,2,3) then n.koeff else 1 end * r.summa else 0 end),2) as tf1,
             round(sum(case when u.usl_norm = 1 then 
        case when n.koeff is not null and u.sptarn in (0,2,3) then n.koeff else 1 end * r.summa else 0 end),2) as tf2
       from 
         a_nabor n join usl u on n.usl=u.usl 
         join a_prices r on n.usl=r.usl and n.mg=r.mg
      where n.mg=:mg_ 
      and u.cd in (''г.вода'', ''г.вода/св.нор'')
      group by n.lsk       
       ) c9
       on s.lsk=c9.lsk       

     left join
     (select n.lsk, round(sum(case when u.usl_norm = 0 then 
        case when n.koeff is not null and u.sptarn in (0,2,3) then n.koeff else 1 end * r.summa else 0 end),2) as tf1,
             round(sum(case when u.usl_norm = 1 then 
        case when n.koeff is not null and u.sptarn in (0,2,3) then n.koeff else 1 end * r.summa else 0 end),2) as tf2
       from 
         a_nabor n join usl u on n.usl=u.usl 
         join a_prices r on n.usl=r.usl and n.mg=r.mg
      where n.mg=:mg_ 
      and u.cd in (''г.вода.ќƒЌ'')
      group by n.lsk       
       ) c10
       on s.lsk=c10.lsk       

     left join
     (select n.lsk, round(sum(case when u.usl_norm = 0 then 
        case when n.koeff is not null and u.sptarn in (0,2,3) then n.koeff else 1 end * r.summa else 0 end),2) as tf1,
             round(sum(case when u.usl_norm = 1 then 
        case when n.koeff is not null and u.sptarn in (0,2,3) then n.koeff else 1 end * r.summa else 0 end),2) as tf2
       from 
         a_nabor n join usl u on n.usl=u.usl 
         join a_prices r on n.usl=r.usl and n.mg=r.mg
      where n.mg=:mg_ 
      and u.cd in (''канализ'', ''канализ/св.нор'')
      group by n.lsk       
       ) c11
       on s.lsk=c11.lsk       

     left join
     (select n.lsk, round(sum(case when u.usl_norm = 0 then 
        case when n.koeff is not null and u.sptarn in (0,2,3) then n.koeff else 1 end * r.summa else 0 end),2) as tf1,
             round(sum(case when u.usl_norm = 1 then 
        case when n.koeff is not null and u.sptarn in (0,2,3) then n.koeff else 1 end * r.summa else 0 end),2) as tf2
       from 
         a_nabor n join usl u on n.usl=u.usl 
         join a_prices r on n.usl=r.usl and n.mg=r.mg
      where n.mg=:mg_ 
      and u.cd in (''отоп'', ''отоп/св.нор'')
      group by n.lsk       
       ) c12
       on s.lsk=c12.lsk       

    order by l.name, s.nd, s.kw'
    using mg_,mg_,mg_,mg_,mg_,mg_,mg_,mg_,mg_,mg_,mg_,mg_,mg_,mg_,mg_,mg_,mg_,mg_,mg_,mg_,mg_,mg_,mg_;
      
      
 end if;


 END rep_stat;

procedure rep_detail(p_cd in varchar2, p_mg in params.period%type, p_lsk in kart.lsk%type,
                       prep_refcursor in out rep_refcursor) is
begin
--дочерний датасет в мастер-детали на форме Form_olap
if p_cd='83' then
 --1-ый датасет дл€ отчета по нормативам, расценкам, поквартирно
 open prep_refcursor for
'select t.lsk, t.mg, u.usl, u.npp, u.nm2, t.cnt, u.ed_izm,
  case when t.limit is not null then to_char(t.limit)
    else to_char(t.val_group2) end as val_group2, t.cena
  from STATISTICS_LSK t, usl u, usl u2 where t.mg=:p_mg and t.lsk=:p_lsk
  /*and t.usl(+)=u.usl and t.usl=u2.fk_usl_chld(+)*/
  and t.usl=u.usl and u.fk_usl_chld=u2.usl(+)
  and u.cd in (''кап.'', ''г.вода'', ''х.вода'', ''х.вода.ќƒЌ'',
   ''г.вода.ќƒЌ'', ''эл.энерг.2'', ''эл.эн.ќƒЌ'', ''найм'', ''канализ'')
--  and t.cnt is not null
--  group by t.lsk, u.usl, u.nm2, u.ed_izm, u.npp
  order by t.lsk, u.npp'
  using p_mg, p_lsk;
end if;

end;


PROCEDURE SQLTofile(p_sql IN VARCHAR2,
                    p_dir IN VARCHAR2,
                    p_header_file IN VARCHAR2,
                    p_data_file IN VARCHAR2 := NULL,
                    p_dlmt IN Varchar2 :=';' --разделитель, по умолчанию - ';'
                    ) IS
  v_finaltxt  VARCHAR2(4000);
  v_v_val     VARCHAR2(4000);
  v_n_val     NUMBER;
  v_d_val     DATE;
  v_ret       NUMBER;
  c           NUMBER;
  d           NUMBER;
  col_cnt     INTEGER;
  f           BOOLEAN;
  rec_tab     DBMS_SQL.DESC_TAB;
  col_num     NUMBER;
  v_fh        UTL_FILE.FILE_TYPE;
  v_samefile  BOOLEAN := (NVL(p_data_file,p_header_file) = p_header_file);
BEGIN
  --выгружает результат SQL в файл
  c := DBMS_SQL.OPEN_CURSOR;
  DBMS_SQL.PARSE(c, p_sql, DBMS_SQL.NATIVE);
  d := DBMS_SQL.EXECUTE(c);
  DBMS_SQL.DESCRIBE_COLUMNS(c, col_cnt, rec_tab);
  FOR j in 1..col_cnt
  LOOP
    CASE rec_tab(j).col_type
      WHEN 1 THEN DBMS_SQL.DEFINE_COLUMN(c,j,v_v_val,2000);
      WHEN 2 THEN DBMS_SQL.DEFINE_COLUMN(c,j,v_n_val);
      WHEN 12 THEN DBMS_SQL.DEFINE_COLUMN(c,j,v_d_val);
    ELSE
      DBMS_SQL.DEFINE_COLUMN(c,j,v_v_val,2000);
    END CASE;
  END LOOP;
  -- This part outputs the HEADER
  v_fh := UTL_FILE.FOPEN(upper(p_dir),p_header_file,'w',32767);
  FOR j in 1..col_cnt
  LOOP
    v_finaltxt := ltrim(v_finaltxt||p_dlmt||lower(rec_tab(j).col_name),p_dlmt);
  END LOOP;
  --  DBMS_OUTPUT.PUT_LINE(v_finaltxt);
  UTL_FILE.PUT_LINE(v_fh, v_finaltxt);
  IF NOT v_samefile THEN
    UTL_FILE.FCLOSE(v_fh);
  END IF;
  --
  -- This part outputs the DATA
  IF NOT v_samefile THEN
    v_fh := UTL_FILE.FOPEN(upper(p_dir),p_data_file,'w',32767);
  END IF;
  LOOP
    v_ret := DBMS_SQL.FETCH_ROWS(c);
    EXIT WHEN v_ret = 0;
    v_finaltxt := NULL;
    FOR j in 1..col_cnt
    LOOP
      CASE rec_tab(j).col_type
        WHEN 1 THEN DBMS_SQL.COLUMN_VALUE(c,j,v_v_val);
                    v_finaltxt := ltrim(v_finaltxt||p_dlmt||''||v_v_val||'',p_dlmt);
        WHEN 2 THEN DBMS_SQL.COLUMN_VALUE(c,j,v_n_val);
                    v_finaltxt := ltrim(v_finaltxt||p_dlmt||v_n_val,p_dlmt);
        WHEN 12 THEN DBMS_SQL.COLUMN_VALUE(c,j,v_d_val);
                    v_finaltxt := ltrim(v_finaltxt||p_dlmt||to_char(v_d_val,'DD/MM/YYYY HH24:MI:SS'), p_dlmt);
      ELSE
        DBMS_SQL.COLUMN_VALUE(c,j,v_v_val);
        v_finaltxt := ltrim(v_finaltxt||p_dlmt||''||v_v_val||'',p_dlmt);
      END CASE;
    END LOOP;
    UTL_FILE.PUT_LINE(v_fh, v_finaltxt);
  END LOOP;
  UTL_FILE.FCLOSE(v_fh);
  DBMS_SQL.CLOSE_CURSOR(c);
END;
END stat;
/

prompt
prompt Creating package body UPDATER
prompt =============================
prompt
create or replace package body scott.UPDATER is

procedure send_message(msg_ in messages.text%type) is
begin
  --отправка сообщений пользовател€м
  sys.dbms_alert.signal('FINDAY', msg_);
  commit;
end;

procedure set_ver(ver_ in number, type_ in number)
is
begin
if nvl(type_,0) = 1 then
  --ќбновление номера версии дл€ ожидани€ программным обеспечением
  update params t set t.wait_ver=ver_;
else
  --ќбновление номера версии программных пакетов Updater-ом
  update params t set t.ver=ver_;
end if;
commit;
end;

procedure del_types
is
begin
  --удаление всех TYPES, дл€ пересоздани€ в пакетах
  --без этого, иногда отваливаетс€ пакет REP_BILLS
  --желательно выполнить 2 раза (dependences)
  for c in
  (select * from all_objects t where t.OBJECT_TYPE='TYPE' and t.object_name like 'SYS%' --не все типы удалить))
    and t.OWNER='SCOTT')
  loop
    begin
    execute immediate 'drop type '||c.owner||'.'||c.object_name;
    exception
      when others then
        null;
    end;
  end loop;
end;
end UPDATER;
/

prompt
prompt Creating package body UTILS
prompt ===========================
prompt
create or replace package body scott.utils is
  function MONTH_NAME1(month_ NUMBER) RETURN varchar2 is
  begin
    if month_ = 1 then
      return 'январ€';
    elsif month_ = 2 then
      return '‘еврал€';
    elsif month_ = 3 then
      return 'ћарта';
    elsif month_ = 4 then
      return 'јпрел€';
    elsif month_ = 5 then
      return 'ћа€';
    elsif month_ = 6 then
      return '»юн€';
    elsif month_ = 7 then
      return '»юл€';
    elsif month_ = 8 then
      return 'јвгуста';
    elsif month_ = 9 then
      return '—ент€бр€';
    elsif month_ = 10 then
      return 'ќкт€бр€';
    elsif month_ = 11 then
      return 'Ќо€бр€';
    elsif month_ = 12 then
      return 'ƒекабр€';
    else
      return null;
    end if;
  end;

  function MONTH_NAME(month_ NUMBER) RETURN VARCHAR2 is
  begin
    if month_ = 1 then
      return 'январь';
    elsif month_ = 2 then
      return '‘евраль';
    elsif month_ = 3 then
      return 'ћарт';
    elsif month_ = 4 then
      return 'јпрель';
    elsif month_ = 5 then
      return 'ћай';
    elsif month_ = 6 then
      return '»юнь';
    elsif month_ = 7 then
      return '»юль';
    elsif month_ = 8 then
      return 'јвгуст';
    elsif month_ = 9 then
      return '—ент€брь';
    elsif month_ = 10 then
      return 'ќкт€брь';
    elsif month_ = 11 then
      return 'Ќо€брь';
    elsif month_ = 12 then
      return 'ƒекабрь';
    else
      return null;
    end if;
  end;

  function add_months_pr(mg_ in varchar2, cnt_ in number) return varchar2 is
  begin
    --возвращает в формате YYYYMM период назад или вперед от заданного
    return to_char(add_months(to_date(mg_||'01','YYYYMMDD'), cnt_),'YYYYMM');
  end;

  FUNCTION get_org_lsk(p_lsk IN kart.lsk%TYPE)
    RETURN NUMBER IS
  l_fk_org number;
  BEGIN
    --вернуть ID орг, по данному л.с.
    BEGIN
    SELECT s.id INTO l_fk_org
      FROM kart t, t_org s
      WHERE t.lsk=p_lsk
      AND t.reu=s.reu;
    EXCEPTION
      WHEN no_data_found THEN
         Raise_application_error(-20000, 'Ќе найден код –Ё” в Ћ/—:'||p_lsk);
    END;
  RETURN l_fk_org;
  END;

  FUNCTION get_nkom_pay_lsk(p_lsk IN kart.lsk%TYPE)
    RETURN c_comps.nkom%type IS
  l_nkom c_comps.nkom%type;
  l_org t_org.id%type;
  p_lsk2 kart.lsk%TYPE;
  BEGIN
    --вернуть є комп.который осуществл€ет ввод оплаты по данному фонду
    p_lsk2:=lpad(p_lsk,8,'0');
    l_org:=get_org_lsk(p_lsk2);
    begin
      select t.nkom into l_nkom
      from c_comps t where t.fk_org=l_org;
    exception
      when no_data_found then
         Raise_application_error(-20000, '¬ справочнике c_comps, не найден є компьютера соответствующий Ћ/—:'||p_lsk);
    end;
    return l_nkom;
  END;

  function GET_LSK_BY_ADR(kul_ kart.kul%TYPE, nd_ kart.nd%TYPE, kw_ kart.kw%TYPE)
           RETURN VARCHAR2 is
  lsk_ kart.lsk%TYPE;
  begin
  --поиск лицевого по адресу
  -- выбираем 1 - из списка (если адреса в базе не уникальны)
  if kw_ is not null then
    select max(lsk) into lsk_ from kart
           where kul=kul_ and nd=nd_ and kw=kw_ and rownum=1;
  else
    select max(lsk) into lsk_ from kart
           where kul=kul_ and nd=nd_ and rownum=1;
  end if;
  return lsk_;
  end GET_LSK_BY_ADR;

  function GET_C_LSK_ID_BY_ADR(kul_ kart.kul%TYPE, nd_ kart.nd%TYPE, kw_ kart.kw%TYPE)
           RETURN VARCHAR2 is
  c_lsk_id_ kart.c_lsk_id%TYPE;
  begin
  --поиск лицевого по адресу
  -- выбираем 1 - из списка (если адреса в базе не уникальны)
  if kw_ is not null then
    select max(c_lsk_id) into c_lsk_id_ from kart
           where kul=kul_ and nd=nd_ and kw=kw_ and rownum=1;
  else
    select max(c_lsk_id) into c_lsk_id_ from kart
           where kul=kul_ and nd=nd_ and rownum=1;
  end if;
  return c_lsk_id_;
  end GET_C_LSK_ID_BY_ADR;

  function GET_LSK_BY_ADR2(house_id_ kart.house_id%TYPE, kw_ kart.kw%TYPE)
           RETURN VARCHAR2 is
  lsk_ kart.lsk%TYPE;
  begin
  --поиск лицевого по адресу
  -- выбираем 1 - из списка (если адреса в базе не уникальны)
  if kw_ is not null then
    select max(trim(lsk)) into lsk_ from kart k
           where k.house_id = house_id_ and kw=kw_ and rownum=1;
  else
    select min(trim(lsk)) into lsk_ from kart k
           where k.house_id = house_id_ and rownum=1;
  end if;
  return lsk_;
  end GET_LSK_BY_ADR2;

  function GET_LSK_BY_ADR3(house_id_ kart.house_id%TYPE, kw_ kart.kw%TYPE)
           RETURN kart.k_lsk_id%type is
    k_lsk_id_  number;
  begin
  --поиск k_lsk_id по адресу
    select max(k.k_lsk_id) into k_lsk_id_ from kart k
           where k.house_id = house_id_ and kw=kw_ and rownum=1;
  return k_lsk_id_;
  end GET_LSK_BY_ADR3;

  function GET_LSK_BY_ADR4(house_id_ kart.house_id%TYPE, kw_ kart.kw%TYPE)
           RETURN kart.c_lsk_id%type is
    c_lsk_id_  number;
  begin
  --поиск c_lsk_id по адресу
    select max(k.c_lsk_id) into c_lsk_id_ from kart k
           where k.house_id = house_id_ and kw=kw_ and rownum=1;
  return c_lsk_id_;
  end GET_LSK_BY_ADR4;

  function GET_K_LSK_ID_BY_LSK(lsk_ kart.lsk%TYPE)
           RETURN kart.k_lsk_id%type is
    k_lsk_id_  number;
  begin
  --поиск k_lsk_id по LSK
    select max(k.k_lsk_id) into k_lsk_id_ from kart k
           where k.lsk = lpad(lsk_,8,'0') and rownum=1;
  return k_lsk_id_;
  end GET_K_LSK_ID_BY_LSK;

  function GET_C_LSK_ID_BY_LSK(lsk_ kart.lsk%TYPE)
           RETURN kart.c_lsk_id%type is
    c_lsk_id_  number;
  begin
  --поиск c_lsk_id по LSK
    select max(k.c_lsk_id) into c_lsk_id_ from kart k
           where k.lsk = lpad(lsk_,8,'0') and rownum=1;
  return c_lsk_id_;
  end GET_C_LSK_ID_BY_LSK;

  function GET_ADR_BY_LSK(lsk_ kart.lsk%TYPE)
           RETURN varchar2 is
  adr_ varchar2(200);
  begin
  --поиск адреса по LSK
    select nvl(max(trim(t.name_reu)||', '||s.name||', '||ltrim(k.nd,'0')||'-'||ltrim(k.kw,'0')),
     'јдрес не найден!')
     into adr_
    from kart k, spul s, s_reu_trest t
      where k.reu=t.reu and k.kul=s.id and
       k.lsk=lpad(lsk_,8,'0');
  return adr_;
  end GET_ADR_BY_LSK;

  function ALLOW_FUNCT(fk_type_ in number)
           RETURN NUMBER is
  cnt_ number;
  begin
  --провер€ет доступность пользователю заданной функции
    select count(*) into cnt_
      from v_cur_rlxfunct t
        where t.fk_type = fk_type_ and t.fk_funct is null;
    if cnt_ > 1 then
      RAISE_APPLICATION_ERROR(-20001,
            'Ќайдены дублирующиес€ функции дл€ роли, настройте роли!');
    end if;
  return cnt_;
  end;

  function ALLOW_EDIT_LSK(lsk_ kart.lsk%TYPE, cd_ in varchar2)
           RETURN NUMBER is
  cnt_ number;
  l_listtp u_listtp.id%type;
  begin
  select t.id into l_listtp from u_listtp t where t.cd='“ип разрешени€';
  --провер€ет можно ли пользователю редактировать лицевой счет
  if cd_ in ('доступ к карт.рэу', 'доступ к карт.площадь',
     'доступ к карт.статус') then
  --дл€ –Ё”
   select count(*) into cnt_ from t_user u, c_users_perm p, kart k, u_list i
      where u.id=p.user_id and u.cd=user
      and k.lsk = lsk_ and p.fk_reu=k.reu and k.psch <> 8
      and i.id=p.fk_perm_tp and i.cd=cd_
      and i.fk_listtp=l_listtp; -- k.psch <> 8 (запрещено править старый фонд);
  elsif cd_='доступ к пасп.столу' then
  --дл€ ѕаспортного
   select count(*) into cnt_ from t_user u, c_users_perm p, kart k, u_list i
      where u.id=p.user_id and upper(u.cd)=upper(user)
      and k.lsk = lsk_ and p.fk_pasp_org=k.fk_pasp_org and k.psch <> 8
      and i.id=p.fk_perm_tp and i.cd=cd_
      and i.fk_listtp=l_listtp; -- k.psch <> 8 (запрещено править старый фонд);
  elsif cd_='доступ к льготам' then
  --дл€ редактировани€ льгот
   select count(*) into cnt_ from t_user u, c_users_perm p, kart k, u_list i
      where u.id=p.user_id and u.cd=user
      and k.lsk = lsk_ and p.fk_reu=k.reu and k.psch <> 8
      and i.id=p.fk_perm_tp and i.cd=cd_
      and i.fk_listtp=l_listtp; -- k.psch <> 8 (запрещено править старый фонд);
  end if;
  return cnt_;
  end;

  function ALLOW_CR_NEW_LSK(lsk_ kart.lsk%TYPE)
           RETURN NUMBER is
  cnt_ number;
  begin
  --провер€ет можно ли пользователю создавать лицевой счет
   select count(*) into cnt_ from t_user u, c_users_perm p, kart k, u_list i
      where u.id=p.user_id and u.cd=user
      and k.lsk = lsk_ and p.fk_reu=k.reu and k.psch <> 8
      and i.id=p.fk_perm_tp and i.cd='доступ к карт.рэу'; -- k.psch <> 8 (запрещено править старый фонд);
  return cnt_;
  end;

  function ALLOW_CHANGES_LSK(lsk_ kart.lsk%TYPE)
           RETURN NUMBER is
  cnt_ number;
  begin
  --провер€ет можно ли пользователю проводить изменени€ начислени€ по л.с.
   select count(*) into cnt_ from t_user u, c_users_perm p, kart k, u_list i
      where u.id=p.user_id and u.cd=user
      and k.lsk = lsk_ and p.fk_reu=k.reu-- and k.psch <> 8
      and i.id=p.fk_perm_tp and i.cd='доступ к карт.рэу'; -- k.psch <> 8 (запрещено править старый фонд);
  return cnt_;
  end;

--генераци€ нового лицевого счета
FUNCTION GET_NEW_LSK(lsk_ in kart.lsk%TYPE, p_lsk in kart.lsk%TYPE) RETURN kart.lsk%TYPE IS
  lsk1_ kart.lsk%TYPE;
  cnt_  NUMBER;
  l_reu kart.reu%TYPE;
BEGIN
  --ред.31.07.12
  SELECT reu INTO l_reu FROM kart k WHERE k.lsk = lsk_;
  --поиск с учЄтом дырок
  lsk1_ := p_houses.find_unq_lsk(l_reu, p_lsk);
  IF lsk1_ IS NULL THEN
    --исчерпались максимальные лицевые в –Ё”,
    --тупо максимальный лицевой +1 в базе
    SELECT lpad(MAX(to_number(lsk)) + 1, 8, '0') INTO lsk1_ FROM kart k;
  END IF;
  RETURN lsk1_;
END;

--генераци€ нового лицевого счета по –Ё”
FUNCTION GET_NEW_LSK_BY_REU(p_reu kart.reu%TYPE) RETURN kart.lsk%TYPE IS
  l_lsk kart.lsk%TYPE;
  l_cnt  NUMBER;
BEGIN
  --ред.01.10.14
  --поиск с учЄтом дырок
  l_lsk := p_houses.find_unq_lsk(p_reu, null);
  IF l_lsk IS NULL THEN
    --исчерпались максимальные лицевые в –Ё”,
    --тупо максимальный лицевой +1 в базе
    SELECT lpad(MAX(to_number(lsk)) + 1, 8, '0') INTO l_lsk FROM kart k;
  END IF;
  RETURN l_lsk;
END;

  function create_vvod (house_id_ c_houses.id%TYPE, usl_ c_vvod.usl%TYPE,
    num_ c_vvod.vvod_num%TYPE)
           RETURN number is
    cnt_ number;
    id_ c_vvod.id%type;
  begin
  --создание ввода на доме
    select count(*) into cnt_
      from c_vvod c where c.house_id=house_id_ and c.usl=usl_
        and c.vvod_num=num_;
    if cnt_ = 0 then
      --создаем ввод
      insert into c_vvod(house_id, usl, vvod_num)
        values (house_id_, usl_, num_)
        returning id into id_;
      commit;
      return id_;
    else
      --данный ввод уже существует в доме!
      return -1;
    end if;
  end;

  function delete_vvod (id_ c_vvod.id%TYPE)
           RETURN number is
    cnt_ number;
  begin
  --удаление ввода на доме
    select count(*) into cnt_
      from c_vvod c where c.id=id_;
    if cnt_ = 1 then
      --удал€ем ввод
      begin
       delete from c_vvod c where c.id=id_;
      exception
      when others then
        raise_application_error(-20001,
                                'ƒанный ввод используетс€, удалите все ссылки в карточках на него!');
      end;
      commit;
      return 0;
    else
      --данный ввод Ќ≈ существует в доме!
      return 1;
    end if;
  end;

  function CREATE_LSK (lsk_ kart.lsk%TYPE, lsk_new_ kart.lsk%TYPE, 
      p_lsk_ext kart.lsk_ext%type, p_fio kart.fio%type)
           RETURN number is
  l_cnt number;
  begin
  begin
    select 1 into l_cnt
     from dual where regexP_like(lsk_new_,'[[:digit:]]{8}')
     and length(trim(lsk_new_))=8
     and not exists (select * from kart k where k.lsk=trim(lsk_new_));
  exception
    when no_data_found then
      return 1; --формат лиц.счета не соответствует требовани€м
  end;
  
  insert into c_lsk (id)
    values (c_lsk_id.nextval);
  insert into k_lsk (id, fk_addrtp)
     select k_lsk_id.nextval, u.id
     from u_list u, u_listtp tp
     where
     u.cd='flat' and tp.cd='object_type';

  insert into kart
    (lsk, k_lsk_id, c_lsk_id, house_id, kul, nd, kw, fio, kpr, kpr_wr,
     kpr_ot, kpr_cem, kpr_s, opl, ppl, pldop, ki,
     psch, psch_dt, status, kwt, lodpl,
     bekpl, balpl, komn, et, kfg,
     kfot, phw, mhw, pgw, mgw, pel, mel,
     sub_nach, subsidii, sub_data,
     polis, sch_el, reu, text,
     eksub1, eksub2, kran, kran1, el,
     el1, sgku, doppl, subs_cor, subs_cur, fk_pasp_org, mg1, mg2, lsk_ext, fk_tp, sel1)
  select
     lsk_new_, k_lsk_id.currval, c_lsk_id.currval, house_id, kul, nd, kw, p_fio as fio,
     0, 0, 0, 0, 0, opl, ppl, pldop, ki,
     0, psch_dt, status, kwt, lodpl,
     bekpl, balpl, komn, et, kfg,
     kfot, 0, 0, 0, 0, 0, 0, sub_nach,
     subsidii, null,
     null as polis,
     sch_el, reu, text,
     0, 0, 0, 0, 0, 0, 0, 0, 0,  0, k.fk_pasp_org, p.period, '999999', p_lsk_ext, tp.id as fk_tp, 1 as sel1
   from kart k, params p, v_lsk_tp tp where k.lsk=lsk_ and tp.cd='LSK_TP_MAIN';
  if SQL%ROWCOUNT = 0 then 
    Raise_application_error(-20000, 'Ќе добавлены записи лицевых счетов!');
  end if;

  insert into nabor
    (lsk, usl, org, koeff, norm)
  select
     lsk_new_, usl, org, koeff, norm
  from nabor n where n.lsk=lsk_;

  --установить по умолчанию статусы счетчиков - норматив
  insert into c_states_sch(lsk, fk_status)
    values
    (lsk_new_, 0);
--  убрал коммит, делать в delphi
--  commit;
  return 0;

  end;

  procedure ins_lg_doc (kart_pr_id_ in c_kart_pr.id%type)
  is
   seq_ number;
  begin
  --добавление нового документа по льготе
   select c_lg_docs_id.nextval into seq_ from dual;
   insert into c_lg_docs (id, c_kart_pr_id, main)
    values (seq_, kart_pr_id_, 0);
  --добавление новых льгот по умолчанию
   insert into c_lg_pr (c_lg_docs_id, spk_id, type)
    values (seq_, 1, 0);
   insert into c_lg_pr (c_lg_docs_id, spk_id, type)
    values (seq_, 1, 1);
  end;

  procedure del_lg_doc (c_lg_docs_id_ in c_lg_docs.id%type) is
  begin
  --удаление документа и каскадно - льгот
   delete from c_lg_docs d where d.id = c_lg_docs_id_;
  end;

  procedure count_krt_kpr (lsk_ in kart.lsk%type) is
  begin
  --«ј„≈ћ Ќ”∆Ќј Ё“ј ‘”Ќ ÷»я?
  --≈—Ћ»  ќЋ-¬ќ ѕ–ќ∆»¬. —„»“ј≈“—я ¬ “–»√√≈–≈?
  --удалить после 01.09.2010
  Raise_application_error(-20000, 'ќЎ»Ѕ ј');
  --подсчет кол-ва проживающих, без коммита
    --кол-во льготников
  update kart k set ki=(select /*+ RULE */ count(distinct t.id) as cnt
    from c_kart_pr t, c_lg_docs d, c_lg_pr p
    where t.id=d.c_kart_pr_id and d.id=p.c_lg_docs_id and p.spk_id <> 1
      and t.lsk=lsk_
      and t.status <> 4 ) --без учета выбывших
      where k.lsk=lsk_;
  --кол-во проживающих
  update kart k set kpr=(select count(*)
    from c_kart_pr p where p.status in (1,2,3,5) and p.lsk=lsk_ and p.status <> 4) --без учета выбывших
    where k.lsk=lsk_; --но с учетом проживающих дл€ Ќачислени€

  update kart k set kpr_ot=(select count(*)
    from c_kart_pr p where p.status in (2) and p.lsk=lsk_ and p.status <> 4) --без учета выбывших
    where k.lsk=lsk_;
  update kart k set kpr_wr=(select count(*)
    from c_kart_pr p where p.status in (3) and p.lsk=lsk_ and p.status <> 4) --без учета выбывших
    where k.lsk=lsk_;
  end;

  function count_krt_kpr (user_id_ in number)
   return number is
   cnt_ number;
  begin
--чЄ за бред? перегруженна€ функци€???
  --ѕроверка на возможность удал€ть USER_ID
   select sum(cnt) into cnt_ from (
    select count(*) as cnt from a_change a
      where a.user_id=user_id_
     union all
    select count(*) from c_change a
      where a.user_id=user_id_
     );
    return cnt_;
  end;

  function get_report_name (id_ in number)
   return varchar2 is
   result_ reports.name%TYPE;
  begin
  --¬ыдает наименование отчета
   select r.name into result_ from reports r where r.id=id_;
   return result_;
  end;

function get_sum_str_2(source in number) return varchar2 is
  result varchar2(300);
begin
  -- k - копейки
  if source < 1 then
    result := 'ноль ' ||
              ltrim(to_char(source,
                            '9,9,,9,,,,,,9,9,,9,,,,,9,9,,9,,,,9,9,,9,,,.99')) || 'k';
  else
    result := ltrim(to_char(source,
                            '9,9,,9,,,,,,9,9,,9,,,,,9,9,,9,,,,9,9,,9,,,.99')) || 'k';
  end if;

  -- t - тыс€чи; m - милионы; M - миллиарды;
  result := replace(result, ',,,,,,', 'eM');
  result := replace(result, ',,,,,', 'em');
  result := replace(result, ',,,,', 'et');
  -- e - единицы; d - дес€тки; c - сотни;
  result := replace(result, ',,,', 'e');
  result := replace(result, ',,', 'd');
  result := replace(result, ',', 'c');
  -- ”даление незначащих нулей
  result := replace(result, '0c0d0et', '');
  result := replace(result, '0c0d0em', '');
  result := replace(result, '0c0d0eM', '');

  -- ќбработка сотен
  result := replace(result, '0c', '');
  result := replace(result, '1c', 'сто ');
  result := replace(result, '2c', 'двести ');
  result := replace(result, '3c', 'триста ');
  result := replace(result, '4c', 'четыреста ');
  result := replace(result, '5c', 'п€тьсот ');
  result := replace(result, '6c', 'шестьсот ');
  result := replace(result, '7c', 'семьсот ');
  result := replace(result, '8c', 'восемьсот ');
  result := replace(result, '9c', 'дев€тьсот ');

  -- ќбработка дес€тков
  result := replace(result, '1d0e', 'дес€ть ');
  result := replace(result, '1d1e', 'одиннадцать ');
  result := replace(result, '1d2e', 'двенадцать ');
  result := replace(result, '1d3e', 'тринадцать ');
  result := replace(result, '1d4e', 'четырнадцать ');
  result := replace(result, '1d5e', 'п€тнадцать ');
  result := replace(result, '1d6e', 'шестнадцать ');
  result := replace(result, '1d7e', 'семнадцать ');
  result := replace(result, '1d8e', 'восемнадцать ');
  result := replace(result, '1d9e', 'дев€тнадцать ');
  result := replace(result, '0d', '');
  result := replace(result, '2d', 'двадцать ');
  result := replace(result, '3d', 'тридцать ');
  result := replace(result, '4d', 'сорок ');
  result := replace(result, '5d', 'п€тьдес€т ');
  result := replace(result, '6d', 'шестьдес€т ');
  result := replace(result, '7d', 'семьдес€т ');
  result := replace(result, '8d', 'восемьдес€т ');
  result := replace(result, '9d', 'дев€носто ');

  -- ќбработка единиц
  result := replace(result, '0e', '');
  result := replace(result, '5e', 'п€ть ');
  result := replace(result, '6e', 'шесть ');
  result := replace(result, '7e', 'семь ');
  result := replace(result, '8e', 'восемь ');
  result := replace(result, '9e', 'дев€ть ');
  --
  result := replace(result, '1e.', 'один рубль ');
  result := replace(result, '2e.', 'два рубл€ ');
  result := replace(result, '3e.', 'три рубл€ ');
  result := replace(result, '4e.', 'четыре рубл€ ');
  result := replace(result, '1et', 'одна тыс€ча ');
  result := replace(result, '2et', 'две тыс€чи ');
  result := replace(result, '3et', 'три тыс€чи ');
  result := replace(result, '4et', 'четыре тыс€чи ');
  result := replace(result, '1em', 'один миллион ');
  result := replace(result, '2em', 'два миллиона ');
  result := replace(result, '3em', 'три миллиона ');
  result := replace(result, '4em', 'четыре миллиона ');
  result := replace(result, '1eM', 'один миллиард ');
  result := replace(result, '2eM', 'два миллиарда ');
  result := replace(result, '3eM', 'три миллиарда ');
  result := replace(result, '4eM', 'четыре миллиарда ');

  -- ќбработка копеек
  result := replace(result, '11k', '11 копеек');
  result := replace(result, '12k', '12 копеек');
  result := replace(result, '13k', '13 копеек');
  result := replace(result, '14k', '14 копеек');
  result := replace(result, '1k', '1 копейка');
  result := replace(result, '2k', '2 копейки');
  result := replace(result, '3k', '3 копейки');
  result := replace(result, '4k', '4 копейки');

  -- ќбработка названий групп
  result := replace(result, '.', 'рублей ');
  result := replace(result, 't', 'тыс€ч ');
  result := replace(result, 'm', 'миллионов ');
  result := replace(result, 'M', 'миллиардов ');
  result := replace(result, 'k', ' копеек');
  --
  return(result);
end get_sum_str_2;





 function f_order(str_ varchar2, len_ number) return varchar2 is
 begin
   --‘ункци€ дл€ order by в запросах
   --возвращает только цифры из выражени€
   return lpad(substr(str_,
                      1,
                      length(str_) -
                      nvl(length(ltrim(str_, '0123456789')), 0)),
               len_,
               '0');
 end;

 function f_order2(str_ varchar2) return varchar2 is
 begin
   --‘ункци€ дл€ order by в запросах
   --возвращает только символы (не цифры из выражени€),
   --дл€ правильной сортировки
   --убирает пробелы
   return nvl(replace(ltrim(str_, '0123456789'),' ',''),'0');
 end;

 function f_ord2(str_ varchar2) return varchar2 is
 begin
   --‘ункци€ дл€ order by в запросах
   --возвращает только символы (не цифры из выражени€),
   --дл€ правильной сортировки
   return replace(translate(str_, '0123456789', ' '), ' ');
 end;

 function f_ord3(p_str varchar2) return varchar2 is
  l_symb varchar2(1000);
  l_str varchar2(1000);
  l_at number;
 begin
   --‘ункци€ дл€ order by в запросах
   --возвращает только символы (не цифры из выражени€ или знаки дроби /\-),
   --дл€ правильной сортировки
   --а так же, убирает пробелы, Ќќ не лишние символы (-,/,\,.) (нужны дл€ сортировки)

  l_str:=trim(p_str);
  l_symb:=substr(f_ord2(l_str),1,1);
  --пытаемс€ найти первый нецифровой символ в строке кода (например дома)
  l_at:=instr(l_str, substr(l_symb,1));
  if l_at > 0 then
    return trim(substr(l_str, l_at, length(l_str)));
  else
    return null;
  end if;
 end;

 function f_ord_digit(p_str varchar2) return number is
  l_symb varchar2(1000);
  l_str varchar2(1000);
  l_at number;
 begin
  --‘ункци€ дл€ order by в запросах
  --возвращает только цифры до знака отделени€ от корпуса дома, например 9а --> 9
  --или 9/1 --> 9
  --использовать две функции: order by f_ord_digit(nd), f_ord3(nd)
  l_str:=trim(p_str);
  l_symb:=substr(f_ord2(l_str),1,1);
  --пытаемс€ найти первый не цифровой символ в строке кода (например дома)
  l_at:=instr(l_str, substr(l_symb,1));
  if l_at > 0 then
    return trunc(substr(l_str, 1, l_at-1));
  else
    return trunc(l_str);
  end if;
 end;

 function add_months2(mg_ in varchar2, months_ in number) return varchar2 is
 begin
 --вернуть период на мес€ц вперЄд-назад
  return to_char(add_months(to_date(mg_||'01','YYYYMMDD'), months_),'YYYYMM');
 end;

procedure prep_users_tree is
 fk_ses_ number;
 maxid_ number;
 begin

 --удалить сессии 3 дневной давности
 delete from t_sess t where t.dat_create < sysdate-3;

 --нова€ сесси€
 --заменил fk_user_ на sessionid
 select USERENV('sessionid') into fk_ses_ from dual;
 insert into t_sess(dat_create, fk_ses)
  values (sysdate, fk_ses_);
 --подготовка домов дл€ выбора пользовател€ми
 delete from tree_objects t
 where exists
  (select * from t_sess s where
    s.fk_ses=t.fk_user and s.dat_create < (sysdate-3));
 delete from t_sess t
 where t.dat_create < (sysdate-3);

  --город
  insert into tree_objects (id, obj_level, fk_user, sel)
    values (0, 0, fk_ses_, 1);
  --∆Ёќ
  insert into tree_objects
    (main_id, id, obj_level, trest, fk_user, sel)
    select 0, rownum as rn, 1, trest, fk_ses_, 1
      from (select distinct trest from s_reu_trest t where t.trest is not null);

  select max(id) into maxid_ from tree_objects t where t.obj_level = 1
   and t.fk_user=fk_ses_;

  --–Ё”
  insert into tree_objects
    (main_id, id, obj_level, reu, fk_user, sel)
    select main_id, maxid_ + rownum as rn, 2, reu, fk_ses_, 1
      from (select distinct s.reu, t.id as main_id
              from s_reu_trest s, tree_objects t
             where s.trest = t.trest and t.fk_user=fk_ses_
               and t.obj_level = 1);
  select max(id) into maxid_ from tree_objects t where t.obj_level = 2;

  --ƒом
  --ред. 01.08.12 (странно почему до этого не было домов... очень странно)
  insert into tree_objects
    (main_id, id, obj_level, reu, kul, nd, fk_user, fk_house, sel, mg1, mg2, psch)
    select main_id, maxid_ + rownum as rn, 3, reu, kul, nd, fk_ses_, fk_house, 1,
      mg1, mg2, psch
      from (select k.reu, k.kul, s.name, k.nd, t.id as main_id,
       k.house_id as fk_house, min(k.mg1) as mg1, max(k.mg2) as mg2, c.psch
              from kart k, tree_objects t, spul s, c_houses c
             where k.reu = t.reu
               and k.kul = s.id and t.fk_user=fk_ses_
               and t.obj_level = 2
               and k.house_id=c.id
               group by k.reu, k.kul, s.name, k.nd, t.id,
               k.house_id, c.psch
               ) a
     order by a.reu, a.name, a.nd;
/*  insert into tree_objects
    (main_id, id, obj_level, reu, kul, nd, fk_user, sel)
    select main_id, maxid_ + rownum as rn, 3, reu, kul, nd, fk_ses_, 1
      from (select distinct k.reu, k.kul, s.name, k.nd, t.id as main_id
              from kart k, tree_objects t, spul s
             where k.reu = t.reu
               and k.kul = s.id and t.fk_user=fk_ses_
               and t.obj_level = 2) a
     order by a.reu, a.name, a.nd;*/

 commit;
 end;

procedure prep_users_par is
 fk_ses_ number;
begin
 --подготовка параметров сессии
 --заменил fk_user_ на sessionid
 select USERENV('sessionid') into fk_ses_ from dual;
 --подготовка домов дл€ выбора пользовател€ми
 --временные таблицы (temporary)
 delete from spr_par_ses t;
 delete from list_c t;

 insert into spr_par_ses
   (id, cd, parvc1, parn1, name, cdtp,
    pardt1, parent_id, npp, fk_ses)
   select
    t.id, cd, parvc1, parn1, name, cdtp,
    pardt1, parent_id, npp, fk_ses_
    from spr_params t where t.fk_parcdtp='FLT_REP';

--подготовка параметров сессии, типа списки
 for c in (select * from spr_params t where t.cdtp in (4,5) and t.sql_text is not null)
 loop
   fill_list_c(c.id);
 end loop;

 commit;
end;

function concatenate(v_rownum    number,
                     v_string    varchar2,
                     v_delimiter varchar2 default null,
                     v_call_id number default 1)
  return varchar2 is
  type string4000_array_type is table of varchar2(4000) index by binary_integer;
  g_concatenated_string_array string4000_array_type;
begin
  --функци€ дл€ превращени€ колонки в строку
  if v_rownum = 1 then
    g_concatenated_string_array(v_call_id) := v_string;
  else
    g_concatenated_string_array(v_call_id) := g_concatenated_string_array(v_call_id) ||
                                              v_delimiter || v_string;
  end if;
  return g_concatenated_string_array(v_call_id);
end;

function tst_krt(lsk_ in kart.lsk%type, var_ in number) return varchar2 is
cnt_ number;
last_id_ number;
org_var_ number;
prop_dt_ date;
begin
--проверка карточки л/c на наличие ошибок
select nvl(org_var,0) into org_var_ from params p;
if org_var_ = 0 then
   --находим последний статус, по дате
   begin
     select max(t.id) keep (dense_rank first order by nvl(t.dt1, to_date('01011900','DDMMYYYY')) desc) into last_id_
      from c_states_sch t where
       t.lsk=lsk_
      group by t.lsk;
   exception
     when no_data_found then
      if var_=1 then
        update kart k set k.fk_err=1 where k.lsk=lsk_;
      end if;
      return 'ќтсутствуют периоды статусов счетчиков!';
   end;

  --проверка на то, что дата последнего статуса счетчиков должена быть открытой
  select nvl(count(*),0) into cnt_ from c_states_sch c where
     c.id=last_id_ and c.dt2 is not null;
   if cnt_ > 0 then
      --найден "пустой" период в статусах (надо чтобы все дни текущего периода были заполнены)
      if var_=1 then
        update kart k set k.fk_err=1 where k.lsk=lsk_;
      end if;
      return 'ƒата последнего периода статуса счетика должна быть открытой!';
   end if;

  --проверка на диапазоны статусов счетчиков
  select nvl(count(*),0) into cnt_ from v_cur_days t,
    (select c.id, nvl(c.dt1, to_date('01011900','DDMMYYYY')) as dt1,
     nvl(c.dt2, to_date('01012900','DDMMYYYY')) as dt2 from c_states_sch c where
     c.lsk=lsk_)  s
     where t.dat between s.dt1(+) and s.dt2(+)
      and s.id is null;
   if cnt_ > 0 then
      --найден "пустой" период в статусах (надо чтобы все дни текущего периода были заполнены)
      if var_=1 then
        update kart k set k.fk_err=1 where k.lsk=lsk_;
      end if;
      return 'ѕериод действи€ статуса не перекрывает все дни текущего мес€ца в статусах счетчиков!';
   end if;

  --дл€ временной регистрации не провер€етс€

  select nvl(count(*),0) into cnt_ from (
   select k.id,
   max(t.dt2) keep (dense_rank first order by nvl(t.dt1, to_date('01011900','DDMMYYYY')) desc) as dat
   from c_kart_pr k, c_states_pr t, u_list u
   where k.lsk=lsk_
   and k.id=t.fk_kart_pr and t.fk_tp=u.id and u.cd='PROP'
   group by k.id) a
   where a.dat is not null;
   if cnt_ > 0 then
      --найден "пустой" период в статусах (надо чтобы все дни текущего периода были заполнены)
      if var_=1 then
        update kart k set k.fk_err=1 where k.lsk=lsk_;
      end if;
      return 'ƒата последнего периода статуса прописки проживающего должна быть открытой!';
   end if;

--ред 01.02.2012 -убрал проверки, так как сложно отследить наличие и правомерность
--"дырок" в периоде
/*for x in (select t.id, t.dat_prop from c_kart_pr t where t.lsk=lsk_)
loop

  select nvl(min(f.dt1), to_date('01011900','DDMMYYYY')) into prop_dt_
    from c_states_pr f, params p where f.fk_kart_pr=x.id
     and f.dt1 between to_date(p.period||'01','YYYYMMDD') and
       last_day(to_date(p.period||'01','YYYYMMDD'));
  select nvl(count(*),0) into cnt_ from (select r.lsk, t.*, r.id from v_cur_days t, c_kart_pr r
     where x.id=r.id
     and t.dat > prop_dt_
     ) t,
      (select c.fk_kart_pr, c.fk_tp, nvl(c.dt1, to_date('01011900','DDMMYYYY')) as dt1,
       nvl(c.dt2, to_date('01012900','DDMMYYYY')) as dt2 from c_kart_pr k, c_states_pr c,
       u_list u where
       k.id=c.fk_kart_pr and c.fk_tp=u.id and u.cd='PROP'
       and c.fk_kart_pr=x.id
       union all
       select c.fk_kart_pr, c.fk_tp, nvl(c.dt1, to_date('01011900','DDMMYYYY')) as dt1,
       nvl(c.dt2, to_date('01012900','DDMMYYYY')) as dt2 from c_kart_pr k, c_states_pr c,
       u_list u where
       k.id=c.fk_kart_pr and c.fk_tp=u.id and u.cd='PROP_REG'
       and c.fk_status = 3 --подмешать период статуса временно зарегистрированного
       and c.fk_kart_pr=x.id
       )  s
       where t.dat between s.dt1(+) and s.dt2(+)
       and s.fk_kart_pr is null;
   if cnt_ > 0 then
      --найден "пустой" период в статусах (надо чтобы все дни текущего периода были заполнены)
      if var_=1 then
        update kart k set k.fk_err=1 where k.lsk=lsk_;
      end if;
      return 'ѕериод действи€ статуса не перекрывает все дни текущего мес€ца в статусах прописки проживающих!';
   end if;
end loop;
*/

/*
--ѕогасил, иначе у всех пользователей вылезало дебильное сообщение.
  ќтсутствует статус прописки, до статуса выписки
  в тех л.с. где сперва человек выписан, потом прописан

  select nvl(count(*),0) into cnt_ from c_kart_pr k, c_states_pr c,
     u_list u where k.lsk=lsk_ and
     k.id=c.fk_kart_pr and c.fk_tp=u.id and u.cd='PROP'
     and c.fk_status=4
     and not exists
     (
      select * from c_kart_pr r, c_states_pr c2,
         u_list u where r.id=k.id and
         r.id=c2.fk_kart_pr and c2.fk_tp=u.id and u.cd='PROP'
         and c2.fk_status=1 and c2.dt2 < c.dt1
     );
   if cnt_ > 0 then
      --не найдена прописка, следующа€ до выписки
      if var_=1 then
        update kart k set k.fk_err=1 where k.lsk=lsk_;
      end if;
      return 'ќтсутствует статус прописки, до статуса выписки!';
   end if;
*/


  select nvl(count(*),0) into cnt_ from kart k, c_states_sch c
  where k.lsk=lsk_
  and k.lsk=c.lsk
  and exists
  (select * from c_states_sch t where t.lsk=k.lsk
  and t.id <> c.id and
  (nvl(t.dt1, to_date('01011900','DDMMYYYY'))
      between nvl(c.dt1, to_date('01011900','DDMMYYYY'))
      and nvl(c.dt2, to_date('01012900','DDMMYYYY'))
    or nvl(t.dt2, to_date('01012900','DDMMYYYY'))
      between nvl(c.dt1, to_date('01011900','DDMMYYYY'))
      and nvl(c.dt2, to_date('01012900','DDMMYYYY'))
  ));
   if cnt_ > 0 then
      if var_=1 then
        update kart k set k.fk_err=1 where k.lsk=lsk_;
      end if;
      return 'ѕериод действи€ статуса счетчиков пересекаетс€ с другим периодом!';
   end if;

/*
--уже не ругаемс€, в квартире может быть не один квартиросъЄмщик, ред 07.02.2012
   select count(*) into cnt_
                from c_kart_pr p, relations s
               where p.lsk = lsk_
                 and p.relat_id = s.id
                 and s.fk_relat_tp = 1
                 and exists
                 (select * from c_states_pr c, params m where  --найти квартиросъемщика, прописанного
                  last_day(to_date(m.period||'01','YYYYMMDD')) --на последнюю дату мес€ца
                  between nvl(c.dt1(+), to_date('01011900','DDMMYYYY')) and
                          nvl(c.dt2(+), to_date('01012900','DDMMYYYY'))
                         and c.fk_kart_pr=p.id
                         and c.fk_status=1);
   if cnt_ > 1 then
      if var_=1 then
        update kart k set k.fk_err=1 where k.lsk=lsk_;
      end if;
      return 'ѕериод прописки  вартиросъемщика пересекаетс€ с периодом прописки другого  вартиросъемщика!';
   end if;
*/

  select nvl(count(*),0) into cnt_ from c_kart_pr k, c_states_pr c
    where k.lsk=lsk_
    and k.id=c.fk_kart_pr
    and exists
    (select * from c_states_pr t where t.fk_kart_pr=k.id and t.fk_tp=c.fk_tp
    and t.id <> c.id and
    (nvl(t.dt1, to_date('01011900','DDMMYYYY'))
        between nvl(c.dt1, to_date('01011900','DDMMYYYY'))
        and nvl(c.dt2, to_date('01012900','DDMMYYYY'))
      or nvl(t.dt2, to_date('01012900','DDMMYYYY'))
        between nvl(c.dt1, to_date('01011900','DDMMYYYY'))
        and nvl(c.dt2, to_date('01012900','DDMMYYYY'))
    ));
   if cnt_ > 0 then
      if var_=1 then
        update kart k set k.fk_err=1 where k.lsk=lsk_;
      end if;
      return 'ѕериод действи€ статуса проживающего пересекаетс€ с другим периодом!';
   end if;
end if;
   --ошибок нет
   if var_=1 then
     update kart k set k.fk_err=0 where k.lsk=lsk_;
   end if;
   return null;
end;

procedure set_kpr(lsk_ in kart.lsk%type) is
   cursor cur_params is
     select * from params;
   rec_params cur_params%rowtype;
   dat_       date;
 begin
   --кол-во проживающих
   --”становка кол-ва прожив в л.с. по c_kart_pr
   --дл€ тех услуг, которые не используют кол-во прожив из c_charge_prep
   open cur_params;
   fetch cur_params
     into rec_params;
   close cur_params;
   dat_ := to_date(rec_params.period || '15', 'YYYYMMDD');
   if lsk_ is not null then
     --ред 24.06.11 льготники отключены
     if nvl(rec_params.is_fullmonth, 0) = 0 then
       update kart k
          set kpr =
               (select nvl(count(*),0)
                  from c_kart_pr t
                 where t.lsk = lsk_
                   and not ((t.status = 4 and --если выписан до 15 то не считать
                        nvl(t.dat_ub, to_date('19000101', 'YYYYMMDD')) <= --если нет даты выписки, то как будто бы выписан давно (в 1900 году)))
                        dat_) or
                        t.status in (1, 5) and --если прописан после 15 то не считать
                        nvl(t.dat_prop, to_date('19000101', 'YYYYMMDD')) >= --если нет даты прописки, то как будто бы прописан давно (в 1900 году)))
                        dat_)
                   and t.status not in (6)), --не берЄм 6 код (временно прожив) ред.24.05.12
               --без учета выбывших
              kpr_ot =
               (select count(*)
                  from c_kart_pr t
                 where t.status in (2)
                   and t.lsk = lsk_),
              kpr_wr =
               (select count(*) --ред 24.12.12 --разделил временно зарег. и временно пропис.
                  from c_kart_pr t
                 where t.status in (3)
                   and t.lsk = lsk_),
              kpr_wrp =
               (select count(*)
                  from c_kart_pr t
                 where t.status in (6)
                   and t.lsk = lsk_)
        where k.lsk = lsk_;
     else
       update kart k
          set kpr =
               (select count(*)
                  from c_kart_pr t
                 where t.lsk = lsk_
                   and t.status not in (4,6)),
               --без учета выбывших
              kpr_ot =
               (select count(*)
                  from c_kart_pr t
                 where t.status in (2)
                   and t.lsk = lsk_),
              kpr_wr =
               (select count(*) --ред 24.12.12 --разделил временно зарег. и временно пропис.
                  from c_kart_pr t
                 where t.status in (3)
                   and t.lsk = lsk_),
              kpr_wrp =
               (select count(*)
                  from c_kart_pr t
                 where t.status in (6)
                   and t.lsk = lsk_)
        where k.lsk = lsk_;
     end if;
   else
     --ред 24.06.11 льготники отключены
     --кол-во проживающих
     if nvl(rec_params.is_fullmonth, 0) = 0 then
       update kart k
          set kpr =
               (select count(*)
                  from c_kart_pr t
                 where t.lsk = k.lsk
                   and not ((t.status = 4 and --если выписан до 15 то не считать
                        nvl(t.dat_ub, to_date('19000101', 'YYYYMMDD')) <= --если нет даты выписки, то как будто бы выписан давно (в 1900 году)))
                        dat_) or
                        t.status in (1, 5) and --если прописан после 15 то не считать
                        nvl(t.dat_prop, to_date('19000101', 'YYYYMMDD')) >= --если нет даты прописки, то как будто бы прописан давно (в 1900 году)))
                        dat_)
                   and t.status not in (6)),
               --без учета выбывших
              kpr_ot =
               (select count(*)
                  from c_kart_pr t
                 where t.status in (2)
                   and t.lsk = k.lsk),
              kpr_wr =
               (select count(*) --ред 24.12.12 --разделил временно зарег. и временно пропис.
                  from c_kart_pr t
                 where t.status in (3)
                   and t.lsk = k.lsk),
              kpr_wrp =
               (select count(*)
                  from c_kart_pr t
                 where t.status in (6)
                   and t.lsk = k.lsk);
     else
       update kart k
          set kpr =
               (select count(*)
                  from c_kart_pr t
                 where t.lsk = k.lsk
                   and t.status not in (4,6)),
               --без учета выбывших
              kpr_ot =
               (select count(*)
                  from c_kart_pr t
                 where t.status in (2)
                   and t.lsk = k.lsk),
              kpr_wr =
               (select count(*) --ред 24.12.12 --разделил временно зарег. и временно пропис.
                  from c_kart_pr t
                 where t.status in (3)
                   and t.lsk = k.lsk),
              kpr_wrp =
               (select count(*)
                  from c_kart_pr t
                 where t.status in (6)
                   and t.lsk = k.lsk);
     end if;
   end if;

 end;


procedure set_krt_adm (lsk_ in c_kart_pr.lsk%type) is
  fk_kart_pr_ c_states_pr.fk_kart_pr%type;
begin
 --установить квартиросъемщика в лицевой счет
/*     for c in (select max(p.id) as id, max(p.fio) as fio, count(*) as cnt
                from c_kart_pr p, relations s
               where p.relat_id = s.id
                 and s.fk_relat_tp = 1
                 and p.lsk=lsk_
                 and exists
                 (select * from c_states_pr c, u_list u, params m where  --найти квартиросъемщика, прописанного
                  last_day(to_date(m.period||'01','YYYYMMDD')) --на последнюю дату мес€ца
                  between nvl(c.dt1(+), to_date('01011900','DDMMYYYY')) and
                          nvl(c.dt2(+), to_date('01012900','DDMMYYYY'))
                         and c.fk_kart_pr=p.id
                         and c.fk_status=1
                         and u.cd='PROP'
                         and c.fk_status=u.id
                         )
                 ) loop*/
fk_kart_pr_:=null;
     for c in (select c.fk_kart_pr from c_states_pr c, u_list u, params m where  --найти квартиросъемщика, прописанного
                  last_day(to_date(m.period||'01','YYYYMMDD')) --на последнюю дату мес€ца
                  between nvl(c.dt1(+), to_date('01011900','DDMMYYYY')) and
                          nvl(c.dt2(+), to_date('01012900','DDMMYYYY'))
                         and c.fk_status = 1 --нельз€ делать статус 5 (так как устанавливаетс€ квартиросъемщик, всЄ серъЄзно)))
                         and u.cd='PROP'
                         and c.fk_tp=u.id
                   and exists
                   (select *
                      from c_kart_pr p, relations s
                     where p.relat_id = s.id
                       and s.fk_relat_tp = 1
                       and p.lsk=lsk_
                       and p.id=c.fk_kart_pr)
                   order by nvl(c.dt1(+), to_date('01011900','DDMMYYYY')) desc --найти последнего прописавшегос€ квартиросъемщ.
                 )
  loop
  fk_kart_pr_:=c.fk_kart_pr;
  --добавили нового квартиросъемщика
  update kart k
     set k.fio = (select p.fio
                     from c_kart_pr p
                    where p.id=c.fk_kart_pr),
         k.k_fam = (select p.k_fam
                     from c_kart_pr p
                    where p.id=c.fk_kart_pr),
         k.k_im = (select p.k_im
                     from c_kart_pr p
                    where p.id=c.fk_kart_pr),
         k.k_ot = (select p.k_ot
                     from c_kart_pr p
                    where p.id=c.fk_kart_pr)
   where k.lsk = lsk_;
   exit;
   end loop;

--уже не ругаемс€, в квартире может быть не один квартиросъЄмщик, ред 07.02.2012
--if fk_kart_pr_ is null then
--если не один в л.с. квартиросъемщик, то ругаемс€
--raise_application_error(-20000,
--                          '¬ л/с может быть только один квартиросъЄмщик!');
 --удал€ть нельз€!!!!! так как может быть квартиросъемщик, не прописанный!!!
-- удалили основного квартиросъемщика
/* if fk_kart_pr_ is null then
    update kart k
       set k.k_fam = null,
           k.k_im = null,
           k.k_ot = null
     where k.lsk = lsk_;
  end if;*/
end;

procedure set_krt_adm2 (fk_kart_pr_ in c_kart_pr.id%type) is
 lsk_ c_kart_pr.lsk%type;
 begin
 --перегруженна€ процедура
  select lsk into lsk_ from c_kart_pr c where c.id=fk_kart_pr_;
  set_krt_adm(lsk_);

end;

procedure upd_c_kart_pr_state(fk_kart_pr_ in c_kart_pr.id%type) is
i number;
time_ date;
ccc number;
  begin
  time_:=sysdate;
  --обновить признак статуса в карточке проживающего
    if fk_kart_pr_ is not null then
  --ред 10.11.2011
    --по данному проживающему (из триггера)
    update c_kart_pr k
       set k.dat_prop =
           (select max(a.dt1)
              from c_states_pr a, u_list u
             where u.id = a.fk_tp
               and u.cd = 'PROP'
               and a.fk_kart_pr = fk_kart_pr_
               and a.fk_status in (1, 5)),
           k.dat_ub  =
           (select max(a.dt1)
              from c_states_pr a, u_list u
             where u.id = a.fk_tp
               and u.cd = 'PROP'
               and a.fk_kart_pr = fk_kart_pr_
               and a.fk_status = 4 --если будет найдена дата убыти€ >= даты прописки
             having max(a.dt1) >= (select max(nvl(a.dt1, to_date('01011900', 'DDMMYYYY')))
                                    from c_states_pr a, u_list u
                                   where u.id = a.fk_tp
                                     and u.cd = 'PROP'
                                     and a.fk_kart_pr = fk_kart_pr_
                                     and a.fk_status in (1, 5))),
           k.status  =
           (select max(case
                         when t.fk_status is null and t2.fk_status is null then
                          4
                         when t.fk_status in (1, 5) and t2.fk_status = 2 --посто€нно зарег. и временно отсут.
                          then
                          2
                         when t.fk_status = 4 and t2.fk_status in (3) --выбыл. и временно зареган.))
                          then
                          3
                         when t.fk_status is null and t2.fk_status in (3) --временно зарег. и необ€з статус прописки
                          then
                          3
                         when t.fk_status = 4 and t2.fk_status in (6) --выбыл. и временно прожив.))
                          then
                          6
                         when t.fk_status is null and t2.fk_status in (6) --временно прожив. и необ€з статус прописки
                          then
                          6
                         when t.fk_status is null and t2.fk_status = 2 --временно отсут. и нет об€зат. статуса прописки
                          then
                          2
                         when t.fk_status is null and t2.fk_status is null then
                          4
                         else
                          t.fk_status
                       end) as status --если совсем ошибочно периоды статусов установлены, прин€ть как временно остутств.
              from c_kart_pr c,
                   (select a.fk_kart_pr,
                           a.fk_status,
                           nvl(a.dt1, to_date('01011900', 'DDMMYYYY')) as dt1,
                           nvl(a.dt2, to_date('01012900', 'DDMMYYYY')) as dt2
                      from c_states_pr a, u_list u, params p
                     where u.id = a.fk_tp
                       and last_day(to_date(p.period || '01', 'YYYYMMDD')) between
                           nvl(a.dt1, to_date('01011900', 'DDMMYYYY')) and nvl(a.dt2, to_date('01012900', 'DDMMYYYY'))
                       and u.cd = 'PROP'
                       and a.fk_kart_pr = fk_kart_pr_) t,
                   (select a.fk_kart_pr,
                           a.fk_status,
                           nvl(a.dt1, to_date('01011900', 'DDMMYYYY')) as dt1,
                           nvl(a.dt2, to_date('01012900', 'DDMMYYYY')) as dt2
                      from c_states_pr a, u_list u, params p
                     where u.id = a.fk_tp
                       and last_day(to_date(p.period || '01', 'YYYYMMDD')) between
                           nvl(a.dt1, to_date('01011900', 'DDMMYYYY')) and nvl(a.dt2, to_date('01012900', 'DDMMYYYY'))
                       and u.cd = 'PROP_REG'
                       and a.fk_kart_pr = fk_kart_pr_) t2
             where c.id = fk_kart_pr_
               and c.id = t.fk_kart_pr(+)
               and c.id = t2.fk_kart_pr(+))
     where k.id = fk_kart_pr_;
--ред 21.10.2011
/*    update c_kart_pr k set k.dat_prop =
     (select max(a.dt1) from c_states_pr a, u_list u
              where u.id=a.fk_tp
              and u.cd='PROP'
              and a.fk_kart_pr=fk_kart_pr_
              and a.fk_status in (1,5)),
     k.dat_ub =(select max(a.dt1) from c_states_pr a, u_list u
              where u.id=a.fk_tp
              and u.cd='PROP'
              and a.fk_kart_pr=fk_kart_pr_
              and a.fk_status=4  --если будет найдена дата убыти€ >= даты прописки
              having max(a.dt1) >=
                (select max(nvl(a.dt1, to_date('01011900','DDMMYYYY'))) from c_states_pr a, u_list u
              where u.id=a.fk_tp
              and u.cd='PROP'
              and a.fk_kart_pr=fk_kart_pr_
              and a.fk_status in (1,5))
              )
     where k.id=fk_kart_pr_;*/
   else
   --ќ„≈Ќ№ ћ≈ƒЋ≈ЌЌќ ¬џѕќЋЌя≈“—я...Ќ≈ —ћќ√ Ќ»„≈√ќ Ћ”„Ў≈ ѕ–»ƒ”ћј“№...
   --по всем проживающим (после перехода)
   i:=0;
   for c in (select distinct t.fk_kart_pr
        from c_states_pr t, u_list u where t.fk_tp=u.id
          and (t.dt1 is not null or t.dt2 is not null)
          )
   loop
     --рекурсией вызываем себ€ же...
     upd_c_kart_pr_state(c.fk_kart_pr);
 --commit каждые 100 записей- иначе out of memory error (oracle падает)
     i:=i+1;
     if i >= 99 then
       i:=0;
--       logger.log_(null, c.fk_kart_pr);
       commit;
     end if;
   end loop;
   commit;
   logger.log_(time_, 'upd_c_kart_pr_state');
   end if;
  end;

procedure killme_upd_nabor_kf_kpr(lsk_ in kart.lsk%type) is
time_ date;
state_base_ number;
begin

--”старело! »спользовать c_kart.set_part_kpr

--обновить коэфф.проживающих в л.с., дл€ долевого расчета
--начислени€ по пока  ќћћ”ЌјЋ№Ќќ… услуге (х.в.,г.в. Ќќ не тек.сод.)
--(при требовании можно дописать данную процедуру под услуги отопл. и тек.сод.)
time_:=sysdate;
--если база открыта или есть админский доступ
if admin.get_state_base = 0 or init.g_admin_acc <> 0  then
  if lsk_ is not null then
    update nabor k set k.kf_kpr=
      (select round(sum(proc),3) as proc from (
        select usl, fk_calc_tp, sum(chrg)/count(*) as proc, id from (
          select t.usl, t.fk_calc_tp, t.id, t.dat, r.fk_status as st_prop, r2.fk_status as st_reg, r3.fk_status as st_sch,
          case when r3.fk_status in (0, decode(t.fk_calc_tp, 3, 3, 17, 3, 4, 2, 18, 2))
            and ((nvl(r.fk_status,0) in (0,4)
            and nvl(r2.fk_status,0) in (3,6))
            or (nvl(r.fk_status,0) in (1,5)
            and nvl(r2.fk_status,0) = 0)) then 1
            else 0 end as chrg
           from (select c.lsk, c.id, a.dat, u.usl, u.fk_calc_tp from
          (select to_date(p.period||case when length(to_char(rownum))=1
                 then '0'||to_char(rownum)
                 else to_char(rownum) end ,'YYYYMMDD') as dat
               from (select level from dual connect by level < 32), params p
          where rownum<=to_char(last_day(to_date(p.period||'01','YYYYMMDD')),'DD')) a, c_kart_pr c, usl u
          where c.lsk=lsk_ and u.fk_calc_tp in (3, 17, 4, 18, 5, 19)) t,
          (select a.fk_status, a.fk_kart_pr, a.dt1, a.dt2 from c_states_pr a, u_list u where a.fk_tp=u.id and
                  exists (select * from c_kart_pr c where c.lsk=lsk_ and c.id=a.fk_kart_pr)
           and u.cd='PROP') r,
          (select a.fk_status, a.fk_kart_pr, a.dt1, a.dt2 from c_states_pr a, u_list u where a.fk_tp=u.id and
                  exists (select * from c_kart_pr c where c.lsk=lsk_ and c.id=a.fk_kart_pr)
           and u.cd='PROP_REG') r2,
           (select a.* from c_states_sch a where a.lsk=lsk_) r3
          where t.fk_calc_tp in (3, 17, 4, 18, 5, 19) and --список услуг по которым возможен долевой расчет
          t.lsk=lsk_ and t.id =r.fk_kart_pr(+) and t.dat between nvl(r.dt1(+), to_date('01011900','DDMMYYYY')) and
          nvl(r.dt2(+), to_date('01012900','DDMMYYYY')) and --если не проставлена дата статуса, то вз€то либо по дате 01.01.1900 (дл€ dt1) или по 01.01.2900 (дл€ dt2)
          t.id =r2.fk_kart_pr(+) and t.dat between nvl(r2.dt1(+), to_date('01011900','DDMMYYYY')) and
          nvl(r2.dt2(+), to_date('01012900','DDMMYYYY')) and
          t.dat between nvl(r3.dt1(+), to_date('01011900','DDMMYYYY')) and
          nvl(r3.dt2(+), to_date('01012900','DDMMYYYY'))
          /*order by t.id, t.dat*/
          ) group by usl, fk_calc_tp, id
          ) a where a.usl=k.usl
           group by a.usl, a.fk_calc_tp),
           k.nrm_kpr=(select count(distinct id) from (
        select usl, fk_calc_tp, id from (
          select t.usl, t.fk_calc_tp, t.id, t.dat, r.fk_status as st_prop, r2.fk_status as st_reg,
          case when ((nvl(r.fk_status,0) in (0,4)
            and nvl(r2.fk_status,0) in (3,6)) --или выбыл или нет статуса пост. прописки и временно зарег.
            or (nvl(r.fk_status,0) in (1,5)   --или посто€нно пропис. и нет прочих статусов
            and nvl(r2.fk_status,0) = 0)) then 1
            else 0 end as chrg
           from (select c.lsk, c.id, a.dat, u.usl, u.fk_calc_tp from
          (select to_date(p.period||case when length(to_char(lvl))=1
                 then '0'||to_char(rownum)
                 else to_char(lvl) end ,'YYYYMMDD') as dat
               from (select level as lvl from dual connect by level < 32), params p
          where lvl <= 15 /* ред.27.04.12 and lvl<=to_char(last_day(to_date(p.period||'01','YYYYMMDD')),'DD')*/) a, c_kart_pr c, usl u
          where c.lsk=lsk_ and u.fk_calc_tp in (1, 3, 17, 4, 18, 5, 19)) t,
          (select a.fk_status, a.fk_kart_pr, a.dt1, a.dt2 from c_states_pr a, u_list u where a.fk_tp=u.id and
                  exists (select * from c_kart_pr c where c.lsk=lsk_ and c.id=a.fk_kart_pr)
           and u.cd='PROP') r,
          (select a.fk_status, a.fk_kart_pr, a.dt1, a.dt2 from c_states_pr a, u_list u where a.fk_tp=u.id and
                  exists (select * from c_kart_pr c where c.lsk=lsk_ and c.id=a.fk_kart_pr)
           and u.cd='PROP_REG') r2
          where t.fk_calc_tp in (1, 3, 17, 4, 18, 5, 19) and --список услуг по которым возможен долевой расчет
          t.lsk=lsk_ and t.id =r.fk_kart_pr(+) and t.dat between nvl(r.dt1(+), to_date('01011900','DDMMYYYY')) and
          nvl(r.dt2(+), to_date('01012900','DDMMYYYY')) and --если не проставлена дата статуса, то вз€то либо по дате 01.01.1900 (дл€ dt1) или по 01.01.2900 (дл€ dt2)
          t.id =r2.fk_kart_pr(+) and t.dat between nvl(r2.dt1(+), to_date('01011900','DDMMYYYY')) and
          nvl(r2.dt2(+), to_date('01012900','DDMMYYYY'))
          /*order by t.id, t.dat*/
          ) where chrg <> 0
          group by usl, fk_calc_tp, id
          ) a where a.usl=k.usl
           group by a.usl, a.fk_calc_tp)

         where k.lsk=lsk_;

    --электроэнерги€ (fk_calc_tp= 31)
    update nabor k set k.kf_kpr=(select t.kpr from kart t where t.lsk=k.lsk)
         where k.lsk=lsk_
          and exists (select * from usl u where u.usl=k.usl and
            u.fk_calc_tp=31)
          and exists (select * from kart t where t.lsk=k.lsk and
            t.psch not in (8,9) and nvl(t.sch_el,0)<>1);
  else
     --ѕќ ¬—≈ћ,- ќ„≈Ќ№ ћ≈ƒЋ≈ЌЌќ Ѕ”ƒ≈“ ¬џѕќЋЌя“№—я...Ќ≈ —ћќ√ Ќ»„≈√ќ Ћ”„Ў≈ ѕ–»ƒ”ћј“№...
     --по тем проживающим, где сущ даты в статусах, соответствующие новому периоду
     --(после перехода)
     for c in (select distinct lsk from (
       select t.lsk
          from kart t where exists
          (select * from c_kart_pr r, c_states_pr p, params m
            where r.lsk = t.lsk and r.id=p.fk_kart_pr
            and (p.dt1 between to_date(m.period||'01','YYYYMMDD')
            and last_day(to_date(m.period||'01','YYYYMMDD')) or
            p.dt2 between to_date(m.period||'01','YYYYMMDD')
            and last_day(to_date(m.period||'01','YYYYMMDD')))
            )
            union all
            select t.lsk
          from kart t where exists
          (select * from c_states_sch p, params m
            where p.lsk = t.lsk
            and (p.dt1 between to_date(m.period||'01','YYYYMMDD')
            and last_day(to_date(m.period||'01','YYYYMMDD')) or
            p.dt2 between to_date(m.period||'01','YYYYMMDD')
            and last_day(to_date(m.period||'01','YYYYMMDD')))
            ))
            )
     loop
       --рекурсией вызываем себ€ же...
       killme_upd_nabor_kf_kpr(c.lsk);
     end loop;

     logger.log_(time_, 'utils.upd_nabor_kf_kpr ');
  end if;
end if;
end;

procedure killme_upd_nabor_kf_kpr2(id_ in c_kart_pr.id%type) is

begin
--”старело! »спользовать c_kart.set_part_kpr_all

--перегруженна€ процедура
--пересчитать все л.с. по которым было движение
--и не только по ним, так как могут быть временно отсут, зарег, до определенного срока
for c in (select distinct lsk from c_kart_pr t where t.id = id_)
loop
  killme_upd_nabor_kf_kpr(c.lsk);
end loop;
end;

function add_list(cdtp_ in u_listtp.cd%type, cd_ in u_list.cd%type,
   name_ in u_list.name%type) return number is
sel_id_ number;
tp_ number;
begin
--добавление новых реквизитов в справочник
 select t.id into tp_ from
  u_listtp t where t.cd=cdtp_;

insert into u_list
  (cd, name, fk_listtp, npp)
  values
  (cd_, name_, tp_, null)
  returning id into sel_id_;
 return sel_id_;
 --без коммита
end;

procedure add_usl(uslm_ in usl.uslm%type, prefix_ in varchar2,
 name_ in varchar2, name2_ in usl.nm2%type, cd_ in usl.cd%type,
 price_ in prices.summa%type, org_ in nabor.org%type,
 koeff_ in nabor.koeff%type, norm_ in nabor.norm%type,
 usl_koeff_ in usl.usl%type, usl_norm_ in usl.usl%type,
 usl_org_ in usl.usl%type
 ) is
 uslm2_ usl.uslm%type;
  type usl_rec is record
  (
    usl_ usl.usl%type,
    usl_order usl.usl_order%type,
    npp usl.npp%type
  );
  usl_rec_ usl_rec;
  cnt_ number;
  nm1_ usl.nm1%type;
begin
--—оздание новой главной услуги
if uslm_ is null then
  select lpad(to_char(max(uslm)+1),3,'0') as uslm into uslm2_
     from uslm u;
  insert into uslm
    (uslm, nm1)
    values
    (uslm2_, name_);
  nm1_:=name_;
else
  uslm2_:=uslm_;
  select u.nm1 as nm1 into nm1_
     from uslm u where u.uslm=uslm_;
end if;

--—оздание новой дочерней услуги
select lpad(to_char(max(usl)+1),3,'0'), nvl(max(u.usl_order),0)+1,
 nvl(max(u.npp),0)+1 into usl_rec_
 from usl u;

select nvl(count(*),0) into cnt_ from nabor n where n.usl=usl_rec_.usl_;

if cnt_ <> 0 then
   Raise_application_error(-20000, 'ƒанна€ услуга, usl='||usl_rec_.usl_||', уже существует в справочниках, добавление невозможно!');
end if;

insert into usl
  (uslm, usl, kartw, kwni, lpw, ed_izm, nm, nm1,
   usl_p, sptarn, usl_type,
   usl_plr, usl_norm, typ_usl,
   usl_order,
   usl_type2, usl_subs, nm2,
   cd, npp, fk_calc_tp, uslg,
   counter, have_vvod, n_progs,
   fk_usl_pen, can_vv, is_iter)
select
  uslm2_, usl_rec_.usl_,
   'N'||prefix_||'_' as kartw,
   'I'||prefix_ as kwni,
   'L'||prefix_ as lpw,
   'точ.',
   name_ as nm,
   nm1_ as nm1,
   usl_rec_.usl_ as usl_p,
   0 as sptarn,
   0 as usl_type,
   0 as usl_plr,
   0 as usl_norm,
   0 as typ_usl,
   usl_rec_.usl_order as usl_order,
   0 as usl_type2,
   0 as usl_subs,
   name2_ as nm2,
   cd_ as cd,
   usl_rec_.npp,
   null as fk_calc_tp_,
   null as uslg_,
   null as counter,
   null as have_vvod,
   null as n_progs,
   usl_rec_.usl_ as fk_usl_pen,
   0 as can_vv,
   0 as is_iter
   from dual;


insert into prices
  (usl, summa, summa2)
values
  (usl_rec_.usl_, price_, null);

insert into c_spk_usl
  (spk_id, usl_id, koef, dop_pl, prioritet, charge_part, limit_part)
select distinct
  spk_id, usl_rec_.usl_, 0 as koef, null as dop_pl, null as prioritet,
   null as charge_part, null as limit_part from c_spk_usl c;

insert into usl_bills
  (id, usl_id, mg1, mg2, is_vol)
values
  (usl_rec_.usl_, usl_rec_.usl_, '000000', '999999', 1);

commit;

--добавить пол€ в таблицы
execute immediate 'alter table EXPKARTW add N'||prefix_||'_ number(8,2)';
execute immediate 'alter table EXPKWNI add I'||prefix_||' number(8,2)';
execute immediate 'alter table EXPPRIVS add L'||prefix_||' number(8,2)';

end;

--добавить несуществующие пол€ в таблицы выгрузок
procedure usl_add_flds is
l_cnt number;
begin

dbms_output.enable;

select nvl(count(*),0) into l_cnt
from (
select count(*) from usl t
  group by t.kartw
  having count(*)>1);
if l_cnt > 0 then
  dbms_output.put_line('Ќайдены дубликаты пол€ usl.kartw!');
  Raise_application_error(-20000, 'Ќайдены дубликаты пол€ usl.kartw!');
end if;

select nvl(count(*),0) into l_cnt
from (
select count(*) from usl t
  group by t.kwni
  having count(*)>1);
if l_cnt > 0 then
  dbms_output.put_line('Ќайдены дубликаты пол€ usl.kwni!');
  Raise_application_error(-20000, 'Ќайдены дубликаты пол€ usl.kwni!');
end if;

select nvl(count(*),0) into l_cnt
from (
select count(*) from usl t
  group by t.lpw
  having count(*)>1);
if l_cnt > 0 then
  dbms_output.put_line('Ќайдены дубликаты пол€ usl.lpw!');
  Raise_application_error(-20000, 'Ќайдены дубликаты пол€ usl.lpw!');
end if;

for c in (select trim(t.kartw) as kartw, trim(t.kwni) as kwni, trim(t.lpw) as lpw from usl t) 
loop
begin
  execute immediate 'alter table EXPKARTW add '||c.kartw||' number(8,2)';
exception
  when others then
  dbms_output.put_line('¬озможно уже есть поле:'||c.kartw||' в таблицу expkartw:');
  dbms_output.put_line('ERRcode - '||SQLCODE||' -ERRmsg- '||SQLERRM);
end;

begin
  execute immediate 'alter table EXPKWNI add '||c.kwni||' number(8,2)';
exception
  when others then
  dbms_output.put_line('¬озможно уже есть поле:'||c.kwni||' в таблицу expkartw:');
  dbms_output.put_line('ERRcode - '||SQLCODE||' -ERRmsg- '||SQLERRM);
end;

begin
  execute immediate 'alter table EXPPRIVS add '||c.lpw||' number(8,2)';
exception
  when others then
  dbms_output.put_line('¬озможно уже есть поле:'||c.lpw||' в таблицу expkartw:');
  dbms_output.put_line('ERRcode - '||SQLCODE||' -ERRmsg- '||SQLERRM);
end;

dbms_output.disable;

end loop;  

end;
  
function del_lsk(lsk_ in kart.lsk%type) return varchar2 is
  l_mg params.period%type;
  l_cnt number;
begin
  --удаление лицевого счета
  select p.period into l_mg from params p;

  select nvl(count(*),0) into l_cnt
    from saldo_usl t where t.lsk=lsk_ and t.mg <= l_mg;
  if l_cnt > 0 then
    return 'Ћицевой счет имеет историю в сальдо, удаление не допустимо!';
  end if;

  select nvl(count(*),0) into l_cnt
    from c_chargepay t where t.lsk=lsk_ and t.period < l_mg;
  if l_cnt > 0 then
    return 'Ћицевой счет имеет историю в оборотах, удаление не допустимо!';
  end if;

  begin
  delete from nabor t where t.lsk=lsk_;
  delete from c_states_sch t where t.lsk=lsk_;
  delete from c_kart_pr t where t.lsk=lsk_;
  delete from saldo_usl t where t.lsk=lsk_;
  delete from c_chargepay t where t.lsk=lsk_ and t.period=l_mg;
  delete from kart t where t.lsk=lsk_;

  exception when others then
    return 'Ћицевой счет используетс€, удаление не допустимо!';
  end;
  commit;
  return null;
end;

procedure del_usl(usl_ in usl.usl%type) is
begin
  --удаление услуги
  delete from nabor t where t.usl=usl_;
  delete from usl_bills t where t.usl_id=usl_;
  delete from c_spk_usl t where t.usl_id=usl_;
  delete from spr_tarif t where t.usl=usl_;
  delete from prices t where t.usl=usl_;
  delete from usl t where t.usl=usl_;
  commit;
end;

procedure del_uslm(uslm_ in usl.uslm%type) is
begin
  --удаление главной услуги
  delete from uslm t where t.uslm=uslm_;
  commit;
end;

procedure cp_price(err_ out number, err_str_ out varchar2,
 usl_ in prices.usl%type, fk_org_src_ in prices.fk_org%type,
 fk_org_dst_ in prices.fk_org%type) is
 cnt_ number;
begin
 err_:=0;
--копирование расценок из орг. в орг.
  select nvl(count(*),0) into cnt_
    from prices t where t.fk_org=fk_org_dst_ and t.usl=usl_;
  if cnt_ = 0 then
    delete from prices t where t.fk_org=fk_org_dst_ and t.usl=usl_;
    insert into prices
       (usl, summa, summa2, fk_org, summa3)
    select usl_, summa, summa2, fk_org_dst_ as fk_org, summa3
     from prices t
     where t.usl=usl_ and (fk_org_src_=0 and t.fk_org is null
      or fk_org_src_ <> 0 and t.fk_org=fk_org_src_);
  else
    err_:=1;
    err_str_:='–асценка уже существует в данной организации!';
  end if;
--коммит в программе
end;

procedure del_price(usl_ in prices.usl%type, fk_org_ in prices.fk_org%type) is
begin
--удаление индивидуальных расценок по ” 
  delete from prices t where t.fk_org=fk_org_ and t.usl=usl_;

end;

 function set_int_param(l_cd spr_params.cd%type,
     l_val spr_params.parn1%type) return spr_params.id%type is
 l_cdtp number;
 l_id spr_params.id%type;
 begin
   --устанавливает значение параметра Number (странно что только одна эта ф-ци€, а где остальные?)
   --если параметра нет - создает его
   begin
   select s.cdtp into l_cdtp
          from spr_params s where upper(s.cd)=upper(l_cd);
   if nvl(l_cdtp,0) <> 0 then
      raise_application_error(-20001,
                              'ѕараметр - '||l_cd||' не €вл€етс€ NUMBER типом!');
   end if;
    exception
    when NO_DATA_FOUND then
    --создает параметр
     insert into spr_params
       (cd, parn1, cdtp)
     values
       (l_cd, l_val, 0)
     returning id into l_id;
/*
TODO: owner="lev" created="10.12.2013"
text="”брал коммиты на фиг"
*/
--     commit;
     return l_id;
   end;
   --обновл€ет параметр значением
   update spr_params t
    set t.parn1=l_val
    where t.cd=l_cd
    returning t.id into l_id;
/*
TODO: owner="lev" created="10.12.2013"
text="”брал коммиты на фиг"
*/
--    commit;
    return l_id;
 end;

 function get_int_param(cd_ varchar2) return spr_params.parn1%type is
 cdtp_ number;
 result_ spr_params.parn1%type;
 begin
   --возращает значение параметра Number
   begin
   select s.parn1, s.cdtp into result_, cdtp_
          from spr_params s where upper(s.cd)=upper(cd_);
   if nvl(cdtp_,0) <> 0 then
      raise_application_error(-20001,
                              'ѕараметр - '||cd_||' не €вл€етс€ NUMBER типом!');
   end if;
    exception
    when NO_DATA_FOUND then
      raise_application_error(-20001,
                              'ѕараметр - '||cd_||' не зарегистрирован!');
   end;
   return result_;
 end;

 function getS_int_param(cd_ varchar2) return spr_params.parn1%type is
 cdtp_ number;
 result_ spr_params.parn1%type;
 fk_ses_ number;
 begin
   select USERENV('sessionid') into fk_ses_ from dual;
   --дл€ сессии
   --возращает значение параметра Number
   begin
   select s.parn1, s.cdtp into result_, cdtp_
          from spr_par_ses s
           where s.fk_ses=fk_ses_ and upper(s.cd)=upper(cd_);
   if nvl(cdtp_,0) <> 0 then
      raise_application_error(-20001,
                              'ѕараметр - '||cd_||' не €вл€етс€ NUMBER типом!');
   end if;
    exception
    when NO_DATA_FOUND then
      raise_application_error(-20001,
                              'ѕараметр - '||cd_||' не зарегистрирован!');
   end;
   return result_;
 end;

 function get_bool_param(cd_ varchar2) return spr_params.parn1%type is
 cdtp_ number;
 result_ spr_params.parn1%type;
 begin
   --возращает значение параметра Boolean
   begin
   select case when nvl(s.parn1,0) = 0
          then 0
          else 1
          end, s.cdtp into result_, cdtp_
          from spr_params s
           where upper(s.cd)=upper(cd_);
   if nvl(cdtp_,0) <> 3 then
      raise_application_error(-20001,
                              'ѕараметр - '||cd_||' не €вл€етс€ BOOLEAN типом!');
   end if;
    exception
    when NO_DATA_FOUND then
      raise_application_error(-20001,
                              'ѕараметр - '||cd_||' не зарегистрирован!');
   end;
   return result_;
 end;

 function getS_bool_param(cd_ varchar2) return spr_params.parn1%type is
 cdtp_ number;
 result_ spr_params.parn1%type;
 fk_ses_ number;
 begin
   select USERENV('sessionid') into fk_ses_ from dual;
   --дл€ сессии
   --возращает значение параметра Number
   begin
   select case when nvl(s.parn1,0) = 0
          then 0
          else 1
          end, s.cdtp into result_, cdtp_
          from spr_par_ses s
           where s.fk_ses=fk_ses_ and upper(s.cd)=upper(cd_);
   if nvl(cdtp_,0) <> 3 then
      raise_application_error(-20001,
                              'ѕараметр - '||cd_||' не €вл€етс€ BOOLEAN типом!');
   end if;
    exception
    when NO_DATA_FOUND then
      raise_application_error(-20001,
                              'ѕараметр - '||cd_||' не зарегистрирован!');
   end;
   return result_;
 end;

 function get_str_param(cd_ varchar2) return spr_params.parvc1%type is
 result_ spr_params.parvc1%type;
 cdtp_ number;
 begin
   --возращает значение параметра Varchar2
   begin
   select s.parvc1, s.cdtp into result_, cdtp_
          from spr_params s where upper(s.cd)=upper(cd_);
   if nvl(cdtp_,0)<>1 then
      raise_application_error(-20001,
                              'ѕараметр - '||cd_||' не €вл€етс€ VARACHAR2 типом!');
   end if;
    exception
    when NO_DATA_FOUND then
      raise_application_error(-20001,
                              'ѕараметр - '||cd_||' не зарегистрирован!');
   end;
   return result_;
 end;

 function getS_str_param(cd_ varchar2) return spr_params.parvc1%type is
 result_ spr_params.parvc1%type;
 cdtp_ number;
 fk_ses_ number;
 begin
   select USERENV('sessionid') into fk_ses_ from dual;
   --дл€ сессии
   --возращает значение параметра Varchar2
   begin
   select s.parvc1, s.cdtp into result_, cdtp_
          from spr_par_ses s
           where s.fk_ses=fk_ses_ and upper(s.cd)=upper(cd_);
   if nvl(cdtp_,0)<>1 then
      raise_application_error(-20001,
                              'ѕараметр - '||cd_||' не €вл€етс€ VARACHAR2 типом!');
   end if;
    exception
    when NO_DATA_FOUND then
      raise_application_error(-20001,
                              'ѕараметр - '||cd_||' не зарегистрирован!');
   end;
   return result_;
 end;

 function get_date_param(cd_ varchar2) return spr_params.pardt1%type is
 result_ spr_params.pardt1%type;
 cdtp_ number;
 begin
   --возращает значение параметра Date
   begin
   select s.pardt1, s.cdtp into result_, cdtp_
          from spr_params s where upper(s.cd)=upper(cd_);
   if nvl(cdtp_,0) <> 2 then
      raise_application_error(-20001,
                              'ѕараметр - '||cd_||' не €вл€етс€ DATE типом!');
   end if;
    exception
    when NO_DATA_FOUND then
      raise_application_error(-20001,
                              'ѕараметр - '||cd_||' не зарегистрирован!');
   end;
   return result_;
 end;

 function getS_date_param(cd_ varchar2) return spr_params.pardt1%type is
 result_ spr_params.pardt1%type;
 cdtp_ number;
 fk_ses_ number;
 begin
   select USERENV('sessionid') into fk_ses_ from dual;
   --дл€ сессии
   --возращает значение параметра Date
   begin
   select s.pardt1, s.cdtp into result_, cdtp_
          from spr_par_ses s
           where s.fk_ses=fk_ses_ and upper(s.cd)=upper(cd_);
   if nvl(cdtp_,0) <> 2 then
      raise_application_error(-20001,
                              'ѕараметр - '||cd_||' не €вл€етс€ DATE типом!');
   end if;
    exception
    when NO_DATA_FOUND then
      raise_application_error(-20001,
                              'ѕараметр - '||cd_||' не зарегистрирован!');
   end;
   return result_;
 end;

  function getS_list_param(cd_ varchar2) return list_c.sel_id%type is
 result_ list_c.sel_id%type;
 cdtp_ number;
 cnt_ number;
 fk_ses_ number;
 begin
   select USERENV('sessionid') into fk_ses_ from dual;
   --дл€ сессии
   --возращает ID параметра List... или -1 если ничего не выбрано
   begin
     select nvl(count(*),0) into cnt_
            from spr_par_ses s
           where s.fk_ses=fk_ses_ and upper(s.cd)=upper(cd_);
    exception
    when NO_DATA_FOUND then
      raise_application_error(-20001,
                              'ѕараметр - '||cd_||' не зарегистрирован!');
   end;

   begin
   select c.sel_id, s.cdtp into result_, cdtp_
          from spr_par_ses s, list_c c
           where c.fk_par=s.id and c.sel=1
          and s.fk_ses=fk_ses_ and s.fk_ses=c.fk_ses
          and upper(s.cd)=upper(cd_);
   if nvl(cdtp_,0) <> 4 then
      raise_application_error(-20001,
                              'ѕараметр - '||cd_||' не €вл€етс€ LIST типом!');
   end if;
    exception
    when NO_DATA_FOUND then
       if nvl(cdtp_,0) <> 4 then
          raise_application_error(-20001,
                                  'ѕараметр - '||cd_||' не €вл€етс€ LIST типом!');
       end if;
       result_:=-1;
   end;
   return result_;
 end;

  function getScd_list_param(cd_ varchar2) return list_c.sel_cd%type is
 result_ list_c.sel_cd%type;
 cdtp_ number;
 cnt_ number;
 fk_ses_ number;
 begin
   select USERENV('sessionid') into fk_ses_ from dual;
   --дл€ сессии
   --возращает —D параметра List... или NULL если ничего не выбрано
   begin
     select nvl(count(*),0) into cnt_
            from spr_par_ses s
           where s.fk_ses=fk_ses_ and upper(s.cd)=upper(cd_);
    exception
    when NO_DATA_FOUND then
      raise_application_error(-20001,
                              'ѕараметр - '||cd_||' не зарегистрирован!');
   end;

   begin
   select c.sel_cd, s.cdtp into result_, cdtp_
          from spr_par_ses s, list_c c
           where c.fk_par=s.id and c.sel=1
          and s.fk_ses=fk_ses_ and s.fk_ses=c.fk_ses
          and upper(s.cd)=upper(cd_);
   if nvl(cdtp_,0) <> 4 then
      raise_application_error(-20001,
                              'ѕараметр - '||cd_||' не €вл€етс€ LIST типом!');
   end if;
    exception
    when NO_DATA_FOUND then
/*       if nvl(cdtp_,0) <> 4 then
          raise_application_error(-20001,
                                  'ѕараметр - '||cd_||' не €вл€етс€ LIST типом!');
       end if;*/
       result_:=null;
   end;
   return result_;
 end;

 procedure fill_list_c (fk_par_ in spr_params.id%type) is
 sql_text_ spr_params.sql_text%type;
 cd_ spr_params.cd%type;
 cnt_ number;
 fk_ses_ number;
 begin
   select USERENV('sessionid') into fk_ses_ from dual;
 --первоначальное заполнение списком значений,
 --дл€ выбора пользователем
 --внимание! поле sel должно быть заполнено у одного элемента =1  - ??? не пон€л 13.12.2013
  select p.sql_text into sql_text_ from spr_par_ses t, spr_params p
   where t.id=fk_par_ and t.fk_ses=fk_ses_
   and t.id=p.id;

  select nvl(count(*),0) into cnt_ from list_c t where t.fk_par=fk_par_
   and t.fk_ses=fk_ses_;
  if cnt_ = 0 then
    begin
        --попробовать, если в запросе нет NPP
      execute immediate 'begin insert into list_c
        (sel_id, sel_cd, name, fk_ses, fk_par, sel, npp)
        '||sql_text_||'; end;'
        using fk_ses_, fk_par_;
      exception when others then
        if SQLCODE=-6550 then
          --если в запросе нет NPP
          begin
          execute immediate 'begin insert into list_c
            (sel_id, sel_cd, name, fk_ses, fk_par, sel)
            '||sql_text_||'; end;'
            using fk_ses_, fk_par_;
          exception when others then
            Raise_application_error(-20000, 'ќшибка в '||sql_text_);
          end;
        else
          Raise_application_error(-20000, 'ќшибка в '||sql_text_);
          --Raise;
        end if;

    end;
  end if;
  commit;
  end;

 procedure set_list_c (fk_par_ in spr_params.id%type, id_ in list_c.id%type) is
 fk_ses_ number;
 begin
   select USERENV('sessionid') into fk_ses_ from dual;
 --установить выбранные значени€ списка
 --дл€ параметра x пользовател€
   update list_c t set t.sel=0 where
    t.id <> id_ and t.fk_par=fk_par_
    and t.fk_ses=fk_ses_;
   update list_c t set t.sel=1 where
    t.id = id_ and t.fk_par=fk_par_
        and t.fk_ses=fk_ses_;
   commit;
 end;

 procedure rep_add_param (fk_rep_ in reports.id%type, fk_par_ in spr_params.id%type) is
 begin
 --добавление параметра в отчет
  insert into repxpar
    (fk_rep, fk_par)
  select
    fk_rep_, fk_par_ from dual t
    where not exists
     (select * from repxpar r where r.fk_rep=fk_rep_ and r.fk_par=fk_par_);
   commit;
 end;

 procedure rep_del_param (fk_rep_ in reports.id%type, fk_par_ in spr_params.id%type) is
 begin
 --удаление параметра из отчета
   delete from repxpar r where r.fk_rep=fk_rep_ and r.fk_par=fk_par_;
   commit;
 end;

 function have_sch(p_lsk in kart.lsk%type, p_counter in usl.counter%type) return number is
  l_cnt number;
begin
--провер€ет, существует ли счетчик в текущем периоде
if p_counter not in ('phw','pgw') then
  Raise_application_error(-20000, 'Ќекорректное использование utils.have_sch!');
end if;
select case when nvl(count(*),0) > 0 then 1 else 0 end into l_cnt from c_states_sch t
  where t.lsk=p_lsk and
  case
    when p_counter='phw' and t.fk_status in (1,2) then 1
    when p_counter='pgw' and t.fk_status in (1,3) then 1
    else 0
  end = 1
  and exists
  (select * from v_cur_days d where
    d.dat between nvl(t.dt1, to_date('01011900','DDMMYYYY'))
    and nvl(t.dt2, to_date('01012900','DDMMYYYY')));
return l_cnt;
end;

 procedure upd_krt_sch_state(lsk_ in kart.lsk%type) is
 time_ date;
  begin
  --обновление признака счетчика в карточке л/c
  --DENSE_RANK - полезна€ штука
  time_:=sysdate;
  if lsk_ is not null then
    --по данному л.с. (из триггера)
    update kart k set k.psch =
       (select max(t.fk_status)
        keep (dense_rank first order by nvl(t.dt1, to_date('01011900','DDMMYYYY')) desc) as fk_status
        from c_states_sch t, params p where
            t.lsk=lsk_
            and last_day(to_date(p.period||'01','YYYYMMDD'))
            between nvl(t.dt1, to_date('01011900','DDMMYYYY'))
            and nvl(t.dt2, to_date('01012900','DDMMYYYY'))
        group by t.lsk)
        where exists
        (select *
        from c_states_sch t, params p where
            t.lsk=k.lsk
            and last_day(to_date(p.period||'01','YYYYMMDD'))
            between nvl(t.dt1, to_date('01011900','DDMMYYYY'))
            and nvl(t.dt2, to_date('01012900','DDMMYYYY'))
        ) and
         k.lsk=lsk_;

   --нельз€ чистить расход, так как должны оставатьс€ расходы по счетчику, дл€
   --учета того периода, когда был счетчик, ред.05.04.13

   /*     ”брал - задолбало нулить счетчики у полыс, ред 04.04.13

if utils.have_sch(lsk_, 'phw') =0 then
       update kart k set k.phw=0 where k.lsk=lsk_;
       update kart k set k.mhw=0 where k.lsk=lsk_;
     end if;
     if utils.have_sch(lsk_, 'pgw') =0 then
       update kart k set k.pgw=0 where k.lsk=lsk_;
       update kart k set k.mgw=0 where k.lsk=lsk_;
     end if;     */

  else
    --по всем л.с. (после перехода)
    update kart k set k.psch =
       (select max(t.fk_status)
        keep (dense_rank first order by nvl(t.dt1, to_date('01011900','DDMMYYYY')) desc) as fk_status
        from c_states_sch t, params p where
            t.lsk=k.lsk
            and last_day(to_date(p.period||'01','YYYYMMDD'))
            between nvl(t.dt1, to_date('01011900','DDMMYYYY'))
            and nvl(t.dt2, to_date('01012900','DDMMYYYY'))
        group by t.lsk)
        where exists
        (select *
        from c_states_sch t, params p where
            t.lsk=k.lsk
            and last_day(to_date(p.period||'01','YYYYMMDD'))
            between nvl(t.dt1, to_date('01011900','DDMMYYYY'))
            and nvl(t.dt2, to_date('01012900','DDMMYYYY')));
     logger.log_(time_, 'gen.upd_krt_sch_state');
  end if;
  end;

 function set_krt_psch (dat_ in c_states_sch.dt1%type,
   fk_status_ in c_states_sch.fk_status%type, lsk_ in kart.lsk%type) return integer
   is
 cnt_ number;
 set_ number;
 cursor cur1 is
   select c.fk_status, c.dt1, c.rowid as rd from c_states_sch c
    where c.lsk=lsk_ and c.dt2 is null;
 rec1_ cur1%rowtype;
 cursor cur2 is
   select c.dt1, c.dt2, c.rowid as rd from c_states_sch c
    where c.lsk=lsk_
    and c.dt2 is not null;
 rec2_ cur2%rowtype;

 cursor cur_krt is
   select k.psch from kart k
    where k.lsk=lsk_;
 rec_krt_ cur_krt%rowtype;

 cursor cur_dt is
  select nvl(count(*),0) as cnt from
   c_states_sch c where dat_ between c.dt1 and c.dt2
   and c.lsk=lsk_
   and c.dt1 <> dat_ and c.dt2<> dat_;
 rec_dt_ cur_dt%rowtype;
 --------
 begin
 --изменение статуса л.с. с добавлением в историю нового статуса
 set_:=0;
 open cur_krt;
 fetch cur_krt into rec_krt_;
 close cur_krt;

 open cur_dt;
 fetch cur_dt into rec_dt_;
 close cur_dt;

 if to_char(dat_,'YYYYMM') = to_char(init.get_date,'YYYYMM') then
   if fk_status_ <> rec_krt_.psch and rec_dt_.cnt = 0 then
  --   dat_:=init.get_date;
     open cur1;
     fetch cur1 into rec1_;
     close cur1;
     open cur2;
     fetch cur2 into rec2_;
     close cur2;

     if rec1_.rd is null then
      --нет открытого периода
      if nvl(rec2_.dt1,to_date('19000101', 'YYYYMMDD')) <= trunc(dat_)-1 then
        --закрываем имеющуюс€ строчку (датой на день раньше)
        update c_states_sch t set t.dt2=trunc(dat_)-1
        where t.rowid=rec2_.rd;
      end if;
      insert into c_states_sch
       (lsk, fk_status, dt1, dt2)
       values
       (lsk_, fk_status_, dat_, null);
     else
      --есть открытый период
      if nvl(rec1_.dt1,to_date('19000101', 'YYYYMMDD')) <= trunc(dat_)-1 then
        --закрываем имеющуюс€ строчку (датой на день раньше)
        update c_states_sch t set t.dt2=trunc(dat_)-1
        where t.rowid=rec1_.rd;
        insert into c_states_sch
         (lsk, fk_status, dt1, dt2)
         values
         (lsk_, fk_status_, dat_, null);
      else
        --мен€ем имеющуюс€ строчку (статус)
        update c_states_sch t set t.fk_status=fk_status_
        where t.rowid=rec1_.rd;
      end if;
     end if;
     set_:=1;
   end if;
 else
  --ошибка, период не соответствует текущему
  set_:=2;
 end if;
 return set_;
 end;

/*
 --заменено на функцию в ext_pkg.is_lst, ред.27.08.14
 
function is_lst_day(p_days in number) return number is
  l_mg params.period%type;
begin
  --провер€ет последний ли день мес€ца и соответствует ли период в базе текущему периоду
  --p_days --сменить на N дней, конец мес€ца))
  select p.period into l_mg from params p;
  if trunc(sysdate) >= last_day(to_date(l_mg||'01','YYYYMMDD'))-nvl(p_days,0) then
    --да, последний день мес€ца
    return 1;
  elsif trunc(sysdate) < last_day(to_date(l_mg||'01','YYYYMMDD'))-nvl(p_days,0)
   and to_char(sysdate,'YYYYMM')=l_mg then --добавил проверку, на случай, если дата в компе не корректна€ совсем (даже не тот мес€ц)
    --нет, не последний день мес€ца
    return 0;
  end if;
end; */

function set_base_state_gen(l_set in number) return number is
l_status number;
l_handle varchar2(128);
begin
--»спользовать в другой сессии, дл€ исключени€ запуска повторных процессов формировани€
--чего-либо из ƒиректа

--найти/разместить идентификатор блокировки
DBMS_LOCK.ALLOCATE_UNIQUE
    ('Direct_gen'
    ,l_handle
    ,86400);

if l_set=1 then
  --попытка выполнить блокировку
  l_status := dbms_lock.request( l_handle, dbms_lock.X_MODE,
                                  timeout => 1);

  IF l_status = 0 THEN
   --заблокировано
   return 0;
  ELSE
   --отказ в блокировке
   return 1;
  END IF;
else
  --попытка сн€ть блокировку (либо сниметс€ по завершении сессии)
  l_status := DBMS_LOCK.RELEASE
                     (lockhandle => l_handle);
  return l_status;
end if;

/*if l_set=1 then
  --выполнить блокировку
  begin
--    delete from c_dummy;
--    insert into c_dummy (n1) values (1);
    for c in (select t.rowid as rd, t.n1
          from c_dummy t
          for update of t.n1 nowait )
    loop
        update c_dummy t set t.n1=1 where t.rowid = c.rd;
    end loop;
  exception
    when others then
      if SQLCODE = -54 then
        return 1;
      else
        raise;
      end if;
  end;

  return 0;
else
  --просто выполнить коммит в этой сесии
  commit;
  return 0;
end if; */

end;

--проверка справочника redir_pay
function check_redir_pay return number is
  l_cnt number;
begin
  --1 проверка оплаты и пени
  select nvl(count(*), 0)
    into l_cnt
    from (select t.fk_usl_src, t.fk_org_dst, t.tp, t.fk_usl_dst, t.fk_org_src, t.reu,
                  count(*)
             from redir_pay t
            where t.tp in (0, 1)
            group by t.fk_usl_src, t.fk_org_dst, t.tp, t.fk_usl_dst, t.fk_org_src, t.reu
           having count(*) > 1);

  if l_cnt > 0 then
    --не прошла проверку настройка оплаты или пени
    return 1;
  end if;

  --2 проверка справочника дл€ статистики
  select nvl(count(*), 0)
    into l_cnt
    from (select t.fk_org_dst, t.fk_org_src, t.mg1, t.mg2, count(*)
             from redir_pay t
            where t.tp in (2)
            group by t.fk_org_dst, t.fk_org_src, t.mg1, t.mg2
           having count(*) > 1);

  if l_cnt > 0 then
    --не прошла проверку настройка справочника дл€ статистики
    return 2;
  end if;

--всЄ ок!
return 0;
end;

end utils;
/

prompt
prompt Creating trigger C_CHANGE_AD_E
prompt ==============================
prompt
create or replace trigger "SCOTT".c_change_ad_e
  after delete on c_change
  for each row
declare
begin
 if nvl(c_charges.trg_proc_next_month,0)=0 then
   --если не переход мес€ца
    logger.log_act(:old.lsk, '”даление перерасчета по л/c: '||:old.lsk||' сумма:'||:old.summa||' дата:'||to_char(:old.dtek,'DD.MM.YYYY'), 2);
 end if;
end c_change_ad_e;
/

prompt
prompt Creating trigger C_CHANGE_BI_E
prompt ==============================
prompt
create or replace trigger "SCOTT".c_change_bi_e
  before insert on c_change
  for each row
declare
begin
  if :new.id is null then
    select scott.changes_id.nextval into :new.id from dual;
  end if;
end c_change_bi_e;
/

prompt
prompt Creating trigger C_CHANGE_BUID_E
prompt ================================
prompt
create or replace trigger "SCOTT".c_change_buid_e
  before insert or update or delete on c_change
  for each row
declare
 txt_ log_actions.text%type;
begin
 if nvl(c_charges.trg_proc_next_month,0)=0 then
   --если не переход мес€ца
   if inserting or updating then
      null;
   elsif deleting then
      select trim(nm) into txt_ from usl u where u.usl=:old.usl;
      logger.log_act(:old.lsk, '”дален перерасчет по услуге: '||trim(txt_)||
       ' от '||to_char(:old.dtek,'DD.MM.YYYY')||' док є '||to_char(:old.doc_id), 2);

   end if;
 end if;
end;
/

prompt
prompt Creating trigger C_CHANGE_DOCS_BI_E
prompt ===================================
prompt
create or replace trigger "SCOTT".c_change_docs_bi_e
  before insert on c_change_docs
  for each row
declare
begin
  if :new.id is null then
    select scott.changes_id.nextval into :new.id from dual;
  end if;

  if :new.user_id is null then
    select u.id into :new.user_id
             from t_user u
            where u.cd = user;
  end if;
end c_change_docs_bi_e;
/

prompt
prompt Creating trigger C_CHANGE_VALID
prompt ===============================
prompt
create or replace trigger "SCOTT".c_change_valid
  before insert or update or delete on c_change
  for each row
declare
begin
--установка статуса пересчета начислени€ и движени€ по л/с
/*  if inserting then
     c_valid.set_valid_lsk(:new.lsk, 1, 'gen_chrgpay');
  elsif updating or deleting then
     c_valid.set_valid_lsk(:old.lsk, 1, 'gen_chrgpay');
  end if;*/
  null;
end c_change_valid;
/

prompt
prompt Creating trigger C_CHARGE_BI
prompt ============================
prompt
create or replace trigger "SCOTT".c_charge_bi
  before insert on c_charge
  for each row
declare
begin
  if :new.id is null then
    select scott.c_charge_id.nextval into :new.id from dual;
  end if;
  if :new.usl is null then
    Raise_application_error(-20000, 'ѕопытка добавить строку с пустым кодом USL по лиц.счету:'||:new.lsk);
  end if;
end c_charge_bi;
/

prompt
prompt Creating trigger C_DEBUG_BI_E
prompt =============================
prompt
create or replace trigger "SCOTT".c_debug_bi_e
  before insert on c_debug
  for each row
begin
  if :new.id is null then
    select u_list_id.nextval into :new.id from dual;
  end if;

end;
/

prompt
prompt Creating trigger C_DEB_OPER_BIE
prompt ===============================
prompt
create or replace trigger scott.c_deb_oper_bie
  before insert on c_deb_oper
  for each row
declare
begin
  if :new.id is null then
    select scott.c_deb_oper_id.nextval into :new.id from dual;
  end if;
end c_deb_oper_bie;
/

prompt
prompt Creating trigger C_DEB_USL2_BI
prompt ==============================
prompt
create or replace trigger "SCOTT".c_deb_usl2_bi
  before insert on c_deb_usl2
  for each row
declare
begin
  if :new.id is null then
    select scott.c_deb_usl_id.nextval into :new.id from dual;
  end if;
end c_deb_usl2_bi;
/

prompt
prompt Creating trigger C_DEB_USL_BI
prompt =============================
prompt
create or replace trigger "SCOTT".c_deb_usl_bi
  before insert on c_deb_usl
  for each row
declare
begin
  if :new.id is null then
    select scott.c_deb_usl_id.nextval into :new.id from dual;
  end if;
end c_deb_usl_bi;
/

prompt
prompt Creating trigger C_HOUSES_BU_E
prompt ==============================
prompt
create or replace trigger "SCOTT".c_houses_bu_e
  before update of fk_pasp_org, kran1 on c_houses
  for each row

declare
  cnt_ number;
begin
  --обновление id паспортного стола в карточках
  update kart k set k.fk_pasp_org=:new.fk_pasp_org
   where k.house_id=:old.id;
  -- раны из системы отоплени€
  update kart k set k.kran1=:new.kran1
   where k.house_id=:old.id;
  if nvl(:old.kran1,0) <> nvl(:new.kran1,0) then
    cnt_:=c_charges.gen_charges(null, null, null, :old.id, 0, 0);
  end if;
end;
/

prompt
prompt Creating trigger C_HOUSES_VALID
prompt ===============================
prompt
create or replace trigger "SCOTT".c_houses_valid
  before insert or update or delete on c_houses
  for each row
declare
begin
--установка статуса пересчета начислени€ и движени€ по л/с
 --если нет каскадного удалени€
NULL;
/*
  if inserting then
     c_valid.set_valid_house(:new.id, 1, 'gen_chrg');
     c_valid.set_valid_house(:new.id, 1, 'gen_part_kpr');
  elsif updating or deleting then
     c_valid.set_valid_house(:old.id, 1, 'gen_chrg');
     c_valid.set_valid_house(:old.id, 1, 'gen_part_kpr');
  end if;
*/

end c_houses_valid;
/

prompt
prompt Creating trigger C_HOUSE_BI_E
prompt =============================
prompt
create or replace trigger "SCOTT".c_house_bi_e
  before insert on c_houses
  for each row
declare
  l_id number;
begin
  if :new.id is null then
    select c_house_id.nextval into :new.id from dual;
  end if;
  if :new.k_lsk_id is null then
    insert into k_lsk (id, fk_addrtp)
       select k_lsk_id.nextval, u.id
       from u_list u, u_listtp tp
       where
       u.cd='house' and tp.cd='object_type';
    select k_lsk_id.currval into :new.k_lsk_id from dual;
  end if;

  --добавить параметр (пощадь общего имущ дома) по умолчанию дл€ дома
  --если он не существует
  l_id := c_obj_par.set_num_param(p_k_lsk_id => :new.k_lsk_id,
                                     p_lsk => null,
                                     p_cd => 'area_general_property',
                                     p_val => null,
                                     p_cdtp => 'house_params');
end;
/

prompt
prompt Creating trigger C_KART_PR_AUID
prompt ===============================
prompt
create or replace trigger "SCOTT".c_kart_pr_auid
  after update or insert or delete on c_kart_pr

declare
 id_ number;
begin
-- Raise_application_error(-20000, c_charges.tab_lsk.count);
  if deleting then
    --каскадное удаление - флаг выключен
    c_charges.trg_c_kart_pr_bd     := 0;
  end if;
  if inserting and nvl(c_charges.trg_c_kart_pr_flag,0) = 0 then
    for element in 1 .. c_charges.tab_c_kart_pr_id.count loop
    --вставка нового документа по льготе
     insert into c_lg_docs (c_kart_pr_id, main)
      values (c_charges.tab_c_kart_pr_id(element), 0)
      returning
       id into id_;
    --вставка новых льгот по умолчанию
     insert into c_lg_pr (c_lg_docs_id, spk_id, type)
      values (id_, 1, 0);
     insert into c_lg_pr (c_lg_docs_id, spk_id, type)
      values (id_, 1, 1);
    end loop;
  end if;

  --кол-во проживающих, льготников
  for element in 1 .. c_charges.tab_lsk.count loop
    if c_charges.tab_lsk(element) is not null then
      utils.set_kpr(c_charges.tab_lsk(element));
--перенес в расчет начислени€ 11.04.14
--      c_kart.set_part_kpr(c_charges.tab_lsk(element));
      --установка ‘»ќ квартиросъемщика в карточку
      if nvl(c_charges.chng_relat_id,0) = 1 then
         utils.set_krt_adm(c_charges.tab_lsk(element));
      end if;
    end if;
  end loop;

  --сбрасываем флаг смены квартиросъемщика
  c_charges.chng_relat_id:=0;
end;
/

prompt
prompt Creating trigger C_KART_PR_BUID
prompt ===============================
prompt
create or replace trigger "SCOTT".c_kart_pr_buid
  before update or delete or insert on c_kart_pr
begin
  c_charges.tab_lsk.delete;
  if inserting then
    --добавление прописанных
    c_charges.tab_c_kart_pr_id.delete;
  elsif deleting then
    --каскадное удаление - флаг включен
    c_charges.trg_c_kart_pr_bd     := 1;
  end if;
end;
/

prompt
prompt Creating trigger C_KART_PR_BUID_E
prompt =================================
prompt
create or replace trigger "SCOTT".c_kart_pr_buid_e
  before update or insert or delete on c_kart_pr
  for each row
declare
  aud_text_ log_actions.text%type;
  txt_ c_status_pr.name%type;
  txt2_ c_status_pr.name%type;
  lsk_ c_kart_pr.lsk%type;
  flag_kv_ number;
begin
  --флаг смены квартиросъемщика
  flag_kv_:=0;
  c_charges.chng_relat_id := 0;

  aud_text_:='';

  if inserting then
    --дл€ подсчета кол-во льготников в триггере c_kart_pr_auid
    c_charges.tab_lsk.extend;
    c_charges.tab_lsk(c_charges.tab_lsk.last) := :new.lsk;

    :new.k_fam:=initcap(:new.k_fam);
    :new.k_im:=initcap(:new.k_im);
    :new.k_ot:=initcap(:new.k_ot);
    :new.fio:=:new.k_fam||' '||:new.k_im||' '||:new.k_ot;
    if :new.id is null then
      select scott.kart_pr_id.nextval into :new.id from dual;
    end if;

    --«аписываем каждого проживающего, дл€ последующей обработки в триггерах
    c_charges.tab_c_kart_pr_id.extend;
    c_charges.tab_c_kart_pr_id(c_charges.tab_c_kart_pr_id.last) := :new.id;


    --в случае, если флаг не установлен, т.е. записи инсерт€тс€ не через скрипт переноса домов
    /*  не пон€л этого... вроде из истории должна братьс€ дата прописки.. ред 28.11.12
    if :new.dat_prop is null and nvl(c_charges.scr_flag_,0) = 0 then
        :new.dat_prop:=init.get_date;
    end if;*/
    --по умолчанию статус - посто€нно зарег.
    if :new.status is null then
      :new.status:=1;
    end if;
    c_charges.nabor_lsk_:=:new.lsk;
    aud_text_:='ƒобавлен новый проживающий: '||trim(:new.fio);
    lsk_:=:new.lsk;

  elsif updating then
/*    if :new.status is null then
      Raise_application_error(-20000, 'Ќекорректно установлен статус проживающего!');
    end if;*/
    --«аписываем ‘»ќ, Ћ.—. дл€ аудита
    c_charges.trg_c_kart_pr_bd_fio:=:old.fio;
    c_charges.trg_c_kart_pr_bd_lsk:=:old.lsk;

    :new.k_fam:=initcap(:new.k_fam);
    :new.k_im:=initcap(:new.k_im);
    :new.k_ot:=initcap(:new.k_ot);
    :new.fio:=:new.k_fam||' '||:new.k_im||' '||:new.k_ot;
    --дл€ подсчета кол-во льг. в триггере c_kart_pr_auid
    c_charges.tab_lsk.extend;
    c_charges.tab_lsk(c_charges.tab_lsk.last) := :old.lsk;
    --«аписываем каждого проживающего, дл€ последующей обработки в триггерах
    c_charges.tab_c_kart_pr_id.extend;
    c_charges.tab_c_kart_pr_id(c_charges.tab_c_kart_pr_id.last) := :old.id;
    --если только не переход мес€ца
    if nvl(c_charges.trg_proc_next_month,0) = 0 then
      aud_text_:='(реквизиты)';
    end if;
    --обнул€ем статус, дату выписки, если не ¬ыписанный
    if :new.status<>4 then
--      :new.dat_ub:=null;
      :new.fk_ub:=null;
      :new.fk_to_cntr:=null;
      :new.fk_to_regn:=null;
      :new.fk_to_distr:=null;
      :new.fk_to_kul:=null;
      :new.to_town:=null;
      :new.to_nd:=null;
      :new.to_kw:=null;
    end if;
    c_charges.nabor_lsk_:=:old.lsk;
    if (:new.fio <> :old.fio
     and :new.fio is not null and :old.fio is not null) or
     (:new.fio is null and :old.fio is not null) or
     (:new.fio is not null and :old.fio is null) then
       aud_text_:=aud_text_||logger.log_text('‘.».ќ.', trim(:old.fio), trim(:new.fio));
       if  nvl(:new.relat_id,0) = 11 or nvl(:old.relat_id,0) = 11 then
       --только в случае работы с квартиросъемщиком
         flag_kv_:=1;
       end if;
    end if;
    lsk_:=:old.lsk;
  if nvl(:new.status,0) <> nvl(:old.status,0) then
    select name into txt_ from c_status_pr t where t.id=:old.status;
    begin
    select name into txt2_ from c_status_pr t where t.id=:new.status;
    exception
      when others then
        Raise_application_error(-20000, :old.id||'-'||:new.status);
    end;
    aud_text_:=aud_text_||logger.log_text('Cтатус', trim(txt_), trim(txt2_));
  end if;
  elsif deleting then
    --«аписываем ‘»ќ, Ћ.—. дл€ аудита
    c_charges.trg_c_kart_pr_bd_fio:=:old.fio;
    c_charges.trg_c_kart_pr_bd_lsk:=:old.lsk;

    --дл€ подсчета кол-во льг. в триггере c_kart_pr_auid
    c_charges.tab_lsk.extend;
    c_charges.tab_lsk(c_charges.tab_lsk.last) := :old.lsk;


    if updating and (:new.status <> :old.status or
       :new.dat_ub <> :old.dat_ub or
       :new.dat_prop <> :old.dat_prop) or inserting then
      --«аписываем каждого проживающего, дл€ последующей обработки в триггерах
      --если были изменены ключевые пол€
      c_charges.tab_c_kart_pr_id.extend;
      c_charges.tab_c_kart_pr_id(c_charges.tab_c_kart_pr_id.last) := :old.id;
    end if;


    c_charges.nabor_lsk_:=:old.lsk;
    aud_text_:='”дален проживающий: '||trim(:old.fio);
    lsk_:=:old.lsk;
    if  nvl(:new.relat_id,0) = 11 or nvl(:old.relat_id,0) = 11 then
      --только в случае работы с квартиросъемщиком
      flag_kv_:=1;
    end if;
  end if;

  if  ((nvl(:new.relat_id,0) = 11 or nvl(:old.relat_id,0) = 11) and
     nvl(:new.relat_id,0) <> nvl(:old.relat_id,0) or flag_kv_=1) then
    --возможно изменилс€ квартиросъемщик
    c_charges.chng_relat_id := 1;
  end if;

  if length(aud_text_) > 0 then
--    if c_charges.trg_proc_next_month = 0 then
    aud_text_:='ќбновлены данные проживающего: '||aud_text_;
--    end if;
    logger.log_act(lsk_, aud_text_, 2);
  end if;

end;
/

prompt
prompt Creating trigger C_KART_PR_VALID
prompt ================================
prompt
create or replace trigger "SCOTT".c_kart_pr_valid
  before insert or update or delete on c_kart_pr
  for each row
declare
begin
--установка статуса пересчета начислени€ и движени€ по л/с
 --если нет каскадного удалени€
 NULL;
/*  if inserting then
     c_valid.set_valid_lsk(:new.lsk, 1, 'gen_chrg');
     c_valid.set_valid_lsk(:new.lsk, 1, 'gen_part_kpr');
  elsif updating or deleting then
     c_valid.set_valid_lsk(:old.lsk, 1, 'gen_chrg');
     c_valid.set_valid_lsk(:old.lsk, 1, 'gen_part_kpr');
  end if;*/

end c_kart_pr_valid;
/

prompt
prompt Creating trigger C_KWTP_AD_E
prompt ============================
prompt
create or replace trigger "SCOTT".c_kwtp_ad_e
  after delete on c_kwtp
  for each row
declare
begin
  if nvl(c_charges.trg_proc_next_month,0) = 0  then
    --если разрешено логгировать - записать в лог
    logger.log_act(:old.lsk, '”даление оплаты по л/c: '||:old.lsk||' сумма:'||:old.summa||' пен€:'||:old.penya||' дата платежа:'||to_char(:old.dtek,'DD.MM.YYYY'), 2);
  end if;
end c_kwtp_bd_e;
/

prompt
prompt Creating trigger C_KWTP_BI_E
prompt ============================
prompt
create or replace trigger "SCOTT".c_kwtp_bi_e
  before insert on c_kwtp
  for each row
declare
begin
  if :new.id is null then
    select scott.c_kwtp_id.nextval into :new.id from dual;
  end if;
end c_kwtp_bi_e;
/

prompt
prompt Creating trigger C_KWTP_MG_AI_E
prompt ===============================
prompt
create or replace trigger scott.c_kwtp_mg_ai_e
  after insert on c_kwtp_mg
  for each row
declare
rec_ c_kwtp_mg%rowtype;
l_reu varchar2(2);
begin
--распределение платежа после вставки строки оплаты
 if nvl(:new.is_dist,0) = 0 then
 --если оплата еще не распределена (распределена бывает после реверс.операции)
 select :new.lsk, :new.summa, :new.penya, :new.oper, :new.dopl, :new.nink, :new.nkom, :new.dtek, :new.nkvit,
  :new.dat_ink, :new.ts, :new.c_kwtp_id, :new.cnt_sch, :new.cnt_sch0, :new.id, :new.is_dist
  into rec_.lsk, rec_.summa, rec_.penya, rec_.oper, rec_.dopl, rec_.nink, rec_.nkom, rec_.dtek,
    rec_.nkvit, rec_.dat_ink, rec_.ts, rec_.c_kwtp_id, rec_.cnt_sch, rec_.cnt_sch0,
    rec_.id, rec_.is_dist from dual;
   if rec_.dtek <= init.g_dt_end then
     --если платЄж прин€т датой, меньшей чем окончание периода,
     --то распределить его по услугам-орг, в противном случае- нет!
     --нужно дл€ того, чтобы не было ошибки кол-ва итераций в c_gen_pay! ред. 15.09.14
     --потом сделать распределение платежей, прин€тых будущими периодами
     if utils.get_int_param('DIST_PAY_TP') = 0 then
     --по-сальдовый способ распределени€ оплаты
       c_gen_pay.dist_pay_lsk(rec_, 0);
     else
     --по-периодный способ распределени€ оплаты
       --сперва подготовить задолжность
       --(не надо, выполн€етс€ в процедуре)
       --c_dist_pay.gen_deb_usl(rec_.lsk);
       --потом распределить оплату
--       if :new.lsk<>'15042520' then
         select reu into l_reu from kart k where k.lsk=rec_.lsk;
         c_dist_pay.dist_pay_deb_mg_lsk(l_reu, rec_);
--       end if;
     end if;
    end if;
 end if;
end c_kwtp_mg_ai_e;
/

prompt
prompt Creating trigger C_KWTP_MG_BI_E
prompt ===============================
prompt
create or replace trigger scott.c_kwtp_mg_bi_e
  before insert on c_kwtp_mg
  for each row
declare
begin
  if :new.id is null then
    select scott.c_kwtp_mg_id.nextval into :new.id from dual;
  end if;
end c_kwtp_mg_bi_e;
/

prompt
prompt Creating trigger C_KWTP_MG_VALID
prompt ================================
prompt
create or replace trigger "SCOTT".c_kwtp_mg_valid
  before insert or update or delete on c_kwtp_mg
  for each row
declare
begin
--установка статуса пересчета начислени€ и движени€ по л/с
  if inserting then
     c_valid.set_valid_lsk(:new.lsk, 1, 'gen_chrgpay');
  elsif updating or deleting then
     c_valid.set_valid_lsk(:old.lsk, 1, 'gen_chrgpay');
  end if;
end c_kwtp_mg_valid;
/

prompt
prompt Creating trigger C_LG_DOCS_AD
prompt =============================
prompt
create or replace trigger "SCOTT".C_LG_DOCS_AD
  after delete on c_lg_docs
declare
  cnt_ number;
begin
  select nvl(count(*),0) into cnt_ from c_kart_pr p where not exists
  (select * from c_lg_docs c
    where p.id=c.c_kart_pr_id)
    and p.lsk=c_charges.trg_c_lg_docs_bd_lsk;
  if cnt_ > 0 then
    Raise_application_error(-20000, '«апрещено удал€ть единственную льготу у проживающего, замените на "–аб/—луж"');
  end if;

  --каскадное удаление, восстановить признак
  c_charges.trg_c_lg_docs_bd:=0;

end C_LG_DOCS_BD;
/

prompt
prompt Creating trigger C_LG_DOCS_BD
prompt =============================
prompt
create or replace trigger "SCOTT".C_LG_DOCS_BD
  before delete on c_lg_docs
declare
begin
  --каскадное удаление
  c_charges.trg_c_lg_docs_bd:=1;

end C_LG_DOCS_BD;
/

prompt
prompt Creating trigger C_LG_DOCS_BD_E
prompt ===============================
prompt
create or replace trigger "SCOTT".c_lg_docs_bd_e
  before delete on c_lg_docs
  for each row
begin
  --каскадное удаление
  --сохран€ем фио дл€ аудита
  if nvl(c_charges.trg_c_kart_pr_bd,0) = 1 then
     --было каскадное удаление от c_kart_pr
     c_charges.trg_c_lg_docs_bd_fio := c_charges.trg_c_kart_pr_bd_fio;
     c_charges.trg_c_lg_docs_bd_lsk := c_charges.trg_c_kart_pr_bd_lsk;
  else
    for c in (select t.lsk, t.fio from c_kart_pr t where t.id = :old.c_kart_pr_id) loop
      c_charges.trg_c_lg_docs_bd_fio := c.fio;
      c_charges.trg_c_lg_docs_bd_lsk := c.lsk;
      exit;
    end loop;
  end if;

end c_lg_docs_bd_e;
/

prompt
prompt Creating trigger C_LG_DOCS_BIU_E
prompt ================================
prompt
create or replace trigger "SCOTT".c_lg_docs_biu_e
  before update or insert on c_lg_docs
  for each row
declare
  aud_text_ log_actions.text%type;
  fio_ c_kart_pr.fio%type;
begin
  aud_text_:='';
  if inserting then
    if :new.id is null then
      select scott.c_lg_docs_id.nextval into :new.id from dual;
    end if;

  elsif updating then
    if (:new.dat_begin <> :old.dat_begin) or (:new.dat_begin is not null and :old.dat_begin is null)
       or (:new.dat_begin is null and :old.dat_begin is not null) then
      select p.fio into fio_ from c_kart_pr p where
       p.id=:old.c_kart_pr_id;
      aud_text_:='ќбновлены данные по документу льготы проживающего: '||trim(fio_)||', '
      ||logger.log_text('ƒата начала', to_char(:old.dat_begin,'DD/MM/YYYY'), to_char(:new.dat_begin,'DD/MM/YYYY'));
    end if;
  end if;
end c_lg_docs_biu_e;
/

prompt
prompt Creating trigger C_LG_DOCS_VALID
prompt ================================
prompt
create or replace trigger "SCOTT".c_lg_docs_valid
  before insert or update or delete on c_lg_docs
  for each row
declare
begin

NULL;
/*--установка статуса пересчета начислени€ и движени€ по л/с
 if c_charges.trg_c_kart_pr_bd <> 1 then
 --если нет каскадного удалени€
  if inserting then
     c_valid.set_valid_states_pr(:new.c_kart_pr_id, 1, 'gen_chrg');
  elsif updating or deleting then
     c_valid.set_valid_states_pr(:old.c_kart_pr_id, 1, 'gen_chrg');
  end if;
 end if;*/
end c_lg_docs_valid;
/

prompt
prompt Creating trigger C_LG_PR_BUI_E
prompt ==============================
prompt
create or replace trigger "SCOTT".c_lg_pr_bui_e
  before delete or update or insert on c_lg_pr
  for each row
declare
  aud_text_ log_actions.text%type;
  txt_      spk.name%type;
  txt2_     spk.name%type;
  lsk_ c_kart_pr.lsk%type;
begin
  --проверка на соответствие льготы статусу жиль€
  if inserting or updating then
    for c in (select case
                       when :new.type = 1 and s.fk_status_g is not null and
                            s.fk_status_g <> nvl(k.status, 0) then
                        0
                       when :new.type = 0 and s.fk_status_k is not null and
                            s.fk_status_k <> nvl(k.status, 0) then
                        0
                       else
                        1 --соответствует
                     end as correct_lg, p.fio, k.lsk, s.name
                from kart k, c_kart_pr p, c_lg_docs d, spk s
               where k.lsk = p.lsk
                 and p.id = d.c_kart_pr_id
                 and d.id = :new.c_lg_docs_id
                 and s.id = :new.spk_id --без учета выбывших
                 and p.status <> 4) loop
      if c.correct_lg = 0 then
        --льгота не соответствует статусу жиль€
        raise_application_error(-20001,
                                'ƒанна€ льгота не соответствует статусу жиль€, отмена!');
      end if;
      if inserting then
        if :new.type = 1 then
          aud_text_ := 'ƒобавлена льгота по тек.содерж., по проживающему:';
        else
          aud_text_ := 'ƒобавлена льгота по коммун.усл., по  по проживающему:';
        end if;
        aud_text_ := aud_text_ || trim(c.fio) || ', ' || trim(c.name);
      elsif updating then
        select s.name into txt_ from spk s where s.id = :old.spk_id;
        select s.name into txt2_ from spk s where s.id = :new.spk_id;
        if :new.type = 1 then
          aud_text_ := 'ќбновлена льгота по тек.содерж., по проживающему:';
        else
          aud_text_ := 'ќбновлена льгота по коммун.усл., по  по проживающему:';
        end if;
        aud_text_ := aud_text_ || trim(c.fio) || ', ' ||
                     logger.log_text('Ћьгота',
                                     trim(txt_),
                                     trim(txt2_));
      end if;

      lsk_:=c.lsk;
      exit;
    end loop;
    if length(aud_text_) > 0 then
      logger.log_act(lsk_, aud_text_, 2);
    end if;
  elsif deleting then

    --аудит, вести если не было каскадного удалени€ из c_kart_pr (иначе mutating в триггере)
    if nvl(c_charges.trg_c_kart_pr_bd,0) = 0 then
      select s.name into txt_ from spk s where s.id = :old.spk_id;
      if :old.type = 1 then
        aud_text_ := '”далена льгота по тек.содерж., по проживающему:';
      else
        aud_text_ := '”далена льгота по коммун.усл., по проживающему:';
      end if;
      if nvl(c_charges.trg_c_lg_docs_bd, 0) = 1 then
        --каскадное удаление от c_lg_docs...
        aud_text_ := aud_text_ || trim(c_charges.trg_c_lg_docs_bd_fio) || ', ' ||
                     trim(txt_);
        lsk_:=c_charges.trg_c_lg_docs_bd_lsk;
      else
        for c in (select case
                           when :old.type = 1 and s.fk_status_g is not null and
                                s.fk_status_g <> nvl(k.status, 0) then
                            0
                           when :old.type = 0 and s.fk_status_k is not null and
                                s.fk_status_k <> nvl(k.status, 0) then
                            0
                           else
                            1 --соответствует
                         end as correct_lg, p.fio, k.lsk, s.name
                    from kart k, c_kart_pr p, c_lg_docs d, spk s
                   where k.lsk = p.lsk
                     and p.id = d.c_kart_pr_id
                     and d.id = :old.c_lg_docs_id
                     and s.id = :old.spk_id --без учета выбывших
                     and p.status <> 4) loop
          aud_text_ := aud_text_ || trim(c.fio) || ', ' ||
                       trim(txt_);
          lsk_:=c.lsk;
          exit;
        end loop;
      end if;
    if length(aud_text_) > 0 then
      logger.log_act(lsk_, aud_text_, 2);
    end if;
    end if;
  end if;
end;
/

prompt
prompt Creating trigger C_PEN_CORR_AD_E
prompt ================================
prompt
create or replace trigger "SCOTT".c_pen_corr_ad_e
  after delete on c_pen_corr
  for each row
declare
begin
  if nvl(c_charges.trg_proc_next_month,0) = 0  then
    --если разрешено логгировать - записать в лог
    logger.log_act(:old.lsk, '”даление корректировки пени по л/c: '||:old.lsk||' сумма:'||:old.penya||' дата корректировки:'||to_char(:old.dtek,'DD.MM.YYYY'), 2);
  end if;
end c_pen_corr_bd_e;
/

prompt
prompt Creating trigger C_PEN_CORR_BIU_E
prompt =================================
prompt
create or replace trigger "SCOTT".c_pen_corr_biu_e
  before insert or update on c_pen_corr
  for each row
declare
begin
  if :new.id is null then
    select scott.c_pen_corr_id.nextval, u.id, sysdate into :new.id, :new.fk_user, :new.ts from t_user u
       where u.cd=user;
  end if;
  if not :new.dtek between init.get_dt_start and init.get_dt_end then
    Raise_application_error(-20000, 'Ќе корректна€ дата проводки!');
  end if;
end c_pen_corr_biu_e;
/

prompt
prompt Creating trigger C_REG_SCH_BI
prompt =============================
prompt
create or replace trigger "SCOTT".c_reg_sch_bi
  before insert on c_reg_sch
  for each row
declare
begin
  if :new.id is null then
    select scott.c_reg_sch_id.nextval into :new.id from dual;
  end if;
end c_reg_sch_bi;
/

prompt
prompt Creating trigger C_SPK_USL_VALID
prompt ================================
prompt
create or replace trigger "SCOTT".c_spk_usl_valid
  before insert or update or delete on c_spk_usl
  for each row
declare
begin
  NULL;

/* c_valid.set_valid_all_nc(1, 'gen_chrg');
 logger.log_(null, 'VALID=1 for c_spk_usl, made by '||user);
 */
end c_spk_usl_valid;
/

prompt
prompt Creating trigger C_STATES_PR_AIUD
prompt =================================
prompt
create or replace trigger "SCOTT".c_states_pr_aiud
  after insert or update or delete on c_states_pr
declare
cnt_ number;
begin
  --не было каскадного удалени€ от c_kart_pr
  if nvl(c_charges.trg_c_kart_pr_bd,0) = 0 then
  for element in 1 .. c_charges.tb_rec_pr_states.count loop
    if nvl(c_charges.debug_flag_,0)=0 then
     --обновить признак статуса в карточке проживающего
     utils.upd_c_kart_pr_state(c_charges.tb_rec_pr_states(element).fk_kart_pr);
--перенес в расчет начислени€ 11.04.14
--обновить доли в наборах услуг
--     c_kart.set_part_kpr_all(c_charges.tb_rec_pr_states(element).fk_kart_pr);
--     utils.upd_nabor_kf_kpr2(c_charges.tb_rec_pr_states(element).fk_kart_pr);
     --установить квартиросъемщика
     utils.set_krt_adm2(c_charges.tb_rec_pr_states(element).fk_kart_pr);
    end if;
  end loop;
  end if;
end c_states_pr_aiud;
/

prompt
prompt Creating trigger C_STATES_PR_BIUD
prompt =================================
prompt
create or replace trigger "SCOTT".c_states_pr_biud
  before insert or update or delete on c_states_pr
declare
begin
    c_charges.tb_rec_pr_states.delete;

end c_states_pr_biud;
/

prompt
prompt Creating trigger C_STATES_PR_BIUDE
prompt ==================================
prompt
create or replace trigger "SCOTT".c_states_pr_biude
  before insert or update or delete on c_states_pr
  for each row
declare
  TYPE rec_kart_pr IS RECORD (
     lsk c_kart_pr.lsk%type,
     fio c_kart_pr.fio%type);
  rec_kart_pr_ rec_kart_pr;
  txt_ c_status_pr.name%type;
  txt2_ c_status_pr.name%type;

begin
    --элементы, которые надо проверить в триггере after
    if inserting then
      if nvl(:new.dt1, to_date('01011900','DDMMYYYY'))
           > nvl(:new.dt2, to_date('01012900','DDMMYYYY')) then
        Raise_application_error(-20000, '¬нимание! ”казана€ дата окончани€ периода статуса прописки/регистрации прожив.меньше начальной!');
      end if;
      if :new.id is null then
        select scott.c_states_pr_id.nextval into :new.id from dual;
      end if;
      c_charges.tb_rec_pr_states.extend;
      c_charges.tb_rec_pr_states(c_charges.tb_rec_pr_states.last).id := :new.id;
      c_charges.tb_rec_pr_states(c_charges.tb_rec_pr_states.last).fk_kart_pr := :new.fk_kart_pr;
      c_charges.tb_rec_pr_states(c_charges.tb_rec_pr_states.last).fk_tp := :new.fk_tp;
      c_charges.tb_rec_pr_states(c_charges.tb_rec_pr_states.last).dt1 := :new.dt1;
      c_charges.tb_rec_pr_states(c_charges.tb_rec_pr_states.last).dt2 := :new.dt2;

      --аудит
      select c.name into txt_ from c_status_pr c where c.id=:new.fk_status;
      select c.lsk, c.fio into rec_kart_pr_ from c_kart_pr c where c.id=:new.fk_kart_pr;
      logger.log_act(rec_kart_pr_.lsk, 'добавлен новый период действи€ статуса проживающего: '||
         trim(rec_kart_pr_.fio)||' -'||
         txt_||
         case when :new.dt1 is not null then ' c '||to_char(:new.dt1,'DD.MM.YYYY') else ' с неопределенной даты начала ' end||
        case when :new.dt2 is not null then ' по '||to_char(:new.dt2,'DD.MM.YYYY') else ' по неопределенную дату окончани€ ' end, 2);
    elsif updating then
      if nvl(:new.dt1, to_date('01011900','DDMMYYYY'))
           > nvl(:new.dt2, to_date('01012900','DDMMYYYY')) then
        Raise_application_error(-20000, '¬нимание! ”казана€ дата окончани€ периода статуса прописки/регистрации прожив.меньше начальной!');
      end if;
      c_charges.tb_rec_pr_states.extend;
      c_charges.tb_rec_pr_states(c_charges.tb_rec_pr_states.last).id := :old.id;
      c_charges.tb_rec_pr_states(c_charges.tb_rec_pr_states.last).fk_kart_pr := :old.fk_kart_pr;
      c_charges.tb_rec_pr_states(c_charges.tb_rec_pr_states.last).fk_tp := :old.fk_tp;
      c_charges.tb_rec_pr_states(c_charges.tb_rec_pr_states.last).dt1 := :new.dt1;
      c_charges.tb_rec_pr_states(c_charges.tb_rec_pr_states.last).dt2 := :new.dt2;
      --аудит
      select c.name into txt_ from c_status_pr c where c.id=:old.fk_status;
      select c.name into txt2_ from c_status_pr c where c.id=:new.fk_status;
      select c.lsk, c.fio into rec_kart_pr_ from c_kart_pr c where c.id=:old.fk_kart_pr;
      logger.log_act(rec_kart_pr_.lsk,
      logger.log_text('ќбновлен период действи€ статуса проживающего: '||
         trim(rec_kart_pr_.fio),
         txt_||
         case when :old.dt1 is not null then ' c '||to_char(:old.dt1,'DD.MM.YYYY') else ' с неопределенной даты начала ' end||
         case when :old.dt2 is not null then ' по '||to_char(:old.dt2,'DD.MM.YYYY') else ' по неопределенную дату окончани€ ' end,
         txt2_||
         case when :new.dt1 is not null then ' c '||to_char(:new.dt1,'DD.MM.YYYY') else ' с неопределенной даты начала ' end||
         case when :new.dt2 is not null then ' по '||to_char(:new.dt2,'DD.MM.YYYY') else ' по неопределенную дату окончани€ ' end)
        , 2);
      --аудит
    elsif deleting then
      c_charges.tb_rec_pr_states.extend;
      c_charges.tb_rec_pr_states(c_charges.tb_rec_pr_states.last).id := :old.id;
      c_charges.tb_rec_pr_states(c_charges.tb_rec_pr_states.last).fk_kart_pr := :old.fk_kart_pr;
      c_charges.tb_rec_pr_states(c_charges.tb_rec_pr_states.last).fk_tp := :old.fk_tp;
      c_charges.tb_rec_pr_states(c_charges.tb_rec_pr_states.last).dt1 := :old.dt1;
      c_charges.tb_rec_pr_states(c_charges.tb_rec_pr_states.last).dt2 := :old.dt2;
      --аудит, вести если не было каскадного удалени€ из c_kart_pr (иначе mutating в триггере)
      if nvl(c_charges.trg_c_kart_pr_bd,0) = 0 then
        select c.name into txt_ from c_status_pr c where c.id=:old.fk_status;
        select c.lsk, c.fio into rec_kart_pr_ from c_kart_pr c where c.id=:old.fk_kart_pr;
        logger.log_act(rec_kart_pr_.lsk, '”дален период действи€ статуса проживающего: '||
           trim(rec_kart_pr_.fio)||' -'||
           txt_||
           case when :old.dt1 is not null then ' c '||to_char(:old.dt1,'DD.MM.YYYY') else ' с неопределенной даты начала ' end||
          case when :old.dt2 is not null then ' по '||to_char(:old.dt2,'DD.MM.YYYY') else ' по неопределенную дату окончани€ ' end, 2);
      end if;
    end if;
end c_states_pr_biude;
/

prompt
prompt Creating trigger C_STATES_PR_VALID
prompt ==================================
prompt
create or replace trigger "SCOTT".c_states_pr_valid
  before insert or update or delete on c_states_pr
  for each row
declare
begin

NULL;
/*--установка статуса пересчета начислени€ и движени€ по л/с
 if c_charges.trg_c_kart_pr_bd <> 1 then
 --если нет каскадного удалени€
  if inserting then
     c_valid.set_valid_states_pr(:new.fk_kart_pr, 1, 'gen_chrg');
     c_valid.set_valid_states_pr(:new.id, 1, 'gen_part_kpr');
  elsif updating or deleting then
     c_valid.set_valid_states_pr(:old.fk_kart_pr, 1, 'gen_chrg');
     c_valid.set_valid_states_pr(:old.id, 1, 'gen_part_kpr');
  end if;
 end if; */
end c_states_pr_valid;
/

prompt
prompt Creating trigger C_STATES_SCH_AIUD
prompt ==================================
prompt
create or replace trigger "SCOTT".c_states_sch_aiud
  after insert or update or delete on c_states_sch
declare
cnt_ number;
begin

for element in 1 .. c_charges.tb_rec_states.count loop
  if c_charges.tb_rec_states(element).lsk is not null then
    --обновить признак счетчика в карточке л/c
      utils.upd_krt_sch_state(c_charges.tb_rec_states(element).lsk);
--перенес в расчет начислени€ 11.04.14
--обновить доли в наборах услуг
--      c_kart.set_part_kpr(c_charges.tb_rec_states(element).lsk);
  end if;
end loop;

end c_states_sch_aiud;
/

prompt
prompt Creating trigger C_STATES_SCH_BIUD
prompt ==================================
prompt
create or replace trigger "SCOTT".c_states_sch_biud
  before insert or update on c_states_sch
declare
begin
   c_charges.tb_rec_states.delete;
end c_states_sch_biud;
/

prompt
prompt Creating trigger C_STATES_SCH_BIUDE
prompt ===================================
prompt
create or replace trigger "SCOTT".c_states_sch_biude
  before insert or update or delete on c_states_sch
  for each row
declare
begin
    --элементы, которые надо проверить в триггере after
    if inserting then
      if nvl(:new.dt1, to_date('01011900','DDMMYYYY'))
           > nvl(:new.dt2, to_date('01012900','DDMMYYYY')) then
        Raise_application_error(-20000, '¬нимание! ”казана€ дата окончани€ периода действи€ статуса счетчиков меньше начальной!!');
      end if;
      if :new.id is null then
        select scott.c_states_sch_id.nextval into :new.id from dual;
      end if;
      c_charges.tb_rec_states.extend;
      c_charges.tb_rec_states(c_charges.tb_rec_states.last).id := :new.id;
      c_charges.tb_rec_states(c_charges.tb_rec_states.last).lsk := :new.lsk;
      c_charges.tb_rec_states(c_charges.tb_rec_states.last).dt1 := :new.dt1;
      c_charges.tb_rec_states(c_charges.tb_rec_states.last).dt2 := :new.dt2;

      logger.log_act(:new.lsk, 'добавлен новый период действи€ статуса счетчика: '||
        case when :new.fk_status =0 then 'Ќорматив'
             when :new.fk_status =1 then '—ч.’.¬. и √.¬.'
             when :new.fk_status =2 then '—ч.’.¬.'
             when :new.fk_status =3 then '—ч.√.¬.'
             when :new.fk_status =8 then 'ѕрошл.'
             when :new.fk_status =9 then '«акрыт'
             else '' end||
         case when :new.dt1 is not null then ' c '||to_char(:new.dt1,'DD.MM.YYYY') else ' с неопределенной даты начала ' end||
        case when :new.dt2 is not null then ' по '||to_char(:new.dt2,'DD.MM.YYYY') else ' по неопределенную дату окончани€ ' end, 2);
    elsif updating then
      if nvl(:new.dt1, to_date('01011900','DDMMYYYY'))
           > nvl(:new.dt2, to_date('01012900','DDMMYYYY')) then
        Raise_application_error(-20000, '¬нимание! ”казана€ дата окончани€ периода статуса счетчиков меньше начальной!!');
      end if;
      c_charges.tb_rec_states.extend;
      c_charges.tb_rec_states(c_charges.tb_rec_states.last).id := :old.id;
      c_charges.tb_rec_states(c_charges.tb_rec_states.last).lsk := :old.lsk;
      c_charges.tb_rec_states(c_charges.tb_rec_states.last).dt1 := :new.dt1;
      c_charges.tb_rec_states(c_charges.tb_rec_states.last).dt2 := :new.dt2;
      logger.log_act(:old.lsk,
        logger.log_text('ќбновлен период действи€ статуса счетчика: ',
        case when :old.fk_status =0 then 'Ќорматив'
             when :old.fk_status =1 then '—ч.’.¬. и √.¬.'
             when :old.fk_status =2 then '—ч.’.¬.'
             when :old.fk_status =3 then '—ч.√.¬.'
             when :old.fk_status =8 then 'ѕрошл.'
             when :old.fk_status =9 then '«акрыт'
             else '' end||
         case when :old.dt1 is not null then ' c '||to_char(:old.dt1,'DD.MM.YYYY') else ' с неопределенной даты начала ' end||
        case when :old.dt2 is not null then ' по '||to_char(:old.dt2,'DD.MM.YYYY') else ' по неопределенную дату окончани€ ' end,
        case when :new.fk_status =0 then 'Ќорматив'
             when :new.fk_status =1 then '—ч.’.¬. и √.¬.'
             when :new.fk_status =2 then '—ч.’.¬.'
             when :new.fk_status =3 then '—ч.√.¬.'
             when :new.fk_status =8 then 'ѕрошл.'
             when :new.fk_status =9 then '«акрыт'
             else '' end||
         case when :new.dt1 is not null then ' c '||to_char(:new.dt1,'DD.MM.YYYY') else ' с неопределенной даты начала ' end||
        case when :new.dt2 is not null then ' по '||to_char(:new.dt2,'DD.MM.YYYY') else ' по неопределенную дату окончани€ ' end), 2);
    elsif deleting then
      c_charges.tb_rec_states.extend;
      c_charges.tb_rec_states(c_charges.tb_rec_states.last).id := :old.id;
      c_charges.tb_rec_states(c_charges.tb_rec_states.last).lsk := :old.lsk;
      c_charges.tb_rec_states(c_charges.tb_rec_states.last).dt1 := :old.dt1;
      c_charges.tb_rec_states(c_charges.tb_rec_states.last).dt2 := :old.dt2;
      logger.log_act(:old.lsk, 'удалЄн период действи€ статуса счетчика: '||
        case when :old.fk_status =0 then 'Ќорматив'
             when :old.fk_status =1 then '—ч.’.¬. и √.¬.'
             when :old.fk_status =2 then '—ч.’.¬.'
             when :old.fk_status =3 then '—ч.√.¬.'
             when :old.fk_status =8 then 'ѕрошл.'
             when :old.fk_status =9 then '«акрыт'
             else '' end||
         case when :old.dt1 is not null then ' c '||to_char(:old.dt1,'DD.MM.YYYY') else ' с неопределенной даты начала ' end||
        case when :old.dt2 is not null then ' по '||to_char(:old.dt2,'DD.MM.YYYY') else ' по неопределенную дату окончани€ ' end, 2);
    end if;
end c_states_sch_biude;
/

prompt
prompt Creating trigger C_STATES_SCH_VALID
prompt ===================================
prompt
create or replace trigger "SCOTT".c_states_sch_valid
  before insert or update or delete on c_states_sch
  for each row
declare
begin
  NULL;
/*--установка статуса пересчета начислени€ и движени€ по л/с
 --если нет каскадного удалени€
  if inserting then
     c_valid.set_valid_lsk(:new.lsk, 1, 'gen_chrg');
     c_valid.set_valid_lsk(:new.lsk, 1, 'gen_part_kpr');
  elsif updating or deleting then
     c_valid.set_valid_lsk(:old.lsk, 1, 'gen_chrg');
     c_valid.set_valid_lsk(:old.lsk, 1, 'gen_part_kpr');
  end if;
  */
end c_states_sch_valid;
/

prompt
prompt Creating trigger C_VVOD_AU
prompt ==========================
prompt
create or replace trigger "SCOTT".c_vvod_au
  after update on c_vvod
declare
 cnt_ number;
begin
  c_charges.trg_c_vvod     := 0; --сн€ть флаг, чтобы правильно писать в лог описание процесса
  if nvl(c_charges.trg_proc_next_month,0)=0 then
  --если не выполн€етс€ переход мес€ца
    for element in 1 .. c_charges.tab_vvod_id.count loop
       --пересчитать ввод
        for c in (select d.* from c_vvod d where d.id=c_charges.tab_vvod_id(element)
            )
          loop
            if c.dist_tp in (4,5) then
            --распределить объем, если нет ќƒѕ”
            p_vvod.gen_dist_wo_vvod_usl(c.id);            
            else
            --распределить объем, если есть ќƒѕ”
            p_vvod.gen_dist(p_klsk => c.fk_k_lsk,
                            p_dist_tp => c.dist_tp,
                            p_usl => c.usl,
                            p_use_sch => c.use_sch,
                            p_old_use_sch => c.use_sch,
                            p_kub_nrm_fact => c.kub_nrm_fact,
                            p_kub_sch_fact => c.kub_sch_fact,
                            p_kub_ar_fact => c.kub_ar_fact,
                            p_kub_ar => c.kub_ar,
                            p_opl_ar => c.opl_ar,
                            p_kub_sch => c.kub_sch,
                            p_sch_cnt => c.sch_cnt,
                            p_sch_kpr => c.sch_kpr,
                            p_kpr => c.kpr,
                            p_cnt_lsk => c.cnt_lsk,
                            p_kub_norm => c.kub_norm,
                            p_kub_fact => c.kub_fact,
                            p_kub_man => c.kub_man,
                            p_kub => c.kub,
                            p_edt_norm => c.edt_norm,
                            p_kub_dist => c.kub_dist,
                            p_id => c.id,
                            p_house_id => c.house_id,
                            p_opl_add => c.opl_add,
                            p_old_kub => c.kub,
                            p_limit_proc => c.limit_proc,
                            p_old_limit_proc => c.limit_proc,
                            p_gen_part_kpr => 1,
                            p_wo_limit => c.wo_limit
                            );
          end if;
          end loop;
    end loop;
  end if;
end;
/

prompt
prompt Creating trigger C_VVOD_BI_E
prompt ============================
prompt
create or replace trigger "SCOTT".c_vvod_bi_e
  before insert on c_vvod for each row
declare
begin
  if :new.id is null then
        select scott.c_vvod_id.nextval into :new.id from dual;
  end if;
  if :new.dist_tp is null then
    --по умолчанию сделать тип распределени€ - по площади
    :new.dist_tp:=1;
  end if;

end;
/

prompt
prompt Creating trigger C_VVOD_BU
prompt ==========================
prompt
create or replace trigger "SCOTT".c_vvod_bu
  before update on c_vvod
declare
begin
  --чистим список вводов дл€ перерасчета начислени€
  c_charges.tab_vvod_id.delete;
  c_charges.trg_c_vvod     := 1; --флаг, чтобы правильно писать в лог описание процесса
end;
/

prompt
prompt Creating trigger C_VVOD_KUB_BU_E
prompt ================================
prompt
create or replace trigger "SCOTT".c_vvod_kub_bu_e
  before update of
   kub, edt_norm, use_sch, dist_tp, limit_proc on c_vvod
  for each row
declare
begin
  --записываем в список вводов
  c_charges.tab_vvod_id.extend;
  c_charges.tab_vvod_id(c_charges.tab_vvod_id.last) := :new.id;

/*    p_vvod.gen_dist(p_klsk => :new.fk_k_lsk,
                    p_dist_tp => :new.dist_tp,
                    p_usl => :OLD.usl,
                    p_use_sch => :new.use_sch,
                    p_old_use_sch => :OLD.use_sch,
                    p_kub_nrm_fact => :new.kub_nrm_fact,
                    p_kub_sch_fact => :new.kub_sch_fact,
                    p_kub_ar_fact => :new.kub_ar_fact,
                    p_kub_ar => :new.kub_ar,
                    p_opl_ar => :new.opl_ar,
                    p_kub_sch => :new.kub_sch,
                    p_sch_cnt => :new.sch_cnt,
                    p_sch_kpr => :new.sch_kpr,
                    p_kpr => :new.kpr,
                    p_cnt_lsk => :new.cnt_lsk,
                    p_kub_norm => :new.kub_norm,
                    p_kub_fact => :new.kub_fact,
                    p_kub_man => :new.kub_man,
                    p_kub => :new.kub, --старые показани€ объема
                    p_kub_dist => :new.kub_dist,
                    p_id => :OLD.id,
                    p_house_id => :OLD.house_id,
                    p_opl_add => :new.opl_add,
                    p_old_kub => :old.kub,
                    p_limit_proc => :new.limit_proc,
                    p_old_limit_proc => :old.limit_proc); --новые показани€ объема */

null;
end;
/

prompt
prompt Creating trigger C_VVOD_VALID
prompt =============================
prompt
create or replace trigger "SCOTT".c_vvod_valid
  before insert or update or delete on c_vvod
  for each row
declare
begin
 NULL;
/*--установка статуса пересчета начислени€ и движени€ по л/с
 --если нет каскадного удалени€
  if inserting then
     c_valid.set_valid_vvod(:new.fk_k_lsk, 1, 'gen_chrg');
  elsif updating or deleting then
     c_valid.set_valid_vvod(:old.fk_k_lsk, 1, 'gen_chrg');
  end if;
*/
end c_vvod_valid;
/

prompt
prompt Creating trigger DU_OBJ_BIU_E
prompt =============================
prompt
create or replace trigger "SCOTT".du_obj_biu_e
  before insert or update on du_obj
  for each row
declare
begin
  if :new.id is null then
    select scott.du_obj_id.nextval into :new.id from dual;
  end if;
  if updating then
    delete from du_obj_comp t
     where t.fk_du_obj=:old.id;
  end if;
end du_obj_biu_e;
/

prompt
prompt Creating trigger DU_OBJ_COMP_BI_E
prompt =================================
prompt
create or replace trigger "SCOTT".du_obj_comp_bi_e
  before insert on du_obj_comp
  for each row
declare
begin
  if :new.id is null then
    select scott.du_obj_id.nextval into :new.id from dual;
  end if;
end du_obj_comp_bi_e;
/

prompt
prompt Creating trigger IMP_C_HOUSE_BI_E
prompt =================================
prompt
create or replace trigger "SCOTT".imp_c_house_bi_e
  before insert on imp_c_houses
  for each row

begin
  --используем тот же sequence что и на c_houses,
  --чтобы поместить потом записи в c_houses
  if :new.id is null then
    select c_house_id.nextval into :new.id from dual;
  end if;
end;
/

prompt
prompt Creating trigger KART_AUID
prompt ==========================
prompt
create or replace trigger "SCOTT".kart_auid
  after update or insert on kart
declare
  lll number;
begin
  --обновить пол€ по дополнительному лицевому счету, вз€в из основного
--    Raise_application_error(-20000, c_charges.trg_klsk_flag);
--    c_charges.trg_klsk_flag:=0;
  if c_charges.trg_tab_klsk.count <>0 and nvl(c_charges.trg_klsk_flag,0)=0 then
  for i in c_charges.trg_tab_klsk.FIRST .. c_charges.trg_tab_klsk.LAST loop --да, да в триггере могут быть дубли лиц.сч.!
--    Raise_application_error(-20000, 1);
--  lll:=nvl(c_charges.trg_tab_klsk(c_charges.trg_tab_klsk.last),-1);
--    begin
   c_charges.trg_klsk_flag:=1;
   for c in (select k.k_fam, k.k_im, k.k_ot, k.status, k.opl, k2.lsk, k.kw, k.nd, k.kul, k.kpr
                from kart k, v_lsk_tp tp, kart k2, v_lsk_tp tp2
               where k.k_lsk_id = c_charges.trg_tab_klsk(i)
                 and k.k_lsk_id = k2.k_lsk_id
                 and k.fk_tp = tp.id
                 and tp.cd = 'LSK_TP_MAIN'
                 and k2.fk_tp = tp2.id
                 and tp2.cd = 'LSK_TP_ADDIT'
                 and k.psch not in (8,9)) loop
      --отключить искажение массива и повторные вызовы триггера
      update kart t
         set t.k_fam = c.k_fam, t.k_im = c.k_im, t.k_ot = c.k_ot,
             t.status = c.status, t.opl = c.opl, t.kw=c.kw, t.nd=c.nd, t.kul=c.kul, t.kpr=c.kpr
       where t.lsk = c.lsk;
       exit;
--    Raise_application_error(-20000, c.status);
    end loop;
    c_charges.trg_klsk_flag:=0;

/*    exception
      when others then
        Raise_application_error(-20000, 'stop='||i||', count='||c_charges.trg_tab_klsk.count );
    end;*/
  end loop;
  end if;


end;
/

prompt
prompt Creating trigger KART_BUI
prompt =========================
prompt
create or replace trigger "SCOTT".kart_bui
  before update or insert on kart
declare
begin
--   c_charges.trg_klsk_flag:=0;
  if nvl(c_charges.trg_klsk_flag,0)=0 then
    c_charges.trg_tab_klsk.delete;
  end if;
end;
/

prompt
prompt Creating trigger KART_BUI_E
prompt ===========================
prompt
create or replace trigger "SCOTT".kart_bui_e
  before update or insert on kart
  for each row
declare
  house_id_ number;
  var_ number;
  correct_lg_ number;
  aud_text_ log_actions.text%type;
  status_txt_ status.name%type;
  status_txt2_ status.name%type;
  street_txt_ spul.name%type;
  street_txt2_ spul.name%type;
  l_usl usl.usl%type;
  l_id number;
  l_cnt number;
  l_tp_cd u_list.cd%type;
  l_write_for_trg number;
begin

   l_write_for_trg:=0;

   aud_text_:='';

   if :new.mg1 > :new.mg2 and :new.mg2 is not null then
        raise_application_error(-20001,
       'Ќекорректный период закрыти€ счета!');
   end if;
   
   if :new.psch is null then
        raise_application_error(-20001,
       'ѕопытка установить пустое значение признака счЄта!');
   end if;
   if :new.kw is null then
        raise_application_error(-20001,
       'ѕопытка установить пустой є квартиры!');
   end if;
   if :new.nd is null then
        raise_application_error(-20001,
       'ѕопытка установить пустой є дома!');
   end if;

   if updating  then
   --јудит по прочим параметрам
   --общ.пл.
   if nvl(:new.opl,0) <> nvl(:old.opl,0) then
    l_write_for_trg:=1;
    aud_text_:=aud_text_||logger.log_text('ќбщ.площадь.', :old.opl, :new.opl);
   end if;
   --Ётаж
   if nvl(:new.et,0) <> nvl(:old.et,0) then
    aud_text_:=aud_text_||logger.log_text('Ётаж', :old.et, :new.et);
   end if;
   -- омнат
   if nvl(:new.komn,0) <> nvl(:old.komn,0) then
    aud_text_:=aud_text_||logger.log_text(' омнат', :old.komn, :new.komn);
   end if;
   -- ол-во прожив.
   if nvl(:new.kpr,0) <> nvl(:old.kpr,0) then
    aud_text_:=aud_text_||logger.log_text(' ол-во прожив.', :old.kpr, :new.kpr);
   end if;
   -- ол-во вр.зарег.
   if nvl(:new.kpr_wr,0) <> nvl(:old.kpr_wr,0) then
    aud_text_:=aud_text_||logger.log_text(' ол-во вр.зарег.', :old.kpr_wr, :new.kpr_wr);
   end if;
   -- ол-во вр.отсут.
   if nvl(:new.kpr_ot,0) <> nvl(:old.kpr_ot,0) then
    aud_text_:=aud_text_||logger.log_text(' ол-во вр.отсут.', :old.kpr_ot, :new.kpr_ot);
   end if;
   -- ол-во льготников
   if nvl(:new.ki,0) <> nvl(:old.ki,0) then
    aud_text_:=aud_text_||logger.log_text(' ол-во льготников', :old.ki, :new.ki);
   end if;

   --ƒата договора (дл€ Ёнерг+)
   if (:new.schel_dt <> :old.schel_dt
     and :new.schel_dt is not null and :old.schel_dt is not null) or
     (:new.schel_dt is null and :old.schel_dt is not null) or
     (:new.schel_dt is not null and :old.schel_dt is null) then
    aud_text_:=aud_text_||logger.log_text('ƒата начала договора:',
      to_char(:old.schel_dt,'DD.MM.YYYY'), to_char(:new.schel_dt,'DD.MM.YYYY'));
   end if;
   if (:new.schel_end <> :old.schel_end
     and :new.schel_end is not null and :old.schel_end is not null) or
     (:new.schel_end is null and :old.schel_end is not null) or
     (:new.schel_end is not null and :old.schel_end is null) then
    aud_text_:=aud_text_||logger.log_text('ƒата окончани€ договора:',
      to_char(:old.schel_end,'DD.MM.YYYY'), to_char(:new.schel_end,'DD.MM.YYYY'));
   end if;

   if nvl(:new.psch,0) <> nvl(:old.psch,0) then
   --при изменении типов счетчиков чистим их расходы-показани€

   --дата открыти€-закрыти€ счета
     if :new.psch in (8,9) then
       :new.schel_end:=trunc(sysdate);
       else
       if :new.schel_dt is null then
         :new.schel_dt:=trunc(sysdate);
       end if;
       :new.schel_end:=null;
     end if;
   end if;

   --PSCH
   if nvl(:new.psch,0) <> nvl(:old.psch,0) then
     select decode(:old.psch, 0, 'Ќорматив', 1, '—четчики ’.¬,√.¬', 2,
       '—четчик ’.¬', 3, '—четчик √.¬', 8, '—тарый фонд', 9, '«акрытый л.с.')
       into status_txt_ from dual;
     select decode(:new.psch, 0, 'Ќорматив', 1, '—четчики ’.¬,√.¬', 2,
       '—четчик ’.¬', 3, '—четчик √.¬', 8, '—тарый фонд', 9, '«акрытый л.с.')
       into status_txt2_ from dual;

    aud_text_:=aud_text_||logger.log_text('ѕризнак счета, счетчика.', status_txt_,
     status_txt2_);
   end if;

   --SCH_EL
   if nvl(:new.sch_el,0) <> nvl(:old.sch_el,0) then
     select decode(nvl(:old.sch_el,0), 0, 'Ќорматив', 1, '—четчик')
       into status_txt_ from dual;
     select decode(nvl(:new.sch_el,0), 0, 'Ќорматив', 1, '—четчик')
       into status_txt2_ from dual;

    aud_text_:=aud_text_||logger.log_text('ѕризнак счетчика Ёл.Ён.', status_txt_,
     status_txt2_);
   end if;

  :new.kw:=substr(lpad(rtrim(:new.kw), 7,'0'),1,7);

  if nvl(:new.house_id,-1) <> nvl(:old.house_id,-1) then
    --изменилс€ ID дома
    select h.nd into :new.nd from c_houses h
      where h.id=:new.house_id;
  elsif nvl(:new.kul,'XXXXXXXX') <> nvl(:old.kul,'XXXXXXXX')
     or nvl(:new.nd,'XXXXXXXX') <> nvl(:old.nd,'XXXXXXXX') then
   :new.nd:=substr(lpad(rtrim(:new.nd), 6,'0'),1,6);
   select max(h.id) into house_id_ --max - чтоб не было exception
    from c_houses h               --считает правильно (primary key на h.id)
    where h.reu=:new.reu and
      h.kul=:new.kul and
      h.nd=:new.nd
      and nvl(h.psch,0) = 0;
    if house_id_ is null then --не найдено указанного дома дл€ вставки в kart
      RAISE_APPLICATION_ERROR(-20001, '”казанный дом не найден!');
    else
      :new.house_id:=house_id_;
    end if;
  end if;

  --јудит
  if :new.kw <> :old.kw then
    l_write_for_trg:=1;
    aud_text_:=aud_text_||logger.log_text('є квартиры', :old.kw, :new.kw);
  end if;
  if :new.kul <> :old.kul then
    l_write_for_trg:=1;
    select s.name into street_txt_ from spul s where s.id=:old.kul;
    select s.name into street_txt2_ from spul s where s.id=:new.kul;
    aud_text_:=aud_text_||logger.log_text('”лица', street_txt_, street_txt2_);
  end if;
  if :new.nd <> :old.nd then
    l_write_for_trg:=1;
    aud_text_:=aud_text_||logger.log_text('є дома', :old.nd, :new.nd);
  end if;

  if nvl(:new.cpn,0) <> nvl(:old.cpn,0) then
    aud_text_:=aud_text_||logger.log_text('ѕризнак не начислени€ пени', nvl(:old.cpn,0) , nvl(:new.cpn,0) );
  end if;

  if nvl(to_char(:new.pn_dt,'DD.MM.YYYY'),'xxx') <> nvl(to_char(:old.pn_dt,'DD.MM.YYYY'),'xxx') then
    aud_text_:=aud_text_||logger.log_text('ƒата ограничени€ начислени€ пени',
      nvl(to_char(:old.pn_dt,'DD.MM.YYYY'),'') , nvl(to_char(:new.pn_dt,'DD.MM.YYYY'),'') );
  end if;

   --найм
   if :new.status <> :old.status and :new.status = 1 then
    update nabor n set n.koeff =1 where n.lsk=:old.lsk and n.usl='026';
   elsif :new.status <> :old.status and :new.status <> 1 then
    update nabor n set n.koeff =0 where n.lsk=:old.lsk and n.usl='026';
   end if;

   if :new.status <> :old.status then
    --записать лиц. дл€ обновлени€ статуса, в "дополнительном л/c"
    l_write_for_trg:=1;

/*    select tp.cd into l_tp_cd from v_lsk_tp tp where tp.id=:new.fk_tp; 
    if l_tp_cd='LSK_TP_MAIN' and nvl(c_charges.trg_klsk_flag,0)=0 then
      c_charges.trg_tab_klsk.extend;
      c_charges.trg_tab_klsk(c_charges.trg_tab_klsk.last):= :new.k_lsk_id;
    end if;  */

    select s.name into status_txt_ from status s where s.id=:old.status;
    select s.name into status_txt2_ from status s where s.id=:new.status;
    aud_text_:=aud_text_||logger.log_text('—татус', status_txt_, status_txt2_);

/*отменено 02.11.2011
      select min(case when c.type=1 and s.fk_status_g is not null
          and s.fk_status_g <>nvl(:new.status,0) then 0
             when c.type=0 and s.fk_status_k is not null
          and s.fk_status_k <>nvl(:new.status,0) then 0
        else 1 --соответствует
        end) into correct_lg_
       from c_kart_pr p, c_lg_docs d, c_lg_pr c, spk s
       where p.id=d.c_kart_pr_id
       and d.id=c.c_lg_docs_id and c.spk_id=s.id
       and p.lsk=:new.lsk and p.status<>4; --без учета выбывших;
      if correct_lg_ = 0 then
        --льгота не соответствует статусу жиль€
        RAISE_APPLICATION_ERROR(-20001,
        '—татус жиль€ не соответствует льготам проживающих, отмена!');
      end if;
*/
   end if;

   --работаем с показани€ми счетчиков
  select nvl(p.cnt_sch,0) into var_ from params p;
   select nvl(count(*),0) into l_cnt  from c_reg_sch t, u_list i
      where t.id=(select max(c.id) from c_reg_sch c, usl u, u_list s where c.lsk=:new.lsk
      and c.lsk=t.lsk
      and c.fk_usl=u.usl
      and c.fk_state=s.id
      and u.cd='х.вода'
      and exists
      (select * from u_list u where u.cd='ѕоверка ѕ”'
        and u.id=c.fk_tp)
      )
      and t.lsk=:new.lsk
      and t.fk_state=i.id
      and i.cd='Ќеисправен ѕ”';

   --показани€ х.в.
   if nvl(:new.phw,0) <> nvl(:old.phw,0) and :new.psch in (1,2) and var_ = 1
       and nvl(:new.mhw,0) = nvl(:old.mhw,0) then
       :new.mhw:=nvl(:new.mhw,0)+nvl(:new.phw,0)-nvl(:old.phw,0);
       aud_text_:=aud_text_||logger.log_text('ѕоказ.сч.’.¬.', :old.phw, :new.phw);
   end if;
   if l_cnt <> 0 then
     --не испр.ѕ”
     :new.phw:=null;
   end if;

   select nvl(count(*),0) into l_cnt  from c_reg_sch t, u_list i
      where t.id=(select max(c.id) from c_reg_sch c, usl u, u_list s where c.lsk=:new.lsk
      and c.lsk=t.lsk
      and c.fk_usl=u.usl
      and c.fk_state=s.id
      and u.cd='г.вода'
      and exists
      (select * from u_list u where u.cd='ѕоверка ѕ”'
        and u.id=c.fk_tp)
      )
      and t.lsk=:new.lsk
      and t.fk_state=i.id
      and i.cd='Ќеисправен ѕ”';

   --показани€ г.в.
   if nvl(:new.pgw,0) <> nvl(:old.pgw,0) and :new.psch in (1,3) and var_ = 1
       and nvl(:new.mgw,0) = nvl(:old.mgw,0) then
       :new.mgw:=nvl(:new.mgw,0)+nvl(:new.pgw,0)-nvl(:old.pgw,0);
       aud_text_:=aud_text_||logger.log_text('ѕоказ.сч.√.¬.', :old.pgw, :new.pgw);
   end if;
   if l_cnt <> 0 then
     --не испр.ѕ”
     :new.pgw:=null;
   end if;

   select nvl(count(*),0) into l_cnt  from c_reg_sch t, u_list i
      where t.id=(select max(c.id) from c_reg_sch c, usl u, u_list s where c.lsk=:new.lsk
      and c.lsk=t.lsk
      and c.fk_usl=u.usl
      and c.fk_state=s.id
      and u.cd='эл.энерг.2'
      and exists
      (select * from u_list u where u.cd='ѕоверка ѕ”'
        and u.id=c.fk_tp)
      )
      and t.lsk=:new.lsk
      and t.fk_state=i.id
      and i.cd='Ќеисправен ѕ”';

   --показани€ эл.эн.
   if nvl(:new.pel,0) <> nvl(:old.pel,0) and var_ = 1
       and nvl(:new.mel,0) = nvl(:old.mel,0) then
       :new.mel:=nvl(:new.mel,0)+nvl(:new.pel,0)-nvl(:old.pel,0);
       aud_text_:=aud_text_||logger.log_text('ѕоказ.сч.Ёл.Ён.', :old.pel, :new.pel);
   end if;
   if l_cnt <> 0 then
     --не испр.ѕ”
     :new.pel:=null;
   end if;


--###### учет счетчиков в t_objxpar #######
    --счетчики
    --х.в. счетчики
    select trim(max(t.usl)) into l_usl from usl t where t.counter='phw';
    if l_usl is not null then
      if inserting and :new.phw is not null then
         l_id:=c_obj_par.ins_num_param(null, :new.lsk,
           'ins_sch', :new.phw,
           l_usl, nvl(p_vvod.g_tp,0));
      elsif updating and nvl(:new.phw,0)<>nvl(:old.phw,0) then
         l_id:=c_obj_par.ins_num_param(null, :old.lsk,
           'ins_sch', :new.phw,
           l_usl, nvl(p_vvod.g_tp,0));
      end if;
    end if;

    --х.в. расход
    if inserting and :new.mhw is not null then
       l_id:=c_obj_par.ins_num_param(null, :new.lsk,
         'ins_vol_sch', nvl(:new.mhw,0),
         l_usl, nvl(p_vvod.g_tp,0));
    elsif updating and nvl(:new.mhw,0)<>nvl(:old.mhw,0) then
       l_id:=c_obj_par.ins_num_param(null, :old.lsk,
         'ins_vol_sch', nvl(:new.mhw,0)-nvl(:old.mhw,0),
         l_usl, nvl(p_vvod.g_tp,0));
    end if;

    --г.в. счетчики
    select trim(max(t.usl)) into l_usl from usl t where t.counter='pgw';
    if l_usl is not null then
      if inserting and :new.pgw is not null then
         l_id:=c_obj_par.ins_num_param(null, :new.lsk,
           'ins_sch', :new.pgw,
           l_usl, nvl(p_vvod.g_tp,0));
      elsif updating and nvl(:new.pgw,0)<>nvl(:old.pgw,0) then
         l_id:=c_obj_par.ins_num_param(null, :old.lsk,
           'ins_sch', :new.pgw,
           l_usl, nvl(p_vvod.g_tp,0));
      end if;
    end if;

    --г.в. расход
    if inserting and :new.mgw is not null then
       l_id:=c_obj_par.ins_num_param(null, :new.lsk,
         'ins_vol_sch', :new.mgw,
         l_usl, nvl(p_vvod.g_tp,0));
    elsif updating and nvl(:new.mgw,0)<>nvl(:old.mgw,0) then
       l_id:=c_obj_par.ins_num_param(null, :old.lsk,
         'ins_vol_sch', nvl(:new.mgw,0)-nvl(:old.mgw,0),
         l_usl, nvl(p_vvod.g_tp,0));
    end if;

    --эл.эн. счетчики
    select trim(max(t.usl)) into l_usl from usl t where t.counter='pel';
    if l_usl is not null then
      if inserting and :new.pel is not null then
         l_id:=c_obj_par.ins_num_param(null, :new.lsk,
           'ins_sch', :new.pel,
           l_usl, nvl(p_vvod.g_tp,0));
      elsif updating and nvl(:new.pel,0)<>nvl(:old.pel,0) then
         l_id:=c_obj_par.ins_num_param(null, :old.lsk,
           'ins_sch', :new.pel,
           l_usl, nvl(p_vvod.g_tp,0));
      end if;
    end if;
    --эл.эн. расход
    if inserting and :new.mel is not null then
       l_id:=c_obj_par.ins_num_param(null, :new.lsk,
         'ins_vol_sch', :new.mel,
         l_usl, nvl(p_vvod.g_tp,0));
    elsif updating and nvl(:new.mel,0)<>nvl(:old.mel,0) then
       l_id:=c_obj_par.ins_num_param(null, :old.lsk,
         'ins_vol_sch', nvl(:new.mel,0)-nvl(:old.mel,0),
         l_usl, nvl(p_vvod.g_tp,0));
    end if;
--###### учет счетчиков в t_objxpar #######

   --јудит по расходу х.в.
   --х.в.
   if nvl(:new.mhw,0) <> nvl(:old.mhw,0) then
    aud_text_:=aud_text_||logger.log_text('–асход.’.¬.', :old.mhw, :new.mhw);
   end if;
   --г.в.
   if nvl(:new.mgw,0) <> nvl(:old.mgw,0) then
    aud_text_:=aud_text_||logger.log_text('–асход.√.¬.', :old.mgw, :new.mgw);
   end if;
   --г.в.
   if nvl(:new.mel,0) <> nvl(:old.mel,0) then
    aud_text_:=aud_text_||logger.log_text('–асход.Ёл.Ён.', :old.mel, :new.mel);
   end if;
  end if;

  --аудит
  if inserting then
    logger.log_act(:new.lsk, 'ƒобавление л/c '||:new.lsk, 2);
  elsif updating then
    if length(aud_text_) > 0 then
      logger.log_act(:new.lsk, 'ќбновление л/c: '||:new.lsk||' '||aud_text_, 2);
    end if;
  end if;

  if nvl(:new.k_fam,'x') <> nvl(:old.k_fam,'x') or nvl(:new.k_im,'x') <> nvl(:old.k_im,'x') or
    nvl(:new.k_ot,'x') <> nvl(:old.k_ot,'x') then

    --записать лиц. дл€ обновлени€ ‘»ќ, в "дополнительном л/c"
    l_write_for_trg:=1;
/*    select tp.cd into l_tp_cd from v_lsk_tp tp where tp.id=:new.fk_tp; 
    if l_tp_cd='LSK_TP_MAIN' and nvl(c_charges.trg_klsk_flag,0)=0 then
      c_charges.trg_tab_klsk.extend;
      c_charges.trg_tab_klsk(c_charges.trg_tab_klsk.last):= :new.k_lsk_id;
    end if;  */

    aud_text_:=logger.log_text('ќбновление ‘.».ќ. квартиросъемщика:', :old.k_fam||' '||:old.k_im||' '||:old.k_ot,
     :new.k_fam||' '||:new.k_im||' '||:new.k_ot);
    logger.log_act(:new.lsk, 'ќбновление л/c: '||:new.lsk||' '||aud_text_, 2);
  end if;
  :new.k_fam:=initcap(:new.k_fam);
  :new.k_im:=initcap(:new.k_im);
  :new.k_ot:=initcap(:new.k_ot);
  :new.fio:=:new.k_fam||' '||:new.k_im||' '||:new.k_ot;
  
  if l_write_for_trg=1 then
    select tp.cd into l_tp_cd from v_lsk_tp tp where tp.id=:new.fk_tp; 
    if l_tp_cd='LSK_TP_MAIN' and nvl(c_charges.trg_klsk_flag,0)=0 then
      c_charges.trg_tab_klsk.extend;
      c_charges.trg_tab_klsk(c_charges.trg_tab_klsk.last):= :new.k_lsk_id;
    end if;  
  end if;  
    

end;
/

prompt
prompt Creating trigger KART_VALID
prompt ===========================
prompt
create or replace trigger "SCOTT".kart_valid
  --сменил before на after так как отваливаетс€ (нет lsk в t_obxpar) при скрипте переноса ред. 06.01.2014
  after insert or update or delete on kart
  for each row
declare
begin
 NULL;
/*--установка статуса пересчета начислени€ и движени€ по л/с
 --если нет каскадного удалени€
  if inserting then
     c_valid.set_valid_lsk(:new.lsk, 1, 'gen_chrg');
     c_valid.set_valid_lsk(:new.lsk, 1, 'gen_part_kpr');
  elsif updating or deleting then
     c_valid.set_valid_lsk(:old.lsk, 1, 'gen_chrg');
     c_valid.set_valid_lsk(:old.lsk, 1, 'gen_part_kpr');
  end if;
  */
end kart_valid;
/

prompt
prompt Creating trigger KILLME_KWTP_DAY_BI_E
prompt =====================================
prompt
create or replace trigger "SCOTT".killme_kwtp_day_bi_e
  before insert on killme_kwtp_day
  for each row
declare
begin
  if :new.id is null then
    select scott.kwtp_day_id.nextval into :new.id from dual;
  end if;
end killme_kwtp_day_bi_e;
/

prompt
prompt Creating trigger KWTP_DAY_BI_E
prompt ==============================
prompt
create or replace trigger "SCOTT".kwtp_day_bi_e
  before insert on kwtp_day
  for each row
declare
begin
  if :new.id is null then
    select scott.kwtp_day_id.nextval into :new.id from dual;
  end if;
end kwtp_day_bi_e;
/

prompt
prompt Creating trigger KWTP_DAY_BU_E
prompt ==============================
prompt
create or replace trigger "SCOTT".kwtp_day_bu_e
  before update of summa, usl, org on kwtp_day
  for each row
declare
begin
  if nvl(c_get_pay.g_flag_upd,0)=0 then 
    logger.log_act(:old.lsk, '–учное распределение оплаты c_kwtp_mg.id='||:old.kwtp_id, 2);
  end if;

end kwtp_day_bu_e;
/

prompt
prompt Creating trigger KWTP_DAY_VALID
prompt ===============================
prompt
create or replace trigger "SCOTT".kwtp_day_valid
  before insert or update or delete on kwtp_day
  for each row
declare
begin
--установка статуса пересчета начислени€ и движени€ по л/с
  if inserting then
     c_valid.set_valid_lsk(:new.lsk, 1, 'gen_chrgpay');
  elsif updating or deleting then
     c_valid.set_valid_lsk(:old.lsk, 1, 'gen_chrgpay');
  end if;
end kwtp_day_valid;
/

prompt
prompt Creating trigger LIST_C_BI_E
prompt ============================
prompt
create or replace trigger "SCOTT".list_c_bi_e
  before insert on list_c
  for each row
declare
begin
  if :new.id is null then
    select scott.list_c_id.nextval into :new.id from dual;
  end if;
  if :new.fk_ses is null then
    select USERENV('sessionid') into :new.fk_ses from dual;
  end if;
end list_c_bi_e;
/

prompt
prompt Creating trigger LOCK_C_CHANGE_BUID
prompt ===================================
prompt
create or replace trigger "SCOTT".lock_c_change_buid
  before insert or update or delete on c_change
--  for each row
declare
  cnt_ number;
begin
  select nvl(max(t.parn1),0) into cnt_ from spr_params t where
   t.cd='c_change_update';

  if cnt_=1 and init.g_admin_acc = 0 then
    Raise_application_error(-20000,
      'Ѕј«ј ƒјЌЌџ’ «ј –џ“ј! ¬ доступе к объектам карточек отказано!');
  end if;
end lock_c_change_buid;
/

prompt
prompt Creating trigger LOCK_C_HOUSES_BUID
prompt ===================================
prompt
create or replace trigger "SCOTT".lock_c_houses_buid
  before insert or update or delete on c_houses
--  for each row
declare
  cnt_ number;
begin
  select nvl(max(t.parn1),0) into cnt_ from spr_params t where
   t.cd='c_houses_update';
  if cnt_=1 and init.g_admin_acc = 0 then
    Raise_application_error(-20000, 'Ѕј«ј ƒјЌЌџ’ «ј –џ“ј! ¬ доступе к списку домов отказано!');
  end if;
end lock_c_houses_buid;
/

prompt
prompt Creating trigger LOCK_C_KART_PR_BUID
prompt ====================================
prompt
create or replace trigger "SCOTT".lock_c_kart_pr_buid
  before insert or update or delete on c_kart_pr
--  for each row
declare
  cnt_ number;
begin
  select nvl(max(t.parn1),0) into cnt_ from spr_params t where
   t.cd='c_kart_pr_update';

  if cnt_=1 and init.g_admin_acc = 0 then
    Raise_application_error(-20000, 'Ѕј«ј ƒјЌЌџ’ «ј –џ“ј! ¬ доступе к списку проживающих отказано!');
  end if;
end lock_c_kart_pr_buid;
/

prompt
prompt Creating trigger LOCK_C_KWTP_BUID
prompt =================================
prompt
create or replace trigger "SCOTT".lock_c_kwtp_buid
  before insert or update or delete on c_kwtp
--  for each row
declare
  cnt_ number;
begin
  select nvl(max(t.parn1),0) into cnt_ from spr_params t where
   t.cd='c_kwtp_update';

  if cnt_=1 and init.g_admin_acc = 0 then
    Raise_application_error(-20000, 'Ѕј«ј ƒјЌЌџ’ «ј –џ“ј! ¬ доступе к ќплате отказано!');
  end if;
end lock_c_kwtp_buid;
/

prompt
prompt Creating trigger LOCK_C_KWTP_MG_BUID
prompt ====================================
prompt
create or replace trigger "SCOTT".lock_c_kwtp_mg_buid
  before insert or update or delete on c_kwtp_mg
--  for each row
declare
  cnt_ number;
begin
  select nvl(max(t.parn1),0) into cnt_ from spr_params t where
   t.cd='c_kwtp_mg_update';

  if cnt_=1 and init.g_admin_acc = 0 then
    Raise_application_error(-20000, 'Ѕј«ј ƒјЌЌџ’ «ј –џ“ј! ¬ доступе к ќплате отказано!');
  end if;
end lock_c_kwtp_mg_buid;
/

prompt
prompt Creating trigger LOCK_C_LG_DOCS_BUID
prompt ====================================
prompt
create or replace trigger "SCOTT".lock_c_lg_docs_buid
  before insert or update or delete on c_lg_docs
--  for each row
declare
  cnt_ number;
begin
  select nvl(max(t.parn1),0) into cnt_ from spr_params t where
   t.cd='c_lg_docs_update';

  if cnt_=1 and init.g_admin_acc = 0 then
    Raise_application_error(-20000, 'Ѕј«ј ƒјЌЌџ’ «ј –џ“ј! ¬ доступе к списку документов льгот проживающих отказано!');
  end if;
end lock_c_lg_docs_buid;
/

prompt
prompt Creating trigger LOCK_C_LG_PR_BUID
prompt ==================================
prompt
create or replace trigger "SCOTT".lock_c_lg_pr_buid
  before insert or update or delete on c_lg_pr
--  for each row
declare
  cnt_ number;
begin
  select nvl(max(t.parn1),0) into cnt_ from spr_params t where
   t.cd='c_lg_pr_update';

  if cnt_=1 and init.g_admin_acc = 0 then
    Raise_application_error(-20000, 'Ѕј«ј ƒјЌЌџ’ «ј –џ“ј! ¬ доступе к списку льгот проживающих отказано!');
  end if;
end lock_c_lg_pr_buid;
/

prompt
prompt Creating trigger LOCK_C_VVOD_BUID
prompt =================================
prompt
create or replace trigger "SCOTT".lock_c_vvod_buid
  before insert or update or delete on c_vvod
--  for each row
declare
  cnt_ number;
begin
  select nvl(max(t.parn1),0) into cnt_ from spr_params t where
   t.cd='c_vvod_update';

  if cnt_=1 and init.g_admin_acc = 0 then
    Raise_application_error(-20000, 'Ѕј«ј ƒјЌЌџ’ «ј –џ“ј! ¬ доступе к вводам отказано!');
  end if;
end lock_c_vvod_buid;
/

prompt
prompt Creating trigger LOCK_KART_BUID
prompt ===============================
prompt
create or replace trigger "SCOTT".lock_kart_buid
  before insert or update or delete on kart
--  for each row
declare
  cnt_ number;
begin
  select nvl(max(t.parn1),0) into cnt_ from spr_params t where
   t.cd='kart_update';
  if cnt_=1 and init.g_admin_acc = 0 then
    Raise_application_error(-20000,
      'Ѕј«ј ƒјЌЌџ’ «ј –џ“ј! ¬ доступе к объектам карточек отказано!');
  end if;
end lock_kart_buid;
/

prompt
prompt Creating trigger LOCK_NABOR_BUID
prompt ================================
prompt
create or replace trigger "SCOTT".lock_nabor_buid
  before insert or update or delete on nabor
--  for each row
declare
  cnt_ number;
begin
  select nvl(max(t.parn1),0) into cnt_ from spr_params t where
   t.cd='nabor_update';

  if cnt_=1 and init.g_admin_acc = 0 then
    Raise_application_error(-20000, 'Ѕј«ј ƒјЌЌџ’ «ј –џ“ј! ¬ доступе к параметрам карточки абонента отказано!');
  end if;
end lock_nabor_buid;
/

prompt
prompt Creating trigger LOG_ACTIONS_BI_E
prompt =================================
prompt
create or replace trigger "SCOTT".log_actions_bi_e
  before insert on log_actions
  for each row
begin
  if :new.id is null then
    select scott.log_actions_id.nextval into :new.id from dual;
  end if;
end;
/

prompt
prompt Creating trigger LOG_BI_E
prompt =========================
prompt
create or replace trigger "SCOTT".log_bi_e
  before insert on log
  for each row
declare
begin
  if :new.id_rec is null then
    select scott.log_id.nextval into :new.id_rec from dual;
  end if;
end log_bi_e;
/

prompt
prompt Creating trigger MESSAGES_AIS
prompt =============================
prompt
create or replace trigger "SCOTT".MESSAGES_AIS
  after insert on messages
declare
begin
    admin.TRG_DEL_REC;
end UPD;
/

prompt
prompt Creating trigger MESSAGES_BIR
prompt =============================
prompt
create or replace trigger "SCOTT".MESSAGES_BIR
  before insert on messages
  for each row
declare
id_ NUMBER;
begin
   select messages_id.nextval into id_ from dual;
   :New.id := id_;
   admin.TRG_SET_VAR(:New.from_id);
end UPD;
/

prompt
prompt Creating trigger MESSAGES_BIS
prompt =============================
prompt
create or replace trigger "SCOTT".MESSAGES_BIS
  before insert on messages
declare
begin
    admin.TRG_DEL_VAR;
end UPD;
/

prompt
prompt Creating trigger NABOR_BID_E
prompt ============================
prompt
create or replace trigger "SCOTT".nabor_bid_e
  before delete or insert on nabor
  for each row
declare
  l_cnt number;
  aud_text_ log_actions.text%type;
  txt_ usl.nm%type;
  l_org_name t_org.name%type;
begin

if inserting then
  select trim(nm) into txt_ from usl u where u.usl=:new.usl;
  select trim(o.name) into l_org_name from t_org o where o.id=:new.org;
  aud_text_:='ƒобавлена услуга '||trim(txt_)||' c коэфф.='||:new.koeff||' и нормативом='||:new.norm
  ||' и ќрг='||l_org_name;
  if length(aud_text_) > 0 then
    logger.log_act(:new.lsk, aud_text_, 2);
  end if;

  if :new.fk_vvod is not null then
    select nvl(count(*),0) into l_cnt
             from kart k where not exists
             (select * from c_vvod c where c.id=:new.fk_vvod
              and c.usl=:new.usl
              and c.house_id=k.house_id)
              and :new.lsk=k.lsk
              and :new.fk_vvod is not null;
    select trim(nm) into txt_ from usl u where u.usl=:old.usl;
    if l_cnt <> 0 then
      RAISE_APPLICATION_ERROR(-20001, 'ѕо услуге '||trim(txt_)||'- не найден соответствующий ввод!');
    end if;
    aud_text_:=aud_text_||logger.log_text('”становлен ввод по услуге '||trim(txt_)||': ', :old.fk_vvod, :new.fk_vvod);
  end if;

  select nvl(count(*),0) into l_cnt
     from usl u where u.usl=:new.usl and u.sptarn=1;
  if l_cnt <> 0
   and nvl(:new.koeff,0) <> 0 then
    RAISE_APPLICATION_ERROR(-20001, 'ѕо услуге '||trim(txt_)||'-коэффициент не допустим!');
  end if;

  select nvl(count(*),0) into l_cnt
     from usl u where u.usl=:new.usl and u.sptarn=0;
  if l_cnt <> 0
    and nvl(:new.norm,0) <> 0 then
    RAISE_APPLICATION_ERROR(-20001, 'ѕо услуге '||trim(txt_)||'-норматив не допустим!');
  end if;

elsif deleting then
  --проверить наличие перерасчЄтов с пустой организацией,
  --которые возможно необходимо удалить предварительно
  select nvl(count(*),0) into l_cnt
    from c_change t, params p where t.lsk=:old.lsk and
     t.mgchange >= p.period and t.org is null
     and t.usl=:old.usl;
  if l_cnt > 0 then
    Raise_application_error(-20000, 'ѕопытка удалени€ услуги, по которой имеетс€ действующий текущим периодом перерасчет! Ћ.—: '||:old.lsk);
  end if;

  select trim(nm) into txt_ from usl u where u.usl=:old.usl;
  select trim(o.name) into l_org_name from t_org o where o.id=:old.org;
  aud_text_:='”далена услуга '||trim(txt_)||' с коэфф.='||:old.koeff||' и нормативом='||:old.norm
  ||' и ќрг='||l_org_name;
  if length(aud_text_) > 0 then
    logger.log_act(:old.lsk, aud_text_, 2);
  end if;
end if;
end;
/

prompt
prompt Creating trigger NABOR_BU_E
prompt ===========================
prompt
create or replace trigger "SCOTT".nabor_bu_e
  before update of org, koeff, norm, fk_tarif, vol, vol_add, fk_vvod on nabor
  for each row
declare
  cnt_ number;
  cena_ number;
  id_ number;
  aud_text_ log_actions.text%type;
  txt_ usl.nm%type;
  txt2_ spr_tarif.name%type;
  txt3_ spr_tarif.name%type;
  l_org_name t_org.name%type;
  l_org_name_new t_org.name%type;
begin

--if :new.limit<> :old.limit and :new.limit is not  null then
--  Raise_application_error(-20000, 'TEST');
--end if;

--триггер выполн€ет проверки и логгинг по измененным пол€м
if nvl(c_charges.trg_proc_next_month,0) = 0  then
  --не выполн€ть, если идет переход мес€ца
  aud_text_:='';
  --обрабатываетс€ ли данна€ услуга тарифами?
  select nvl(count(*),0) into cnt_
     from spr_tarif t where t.usl=:old.usl;
  if cnt_ > 0 then
    --устанавливаем похожий по цене тариф
    if nvl(init.spr_tarif_upd_,0)=0 then
      if nvl(:old.koeff,0) <> nvl(:new.koeff,0) then
        select max(t.id) into id_ from spr_tarif t, spr_tarif_prices s, params p where t.usl=:old.usl
          and t.id=s.fk_tarif and s.cena=:new.koeff and p.period between s.mg1 and s.mg2;
        :new.fk_tarif:=id_;
      end if;
    end if;
  end if;

  --разрешено ли по данной услуге править ID DVB -декодера
  select nvl(count(*),0) into cnt_
     from usl t where t.usl=:old.usl and nvl(t.n_progs,0)=1;
  select trim(nm) into txt_ from usl u where u.usl=:old.usl;

  --јудит
  if  nvl(:new.fk_tarif,0) <> nvl(:old.fk_tarif,0) then
    select trim(nm) into txt_ from usl u where u.usl=:old.usl;
    select max(trim(s.name)) into txt2_ from spr_tarif s where s.id=:old.fk_tarif;
    select max(trim(s.name)) into txt3_ from spr_tarif s where s.id=:new.fk_tarif;
    aud_text_:=aud_text_||logger.log_text('“ариф по услуге'||trim(txt_)||': ', txt2_, txt3_);
  end if;

  if  nvl(:new.org,0) <> nvl(:old.org,0) then
    select trim(o.name) into l_org_name from t_org o where o.id=:old.org;
    select trim(o.name) into l_org_name_new from t_org o where o.id=:new.org;
    aud_text_:=aud_text_||logger.log_text('ќрг. по '||trim(txt_)||': ', l_org_name, l_org_name_new);
  end if;

  if  nvl(:new.koeff,0) <> nvl(:old.koeff,0) then
    select trim(nm) into txt_ from usl u where u.usl=:old.usl;
    aud_text_:=aud_text_||logger.log_text(' оэфф по '||trim(txt_)||': ', :old.koeff, :new.koeff);
  end if;

  if  nvl(:new.norm,0) <> nvl(:old.norm,0) then
    select trim(nm) into txt_ from usl u where u.usl=:old.usl;
    aud_text_:=aud_text_||logger.log_text('Ќорматив по '||trim(txt_)||': ', :old.norm, :new.norm);
  end if;

  if  nvl(:new.vol,0) <> nvl(:old.vol,0) then
    select trim(nm) into txt_ from usl u where u.usl=:old.usl;
    aud_text_:=aud_text_||logger.log_text('–аспределение по норме '||trim(txt_)||': ', :old.vol, :new.vol);
  end if;

  if  nvl(:new.vol_add,0) <> nvl(:old.vol_add,0) then
    select trim(nm) into txt_ from usl u where u.usl=:old.usl;
    aud_text_:=aud_text_||logger.log_text('–аспределение по счетчику '||trim(txt_)||': ', :old.vol_add, :new.vol_add);
  end if;


  if  nvl(:new.fk_vvod,0) <> nvl(:old.fk_vvod,0) then
    select nvl(count(*),0) into cnt_
             from kart k where not exists
             (select * from c_vvod c where c.id=:new.fk_vvod
              and c.usl=:new.usl
              and c.house_id=k.house_id)
              and :new.lsk=k.lsk
              and :new.fk_vvod is not null;
    select trim(nm) into txt_ from usl u where u.usl=:old.usl;
    if cnt_ <> 0 then
      RAISE_APPLICATION_ERROR(-20001, 'ѕо услуге '||trim(txt_)||'- не найден соответствующий ввод!');
    end if;
    aud_text_:=aud_text_||logger.log_text('”становлен ввод по услуге '||trim(txt_)||': ', :old.fk_vvod, :new.fk_vvod);
  end if;

  select nvl(count(*),0) into cnt_
     from usl u where u.usl=:new.usl and u.sptarn=1;
  if cnt_ <> 0
   and nvl(:new.koeff,0) <> 0 then
    RAISE_APPLICATION_ERROR(-20001, 'ѕо услуге '||trim(txt_)||'-коэффициент не допустим!');
  end if;

  select nvl(count(*),0) into cnt_
     from usl u where u.usl=:new.usl and u.sptarn=0;
  if cnt_ <> 0
    and nvl(:new.norm,0) <> 0 then
    RAISE_APPLICATION_ERROR(-20001, 'ѕо услуге '||trim(txt_)||'-норматив не допустим!');
  end if;



  --Ёнерг +
  if :old.usl='043' and nvl(:new.norm,0)>1 then
    RAISE_APPLICATION_ERROR(-20001, 'ѕо услуге '||trim(txt_)||' -кол-во точек не допустимо больше 1!');
  end if;

  if length(aud_text_) > 0 then
    if nvl(c_charges.trg_c_vvod,0)=0 then
      logger.log_act(:new.lsk, 'ќбновление услуг в карточке: '||aud_text_, 2);
    else
      logger.log_act(:new.lsk, '–аспределение объЄма по вводу: '||aud_text_, 2);
    end if;
  end if;
end if;
end;
/

prompt
prompt Creating trigger NABOR_FK_TARIF_BU_E
prompt ====================================
prompt
create or replace trigger "SCOTT".nabor_fk_tarif_bu_e
  before update of  fk_tarif on nabor
  for each row
declare
  cnt_ number;
  cena_ number;
  id_ number;
begin
  if nvl(:old.fk_tarif,0) <> nvl(:new.fk_tarif,0) then
  --обновление тарифа
    select max(nvl(t.cena,0)) into cena_ from spr_tarif_prices t, params p where t.fk_tarif=:new.fk_tarif
      and p.period between t.mg1 and t.mg2;
      :new.koeff:=cena_;
  end if;
end;
/

prompt
prompt Creating trigger NABOR_PROGS_BI
prompt ===============================
prompt
create or replace trigger "SCOTT".nabor_progs_bi
  before insert on nabor_progs
  for each row
declare
begin
  if :new.id is null then
    select scott.nabor_progs_id.nextval into :new.id from dual;
  end if;
end nabor_progs_bi;
/

prompt
prompt Creating trigger NABOR_VALID
prompt ============================
prompt
create or replace trigger "SCOTT".nabor_valid
  before insert or update or delete on nabor
  for each row
declare
begin
 NULL;
/*--установка статуса пересчета начислени€ и движени€ по л/с
 --если нет каскадного удалени€

  if inserting then
    c_valid.set_valid_lsk(:new.lsk, 1, 'gen_part_kpr');
    c_valid.set_valid_lsk(:new.lsk, 1, 'gen_chrg');
    if :new.fk_vvod is not null then
       c_valid.set_valid_as_vvod(:new.fk_vvod, 1, 'gen_obj');
    else
       c_valid.set_valid_as_house(:new.lsk, 1, 'gen_obj');
    end if;
  elsif updating then
    c_valid.set_valid_lsk(:new.lsk, 1, 'gen_part_kpr');
    c_valid.set_valid_lsk(:new.lsk, 1, 'gen_chrg');
    if :new.fk_vvod is not null then
       c_valid.set_valid_as_vvod(:new.fk_vvod, 1, 'gen_obj');
    else
       c_valid.set_valid_as_house(:new.lsk, 1, 'gen_obj');
    end if;
  elsif deleting then
    c_valid.set_valid_lsk(:old.lsk, 1, 'gen_part_kpr');
    c_valid.set_valid_lsk(:old.lsk, 1, 'gen_chrg');
    if :old.fk_vvod is not null then
       c_valid.set_valid_as_vvod(:old.fk_vvod, 1, 'gen_obj');
    else
       c_valid.set_valid_as_house(:old.lsk, 1, 'gen_obj');
    end if;
  end if;*/
end nabor_valid;
/

prompt
prompt Creating trigger ON_LOGON
prompt =========================
prompt
create or replace trigger "SCOTT".On_Logon after logon on database
begin
 Execute immediate 'alter session set NLS_NUMERIC_CHARACTERS = ". "';
end;
/

prompt
prompt Creating trigger OPER_BIE
prompt =========================
prompt
create or replace trigger "SCOTT".oper_bie
  before insert on oper
  for each row
declare
 oper_ oper.oper%type;
begin
--копируем в новую категорию льготы коэфф с раб-служ.
if :new.oper is null then
  select min(oper) into oper_
  from (select lpad(rownum, 2, '0') as oper from all_objects t
  where rownum <99) a
  where not exists (select * from oper o where o.oper=a.oper);
  :new.oper:=oper_;
end if;
end;
/

prompt
prompt Creating trigger PERIOD_REPORTS_AIU
prompt ===================================
prompt
create or replace trigger "SCOTT".period_reports_aiu
  before insert or update on period_reports
  for each row
declare
  set_ number;
begin
  --автоматически подписать отчЄты
  select nvl(p.auto_sign,0) into set_ from params p;
  if set_=1 then
   :new.signed:=1;
  end if;

end;
/

prompt
prompt Creating trigger PREP_FILE_BI
prompt =============================
prompt
create or replace trigger "SCOTT".prep_file_bi
  before insert on prep_file
  for each row
declare
begin
  if :new.id is null then
    select scott.prep_file_id.nextval into :new.id from dual;
  end if;

end prep_file_bi;
/

prompt
prompt Creating trigger PREP_SAL_BIE
prompt =============================
prompt
create or replace trigger "SCOTT".prep_sal_bie
  before insert on prep_sal
  for each row
declare
begin
  if :new.id is null then
    select scott.prep_sal_id.nextval into :new.id from dual;
  end if;
end prep_sal_bie;
/

prompt
prompt Creating trigger PRICES_VALID
prompt =============================
prompt
create or replace trigger "SCOTT".prices_valid
  before insert or update or delete on prices
--  for each row  ред.21.10.13,- убрал each row, так как тормозит сильно
declare
begin
  NULL;
-- c_valid.set_valid_all_nc(1, 'gen_chrg');
-- logger.log_(null, 'VALID=1 for prices, made by '||user);

end prices_valid;
/

prompt
prompt Creating trigger SPK_AIE
prompt ========================
prompt
create or replace trigger "SCOTT".spk_aie
  after insert on spk
  for each row
begin
  --копируем в новую категорию льготы коэфф с раб-служ.
  insert into c_spk_usl c (spk_id, usl_id, koef)
    select utils.spk_id_, usl, 0 from usl u;
end;
/

prompt
prompt Creating trigger SPK_BI
prompt =======================
prompt
create or replace trigger "SCOTT".spk_bi
  before insert on spk
declare
 spk_id_ number;
begin
--копируем в новую категорию льготы коэфф с раб-служ.
 select nvl(max(s.id),0) into spk_id_ from spk s;
 utils.spk_id_:=spk_id_+1;
end;
/

prompt
prompt Creating trigger SPK_BIE
prompt ========================
prompt
create or replace trigger "SCOTT".spk_bie
  before insert on spk
  for each row
begin
  :new.id:=utils.spk_id_;
end;
/

prompt
prompt Creating trigger SPR_KOEFF_BI
prompt =============================
prompt
create or replace trigger "SCOTT".spr_koeff_bi
  before insert on spr_koeff
  for each row
declare
begin
  if :new.id is null then
    select scott.spr_koeff_id.nextval into :new.id from dual;
  end if;
end spr_koeff_bi;
/

prompt
prompt Creating trigger SPR_KOEFF_VALID
prompt ================================
prompt
create or replace trigger "SCOTT".spr_koeff_valid
  before insert or update or delete on spr_koeff
  for each row
declare
begin
 NULL;
-- c_valid.set_valid_all_nc(1, 'gen_chrg');
-- logger.log_(null, 'VALID=1 for spr_koeff, made by '||user);

end spr_koeff_valid;
/

prompt
prompt Creating trigger SPR_PARAMS_BUIE
prompt ================================
prompt
create or replace trigger "SCOTT".spr_params_buie
  before insert or update on spr_params
  for each row
begin
  if inserting then
    if :new.id is null then
      select scott.spr_params_id.nextval into :new.id from dual;
    end if;
  end if;
  if nvl(:new.cdtp,0) = 0 and (:new.parvc1 is not null or :new.pardt1 is not null) then
    RAISE_APPLICATION_ERROR(-20001, 'Ќе допустим ввод символьного значени€ и даты  по данному параметру!');
  elsif nvl(:new.cdtp,0) = 1 and (:new.parn1 is not null or :new.pardt1 is not null) then
    RAISE_APPLICATION_ERROR(-20001, 'Ќе допустим ввод числового значени€ и даты по данному параметру!');
  elsif nvl(:new.cdtp,0) = 2 and (:new.parvc1 is not null or :new.parn1 is not null) then
    RAISE_APPLICATION_ERROR(-20001, 'Ќе допустим ввод числового и символьного значени€ по данному параметру!');
  end if;
end;
/

prompt
prompt Creating trigger SPR_PAR_SES_BI_E
prompt =================================
prompt
create or replace trigger "SCOTT".spr_par_ses_bi_e
  before insert on spr_par_ses
  for each row
declare
begin
  if :new.fk_ses is null then
    select USERENV('sessionid') into :new.fk_ses from dual;
  end if;
end spr_par_ses_bi_e;
/

prompt
prompt Creating trigger SPR_REPXPAR_BI_E
prompt =================================
prompt
create or replace trigger "SCOTT".spr_repxpar_bi_e
  before insert on REPXPAR
  for each row
declare
begin
  if :new.id is null then
    select scott.spr_repxpar_id.nextval into :new.id from dual;
  end if;
end spr_repxpar_bi_e;
/

prompt
prompt Creating trigger SPR_TARIF_AIE
prompt ==============================
prompt
create or replace trigger "SCOTT".spr_tarif_aie
  after insert on spr_tarif
  for each row
begin
  insert into spr_tarifxprogs
    (fk_tarif, fk_prog)
   values
     (utils.spr_tarif_root_id_, :new.id);
end;
/

prompt
prompt Creating trigger SPR_TARIF_BI
prompt =============================
prompt
create or replace trigger "SCOTT".spr_tarif_bi
  before insert on spr_tarif
declare
 spr_tarif_id_ number;
begin
 --получаем следующий ID дл€ нового тарифа
 select nvl(max(s.id),0) into spr_tarif_id_ from spr_tarif s;
 utils.spr_tarif_id_:=spr_tarif_id_+1;

 --получаем корневой элемент справочника тарифов
 select t.id into utils.spr_tarif_root_id_
    from spr_tarif t where
     t.cd='000';
end;
/

prompt
prompt Creating trigger SPR_TARIF_BIE
prompt ==============================
prompt
create or replace trigger "SCOTT".spr_tarif_bie
  before insert on spr_tarif
  for each row
begin
  :new.mask:=lpad('0',992,'0');
  :new.id:=utils.spr_tarif_id_;
  :new.cd:=utils.spr_tarif_id_;
end;
/

prompt
prompt Creating trigger SPR_TARIF_PRICES_AU
prompt ====================================
prompt
create or replace trigger "SCOTT".spr_tarif_prices_au
  after update on spr_tarif_prices
begin
  init.spr_tarif_upd_:=0;
end;
/

prompt
prompt Creating trigger SPR_TARIF_PRICES_AUE
prompt =====================================
prompt
create or replace trigger "SCOTT".spr_tarif_prices_aue
  after update of cena, mg1, mg2 on spr_tarif_prices
  for each row
declare
  period_ params.period%type;
begin
  --јнтенны
  --ќбновление расценок по тарифу
  --»спользовалось, когда оператор мог свободно регулировать
  --расценку в nabor, удалить триггер после 16.11.2010
/*  select period into period_ from params;
  if period_ between :new.mg1 and :new.mg2 then
    update nabor n set n.koeff=:new.cena
      where n.fk_tarif=:old.fk_tarif;
  end if;*/
  null;
end;
/

prompt
prompt Creating trigger SPR_TARIF_PRICES_BU
prompt ====================================
prompt
create or replace trigger "SCOTT".spr_tarif_prices_bu
  before update on spr_tarif_prices
begin
  init.spr_tarif_upd_:=1;
end;
/

prompt
prompt Creating trigger SPR_TARIF_USL_AUE
prompt ==================================
prompt
create or replace trigger "SCOTT".spr_tarif_usl_aue
  after update of usl on spr_tarif
  for each row
declare
 cnt_ number;
begin
null;
 --—транно.... а оно надо?
  --јнтенны
  --ѕроверка на корректность обновлени€ пол€ usl
/*  select nvl(count(*),0) into cnt_
    from nabor n where n.usl=:old.usl and n.fk_tarif=:old.id;
  if cnt_ > 0 then
    Raise_application_error(-20001,
      'ƒанный тариф используетс€ другой услугой, изменение запрещено!');
  end if;*/
end;
/

prompt
prompt Creating trigger SPR_TARIF_VALID
prompt ================================
prompt
create or replace trigger "SCOTT".spr_tarif_valid
  before insert or update or delete on spr_tarif
  for each row
declare
begin
 NULL;
-- c_valid.set_valid_all_nc(1, 'gen_chrg');
-- logger.log_(null, 'VALID=1 for spr_tarif, made by '||user);

end spr_tarif_valid;
/

prompt
prompt Creating trigger SPUL_BIE
prompt =========================
prompt
create or replace trigger "SCOTT".spul_bie
  before insert on spul
  for each row
declare
 id_ spul.id%type;
begin
--копируем в новую категорию льготы коэфф с раб-служ.
if :new.id is null then
 select lpad(trim(to_char(max(to_number(o.id)+1))), 4, '0') into id_
   from spul o;
 :new.id:=id_;
end if;
end;
/

prompt
prompt Creating trigger TEMP_PREP2_BI
prompt ==============================
prompt
create or replace trigger "SCOTT".temp_prep2_bi
  before insert on temp_prep2
  for each row
declare
begin
  if :new.id is null then
    select scott.temp_prep2_id.nextval into :new.id from dual;
  end if;
end temp_prep2_bi;
/

prompt
prompt Creating trigger T_A_LOGON
prompt ==========================
prompt
create or replace trigger "SCOTT".t_a_logon
  after logon on database
begin
  --логгирование пользователей
  --закомментировано... бывают проблемы у Ёнергии плюс
/*  insert into log
      (id, timestampm, ip, terminal, event_id)
      select uid, sysdate, SYS_CONTEXT('USERENV','IP_ADDRESS'),
       SYS_CONTEXT('USERENV','SESSION_USER'), 1 from dual;
       */

null;
end t_a_logon;
/

prompt
prompt Creating trigger T_BILL_DET_BI_E
prompt ================================
prompt
create or replace trigger "SCOTT".t_bill_det_bi_e
  before insert on c_bill_det
  for each row
declare
begin
  if :new.id is null then
    select scott.c_bill_det_id.nextval into :new.id from dual;
  end if;
end c_bill_det_e;
/

prompt
prompt Creating trigger T_CORRECTS_PAYMENTS_BIE
prompt ========================================
prompt
create or replace trigger "SCOTT".t_corrects_payments_bie
  before insert on t_corrects_payments
  for each row
begin
  if :new.id is null then
    select scott.t_corrects_payments_id.nextval into :new.id from dual;
  end if;
end t_corrects_payments_bie;
/

prompt
prompt Creating trigger T_CORRECTS_PAYMENTS_VALID
prompt ==========================================
prompt
create or replace trigger "SCOTT".t_corrects_payments_valid
  before insert or update or delete on t_corrects_payments
  for each row
declare
begin
--установка статуса пересчета начислени€ и движени€ по л/с
  if inserting then
     c_valid.set_valid_lsk(:new.lsk, 1, 'gen_chrgpay');
  elsif updating or deleting then
     c_valid.set_valid_lsk(:old.lsk, 1, 'gen_chrgpay');
  end if;
end t_corrects_payments_valid;
/

prompt
prompt Creating trigger T_HOUSEXLIST_BIE
prompt =================================
prompt
create or replace trigger "SCOTT".t_housexlist_bie
  before insert on t_housexlist
  for each row
declare
begin
  if :new.id is null then
    select scott.u_list_id.nextval into :new.id from dual;
  end if;
end t_housexlist_bie;
/

prompt
prompt Creating trigger T_OBJXPAR_BI
prompt =============================
prompt
create or replace trigger "SCOTT".t_objxpar_bi
  before insert on T_OBJXPAR
  for each row
declare
begin
  if :new.id is null then
    select scott.u_list_id.nextval into :new.id from dual;
  end if;
end t_objxpar_bi;
/

prompt
prompt Creating trigger T_ORG_AIUD
prompt ===========================
prompt
create or replace trigger "SCOTT".t_org_aiud
  after insert or update or delete on t_org
declare
cnt_ number;
begin
 --предотвращаем повторный вызов себ€ же
 if nvl(c_charges.trg_t_org_flag,0)=0 then
 --установка иерархии отношений по расценке организаций
   c_charges.trg_t_org_flag:=1;
   begin
      for c in (select t.id from t_org t)
      loop
        update t_org o set o.fk_org2=(select id from (
        select t.id from t_org t
        connect by prior t.parent_id2=t.id
        start with t.id=c.id
        order by level desc
        ) where rownum=1)
        where o.id=c.id;
      end loop;
      --установить самих себ€, где поставлено null в родит.орг.
      update t_org o set o.fk_org2=o.id where o.fk_org2 is null
       and o.parent_id2 is null;
   exception
   when others then
     c_charges.trg_t_org_flag:=0;
     --повторить exception
     raise;
   end;
   c_charges.trg_t_org_flag:=0;
 end if;

end t_org_ai;
/

prompt
prompt Creating trigger T_ORG_BIUD_E
prompt =============================
prompt
create or replace trigger "SCOTT".t_org_biud_e
  before insert or update or delete on t_org
  for each row
declare
cnt_ number;
begin
  if inserting then
    if :new.id is null then
      select scott.t_org_id.nextval into :new.id from dual;
    else
      if init.is_allow('drx6_админ_спр_организаций') = 0 then
          raise_application_error(-20001,
                               'ќтсутствуют права на изменени€ пол€  од ID');
      end if;
    end if;

    if init.is_allow('drx6_админ_спр_организаций') = 0
      and (:new.reu is not null or :new.trest is not null or
      :new.parent_id is not null) then
        raise_application_error(-20001,
                             'ќтсутствуют права на изменени€ полей  од –Ё”,  од ∆Ёќ, ¬ышест.ID');
    end if;
    if :new.cd is null then
      :new.cd:=:new.id;
    else
      if init.is_allow('drx6_админ_спр_организаций') = 0 then
          raise_application_error(-20001,
                               'ќтсутствуют права на изменени€ пол€  од CD');
      end if;
    end if;
  elsif updating then
    if init.is_allow('drx6_админ_спр_организаций') = 0
      and (:new.cd is null or :new.reu is not null or :new.trest is not null or
      :new.parent_id is not null) then
        raise_application_error(-20001,
                             'ќтсутствуют права на изменени€ полей  од CD,  од –Ё”,  од ∆Ёќ, ¬ышест.ID');

    end if;
  elsif deleting then
    if init.is_allow('drx6_админ_спр_организаций') = 0
      and (:old.reu is not null) then
        raise_application_error(-20001,
                             'ќтсутствуют права на удаление записей, содержащие пол€  од –Ё”');
    else
      if :old.reu is not null then
        --проверка на использование кодов REU
        select nvl(count(*),0) into cnt_ from kart k
         where k.reu=:old.reu;
        if cnt_ <> 0 then
            raise_application_error(-20001,
                                 '«апрещено удал€ть используемый в справочнике карточек л/c код –Ё”');
        end if;
        --проверка на использование кодов REU
        select nvl(count(*),0) into cnt_ from xitog3 k
         where k.reu=:old.reu;
        if cnt_ <> 0 then
            raise_application_error(-20001,
                                 '«апрещено удал€ть используемый в оборотной ведомости код –Ё”');
        end if;
      end if;
    end if;

    if init.is_allow('drx6_админ_спр_организаций') = 0
      and (:old.trest is not null) then
        raise_application_error(-20001,
                             'ќтсутствуют права на удаление записей, содержащие пол€  од ∆Ёќ');
    else
      if :old.trest is not null then
        --проверка на использование кодов TREST
        select nvl(count(*),0) into cnt_ from xitog3 k
         where k.trest=:old.trest;
        if cnt_ <> 0 then
            raise_application_error(-20001,
                                 '«апрещено удал€ть используемый в оборотной ведомости код ∆Ёќ');
        end if;
      end if;
    end if;
  end if;

end t_org_bi;
/

prompt
prompt Creating trigger T_ORG_TP_BI
prompt ============================
prompt
create or replace trigger "SCOTT".t_org_tp_bi
  before insert on t_org_tp
  for each row
declare
begin
  if :new.id is null then
    select scott.t_org_tp_id.nextval into :new.id from dual;
  end if;
end t_org_tp_bi;
/

prompt
prompt Creating trigger T_PERIOD_REPORTS_BI
prompt ====================================
prompt
create or replace trigger "SCOTT".t_period_reports_bi
  before insert on period_reports
  for each row
declare
begin
  if :new.id is null then
    select scott.period_rep_id.nextval into :new.id from dual;
  end if;
end t_period_reports_bi;
/

prompt
prompt Creating trigger T_REPORTS_BI
prompt =============================
prompt
create or replace trigger "SCOTT".t_reports_bi
  before insert on reports
  for each row
declare
begin
  if :new.id is null then
    select scott.reports_id.nextval into :new.id from dual;
  end if;
end t_reports_bi;
/

prompt
prompt Creating trigger T_REP_LEVELS_BI
prompt ================================
prompt
create or replace trigger "SCOTT".t_rep_levels_bi
  before insert on rep_levels
  for each row
declare
begin
  if :new.id is null then
    select scott.rep_levels_id.nextval into :new.id from dual;
  end if;
end t_rep_levels_bi;
/

prompt
prompt Creating trigger T_ROLE_BI
prompt ==========================
prompt
create or replace trigger "SCOTT".t_role_bi
  before insert on t_role
  for each row
declare
begin
  if :new.id is null then
    select scott.t_role_id.nextval into :new.id from dual;
  end if;
end t_role_bi;
/

prompt
prompt Creating trigger T_SESS_C_BI_E
prompt ==============================
prompt
create or replace trigger "SCOTT".t_sess_c_bi_e
  before insert on t_sess
  for each row
declare
begin
  if :new.id is null then
    select scott.t_sess_id.nextval into :new.id from dual;
  end if;
end t_sess_bi_e;
/

prompt
prompt Creating trigger T_USER_BIE
prompt ===========================
prompt
create or replace trigger "SCOTT".t_user_bie
  before insert on t_user
  for each row
declare
begin
  if :new.id is null then
    select scott.t_user_id.nextval into :new.id from dual;
  end if;
end t_user_bie;
/

prompt
prompt Creating trigger T_USXRL_BI
prompt ===========================
prompt
create or replace trigger "SCOTT".t_usxrl_bi
  before insert on t_usxrl
  for each row
declare
begin
  if :new.id is null then
    select scott.t_usxrl_id.nextval into :new.id from dual;
  end if;
  select trim(to_char(:new.id)) into :new.cd from dual;
end t_usxrl_bi;
/

prompt
prompt Creating trigger USL_BI
prompt =======================
prompt
create or replace trigger "SCOTT".usl_bi
  before insert on usl
  for each row
declare
begin
  if :new.cd is null then
    :new.cd:=:new.usl;
  end if;
end usl_bi;
/

prompt
prompt Creating trigger USL_VALID
prompt ==========================
prompt
create or replace trigger "SCOTT".usl_valid
  after insert or update or delete
  on usl
declare
begin

 NULL;
/* if nvl(c_valid.g_upd_usl,0)=1 then
   c_valid.set_valid_all_nc(1, 'gen_chrg');
   c_valid.set_valid_all_nc(1, 'gen_part_kpr');
 end if;
 c_valid.g_upd_usl:=0;
 logger.log_(null, 'VALID=1 for usl, made by '||user);
 */
end usl_valid;
/

prompt
prompt Creating trigger USL_VALID_E
prompt ============================
prompt
create or replace trigger "SCOTT".usl_valid_e
  before insert or update or delete
  of
   uslm, usl, kartw, kwni, lpw, ed_izm,
   usl_p, sptarn, usl_type, usl_plr, usl_norm, typ_usl,
   usl_order, usl_type2, usl_subs, cd, npp,
   fk_calc_tp, uslg, counter, have_vvod, n_progs,
   fk_usl_pen, can_vv, is_iter, max_vol, fk_usl_chld
  on usl
  for each row
declare
begin

 NULL;
 --флаг, что произошло обновление данных, конкретных полей
 --(указанных выше)
 --пока не стал делать подобный триггер в других таблицах
 --(должно обновл€тьс€ достаточно быстро, ред.19.11.12)
-- c_valid.g_upd_usl:=1;

end usl_valid_e;
/

prompt
prompt Creating trigger U_LISTTP_BI
prompt ============================
prompt
create or replace trigger "SCOTT".u_listtp_bi
  before insert on u_listtp
  for each row
declare
begin
  if :new.id is null then
    select scott.u_list_id.nextval into :new.id from dual;
  end if;
end u_listtp_bi;
/

prompt
prompt Creating trigger U_LIST_BI
prompt ==========================
prompt
create or replace trigger "SCOTT".u_list_bi
  before insert on u_list
  for each row
declare
begin
  if :new.id is null then
    select scott.u_list_id.nextval into :new.id from dual;
  end if;
  if :new.cd is null then
     :new.cd:=:new.id;
  end if;
end u_list_bi;
/


spool off
